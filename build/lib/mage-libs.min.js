/*! mage version: 0.0.83, 12-09-2018 */
var license = "Copyright (c) 2017 by Marco Stagni < http://marcostagni.com mrc.stagni@gmail.com > and contributors.\n\nSome rights reserved. Redistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the following\n  disclaimer in the documentation and/or other materials provided\n  with the distribution.\n\n* The names of the contributors may not be used to endorse or\n  promote products derived from this software without specific\n  prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nMage contains third party software in the 'app/vendor' directory: each\nfile/module in this directory is distributed under its original license.\n\n";

!function(a, b) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
        if (!a.document) throw new Error("jQuery requires a window with a document");
        return b(a);
    } : b(a);
}("undefined" != typeof window ? window : this, function(a, b) {
    function c(a) {
        var b = a.length, c = fa.type(a);
        return "function" !== c && !fa.isWindow(a) && (!(1 !== a.nodeType || !b) || ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a));
    }
    function d(a, b, c) {
        if (fa.isFunction(b)) return fa.grep(a, function(a, d) {
            return !!b.call(a, d, a) !== c;
        });
        if (b.nodeType) return fa.grep(a, function(a) {
            return a === b !== c;
        });
        if ("string" == typeof b) {
            if (na.test(b)) return fa.filter(b, a, c);
            b = fa.filter(b, a);
        }
        return fa.grep(a, function(a) {
            return fa.inArray(a, b) >= 0 !== c;
        });
    }
    function e(a, b) {
        do {
            a = a[b];
        } while (a && 1 !== a.nodeType);
        return a;
    }
    function f(a) {
        var b = ua[a] = {};
        return fa.each(a.match(ta) || [], function(a, c) {
            b[c] = !0;
        }), b;
    }
    function g() {
        pa.addEventListener ? (pa.removeEventListener("DOMContentLoaded", h, !1), a.removeEventListener("load", h, !1)) : (pa.detachEvent("onreadystatechange", h), 
        a.detachEvent("onload", h));
    }
    function h() {
        (pa.addEventListener || "load" === event.type || "complete" === pa.readyState) && (g(), 
        fa.ready());
    }
    function i(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(za, "-$1").toLowerCase();
            if ("string" == typeof (c = a.getAttribute(d))) {
                try {
                    c = "true" === c || "false" !== c && ("null" === c ? null : +c + "" === c ? +c : ya.test(c) ? fa.parseJSON(c) : c);
                } catch (a) {}
                fa.data(a, b, c);
            } else c = void 0;
        }
        return c;
    }
    function j(a) {
        var b;
        for (b in a) if (("data" !== b || !fa.isEmptyObject(a[b])) && "toJSON" !== b) return !1;
        return !0;
    }
    function k(a, b, c, d) {
        if (fa.acceptData(a)) {
            var e, f, g = fa.expando, h = a.nodeType, i = h ? fa.cache : a, j = h ? a[g] : a[g] && g;
            if (j && i[j] && (d || i[j].data) || void 0 !== c || "string" != typeof b) return j || (j = h ? a[g] = W.pop() || fa.guid++ : g), 
            i[j] || (i[j] = h ? {} : {
                toJSON: fa.noop
            }), ("object" == typeof b || "function" == typeof b) && (d ? i[j] = fa.extend(i[j], b) : i[j].data = fa.extend(i[j].data, b)), 
            f = i[j], d || (f.data || (f.data = {}), f = f.data), void 0 !== c && (f[fa.camelCase(b)] = c), 
            "string" == typeof b ? null == (e = f[b]) && (e = f[fa.camelCase(b)]) : e = f, e;
        }
    }
    function l(a, b, c) {
        if (fa.acceptData(a)) {
            var d, e, f = a.nodeType, g = f ? fa.cache : a, h = f ? a[fa.expando] : fa.expando;
            if (g[h]) {
                if (b && (d = c ? g[h] : g[h].data)) {
                    fa.isArray(b) ? b = b.concat(fa.map(b, fa.camelCase)) : b in d ? b = [ b ] : (b = fa.camelCase(b), 
                    b = b in d ? [ b ] : b.split(" ")), e = b.length;
                    for (;e--; ) delete d[b[e]];
                    if (c ? !j(d) : !fa.isEmptyObject(d)) return;
                }
                (c || (delete g[h].data, j(g[h]))) && (f ? fa.cleanData([ a ], !0) : da.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
            }
        }
    }
    function m() {
        return !0;
    }
    function n() {
        return !1;
    }
    function o() {
        try {
            return pa.activeElement;
        } catch (a) {}
    }
    function p(a) {
        var b = Ka.split("|"), c = a.createDocumentFragment();
        if (c.createElement) for (;b.length; ) c.createElement(b.pop());
        return c;
    }
    function q(a, b) {
        var c, d, e = 0, f = typeof a.getElementsByTagName !== xa ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== xa ? a.querySelectorAll(b || "*") : void 0;
        if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || fa.nodeName(d, b) ? f.push(d) : fa.merge(f, q(d, b));
        return void 0 === b || b && fa.nodeName(a, b) ? fa.merge([ a ], f) : f;
    }
    function r(a) {
        Ea.test(a.type) && (a.defaultChecked = a.checked);
    }
    function s(a, b) {
        return fa.nodeName(a, "table") && fa.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
    }
    function t(a) {
        return a.type = (null !== fa.find.attr(a, "type")) + "/" + a.type, a;
    }
    function u(a) {
        var b = Va.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"), a;
    }
    function v(a, b) {
        for (var c, d = 0; null != (c = a[d]); d++) fa._data(c, "globalEval", !b || fa._data(b[d], "globalEval"));
    }
    function w(a, b) {
        if (1 === b.nodeType && fa.hasData(a)) {
            var c, d, e, f = fa._data(a), g = fa._data(b, f), h = f.events;
            if (h) {
                delete g.handle, g.events = {};
                for (c in h) for (d = 0, e = h[c].length; e > d; d++) fa.event.add(b, c, h[c][d]);
            }
            g.data && (g.data = fa.extend({}, g.data));
        }
    }
    function x(a, b) {
        var c, d, e;
        if (1 === b.nodeType) {
            if (c = b.nodeName.toLowerCase(), !da.noCloneEvent && b[fa.expando]) {
                e = fa._data(b);
                for (d in e.events) fa.removeEvent(b, d, e.handle);
                b.removeAttribute(fa.expando);
            }
            "script" === c && b.text !== a.text ? (t(b).text = a.text, u(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), 
            da.html5Clone && a.innerHTML && !fa.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && Ea.test(a.type) ? (b.defaultChecked = b.checked = a.checked, 
            b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
        }
    }
    function y(b, c) {
        var d = fa(c.createElement(b)).appendTo(c.body), e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : fa.css(d[0], "display");
        return d.detach(), e;
    }
    function z(a) {
        var b = pa, c = _a[a];
        return c || (c = y(a, b), "none" !== c && c || ($a = ($a || fa("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), 
        b = ($a[0].contentWindow || $a[0].contentDocument).document, b.write(), b.close(), 
        c = y(a, b), $a.detach()), _a[a] = c), c;
    }
    function A(a, b) {
        return {
            get: function() {
                var c = a();
                if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments);
            }
        };
    }
    function B(a, b) {
        if (b in a) return b;
        for (var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = mb.length; e--; ) if ((b = mb[e] + c) in a) return b;
        return d;
    }
    function C(a, b) {
        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = fa._data(d, "olddisplay"), 
        c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && Ca(d) && (f[g] = fa._data(d, "olddisplay", z(d.nodeName)))) : f[g] || (e = Ca(d), 
        (c && "none" !== c || !e) && fa._data(d, "olddisplay", e ? c : fa.css(d, "display"))));
        for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
        return a;
    }
    function D(a, b, c) {
        var d = ib.exec(b);
        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
    }
    function E(a, b, c, d, e) {
        for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += fa.css(a, c + Ba[f], !0, e)), 
        d ? ("content" === c && (g -= fa.css(a, "padding" + Ba[f], !0, e)), "margin" !== c && (g -= fa.css(a, "border" + Ba[f] + "Width", !0, e))) : (g += fa.css(a, "padding" + Ba[f], !0, e), 
        "padding" !== c && (g += fa.css(a, "border" + Ba[f] + "Width", !0, e)));
        return g;
    }
    function F(a, b, c) {
        var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = ab(a), g = da.boxSizing() && "border-box" === fa.css(a, "boxSizing", !1, f);
        if (0 >= e || null == e) {
            if (e = bb(a, b, f), (0 > e || null == e) && (e = a.style[b]), db.test(e)) return e;
            d = g && (da.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
        }
        return e + E(a, b, c || (g ? "border" : "content"), d, f) + "px";
    }
    function G(a, b, c, d, e) {
        return new G.prototype.init(a, b, c, d, e);
    }
    function H() {
        return setTimeout(function() {
            nb = void 0;
        }), nb = fa.now();
    }
    function I(a, b) {
        var c, d = {
            height: a
        }, e = 0;
        for (b = b ? 1 : 0; 4 > e; e += 2 - b) c = Ba[e], d["margin" + c] = d["padding" + c] = a;
        return b && (d.opacity = d.width = a), d;
    }
    function J(a, b, c) {
        for (var d, e = (tb[b] || []).concat(tb["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d;
    }
    function K(a, b, c) {
        var d, e, f, g, h, i, j, k, l = this, m = {}, n = a.style, o = a.nodeType && Ca(a), p = fa._data(a, "fxshow");
        c.queue || (h = fa._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, 
        i = h.empty.fire, h.empty.fire = function() {
            h.unqueued || i();
        }), h.unqueued++, l.always(function() {
            l.always(function() {
                h.unqueued--, fa.queue(a, "fx").length || h.empty.fire();
            });
        })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [ n.overflow, n.overflowX, n.overflowY ], 
        j = fa.css(a, "display"), k = z(a.nodeName), "none" === j && (j = k), "inline" === j && "none" === fa.css(a, "float") && (da.inlineBlockNeedsLayout && "inline" !== k ? n.zoom = 1 : n.display = "inline-block")), 
        c.overflow && (n.overflow = "hidden", da.shrinkWrapBlocks() || l.always(function() {
            n.overflow = c.overflow[0], n.overflowX = c.overflow[1], n.overflowY = c.overflow[2];
        }));
        for (d in b) if (e = b[d], pb.exec(e)) {
            if (delete b[d], f = f || "toggle" === e, e === (o ? "hide" : "show")) {
                if ("show" !== e || !p || void 0 === p[d]) continue;
                o = !0;
            }
            m[d] = p && p[d] || fa.style(a, d);
        }
        if (!fa.isEmptyObject(m)) {
            p ? "hidden" in p && (o = p.hidden) : p = fa._data(a, "fxshow", {}), f && (p.hidden = !o), 
            o ? fa(a).show() : l.done(function() {
                fa(a).hide();
            }), l.done(function() {
                var b;
                fa._removeData(a, "fxshow");
                for (b in m) fa.style(a, b, m[b]);
            });
            for (d in m) g = J(o ? p[d] : 0, d, l), d in p || (p[d] = g.start, o && (g.end = g.start, 
            g.start = "width" === d || "height" === d ? 1 : 0));
        }
    }
    function L(a, b) {
        var c, d, e, f, g;
        for (c in a) if (d = fa.camelCase(c), e = b[d], f = a[c], fa.isArray(f) && (e = f[1], 
        f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), (g = fa.cssHooks[d]) && "expand" in g) {
            f = g.expand(f), delete a[d];
            for (c in f) c in a || (a[c] = f[c], b[c] = e);
        } else b[d] = e;
    }
    function M(a, b, c) {
        var d, e, f = 0, g = sb.length, h = fa.Deferred().always(function() {
            delete i.elem;
        }), i = function() {
            if (e) return !1;
            for (var b = nb || H(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
            return h.notifyWith(a, [ j, f, c ]), 1 > f && i ? c : (h.resolveWith(a, [ j ]), 
            !1);
        }, j = h.promise({
            elem: a,
            props: fa.extend({}, b),
            opts: fa.extend(!0, {
                specialEasing: {}
            }, c),
            originalProperties: b,
            originalOptions: c,
            startTime: nb || H(),
            duration: c.duration,
            tweens: [],
            createTween: function(b, c) {
                var d = fa.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                return j.tweens.push(d), d;
            },
            stop: function(b) {
                var c = 0, d = b ? j.tweens.length : 0;
                if (e) return this;
                for (e = !0; d > c; c++) j.tweens[c].run(1);
                return b ? h.resolveWith(a, [ j, b ]) : h.rejectWith(a, [ j, b ]), this;
            }
        }), k = j.props;
        for (L(k, j.opts.specialEasing); g > f; f++) if (d = sb[f].call(j, a, k, j.opts)) return d;
        return fa.map(k, J, j), fa.isFunction(j.opts.start) && j.opts.start.call(a, j), 
        fa.fx.timer(fa.extend(i, {
            elem: a,
            anim: j,
            queue: j.opts.queue
        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
    }
    function N(a) {
        return function(b, c) {
            "string" != typeof b && (c = b, b = "*");
            var d, e = 0, f = b.toLowerCase().match(ta) || [];
            if (fa.isFunction(c)) for (;d = f[e++]; ) "+" === d.charAt(0) ? (d = d.slice(1) || "*", 
            (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
        };
    }
    function O(a, b, c, d) {
        function e(h) {
            var i;
            return f[h] = !0, fa.each(a[h] || [], function(a, h) {
                var j = h(b, c, d);
                return "string" != typeof j || g || f[j] ? g ? !(i = j) : void 0 : (b.dataTypes.unshift(j), 
                e(j), !1);
            }), i;
        }
        var f = {}, g = a === Rb;
        return e(b.dataTypes[0]) || !f["*"] && e("*");
    }
    function P(a, b) {
        var c, d, e = fa.ajaxSettings.flatOptions || {};
        for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
        return c && fa.extend(!0, a, c), a;
    }
    function Q(a, b, c) {
        for (var d, e, f, g, h = a.contents, i = a.dataTypes; "*" === i[0]; ) i.shift(), 
        void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
        if (e) for (g in h) if (h[g] && h[g].test(e)) {
            i.unshift(g);
            break;
        }
        if (i[0] in c) f = i[0]; else {
            for (g in c) {
                if (!i[0] || a.converters[g + " " + i[0]]) {
                    f = g;
                    break;
                }
                d || (d = g);
            }
            f = f || d;
        }
        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
    }
    function R(a, b, c, d) {
        var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
        if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
        for (f = k.shift(); f; ) if (a.responseFields[f] && (c[a.responseFields[f]] = b), 
        !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) {
            if (!(g = j[i + " " + f] || j["* " + f])) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                !0 === g ? g = j[e] : !0 !== j[e] && (f = h[0], k.unshift(h[1]));
                break;
            }
            if (!0 !== g) if (g && a.throws) b = g(b); else try {
                b = g(b);
            } catch (a) {
                return {
                    state: "parsererror",
                    error: g ? a : "No conversion from " + i + " to " + f
                };
            }
        }
        return {
            state: "success",
            data: b
        };
    }
    function S(a, b, c, d) {
        var e;
        if (fa.isArray(b)) fa.each(b, function(b, e) {
            c || Ub.test(a) ? d(a, e) : S(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
        }); else if (c || "object" !== fa.type(b)) d(a, b); else for (e in b) S(a + "[" + e + "]", b[e], c, d);
    }
    function T() {
        try {
            return new a.XMLHttpRequest();
        } catch (a) {}
    }
    function U() {
        try {
            return new a.ActiveXObject("Microsoft.XMLHTTP");
        } catch (a) {}
    }
    function V(a) {
        return fa.isWindow(a) ? a : 9 === a.nodeType && (a.defaultView || a.parentWindow);
    }
    var W = [], X = W.slice, Y = W.concat, Z = W.push, $ = W.indexOf, _ = {}, aa = _.toString, ba = _.hasOwnProperty, ca = "".trim, da = {}, ea = "1.11.0", fa = function(a, b) {
        return new fa.fn.init(a, b);
    }, ga = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ha = /^-ms-/, ia = /-([\da-z])/gi, ja = function(a, b) {
        return b.toUpperCase();
    };
    fa.fn = fa.prototype = {
        jquery: ea,
        constructor: fa,
        selector: "",
        length: 0,
        toArray: function() {
            return X.call(this);
        },
        get: function(a) {
            return null != a ? 0 > a ? this[a + this.length] : this[a] : X.call(this);
        },
        pushStack: function(a) {
            var b = fa.merge(this.constructor(), a);
            return b.prevObject = this, b.context = this.context, b;
        },
        each: function(a, b) {
            return fa.each(this, a, b);
        },
        map: function(a) {
            return this.pushStack(fa.map(this, function(b, c) {
                return a.call(b, c, b);
            }));
        },
        slice: function() {
            return this.pushStack(X.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(a) {
            var b = this.length, c = +a + (0 > a ? b : 0);
            return this.pushStack(c >= 0 && b > c ? [ this[c] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: Z,
        sort: W.sort,
        splice: W.splice
    }, fa.extend = fa.fn.extend = function() {
        var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
        for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || fa.isFunction(g) || (g = {}), 
        h === i && (g = this, h--); i > h; h++) if (null != (e = arguments[h])) for (d in e) a = g[d], 
        c = e[d], g !== c && (j && c && (fa.isPlainObject(c) || (b = fa.isArray(c))) ? (b ? (b = !1, 
        f = a && fa.isArray(a) ? a : []) : f = a && fa.isPlainObject(a) ? a : {}, g[d] = fa.extend(j, f, c)) : void 0 !== c && (g[d] = c));
        return g;
    }, fa.extend({
        expando: "jQuery" + (ea + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(a) {
            throw new Error(a);
        },
        noop: function() {},
        isFunction: function(a) {
            return "function" === fa.type(a);
        },
        isArray: Array.isArray || function(a) {
            return "array" === fa.type(a);
        },
        isWindow: function(a) {
            return null != a && a == a.window;
        },
        isNumeric: function(a) {
            return a - parseFloat(a) >= 0;
        },
        isEmptyObject: function(a) {
            var b;
            for (b in a) return !1;
            return !0;
        },
        isPlainObject: function(a) {
            var b;
            if (!a || "object" !== fa.type(a) || a.nodeType || fa.isWindow(a)) return !1;
            try {
                if (a.constructor && !ba.call(a, "constructor") && !ba.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (a) {
                return !1;
            }
            if (da.ownLast) for (b in a) return ba.call(a, b);
            for (b in a) ;
            return void 0 === b || ba.call(a, b);
        },
        type: function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? _[aa.call(a)] || "object" : typeof a;
        },
        globalEval: function(b) {
            b && fa.trim(b) && (a.execScript || function(b) {
                a.eval.call(a, b);
            })(b);
        },
        camelCase: function(a) {
            return a.replace(ha, "ms-").replace(ia, ja);
        },
        nodeName: function(a, b) {
            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
        },
        each: function(a, b, d) {
            var e = 0, f = a.length, g = c(a);
            if (d) {
                if (g) for (;f > e && !1 !== b.apply(a[e], d); e++) ; else for (e in a) if (!1 === b.apply(a[e], d)) break;
            } else if (g) for (;f > e && !1 !== b.call(a[e], e, a[e]); e++) ; else for (e in a) if (!1 === b.call(a[e], e, a[e])) break;
            return a;
        },
        trim: ca && !ca.call("\ufeff ") ? function(a) {
            return null == a ? "" : ca.call(a);
        } : function(a) {
            return null == a ? "" : (a + "").replace(ga, "");
        },
        makeArray: function(a, b) {
            var d = b || [];
            return null != a && (c(Object(a)) ? fa.merge(d, "string" == typeof a ? [ a ] : a) : Z.call(d, a)), 
            d;
        },
        inArray: function(a, b, c) {
            var d;
            if (b) {
                if ($) return $.call(b, a, c);
                for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) if (c in b && b[c] === a) return c;
            }
            return -1;
        },
        merge: function(a, b) {
            for (var c = +b.length, d = 0, e = a.length; c > d; ) a[e++] = b[d++];
            if (c !== c) for (;void 0 !== b[d]; ) a[e++] = b[d++];
            return a.length = e, a;
        },
        grep: function(a, b, c) {
            for (var d = [], e = 0, f = a.length, g = !c; f > e; e++) !b(a[e], e) !== g && d.push(a[e]);
            return d;
        },
        map: function(a, b, d) {
            var e, f = 0, g = a.length, h = c(a), i = [];
            if (h) for (;g > f; f++) null != (e = b(a[f], f, d)) && i.push(e); else for (f in a) null != (e = b(a[f], f, d)) && i.push(e);
            return Y.apply([], i);
        },
        guid: 1,
        proxy: function(a, b) {
            var c, d, e;
            return "string" == typeof b && (e = a[b], b = a, a = e), fa.isFunction(a) ? (c = X.call(arguments, 2), 
            d = function() {
                return a.apply(b || this, c.concat(X.call(arguments)));
            }, d.guid = a.guid = a.guid || fa.guid++, d) : void 0;
        },
        now: function() {
            return +new Date();
        },
        support: da
    }), fa.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
        _["[object " + b + "]"] = b.toLowerCase();
    });
    var ka = function(a) {
        function b(a, b, c, d) {
            var e, f, g, h, i, j, l, o, p, q;
            if ((b ? b.ownerDocument || b : O) !== G && F(b), b = b || G, c = c || [], !a || "string" != typeof a) return c;
            if (1 !== (h = b.nodeType) && 9 !== h) return [];
            if (I && !d) {
                if (e = sa.exec(a)) if (g = e[1]) {
                    if (9 === h) {
                        if (!(f = b.getElementById(g)) || !f.parentNode) return c;
                        if (f.id === g) return c.push(f), c;
                    } else if (b.ownerDocument && (f = b.ownerDocument.getElementById(g)) && M(b, f) && f.id === g) return c.push(f), 
                    c;
                } else {
                    if (e[2]) return _.apply(c, b.getElementsByTagName(a)), c;
                    if ((g = e[3]) && x.getElementsByClassName && b.getElementsByClassName) return _.apply(c, b.getElementsByClassName(g)), 
                    c;
                }
                if (x.qsa && (!J || !J.test(a))) {
                    if (o = l = N, p = b, q = 9 === h && a, 1 === h && "object" !== b.nodeName.toLowerCase()) {
                        for (j = m(a), (l = b.getAttribute("id")) ? o = l.replace(ua, "\\$&") : b.setAttribute("id", o), 
                        o = "[id='" + o + "'] ", i = j.length; i--; ) j[i] = o + n(j[i]);
                        p = ta.test(a) && k(b.parentNode) || b, q = j.join(",");
                    }
                    if (q) try {
                        return _.apply(c, p.querySelectorAll(q)), c;
                    } catch (a) {} finally {
                        l || b.removeAttribute("id");
                    }
                }
            }
            return v(a.replace(ia, "$1"), b, c, d);
        }
        function c() {
            function a(c, d) {
                return b.push(c + " ") > y.cacheLength && delete a[b.shift()], a[c + " "] = d;
            }
            var b = [];
            return a;
        }
        function d(a) {
            return a[N] = !0, a;
        }
        function e(a) {
            var b = G.createElement("div");
            try {
                return !!a(b);
            } catch (a) {
                return !1;
            } finally {
                b.parentNode && b.parentNode.removeChild(b), b = null;
            }
        }
        function f(a, b) {
            for (var c = a.split("|"), d = a.length; d--; ) y.attrHandle[c[d]] = b;
        }
        function g(a, b) {
            var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || W) - (~a.sourceIndex || W);
            if (d) return d;
            if (c) for (;c = c.nextSibling; ) if (c === b) return -1;
            return a ? 1 : -1;
        }
        function h(a) {
            return function(b) {
                return "input" === b.nodeName.toLowerCase() && b.type === a;
            };
        }
        function i(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a;
            };
        }
        function j(a) {
            return d(function(b) {
                return b = +b, d(function(c, d) {
                    for (var e, f = a([], c.length, b), g = f.length; g--; ) c[e = f[g]] && (c[e] = !(d[e] = c[e]));
                });
            });
        }
        function k(a) {
            return a && typeof a.getElementsByTagName !== V && a;
        }
        function l() {}
        function m(a, c) {
            var d, e, f, g, h, i, j, k = S[a + " "];
            if (k) return c ? 0 : k.slice(0);
            for (h = a, i = [], j = y.preFilter; h; ) {
                (!d || (e = ja.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), 
                d = !1, (e = ka.exec(h)) && (d = e.shift(), f.push({
                    value: d,
                    type: e[0].replace(ia, " ")
                }), h = h.slice(d.length));
                for (g in y.filter) !(e = oa[g].exec(h)) || j[g] && !(e = j[g](e)) || (d = e.shift(), 
                f.push({
                    value: d,
                    type: g,
                    matches: e
                }), h = h.slice(d.length));
                if (!d) break;
            }
            return c ? h.length : h ? b.error(a) : S(a, i).slice(0);
        }
        function n(a) {
            for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
            return d;
        }
        function o(a, b, c) {
            var d = b.dir, e = c && "parentNode" === d, f = Q++;
            return b.first ? function(b, c, f) {
                for (;b = b[d]; ) if (1 === b.nodeType || e) return a(b, c, f);
            } : function(b, c, g) {
                var h, i, j = [ P, f ];
                if (g) {
                    for (;b = b[d]; ) if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
                } else for (;b = b[d]; ) if (1 === b.nodeType || e) {
                    if (i = b[N] || (b[N] = {}), (h = i[d]) && h[0] === P && h[1] === f) return j[2] = h[2];
                    if (i[d] = j, j[2] = a(b, c, g)) return !0;
                }
            };
        }
        function p(a) {
            return a.length > 1 ? function(b, c, d) {
                for (var e = a.length; e--; ) if (!a[e](b, c, d)) return !1;
                return !0;
            } : a[0];
        }
        function q(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), 
            j && b.push(h));
            return g;
        }
        function r(a, b, c, e, f, g) {
            return e && !e[N] && (e = r(e)), f && !f[N] && (f = r(f, g)), d(function(d, g, h, i) {
                var j, k, l, m = [], n = [], o = g.length, p = d || u(b || "*", h.nodeType ? [ h ] : h, []), r = !a || !d && b ? p : q(p, m, a, h, i), s = c ? f || (d ? a : o || e) ? [] : g : r;
                if (c && c(r, s, h, i), e) for (j = q(s, n), e(j, [], h, i), k = j.length; k--; ) (l = j[k]) && (s[n[k]] = !(r[n[k]] = l));
                if (d) {
                    if (f || a) {
                        if (f) {
                            for (j = [], k = s.length; k--; ) (l = s[k]) && j.push(r[k] = l);
                            f(null, s = [], j, i);
                        }
                        for (k = s.length; k--; ) (l = s[k]) && (j = f ? ba.call(d, l) : m[k]) > -1 && (d[j] = !(g[j] = l));
                    }
                } else s = q(s === g ? s.splice(o, s.length) : s), f ? f(null, g, s, i) : _.apply(g, s);
            });
        }
        function s(a) {
            for (var b, c, d, e = a.length, f = y.relative[a[0].type], g = f || y.relative[" "], h = f ? 1 : 0, i = o(function(a) {
                return a === b;
            }, g, !0), j = o(function(a) {
                return ba.call(b, a) > -1;
            }, g, !0), k = [ function(a, c, d) {
                return !f && (d || c !== C) || ((b = c).nodeType ? i(a, c, d) : j(a, c, d));
            } ]; e > h; h++) if (c = y.relative[a[h].type]) k = [ o(p(k), c) ]; else {
                if (c = y.filter[a[h].type].apply(null, a[h].matches), c[N]) {
                    for (d = ++h; e > d && !y.relative[a[d].type]; d++) ;
                    return r(h > 1 && p(k), h > 1 && n(a.slice(0, h - 1).concat({
                        value: " " === a[h - 2].type ? "*" : ""
                    })).replace(ia, "$1"), c, d > h && s(a.slice(h, d)), e > d && s(a = a.slice(d)), e > d && n(a));
                }
                k.push(c);
            }
            return p(k);
        }
        function t(a, c) {
            var e = c.length > 0, f = a.length > 0, g = function(d, g, h, i, j) {
                var k, l, m, n = 0, o = "0", p = d && [], r = [], s = C, t = d || f && y.find.TAG("*", j), u = P += null == s ? 1 : Math.random() || .1, v = t.length;
                for (j && (C = g !== G && g); o !== v && null != (k = t[o]); o++) {
                    if (f && k) {
                        for (l = 0; m = a[l++]; ) if (m(k, g, h)) {
                            i.push(k);
                            break;
                        }
                        j && (P = u);
                    }
                    e && ((k = !m && k) && n--, d && p.push(k));
                }
                if (n += o, e && o !== n) {
                    for (l = 0; m = c[l++]; ) m(p, r, g, h);
                    if (d) {
                        if (n > 0) for (;o--; ) p[o] || r[o] || (r[o] = Z.call(i));
                        r = q(r);
                    }
                    _.apply(i, r), j && !d && r.length > 0 && n + c.length > 1 && b.uniqueSort(i);
                }
                return j && (P = u, C = s), p;
            };
            return e ? d(g) : g;
        }
        function u(a, c, d) {
            for (var e = 0, f = c.length; f > e; e++) b(a, c[e], d);
            return d;
        }
        function v(a, b, c, d) {
            var e, f, g, h, i, j = m(a);
            if (!d && 1 === j.length) {
                if (f = j[0] = j[0].slice(0), f.length > 2 && "ID" === (g = f[0]).type && x.getById && 9 === b.nodeType && I && y.relative[f[1].type]) {
                    if (!(b = (y.find.ID(g.matches[0].replace(va, wa), b) || [])[0])) return c;
                    a = a.slice(f.shift().value.length);
                }
                for (e = oa.needsContext.test(a) ? 0 : f.length; e-- && (g = f[e], !y.relative[h = g.type]); ) if ((i = y.find[h]) && (d = i(g.matches[0].replace(va, wa), ta.test(f[0].type) && k(b.parentNode) || b))) {
                    if (f.splice(e, 1), !(a = d.length && n(f))) return _.apply(c, d), c;
                    break;
                }
            }
            return B(a, j)(d, b, !I, c, ta.test(a) && k(b.parentNode) || b), c;
        }
        var w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N = "sizzle" + -new Date(), O = a.document, P = 0, Q = 0, R = c(), S = c(), T = c(), U = function(a, b) {
            return a === b && (E = !0), 0;
        }, V = "undefined", W = 1 << 31, X = {}.hasOwnProperty, Y = [], Z = Y.pop, $ = Y.push, _ = Y.push, aa = Y.slice, ba = Y.indexOf || function(a) {
            for (var b = 0, c = this.length; c > b; b++) if (this[b] === a) return b;
            return -1;
        }, ca = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", da = "[\\x20\\t\\r\\n\\f]", ea = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", fa = ea.replace("w", "w#"), ga = "\\[" + da + "*(" + ea + ")" + da + "*(?:([*^$|!~]?=)" + da + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + fa + ")|)|)" + da + "*\\]", ha = ":(" + ea + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + ga.replace(3, 8) + ")*)|.*)\\)|)", ia = new RegExp("^" + da + "+|((?:^|[^\\\\])(?:\\\\.)*)" + da + "+$", "g"), ja = new RegExp("^" + da + "*," + da + "*"), ka = new RegExp("^" + da + "*([>+~]|" + da + ")" + da + "*"), la = new RegExp("=" + da + "*([^\\]'\"]*?)" + da + "*\\]", "g"), ma = new RegExp(ha), na = new RegExp("^" + fa + "$"), oa = {
            ID: new RegExp("^#(" + ea + ")"),
            CLASS: new RegExp("^\\.(" + ea + ")"),
            TAG: new RegExp("^(" + ea.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + ga),
            PSEUDO: new RegExp("^" + ha),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + da + "*(even|odd|(([+-]|)(\\d*)n|)" + da + "*(?:([+-]|)" + da + "*(\\d+)|))" + da + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + ca + ")$", "i"),
            needsContext: new RegExp("^" + da + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + da + "*((?:-\\d)?\\d*)" + da + "*\\)|)(?=[^-]|$)", "i")
        }, pa = /^(?:input|select|textarea|button)$/i, qa = /^h\d$/i, ra = /^[^{]+\{\s*\[native \w/, sa = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ta = /[+~]/, ua = /'|\\/g, va = new RegExp("\\\\([\\da-f]{1,6}" + da + "?|(" + da + ")|.)", "ig"), wa = function(a, b, c) {
            var d = "0x" + b - 65536;
            return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
        };
        try {
            _.apply(Y = aa.call(O.childNodes), O.childNodes), Y[O.childNodes.length].nodeType;
        } catch (a) {
            _ = {
                apply: Y.length ? function(a, b) {
                    $.apply(a, aa.call(b));
                } : function(a, b) {
                    for (var c = a.length, d = 0; a[c++] = b[d++]; ) ;
                    a.length = c - 1;
                }
            };
        }
        x = b.support = {}, A = b.isXML = function(a) {
            var b = a && (a.ownerDocument || a).documentElement;
            return !!b && "HTML" !== b.nodeName;
        }, F = b.setDocument = function(a) {
            var b, c = a ? a.ownerDocument || a : O, d = c.defaultView;
            return c !== G && 9 === c.nodeType && c.documentElement ? (G = c, H = c.documentElement, 
            I = !A(c), d && d !== d.top && (d.addEventListener ? d.addEventListener("unload", function() {
                F();
            }, !1) : d.attachEvent && d.attachEvent("onunload", function() {
                F();
            })), x.attributes = e(function(a) {
                return a.className = "i", !a.getAttribute("className");
            }), x.getElementsByTagName = e(function(a) {
                return a.appendChild(c.createComment("")), !a.getElementsByTagName("*").length;
            }), x.getElementsByClassName = ra.test(c.getElementsByClassName) && e(function(a) {
                return a.innerHTML = "<div class='a'></div><div class='a i'></div>", a.firstChild.className = "i", 
                2 === a.getElementsByClassName("i").length;
            }), x.getById = e(function(a) {
                return H.appendChild(a).id = N, !c.getElementsByName || !c.getElementsByName(N).length;
            }), x.getById ? (y.find.ID = function(a, b) {
                if (typeof b.getElementById !== V && I) {
                    var c = b.getElementById(a);
                    return c && c.parentNode ? [ c ] : [];
                }
            }, y.filter.ID = function(a) {
                var b = a.replace(va, wa);
                return function(a) {
                    return a.getAttribute("id") === b;
                };
            }) : (delete y.find.ID, y.filter.ID = function(a) {
                var b = a.replace(va, wa);
                return function(a) {
                    var c = typeof a.getAttributeNode !== V && a.getAttributeNode("id");
                    return c && c.value === b;
                };
            }), y.find.TAG = x.getElementsByTagName ? function(a, b) {
                return typeof b.getElementsByTagName !== V ? b.getElementsByTagName(a) : void 0;
            } : function(a, b) {
                var c, d = [], e = 0, f = b.getElementsByTagName(a);
                if ("*" === a) {
                    for (;c = f[e++]; ) 1 === c.nodeType && d.push(c);
                    return d;
                }
                return f;
            }, y.find.CLASS = x.getElementsByClassName && function(a, b) {
                return typeof b.getElementsByClassName !== V && I ? b.getElementsByClassName(a) : void 0;
            }, K = [], J = [], (x.qsa = ra.test(c.querySelectorAll)) && (e(function(a) {
                a.innerHTML = "<select t=''><option selected=''></option></select>", a.querySelectorAll("[t^='']").length && J.push("[*^$]=" + da + "*(?:''|\"\")"), 
                a.querySelectorAll("[selected]").length || J.push("\\[" + da + "*(?:value|" + ca + ")"), 
                a.querySelectorAll(":checked").length || J.push(":checked");
            }), e(function(a) {
                var b = c.createElement("input");
                b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && J.push("name" + da + "*[*^$|!~]?="), 
                a.querySelectorAll(":enabled").length || J.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), 
                J.push(",.*:");
            })), (x.matchesSelector = ra.test(L = H.webkitMatchesSelector || H.mozMatchesSelector || H.oMatchesSelector || H.msMatchesSelector)) && e(function(a) {
                x.disconnectedMatch = L.call(a, "div"), L.call(a, "[s!='']:x"), K.push("!=", ha);
            }), J = J.length && new RegExp(J.join("|")), K = K.length && new RegExp(K.join("|")), 
            b = ra.test(H.compareDocumentPosition), M = b || ra.test(H.contains) ? function(a, b) {
                var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, U = b ? function(a, b) {
                if (a === b) return E = !0, 0;
                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return d || (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & d || !x.sortDetached && b.compareDocumentPosition(a) === d ? a === c || a.ownerDocument === O && M(O, a) ? -1 : b === c || b.ownerDocument === O && M(O, b) ? 1 : D ? ba.call(D, a) - ba.call(D, b) : 0 : 4 & d ? -1 : 1);
            } : function(a, b) {
                if (a === b) return E = !0, 0;
                var d, e = 0, f = a.parentNode, h = b.parentNode, i = [ a ], j = [ b ];
                if (!f || !h) return a === c ? -1 : b === c ? 1 : f ? -1 : h ? 1 : D ? ba.call(D, a) - ba.call(D, b) : 0;
                if (f === h) return g(a, b);
                for (d = a; d = d.parentNode; ) i.unshift(d);
                for (d = b; d = d.parentNode; ) j.unshift(d);
                for (;i[e] === j[e]; ) e++;
                return e ? g(i[e], j[e]) : i[e] === O ? -1 : j[e] === O ? 1 : 0;
            }, c) : G;
        }, b.matches = function(a, c) {
            return b(a, null, null, c);
        }, b.matchesSelector = function(a, c) {
            if ((a.ownerDocument || a) !== G && F(a), c = c.replace(la, "='$1']"), !(!x.matchesSelector || !I || K && K.test(c) || J && J.test(c))) try {
                var d = L.call(a, c);
                if (d || x.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
            } catch (a) {}
            return b(c, G, null, [ a ]).length > 0;
        }, b.contains = function(a, b) {
            return (a.ownerDocument || a) !== G && F(a), M(a, b);
        }, b.attr = function(a, b) {
            (a.ownerDocument || a) !== G && F(a);
            var c = y.attrHandle[b.toLowerCase()], d = c && X.call(y.attrHandle, b.toLowerCase()) ? c(a, b, !I) : void 0;
            return void 0 !== d ? d : x.attributes || !I ? a.getAttribute(b) : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
        }, b.error = function(a) {
            throw new Error("Syntax error, unrecognized expression: " + a);
        }, b.uniqueSort = function(a) {
            var b, c = [], d = 0, e = 0;
            if (E = !x.detectDuplicates, D = !x.sortStable && a.slice(0), a.sort(U), E) {
                for (;b = a[e++]; ) b === a[e] && (d = c.push(e));
                for (;d--; ) a.splice(c[d], 1);
            }
            return D = null, a;
        }, z = b.getText = function(a) {
            var b, c = "", d = 0, e = a.nodeType;
            if (e) {
                if (1 === e || 9 === e || 11 === e) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += z(a);
                } else if (3 === e || 4 === e) return a.nodeValue;
            } else for (;b = a[d++]; ) c += z(b);
            return c;
        }, y = b.selectors = {
            cacheLength: 50,
            createPseudo: d,
            match: oa,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(a) {
                    return a[1] = a[1].replace(va, wa), a[3] = (a[4] || a[5] || "").replace(va, wa), 
                    "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
                },
                CHILD: function(a) {
                    return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || b.error(a[0]), 
                    a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && b.error(a[0]), 
                    a;
                },
                PSEUDO: function(a) {
                    var b, c = !a[5] && a[2];
                    return oa.CHILD.test(a[0]) ? null : (a[3] && void 0 !== a[4] ? a[2] = a[4] : c && ma.test(c) && (b = m(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), 
                    a[2] = c.slice(0, b)), a.slice(0, 3));
                }
            },
            filter: {
                TAG: function(a) {
                    var b = a.replace(va, wa).toLowerCase();
                    return "*" === a ? function() {
                        return !0;
                    } : function(a) {
                        return a.nodeName && a.nodeName.toLowerCase() === b;
                    };
                },
                CLASS: function(a) {
                    var b = R[a + " "];
                    return b || (b = new RegExp("(^|" + da + ")" + a + "(" + da + "|$)")) && R(a, function(a) {
                        return b.test("string" == typeof a.className && a.className || typeof a.getAttribute !== V && a.getAttribute("class") || "");
                    });
                },
                ATTR: function(a, c, d) {
                    return function(e) {
                        var f = b.attr(e, a);
                        return null == f ? "!=" === c : !c || (f += "", "=" === c ? f === d : "!=" === c ? f !== d : "^=" === c ? d && 0 === f.indexOf(d) : "*=" === c ? d && f.indexOf(d) > -1 : "$=" === c ? d && f.slice(-d.length) === d : "~=" === c ? (" " + f + " ").indexOf(d) > -1 : "|=" === c && (f === d || f.slice(0, d.length + 1) === d + "-"));
                    };
                },
                CHILD: function(a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                    return 1 === d && 0 === e ? function(a) {
                        return !!a.parentNode;
                    } : function(b, c, i) {
                        var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h;
                        if (q) {
                            if (f) {
                                for (;p; ) {
                                    for (l = b; l = l[p]; ) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                                    o = p = "only" === a && !o && "nextSibling";
                                }
                                return !0;
                            }
                            if (o = [ g ? q.firstChild : q.lastChild ], g && s) {
                                for (k = q[N] || (q[N] = {}), j = k[a] || [], n = j[0] === P && j[1], m = j[0] === P && j[2], 
                                l = n && q.childNodes[n]; l = ++n && l && l[p] || (m = n = 0) || o.pop(); ) if (1 === l.nodeType && ++m && l === b) {
                                    k[a] = [ P, n, m ];
                                    break;
                                }
                            } else if (s && (j = (b[N] || (b[N] = {}))[a]) && j[0] === P) m = j[1]; else for (;(l = ++n && l && l[p] || (m = n = 0) || o.pop()) && ((h ? l.nodeName.toLowerCase() !== r : 1 !== l.nodeType) || !++m || (s && ((l[N] || (l[N] = {}))[a] = [ P, m ]), 
                            l !== b)); ) ;
                            return (m -= e) === d || m % d == 0 && m / d >= 0;
                        }
                    };
                },
                PSEUDO: function(a, c) {
                    var e, f = y.pseudos[a] || y.setFilters[a.toLowerCase()] || b.error("unsupported pseudo: " + a);
                    return f[N] ? f(c) : f.length > 1 ? (e = [ a, a, "", c ], y.setFilters.hasOwnProperty(a.toLowerCase()) ? d(function(a, b) {
                        for (var d, e = f(a, c), g = e.length; g--; ) d = ba.call(a, e[g]), a[d] = !(b[d] = e[g]);
                    }) : function(a) {
                        return f(a, 0, e);
                    }) : f;
                }
            },
            pseudos: {
                not: d(function(a) {
                    var b = [], c = [], e = B(a.replace(ia, "$1"));
                    return e[N] ? d(function(a, b, c, d) {
                        for (var f, g = e(a, null, d, []), h = a.length; h--; ) (f = g[h]) && (a[h] = !(b[h] = f));
                    }) : function(a, d, f) {
                        return b[0] = a, e(b, null, f, c), !c.pop();
                    };
                }),
                has: d(function(a) {
                    return function(c) {
                        return b(a, c).length > 0;
                    };
                }),
                contains: d(function(a) {
                    return function(b) {
                        return (b.textContent || b.innerText || z(b)).indexOf(a) > -1;
                    };
                }),
                lang: d(function(a) {
                    return na.test(a || "") || b.error("unsupported lang: " + a), a = a.replace(va, wa).toLowerCase(), 
                    function(b) {
                        var c;
                        do {
                            if (c = I ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return (c = c.toLowerCase()) === a || 0 === c.indexOf(a + "-");
                        } while ((b = b.parentNode) && 1 === b.nodeType);
                        return !1;
                    };
                }),
                target: function(b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id;
                },
                root: function(a) {
                    return a === H;
                },
                focus: function(a) {
                    return a === G.activeElement && (!G.hasFocus || G.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
                },
                enabled: function(a) {
                    return !1 === a.disabled;
                },
                disabled: function(a) {
                    return !0 === a.disabled;
                },
                checked: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && !!a.checked || "option" === b && !!a.selected;
                },
                selected: function(a) {
                    return a.parentNode && a.parentNode.selectedIndex, !0 === a.selected;
                },
                empty: function(a) {
                    for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(a) {
                    return !y.pseudos.empty(a);
                },
                header: function(a) {
                    return qa.test(a.nodeName);
                },
                input: function(a) {
                    return pa.test(a.nodeName);
                },
                button: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b;
                },
                text: function(a) {
                    var b;
                    return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());
                },
                first: j(function() {
                    return [ 0 ];
                }),
                last: j(function(a, b) {
                    return [ b - 1 ];
                }),
                eq: j(function(a, b, c) {
                    return [ 0 > c ? c + b : c ];
                }),
                even: j(function(a, b) {
                    for (var c = 0; b > c; c += 2) a.push(c);
                    return a;
                }),
                odd: j(function(a, b) {
                    for (var c = 1; b > c; c += 2) a.push(c);
                    return a;
                }),
                lt: j(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; --d >= 0; ) a.push(d);
                    return a;
                }),
                gt: j(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; ++d < b; ) a.push(d);
                    return a;
                })
            }
        }, y.pseudos.nth = y.pseudos.eq;
        for (w in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) y.pseudos[w] = h(w);
        for (w in {
            submit: !0,
            reset: !0
        }) y.pseudos[w] = i(w);
        return l.prototype = y.filters = y.pseudos, y.setFilters = new l(), B = b.compile = function(a, b) {
            var c, d = [], e = [], f = T[a + " "];
            if (!f) {
                for (b || (b = m(a)), c = b.length; c--; ) f = s(b[c]), f[N] ? d.push(f) : e.push(f);
                f = T(a, t(e, d));
            }
            return f;
        }, x.sortStable = N.split("").sort(U).join("") === N, x.detectDuplicates = !!E, 
        F(), x.sortDetached = e(function(a) {
            return 1 & a.compareDocumentPosition(G.createElement("div"));
        }), e(function(a) {
            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
        }) || f("type|href|height|width", function(a, b, c) {
            return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
        }), x.attributes && e(function(a) {
            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");
        }) || f("value", function(a, b, c) {
            return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
        }), e(function(a) {
            return null == a.getAttribute("disabled");
        }) || f(ca, function(a, b, c) {
            var d;
            return c ? void 0 : !0 === a[b] ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
        }), b;
    }(a);
    fa.find = ka, fa.expr = ka.selectors, fa.expr[":"] = fa.expr.pseudos, fa.unique = ka.uniqueSort, 
    fa.text = ka.getText, fa.isXMLDoc = ka.isXML, fa.contains = ka.contains;
    var la = fa.expr.match.needsContext, ma = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, na = /^.[^:#\[\.,]*$/;
    fa.filter = function(a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? fa.find.matchesSelector(d, a) ? [ d ] : [] : fa.find.matches(a, fa.grep(b, function(a) {
            return 1 === a.nodeType;
        }));
    }, fa.fn.extend({
        find: function(a) {
            var b, c = [], d = this, e = d.length;
            if ("string" != typeof a) return this.pushStack(fa(a).filter(function() {
                for (b = 0; e > b; b++) if (fa.contains(d[b], this)) return !0;
            }));
            for (b = 0; e > b; b++) fa.find(a, d[b], c);
            return c = this.pushStack(e > 1 ? fa.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, 
            c;
        },
        filter: function(a) {
            return this.pushStack(d(this, a || [], !1));
        },
        not: function(a) {
            return this.pushStack(d(this, a || [], !0));
        },
        is: function(a) {
            return !!d(this, "string" == typeof a && la.test(a) ? fa(a) : a || [], !1).length;
        }
    });
    var oa, pa = a.document, qa = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;
    (fa.fn.init = function(a, b) {
        var c, d;
        if (!a) return this;
        if ("string" == typeof a) {
            if (!(c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [ null, a, null ] : qa.exec(a)) || !c[1] && b) return !b || b.jquery ? (b || oa).find(a) : this.constructor(b).find(a);
            if (c[1]) {
                if (b = b instanceof fa ? b[0] : b, fa.merge(this, fa.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : pa, !0)), 
                ma.test(c[1]) && fa.isPlainObject(b)) for (c in b) fa.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                return this;
            }
            if ((d = pa.getElementById(c[2])) && d.parentNode) {
                if (d.id !== c[2]) return oa.find(a);
                this.length = 1, this[0] = d;
            }
            return this.context = pa, this.selector = a, this;
        }
        return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : fa.isFunction(a) ? void 0 !== oa.ready ? oa.ready(a) : a(fa) : (void 0 !== a.selector && (this.selector = a.selector, 
        this.context = a.context), fa.makeArray(a, this));
    }).prototype = fa.fn, oa = fa(pa);
    var ra = /^(?:parents|prev(?:Until|All))/, sa = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    fa.extend({
        dir: function(a, b, c) {
            for (var d = [], e = a[b]; e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !fa(e).is(c)); ) 1 === e.nodeType && d.push(e), 
            e = e[b];
            return d;
        },
        sibling: function(a, b) {
            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
            return c;
        }
    }), fa.fn.extend({
        has: function(a) {
            var b, c = fa(a, this), d = c.length;
            return this.filter(function() {
                for (b = 0; d > b; b++) if (fa.contains(this, c[b])) return !0;
            });
        },
        closest: function(a, b) {
            for (var c, d = 0, e = this.length, f = [], g = la.test(a) || "string" != typeof a ? fa(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && fa.find.matchesSelector(c, a))) {
                f.push(c);
                break;
            }
            return this.pushStack(f.length > 1 ? fa.unique(f) : f);
        },
        index: function(a) {
            return a ? "string" == typeof a ? fa.inArray(this[0], fa(a)) : fa.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(a, b) {
            return this.pushStack(fa.unique(fa.merge(this.get(), fa(a, b))));
        },
        addBack: function(a) {
            return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
        }
    }), fa.each({
        parent: function(a) {
            var b = a.parentNode;
            return b && 11 !== b.nodeType ? b : null;
        },
        parents: function(a) {
            return fa.dir(a, "parentNode");
        },
        parentsUntil: function(a, b, c) {
            return fa.dir(a, "parentNode", c);
        },
        next: function(a) {
            return e(a, "nextSibling");
        },
        prev: function(a) {
            return e(a, "previousSibling");
        },
        nextAll: function(a) {
            return fa.dir(a, "nextSibling");
        },
        prevAll: function(a) {
            return fa.dir(a, "previousSibling");
        },
        nextUntil: function(a, b, c) {
            return fa.dir(a, "nextSibling", c);
        },
        prevUntil: function(a, b, c) {
            return fa.dir(a, "previousSibling", c);
        },
        siblings: function(a) {
            return fa.sibling((a.parentNode || {}).firstChild, a);
        },
        children: function(a) {
            return fa.sibling(a.firstChild);
        },
        contents: function(a) {
            return fa.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : fa.merge([], a.childNodes);
        }
    }, function(a, b) {
        fa.fn[a] = function(c, d) {
            var e = fa.map(this, b, c);
            return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = fa.filter(d, e)), 
            this.length > 1 && (sa[a] || (e = fa.unique(e)), ra.test(a) && (e = e.reverse())), 
            this.pushStack(e);
        };
    });
    var ta = /\S+/g, ua = {};
    fa.Callbacks = function(a) {
        a = "string" == typeof a ? ua[a] || f(a) : fa.extend({}, a);
        var b, c, d, e, g, h, i = [], j = !a.once && [], k = function(f) {
            for (c = a.memory && f, d = !0, g = h || 0, h = 0, e = i.length, b = !0; i && e > g; g++) if (!1 === i[g].apply(f[0], f[1]) && a.stopOnFalse) {
                c = !1;
                break;
            }
            b = !1, i && (j ? j.length && k(j.shift()) : c ? i = [] : l.disable());
        }, l = {
            add: function() {
                if (i) {
                    var d = i.length;
                    !function b(c) {
                        fa.each(c, function(c, d) {
                            var e = fa.type(d);
                            "function" === e ? a.unique && l.has(d) || i.push(d) : d && d.length && "string" !== e && b(d);
                        });
                    }(arguments), b ? e = i.length : c && (h = d, k(c));
                }
                return this;
            },
            remove: function() {
                return i && fa.each(arguments, function(a, c) {
                    for (var d; (d = fa.inArray(c, i, d)) > -1; ) i.splice(d, 1), b && (e >= d && e--, 
                    g >= d && g--);
                }), this;
            },
            has: function(a) {
                return a ? fa.inArray(a, i) > -1 : !(!i || !i.length);
            },
            empty: function() {
                return i = [], e = 0, this;
            },
            disable: function() {
                return i = j = c = void 0, this;
            },
            disabled: function() {
                return !i;
            },
            lock: function() {
                return j = void 0, c || l.disable(), this;
            },
            locked: function() {
                return !j;
            },
            fireWith: function(a, c) {
                return !i || d && !j || (c = c || [], c = [ a, c.slice ? c.slice() : c ], b ? j.push(c) : k(c)), 
                this;
            },
            fire: function() {
                return l.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!d;
            }
        };
        return l;
    }, fa.extend({
        Deferred: function(a) {
            var b = [ [ "resolve", "done", fa.Callbacks("once memory"), "resolved" ], [ "reject", "fail", fa.Callbacks("once memory"), "rejected" ], [ "notify", "progress", fa.Callbacks("memory") ] ], c = "pending", d = {
                state: function() {
                    return c;
                },
                always: function() {
                    return e.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var a = arguments;
                    return fa.Deferred(function(c) {
                        fa.each(b, function(b, f) {
                            var g = fa.isFunction(a[b]) && a[b];
                            e[f[1]](function() {
                                var a = g && g.apply(this, arguments);
                                a && fa.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [ a ] : arguments);
                            });
                        }), a = null;
                    }).promise();
                },
                promise: function(a) {
                    return null != a ? fa.extend(a, d) : d;
                }
            }, e = {};
            return d.pipe = d.then, fa.each(b, function(a, f) {
                var g = f[2], h = f[3];
                d[f[1]] = g.add, h && g.add(function() {
                    c = h;
                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
                    return e[f[0] + "With"](this === e ? d : this, arguments), this;
                }, e[f[0] + "With"] = g.fireWith;
            }), d.promise(e), a && a.call(e, e), e;
        },
        when: function(a) {
            var b, c, d, e = 0, f = X.call(arguments), g = f.length, h = 1 !== g || a && fa.isFunction(a.promise) ? g : 0, i = 1 === h ? a : fa.Deferred(), j = function(a, c, d) {
                return function(e) {
                    c[a] = this, d[a] = arguments.length > 1 ? X.call(arguments) : e, d === b ? i.notifyWith(c, d) : --h || i.resolveWith(c, d);
                };
            };
            if (g > 1) for (b = new Array(g), c = new Array(g), d = new Array(g); g > e; e++) f[e] && fa.isFunction(f[e].promise) ? f[e].promise().done(j(e, d, f)).fail(i.reject).progress(j(e, c, b)) : --h;
            return h || i.resolveWith(d, f), i.promise();
        }
    });
    var va;
    fa.fn.ready = function(a) {
        return fa.ready.promise().done(a), this;
    }, fa.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(a) {
            a ? fa.readyWait++ : fa.ready(!0);
        },
        ready: function(a) {
            if (!0 === a ? !--fa.readyWait : !fa.isReady) {
                if (!pa.body) return setTimeout(fa.ready);
                fa.isReady = !0, !0 !== a && --fa.readyWait > 0 || (va.resolveWith(pa, [ fa ]), 
                fa.fn.trigger && fa(pa).trigger("ready").off("ready"));
            }
        }
    }), fa.ready.promise = function(b) {
        if (!va) if (va = fa.Deferred(), "complete" === pa.readyState) setTimeout(fa.ready); else if (pa.addEventListener) pa.addEventListener("DOMContentLoaded", h, !1), 
        a.addEventListener("load", h, !1); else {
            pa.attachEvent("onreadystatechange", h), a.attachEvent("onload", h);
            var c = !1;
            try {
                c = null == a.frameElement && pa.documentElement;
            } catch (a) {}
            c && c.doScroll && function a() {
                if (!fa.isReady) {
                    try {
                        c.doScroll("left");
                    } catch (b) {
                        return setTimeout(a, 50);
                    }
                    g(), fa.ready();
                }
            }();
        }
        return va.promise(b);
    };
    var wa, xa = "undefined";
    for (wa in fa(da)) break;
    da.ownLast = "0" !== wa, da.inlineBlockNeedsLayout = !1, fa(function() {
        var a, b, c = pa.getElementsByTagName("body")[0];
        c && (a = pa.createElement("div"), a.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", 
        b = pa.createElement("div"), c.appendChild(a).appendChild(b), typeof b.style.zoom !== xa && (b.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1", 
        (da.inlineBlockNeedsLayout = 3 === b.offsetWidth) && (c.style.zoom = 1)), c.removeChild(a), 
        a = b = null);
    }), function() {
        var a = pa.createElement("div");
        if (null == da.deleteExpando) {
            da.deleteExpando = !0;
            try {
                delete a.test;
            } catch (a) {
                da.deleteExpando = !1;
            }
        }
        a = null;
    }(), fa.acceptData = function(a) {
        var b = fa.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1;
        return (1 === c || 9 === c) && (!b || !0 !== b && a.getAttribute("classid") === b);
    };
    var ya = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, za = /([A-Z])/g;
    fa.extend({
        cache: {},
        noData: {
            "applet ": !0,
            "embed ": !0,
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(a) {
            return !!(a = a.nodeType ? fa.cache[a[fa.expando]] : a[fa.expando]) && !j(a);
        },
        data: function(a, b, c) {
            return k(a, b, c);
        },
        removeData: function(a, b) {
            return l(a, b);
        },
        _data: function(a, b, c) {
            return k(a, b, c, !0);
        },
        _removeData: function(a, b) {
            return l(a, b, !0);
        }
    }), fa.fn.extend({
        data: function(a, b) {
            var c, d, e, f = this[0], g = f && f.attributes;
            if (void 0 === a) {
                if (this.length && (e = fa.data(f), 1 === f.nodeType && !fa._data(f, "parsedAttrs"))) {
                    for (c = g.length; c--; ) d = g[c].name, 0 === d.indexOf("data-") && (d = fa.camelCase(d.slice(5)), 
                    i(f, d, e[d]));
                    fa._data(f, "parsedAttrs", !0);
                }
                return e;
            }
            return "object" == typeof a ? this.each(function() {
                fa.data(this, a);
            }) : arguments.length > 1 ? this.each(function() {
                fa.data(this, a, b);
            }) : f ? i(f, a, fa.data(f, a)) : void 0;
        },
        removeData: function(a) {
            return this.each(function() {
                fa.removeData(this, a);
            });
        }
    }), fa.extend({
        queue: function(a, b, c) {
            var d;
            return a ? (b = (b || "fx") + "queue", d = fa._data(a, b), c && (!d || fa.isArray(c) ? d = fa._data(a, b, fa.makeArray(c)) : d.push(c)), 
            d || []) : void 0;
        },
        dequeue: function(a, b) {
            b = b || "fx";
            var c = fa.queue(a, b), d = c.length, e = c.shift(), f = fa._queueHooks(a, b), g = function() {
                fa.dequeue(a, b);
            };
            "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), 
            delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
        },
        _queueHooks: function(a, b) {
            var c = b + "queueHooks";
            return fa._data(a, c) || fa._data(a, c, {
                empty: fa.Callbacks("once memory").add(function() {
                    fa._removeData(a, b + "queue"), fa._removeData(a, c);
                })
            });
        }
    }), fa.fn.extend({
        queue: function(a, b) {
            var c = 2;
            return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? fa.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                var c = fa.queue(this, a, b);
                fa._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && fa.dequeue(this, a);
            });
        },
        dequeue: function(a) {
            return this.each(function() {
                fa.dequeue(this, a);
            });
        },
        clearQueue: function(a) {
            return this.queue(a || "fx", []);
        },
        promise: function(a, b) {
            var c, d = 1, e = fa.Deferred(), f = this, g = this.length, h = function() {
                --d || e.resolveWith(f, [ f ]);
            };
            for ("string" != typeof a && (b = a, a = void 0), a = a || "fx"; g--; ) (c = fa._data(f[g], a + "queueHooks")) && c.empty && (d++, 
            c.empty.add(h));
            return h(), e.promise(b);
        }
    });
    var Aa = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Ba = [ "Top", "Right", "Bottom", "Left" ], Ca = function(a, b) {
        return a = b || a, "none" === fa.css(a, "display") || !fa.contains(a.ownerDocument, a);
    }, Da = fa.access = function(a, b, c, d, e, f, g) {
        var h = 0, i = a.length, j = null == c;
        if ("object" === fa.type(c)) {
            e = !0;
            for (h in c) fa.access(a, b, h, c[h], !0, f, g);
        } else if (void 0 !== d && (e = !0, fa.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), 
        b = null) : (j = b, b = function(a, b, c) {
            return j.call(fa(a), c);
        })), b)) for (;i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
    }, Ea = /^(?:checkbox|radio)$/i;
    !function() {
        var a = pa.createDocumentFragment(), b = pa.createElement("div"), c = pa.createElement("input");
        if (b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a>", 
        da.leadingWhitespace = 3 === b.firstChild.nodeType, da.tbody = !b.getElementsByTagName("tbody").length, 
        da.htmlSerialize = !!b.getElementsByTagName("link").length, da.html5Clone = "<:nav></:nav>" !== pa.createElement("nav").cloneNode(!0).outerHTML, 
        c.type = "checkbox", c.checked = !0, a.appendChild(c), da.appendChecked = c.checked, 
        b.innerHTML = "<textarea>x</textarea>", da.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, 
        a.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", 
        da.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, da.noCloneEvent = !0, 
        b.attachEvent && (b.attachEvent("onclick", function() {
            da.noCloneEvent = !1;
        }), b.cloneNode(!0).click()), null == da.deleteExpando) {
            da.deleteExpando = !0;
            try {
                delete b.test;
            } catch (a) {
                da.deleteExpando = !1;
            }
        }
        a = b = c = null;
    }(), function() {
        var b, c, d = pa.createElement("div");
        for (b in {
            submit: !0,
            change: !0,
            focusin: !0
        }) c = "on" + b, (da[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), da[b + "Bubbles"] = !1 === d.attributes[c].expando);
        d = null;
    }();
    var Fa = /^(?:input|select|textarea)$/i, Ga = /^key/, Ha = /^(?:mouse|contextmenu)|click/, Ia = /^(?:focusinfocus|focusoutblur)$/, Ja = /^([^.]*)(?:\.(.+)|)$/;
    fa.event = {
        global: {},
        add: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q = fa._data(a);
            if (q) {
                for (c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = fa.guid++), 
                (g = q.events) || (g = q.events = {}), (k = q.handle) || (k = q.handle = function(a) {
                    return typeof fa === xa || a && fa.event.triggered === a.type ? void 0 : fa.event.dispatch.apply(k.elem, arguments);
                }, k.elem = a), b = (b || "").match(ta) || [ "" ], h = b.length; h--; ) f = Ja.exec(b[h]) || [], 
                n = p = f[1], o = (f[2] || "").split(".").sort(), n && (j = fa.event.special[n] || {}, 
                n = (e ? j.delegateType : j.bindType) || n, j = fa.event.special[n] || {}, l = fa.extend({
                    type: n,
                    origType: p,
                    data: d,
                    handler: c,
                    guid: c.guid,
                    selector: e,
                    needsContext: e && fa.expr.match.needsContext.test(e),
                    namespace: o.join(".")
                }, i), (m = g[n]) || (m = g[n] = [], m.delegateCount = 0, j.setup && !1 !== j.setup.call(a, d, o, k) || (a.addEventListener ? a.addEventListener(n, k, !1) : a.attachEvent && a.attachEvent("on" + n, k))), 
                j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, l) : m.push(l), 
                fa.event.global[n] = !0);
                a = null;
            }
        },
        remove: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q = fa.hasData(a) && fa._data(a);
            if (q && (k = q.events)) {
                for (b = (b || "").match(ta) || [ "" ], j = b.length; j--; ) if (h = Ja.exec(b[j]) || [], 
                n = p = h[1], o = (h[2] || "").split(".").sort(), n) {
                    for (l = fa.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, 
                    m = k[n] || [], h = h[2] && new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
                    i = f = m.length; f--; ) g = m[f], !e && p !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (m.splice(f, 1), 
                    g.selector && m.delegateCount--, l.remove && l.remove.call(a, g));
                    i && !m.length && (l.teardown && !1 !== l.teardown.call(a, o, q.handle) || fa.removeEvent(a, n, q.handle), 
                    delete k[n]);
                } else for (n in k) fa.event.remove(a, n + b[j], c, d, !0);
                fa.isEmptyObject(k) && (delete q.handle, fa._removeData(a, "events"));
            }
        },
        trigger: function(b, c, d, e) {
            var f, g, h, i, j, k, l, m = [ d || pa ], n = ba.call(b, "type") ? b.type : b, o = ba.call(b, "namespace") ? b.namespace.split(".") : [];
            if (h = k = d = d || pa, 3 !== d.nodeType && 8 !== d.nodeType && !Ia.test(n + fa.event.triggered) && (n.indexOf(".") >= 0 && (o = n.split("."), 
            n = o.shift(), o.sort()), g = n.indexOf(":") < 0 && "on" + n, b = b[fa.expando] ? b : new fa.Event(n, "object" == typeof b && b), 
            b.isTrigger = e ? 2 : 3, b.namespace = o.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            b.result = void 0, b.target || (b.target = d), c = null == c ? [ b ] : fa.makeArray(c, [ b ]), 
            j = fa.event.special[n] || {}, e || !j.trigger || !1 !== j.trigger.apply(d, c))) {
                if (!e && !j.noBubble && !fa.isWindow(d)) {
                    for (i = j.delegateType || n, Ia.test(i + n) || (h = h.parentNode); h; h = h.parentNode) m.push(h), 
                    k = h;
                    k === (d.ownerDocument || pa) && m.push(k.defaultView || k.parentWindow || a);
                }
                for (l = 0; (h = m[l++]) && !b.isPropagationStopped(); ) b.type = l > 1 ? i : j.bindType || n, 
                f = (fa._data(h, "events") || {})[b.type] && fa._data(h, "handle"), f && f.apply(h, c), 
                (f = g && h[g]) && f.apply && fa.acceptData(h) && (b.result = f.apply(h, c), !1 === b.result && b.preventDefault());
                if (b.type = n, !e && !b.isDefaultPrevented() && (!j._default || !1 === j._default.apply(m.pop(), c)) && fa.acceptData(d) && g && d[n] && !fa.isWindow(d)) {
                    k = d[g], k && (d[g] = null), fa.event.triggered = n;
                    try {
                        d[n]();
                    } catch (a) {}
                    fa.event.triggered = void 0, k && (d[g] = k);
                }
                return b.result;
            }
        },
        dispatch: function(a) {
            a = fa.event.fix(a);
            var b, c, d, e, f, g = [], h = X.call(arguments), i = (fa._data(this, "events") || {})[a.type] || [], j = fa.event.special[a.type] || {};
            if (h[0] = a, a.delegateTarget = this, !j.preDispatch || !1 !== j.preDispatch.call(this, a)) {
                for (g = fa.event.handlers.call(this, a, i), b = 0; (e = g[b++]) && !a.isPropagationStopped(); ) for (a.currentTarget = e.elem, 
                f = 0; (d = e.handlers[f++]) && !a.isImmediatePropagationStopped(); ) (!a.namespace_re || a.namespace_re.test(d.namespace)) && (a.handleObj = d, 
                a.data = d.data, void 0 !== (c = ((fa.event.special[d.origType] || {}).handle || d.handler).apply(e.elem, h)) && !1 === (a.result = c) && (a.preventDefault(), 
                a.stopPropagation()));
                return j.postDispatch && j.postDispatch.call(this, a), a.result;
            }
        },
        handlers: function(a, b) {
            var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type)) for (;i != this; i = i.parentNode || this) if (1 === i.nodeType && (!0 !== i.disabled || "click" !== a.type)) {
                for (e = [], f = 0; h > f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? fa(c, this).index(i) >= 0 : fa.find(c, this, null, [ i ]).length), 
                e[c] && e.push(d);
                e.length && g.push({
                    elem: i,
                    handlers: e
                });
            }
            return h < b.length && g.push({
                elem: this,
                handlers: b.slice(h)
            }), g;
        },
        fix: function(a) {
            if (a[fa.expando]) return a;
            var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
            for (g || (this.fixHooks[e] = g = Ha.test(e) ? this.mouseHooks : Ga.test(e) ? this.keyHooks : {}), 
            d = g.props ? this.props.concat(g.props) : this.props, a = new fa.Event(f), b = d.length; b--; ) c = d[b], 
            a[c] = f[c];
            return a.target || (a.target = f.srcElement || pa), 3 === a.target.nodeType && (a.target = a.target.parentNode), 
            a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(a, b) {
                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), 
                a;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(a, b) {
                var c, d, e, f = b.button, g = b.fromElement;
                return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || pa, 
                e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), 
                a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), 
                !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), 
                a;
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== o() && this.focus) try {
                        return this.focus(), !1;
                    } catch (a) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === o() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return fa.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), 
                    !1) : void 0;
                },
                _default: function(a) {
                    return fa.nodeName(a.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(a) {
                    void 0 !== a.result && (a.originalEvent.returnValue = a.result);
                }
            }
        },
        simulate: function(a, b, c, d) {
            var e = fa.extend(new fa.Event(), c, {
                type: a,
                isSimulated: !0,
                originalEvent: {}
            });
            d ? fa.event.trigger(e, null, b) : fa.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
        }
    }, fa.removeEvent = pa.removeEventListener ? function(a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c, !1);
    } : function(a, b, c) {
        var d = "on" + b;
        a.detachEvent && (typeof a[d] === xa && (a[d] = null), a.detachEvent(d, c));
    }, fa.Event = function(a, b) {
        return this instanceof fa.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, 
        this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && (!1 === a.returnValue || a.getPreventDefault && a.getPreventDefault()) ? m : n) : this.type = a, 
        b && fa.extend(this, b), this.timeStamp = a && a.timeStamp || fa.now(), void (this[fa.expando] = !0)) : new fa.Event(a, b);
    }, fa.Event.prototype = {
        isDefaultPrevented: n,
        isPropagationStopped: n,
        isImmediatePropagationStopped: n,
        preventDefault: function() {
            var a = this.originalEvent;
            this.isDefaultPrevented = m, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
        },
        stopPropagation: function() {
            var a = this.originalEvent;
            this.isPropagationStopped = m, a && (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = m, this.stopPropagation();
        }
    }, fa.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function(a, b) {
        fa.event.special[a] = {
            delegateType: b,
            bindType: b,
            handle: function(a) {
                var c, d = this, e = a.relatedTarget, f = a.handleObj;
                return (!e || e !== d && !fa.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), 
                a.type = b), c;
            }
        };
    }), da.submitBubbles || (fa.event.special.submit = {
        setup: function() {
            return !fa.nodeName(this, "form") && void fa.event.add(this, "click._submit keypress._submit", function(a) {
                var b = a.target, c = fa.nodeName(b, "input") || fa.nodeName(b, "button") ? b.form : void 0;
                c && !fa._data(c, "submitBubbles") && (fa.event.add(c, "submit._submit", function(a) {
                    a._submit_bubble = !0;
                }), fa._data(c, "submitBubbles", !0));
            });
        },
        postDispatch: function(a) {
            a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && fa.event.simulate("submit", this.parentNode, a, !0));
        },
        teardown: function() {
            return !fa.nodeName(this, "form") && void fa.event.remove(this, "._submit");
        }
    }), da.changeBubbles || (fa.event.special.change = {
        setup: function() {
            return Fa.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (fa.event.add(this, "propertychange._change", function(a) {
                "checked" === a.originalEvent.propertyName && (this._just_changed = !0);
            }), fa.event.add(this, "click._change", function(a) {
                this._just_changed && !a.isTrigger && (this._just_changed = !1), fa.event.simulate("change", this, a, !0);
            })), !1) : void fa.event.add(this, "beforeactivate._change", function(a) {
                var b = a.target;
                Fa.test(b.nodeName) && !fa._data(b, "changeBubbles") && (fa.event.add(b, "change._change", function(a) {
                    !this.parentNode || a.isSimulated || a.isTrigger || fa.event.simulate("change", this.parentNode, a, !0);
                }), fa._data(b, "changeBubbles", !0));
            });
        },
        handle: function(a) {
            var b = a.target;
            return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0;
        },
        teardown: function() {
            return fa.event.remove(this, "._change"), !Fa.test(this.nodeName);
        }
    }), da.focusinBubbles || fa.each({
        focus: "focusin",
        blur: "focusout"
    }, function(a, b) {
        var c = function(a) {
            fa.event.simulate(b, a.target, fa.event.fix(a), !0);
        };
        fa.event.special[b] = {
            setup: function() {
                var d = this.ownerDocument || this, e = fa._data(d, b);
                e || d.addEventListener(a, c, !0), fa._data(d, b, (e || 0) + 1);
            },
            teardown: function() {
                var d = this.ownerDocument || this, e = fa._data(d, b) - 1;
                e ? fa._data(d, b, e) : (d.removeEventListener(a, c, !0), fa._removeData(d, b));
            }
        };
    }), fa.fn.extend({
        on: function(a, b, c, d, e) {
            var f, g;
            if ("object" == typeof a) {
                "string" != typeof b && (c = c || b, b = void 0);
                for (f in a) this.on(f, b, c, a[f], e);
                return this;
            }
            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, 
            c = void 0) : (d = c, c = b, b = void 0)), !1 === d) d = n; else if (!d) return this;
            return 1 === e && (g = d, d = function(a) {
                return fa().off(a), g.apply(this, arguments);
            }, d.guid = g.guid || (g.guid = fa.guid++)), this.each(function() {
                fa.event.add(this, a, d, c, b);
            });
        },
        one: function(a, b, c, d) {
            return this.on(a, b, c, d, 1);
        },
        off: function(a, b, c) {
            var d, e;
            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, fa(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), 
            this;
            if ("object" == typeof a) {
                for (e in a) this.off(e, b, a[e]);
                return this;
            }
            return (!1 === b || "function" == typeof b) && (c = b, b = void 0), !1 === c && (c = n), 
            this.each(function() {
                fa.event.remove(this, a, c, b);
            });
        },
        trigger: function(a, b) {
            return this.each(function() {
                fa.event.trigger(a, b, this);
            });
        },
        triggerHandler: function(a, b) {
            var c = this[0];
            return c ? fa.event.trigger(a, b, c, !0) : void 0;
        }
    });
    var Ka = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", La = / jQuery\d+="(?:null|\d+)"/g, Ma = new RegExp("<(?:" + Ka + ")[\\s/>]", "i"), Na = /^\s+/, Oa = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, Pa = /<([\w:]+)/, Qa = /<tbody/i, Ra = /<|&#?\w+;/, Sa = /<(?:script|style|link)/i, Ta = /checked\s*(?:[^=]|=\s*.checked.)/i, Ua = /^$|\/(?:java|ecma)script/i, Va = /^true\/(.*)/, Wa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, Xa = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: da.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, Ya = p(pa), Za = Ya.appendChild(pa.createElement("div"));
    Xa.optgroup = Xa.option, Xa.tbody = Xa.tfoot = Xa.colgroup = Xa.caption = Xa.thead, 
    Xa.th = Xa.td, fa.extend({
        clone: function(a, b, c) {
            var d, e, f, g, h, i = fa.contains(a.ownerDocument, a);
            if (da.html5Clone || fa.isXMLDoc(a) || !Ma.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (Za.innerHTML = a.outerHTML, 
            Za.removeChild(f = Za.firstChild)), !(da.noCloneEvent && da.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || fa.isXMLDoc(a))) for (d = q(f), 
            h = q(a), g = 0; null != (e = h[g]); ++g) d[g] && x(e, d[g]);
            if (b) if (c) for (h = h || q(a), d = d || q(f), g = 0; null != (e = h[g]); g++) w(e, d[g]); else w(a, f);
            return d = q(f, "script"), d.length > 0 && v(d, !i && q(a, "script")), d = h = e = null, 
            f;
        },
        buildFragment: function(a, b, c, d) {
            for (var e, f, g, h, i, j, k, l = a.length, m = p(b), n = [], o = 0; l > o; o++) if ((f = a[o]) || 0 === f) if ("object" === fa.type(f)) fa.merge(n, f.nodeType ? [ f ] : f); else if (Ra.test(f)) {
                for (h = h || m.appendChild(b.createElement("div")), i = (Pa.exec(f) || [ "", "" ])[1].toLowerCase(), 
                k = Xa[i] || Xa._default, h.innerHTML = k[1] + f.replace(Oa, "<$1></$2>") + k[2], 
                e = k[0]; e--; ) h = h.lastChild;
                if (!da.leadingWhitespace && Na.test(f) && n.push(b.createTextNode(Na.exec(f)[0])), 
                !da.tbody) for (f = "table" !== i || Qa.test(f) ? "<table>" !== k[1] || Qa.test(f) ? 0 : h : h.firstChild, 
                e = f && f.childNodes.length; e--; ) fa.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
                for (fa.merge(n, h.childNodes), h.textContent = ""; h.firstChild; ) h.removeChild(h.firstChild);
                h = m.lastChild;
            } else n.push(b.createTextNode(f));
            for (h && m.removeChild(h), da.appendChecked || fa.grep(q(n, "input"), r), o = 0; f = n[o++]; ) if ((!d || -1 === fa.inArray(f, d)) && (g = fa.contains(f.ownerDocument, f), 
            h = q(m.appendChild(f), "script"), g && v(h), c)) for (e = 0; f = h[e++]; ) Ua.test(f.type || "") && c.push(f);
            return h = null, m;
        },
        cleanData: function(a, b) {
            for (var c, d, e, f, g = 0, h = fa.expando, i = fa.cache, j = da.deleteExpando, k = fa.event.special; null != (c = a[g]); g++) if ((b || fa.acceptData(c)) && (e = c[h], 
            f = e && i[e])) {
                if (f.events) for (d in f.events) k[d] ? fa.event.remove(c, d) : fa.removeEvent(c, d, f.handle);
                i[e] && (delete i[e], j ? delete c[h] : typeof c.removeAttribute !== xa ? c.removeAttribute(h) : c[h] = null, 
                W.push(e));
            }
        }
    }), fa.fn.extend({
        text: function(a) {
            return Da(this, function(a) {
                return void 0 === a ? fa.text(this) : this.empty().append((this[0] && this[0].ownerDocument || pa).createTextNode(a));
            }, null, a, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    s(this, a).appendChild(a);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = s(this, a);
                    b.insertBefore(a, b.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
            });
        },
        remove: function(a, b) {
            for (var c, d = a ? fa.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || fa.cleanData(q(c)), 
            c.parentNode && (b && fa.contains(c.ownerDocument, c) && v(q(c, "script")), c.parentNode.removeChild(c));
            return this;
        },
        empty: function() {
            for (var a, b = 0; null != (a = this[b]); b++) {
                for (1 === a.nodeType && fa.cleanData(q(a, !1)); a.firstChild; ) a.removeChild(a.firstChild);
                a.options && fa.nodeName(a, "select") && (a.options.length = 0);
            }
            return this;
        },
        clone: function(a, b) {
            return a = null != a && a, b = null == b ? a : b, this.map(function() {
                return fa.clone(this, a, b);
            });
        },
        html: function(a) {
            return Da(this, function(a) {
                var b = this[0] || {}, c = 0, d = this.length;
                if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(La, "") : void 0;
                if (!("string" != typeof a || Sa.test(a) || !da.htmlSerialize && Ma.test(a) || !da.leadingWhitespace && Na.test(a) || Xa[(Pa.exec(a) || [ "", "" ])[1].toLowerCase()])) {
                    a = a.replace(Oa, "<$1></$2>");
                    try {
                        for (;d > c; c++) b = this[c] || {}, 1 === b.nodeType && (fa.cleanData(q(b, !1)), 
                        b.innerHTML = a);
                        b = 0;
                    } catch (a) {}
                }
                b && this.empty().append(a);
            }, null, a, arguments.length);
        },
        replaceWith: function() {
            var a = arguments[0];
            return this.domManip(arguments, function(b) {
                a = this.parentNode, fa.cleanData(q(this)), a && a.replaceChild(b, this);
            }), a && (a.length || a.nodeType) ? this : this.remove();
        },
        detach: function(a) {
            return this.remove(a, !0);
        },
        domManip: function(a, b) {
            a = Y.apply([], a);
            var c, d, e, f, g, h, i = 0, j = this.length, k = this, l = j - 1, m = a[0], n = fa.isFunction(m);
            if (n || j > 1 && "string" == typeof m && !da.checkClone && Ta.test(m)) return this.each(function(c) {
                var d = k.eq(c);
                n && (a[0] = m.call(this, c, d.html())), d.domManip(a, b);
            });
            if (j && (h = fa.buildFragment(a, this[0].ownerDocument, !1, this), c = h.firstChild, 
            1 === h.childNodes.length && (h = c), c)) {
                for (f = fa.map(q(h, "script"), t), e = f.length; j > i; i++) d = h, i !== l && (d = fa.clone(d, !0, !0), 
                e && fa.merge(f, q(d, "script"))), b.call(this[i], d, i);
                if (e) for (g = f[f.length - 1].ownerDocument, fa.map(f, u), i = 0; e > i; i++) d = f[i], 
                Ua.test(d.type || "") && !fa._data(d, "globalEval") && fa.contains(g, d) && (d.src ? fa._evalUrl && fa._evalUrl(d.src) : fa.globalEval((d.text || d.textContent || d.innerHTML || "").replace(Wa, "")));
                h = c = null;
            }
            return this;
        }
    }), fa.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(a, b) {
        fa.fn[a] = function(a) {
            for (var c, d = 0, e = [], f = fa(a), g = f.length - 1; g >= d; d++) c = d === g ? this : this.clone(!0), 
            fa(f[d])[b](c), Z.apply(e, c.get());
            return this.pushStack(e);
        };
    });
    var $a, _a = {};
    !function() {
        var a, b, c = pa.createElement("div");
        c.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        a = c.getElementsByTagName("a")[0], a.style.cssText = "float:left;opacity:.5", da.opacity = /^0.5/.test(a.style.opacity), 
        da.cssFloat = !!a.style.cssFloat, c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", 
        da.clearCloneStyle = "content-box" === c.style.backgroundClip, a = c = null, da.shrinkWrapBlocks = function() {
            var a, c, d;
            if (null == b) {
                if (!(a = pa.getElementsByTagName("body")[0])) return;
                c = pa.createElement("div"), d = pa.createElement("div"), a.appendChild(c).appendChild(d), 
                b = !1, typeof d.style.zoom !== xa && (d.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0;width:1px;padding:1px;zoom:1", 
                d.innerHTML = "<div></div>", d.firstChild.style.width = "5px", b = 3 !== d.offsetWidth), 
                a.removeChild(c), a = c = d = null;
            }
            return b;
        };
    }();
    var ab, bb, cb = /^margin/, db = new RegExp("^(" + Aa + ")(?!px)[a-z%]+$", "i"), eb = /^(top|right|bottom|left)$/;
    a.getComputedStyle ? (ab = function(a) {
        return a.ownerDocument.defaultView.getComputedStyle(a, null);
    }, bb = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || ab(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || fa.contains(a.ownerDocument, a) || (g = fa.style(a, b)), 
        db.test(g) && cb.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, 
        g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + "";
    }) : pa.documentElement.currentStyle && (ab = function(a) {
        return a.currentStyle;
    }, bb = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || ab(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), 
        db.test(g) && !eb.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), 
        h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), 
        void 0 === g ? g : g + "" || "auto";
    }), !function() {
        function b() {
            var b, c, d = pa.getElementsByTagName("body")[0];
            d && (b = pa.createElement("div"), c = pa.createElement("div"), b.style.cssText = j, 
            d.appendChild(b).appendChild(c), c.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%", 
            fa.swap(d, null != d.style.zoom ? {
                zoom: 1
            } : {}, function() {
                e = 4 === c.offsetWidth;
            }), f = !0, g = !1, h = !0, a.getComputedStyle && (g = "1%" !== (a.getComputedStyle(c, null) || {}).top, 
            f = "4px" === (a.getComputedStyle(c, null) || {
                width: "4px"
            }).width), d.removeChild(b), c = d = null);
        }
        var c, d, e, f, g, h, i = pa.createElement("div"), j = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px";
        i.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        c = i.getElementsByTagName("a")[0], c.style.cssText = "float:left;opacity:.5", da.opacity = /^0.5/.test(c.style.opacity), 
        da.cssFloat = !!c.style.cssFloat, i.style.backgroundClip = "content-box", i.cloneNode(!0).style.backgroundClip = "", 
        da.clearCloneStyle = "content-box" === i.style.backgroundClip, c = i = null, fa.extend(da, {
            reliableHiddenOffsets: function() {
                if (null != d) return d;
                var a, b, c, e = pa.createElement("div"), f = pa.getElementsByTagName("body")[0];
                return f ? (e.setAttribute("className", "t"), e.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
                a = pa.createElement("div"), a.style.cssText = j, f.appendChild(a).appendChild(e), 
                e.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", b = e.getElementsByTagName("td"), 
                b[0].style.cssText = "padding:0;margin:0;border:0;display:none", c = 0 === b[0].offsetHeight, 
                b[0].style.display = "", b[1].style.display = "none", d = c && 0 === b[0].offsetHeight, 
                f.removeChild(a), e = f = null, d) : void 0;
            },
            boxSizing: function() {
                return null == e && b(), e;
            },
            boxSizingReliable: function() {
                return null == f && b(), f;
            },
            pixelPosition: function() {
                return null == g && b(), g;
            },
            reliableMarginRight: function() {
                var b, c, d, e;
                if (null == h && a.getComputedStyle) {
                    if (!(b = pa.getElementsByTagName("body")[0])) return;
                    c = pa.createElement("div"), d = pa.createElement("div"), c.style.cssText = j, b.appendChild(c).appendChild(d), 
                    e = d.appendChild(pa.createElement("div")), e.style.cssText = d.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0", 
                    e.style.marginRight = e.style.width = "0", d.style.width = "1px", h = !parseFloat((a.getComputedStyle(e, null) || {}).marginRight), 
                    b.removeChild(c);
                }
                return h;
            }
        });
    }(), fa.swap = function(a, b, c, d) {
        var e, f, g = {};
        for (f in b) g[f] = a.style[f], a.style[f] = b[f];
        e = c.apply(a, d || []);
        for (f in b) a.style[f] = g[f];
        return e;
    };
    var fb = /alpha\([^)]*\)/i, gb = /opacity\s*=\s*([^)]*)/, hb = /^(none|table(?!-c[ea]).+)/, ib = new RegExp("^(" + Aa + ")(.*)$", "i"), jb = new RegExp("^([+-])=(" + Aa + ")", "i"), kb = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, lb = {
        letterSpacing: 0,
        fontWeight: 400
    }, mb = [ "Webkit", "O", "Moz", "ms" ];
    fa.extend({
        cssHooks: {
            opacity: {
                get: function(a, b) {
                    if (b) {
                        var c = bb(a, "opacity");
                        return "" === c ? "1" : c;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: da.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = fa.camelCase(b), i = a.style;
                if (b = fa.cssProps[h] || (fa.cssProps[h] = B(i, h)), g = fa.cssHooks[b] || fa.cssHooks[h], 
                void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                if (f = typeof c, "string" === f && (e = jb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(fa.css(a, b)), 
                f = "number"), null != c && c === c && ("number" !== f || fa.cssNumber[h] || (c += "px"), 
                da.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), 
                !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
                    i[b] = "", i[b] = c;
                } catch (a) {}
            }
        },
        css: function(a, b, c, d) {
            var e, f, g, h = fa.camelCase(b);
            return b = fa.cssProps[h] || (fa.cssProps[h] = B(a.style, h)), g = fa.cssHooks[b] || fa.cssHooks[h], 
            g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = bb(a, b, d)), "normal" === f && b in lb && (f = lb[b]), 
            "" === c || c ? (e = parseFloat(f), !0 === c || fa.isNumeric(e) ? e || 0 : f) : f;
        }
    }), fa.each([ "height", "width" ], function(a, b) {
        fa.cssHooks[b] = {
            get: function(a, c, d) {
                return c ? 0 === a.offsetWidth && hb.test(fa.css(a, "display")) ? fa.swap(a, kb, function() {
                    return F(a, b, d);
                }) : F(a, b, d) : void 0;
            },
            set: function(a, c, d) {
                var e = d && ab(a);
                return D(a, c, d ? E(a, b, d, da.boxSizing() && "border-box" === fa.css(a, "boxSizing", !1, e), e) : 0);
            }
        };
    }), da.opacity || (fa.cssHooks.opacity = {
        get: function(a, b) {
            return gb.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "";
        },
        set: function(a, b) {
            var c = a.style, d = a.currentStyle, e = fa.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || "";
            c.zoom = 1, (b >= 1 || "" === b) && "" === fa.trim(f.replace(fb, "")) && c.removeAttribute && (c.removeAttribute("filter"), 
            "" === b || d && !d.filter) || (c.filter = fb.test(f) ? f.replace(fb, e) : f + " " + e);
        }
    }), fa.cssHooks.marginRight = A(da.reliableMarginRight, function(a, b) {
        return b ? fa.swap(a, {
            display: "inline-block"
        }, bb, [ a, "marginRight" ]) : void 0;
    }), fa.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(a, b) {
        fa.cssHooks[a + b] = {
            expand: function(c) {
                for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [ c ]; 4 > d; d++) e[a + Ba[d] + b] = f[d] || f[d - 2] || f[0];
                return e;
            }
        }, cb.test(a) || (fa.cssHooks[a + b].set = D);
    }), fa.fn.extend({
        css: function(a, b) {
            return Da(this, function(a, b, c) {
                var d, e, f = {}, g = 0;
                if (fa.isArray(b)) {
                    for (d = ab(a), e = b.length; e > g; g++) f[b[g]] = fa.css(a, b[g], !1, d);
                    return f;
                }
                return void 0 !== c ? fa.style(a, b, c) : fa.css(a, b);
            }, a, b, arguments.length > 1);
        },
        show: function() {
            return C(this, !0);
        },
        hide: function() {
            return C(this);
        },
        toggle: function(a) {
            return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                Ca(this) ? fa(this).show() : fa(this).hide();
            });
        }
    }), fa.Tween = G, G.prototype = {
        constructor: G,
        init: function(a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), 
            this.end = d, this.unit = f || (fa.cssNumber[c] ? "" : "px");
        },
        cur: function() {
            var a = G.propHooks[this.prop];
            return a && a.get ? a.get(this) : G.propHooks._default.get(this);
        },
        run: function(a) {
            var b, c = G.propHooks[this.prop];
            return this.pos = b = this.options.duration ? fa.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, 
            this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            c && c.set ? c.set(this) : G.propHooks._default.set(this), this;
        }
    }, G.prototype.init.prototype = G.prototype, G.propHooks = {
        _default: {
            get: function(a) {
                var b;
                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = fa.css(a.elem, a.prop, ""), 
                b && "auto" !== b ? b : 0) : a.elem[a.prop];
            },
            set: function(a) {
                fa.fx.step[a.prop] ? fa.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[fa.cssProps[a.prop]] || fa.cssHooks[a.prop]) ? fa.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
            }
        }
    }, G.propHooks.scrollTop = G.propHooks.scrollLeft = {
        set: function(a) {
            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
        }
    }, fa.easing = {
        linear: function(a) {
            return a;
        },
        swing: function(a) {
            return .5 - Math.cos(a * Math.PI) / 2;
        }
    }, fa.fx = G.prototype.init, fa.fx.step = {};
    var nb, ob, pb = /^(?:toggle|show|hide)$/, qb = new RegExp("^(?:([+-])=|)(" + Aa + ")([a-z%]*)$", "i"), rb = /queueHooks$/, sb = [ K ], tb = {
        "*": [ function(a, b) {
            var c = this.createTween(a, b), d = c.cur(), e = qb.exec(b), f = e && e[3] || (fa.cssNumber[a] ? "" : "px"), g = (fa.cssNumber[a] || "px" !== f && +d) && qb.exec(fa.css(c.elem, a)), h = 1, i = 20;
            if (g && g[3] !== f) {
                f = f || g[3], e = e || [], g = +d || 1;
                do {
                    h = h || ".5", g /= h, fa.style(c.elem, a, g + f);
                } while (h !== (h = c.cur() / d) && 1 !== h && --i);
            }
            return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), 
            c;
        } ]
    };
    fa.Animation = fa.extend(M, {
        tweener: function(a, b) {
            fa.isFunction(a) ? (b = a, a = [ "*" ]) : a = a.split(" ");
            for (var c, d = 0, e = a.length; e > d; d++) c = a[d], tb[c] = tb[c] || [], tb[c].unshift(b);
        },
        prefilter: function(a, b) {
            b ? sb.unshift(a) : sb.push(a);
        }
    }), fa.speed = function(a, b, c) {
        var d = a && "object" == typeof a ? fa.extend({}, a) : {
            complete: c || !c && b || fa.isFunction(a) && a,
            duration: a,
            easing: c && b || b && !fa.isFunction(b) && b
        };
        return d.duration = fa.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in fa.fx.speeds ? fa.fx.speeds[d.duration] : fa.fx.speeds._default, 
        (null == d.queue || !0 === d.queue) && (d.queue = "fx"), d.old = d.complete, d.complete = function() {
            fa.isFunction(d.old) && d.old.call(this), d.queue && fa.dequeue(this, d.queue);
        }, d;
    }, fa.fn.extend({
        fadeTo: function(a, b, c, d) {
            return this.filter(Ca).css("opacity", 0).show().end().animate({
                opacity: b
            }, a, c, d);
        },
        animate: function(a, b, c, d) {
            var e = fa.isEmptyObject(a), f = fa.speed(b, c, d), g = function() {
                var b = M(this, fa.extend({}, a), f);
                (e || fa._data(this, "finish")) && b.stop(!0);
            };
            return g.finish = g, e || !1 === f.queue ? this.each(g) : this.queue(f.queue, g);
        },
        stop: function(a, b, c) {
            var d = function(a) {
                var b = a.stop;
                delete a.stop, b(c);
            };
            return "string" != typeof a && (c = b, b = a, a = void 0), b && !1 !== a && this.queue(a || "fx", []), 
            this.each(function() {
                var b = !0, e = null != a && a + "queueHooks", f = fa.timers, g = fa._data(this);
                if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && rb.test(e) && d(g[e]);
                for (e = f.length; e--; ) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), 
                b = !1, f.splice(e, 1));
                (b || !c) && fa.dequeue(this, a);
            });
        },
        finish: function(a) {
            return !1 !== a && (a = a || "fx"), this.each(function() {
                var b, c = fa._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = fa.timers, g = d ? d.length : 0;
                for (c.finish = !0, fa.queue(this, a, []), e && e.stop && e.stop.call(this, !0), 
                b = f.length; b--; ) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), 
                f.splice(b, 1));
                for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
                delete c.finish;
            });
        }
    }), fa.each([ "toggle", "show", "hide" ], function(a, b) {
        var c = fa.fn[b];
        fa.fn[b] = function(a, d, e) {
            return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(I(b, !0), a, d, e);
        };
    }), fa.each({
        slideDown: I("show"),
        slideUp: I("hide"),
        slideToggle: I("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(a, b) {
        fa.fn[a] = function(a, c, d) {
            return this.animate(b, a, c, d);
        };
    }), fa.timers = [], fa.fx.tick = function() {
        var a, b = fa.timers, c = 0;
        for (nb = fa.now(); c < b.length; c++) (a = b[c])() || b[c] !== a || b.splice(c--, 1);
        b.length || fa.fx.stop(), nb = void 0;
    }, fa.fx.timer = function(a) {
        fa.timers.push(a), a() ? fa.fx.start() : fa.timers.pop();
    }, fa.fx.interval = 13, fa.fx.start = function() {
        ob || (ob = setInterval(fa.fx.tick, fa.fx.interval));
    }, fa.fx.stop = function() {
        clearInterval(ob), ob = null;
    }, fa.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, fa.fn.delay = function(a, b) {
        return a = fa.fx ? fa.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
            var d = setTimeout(b, a);
            c.stop = function() {
                clearTimeout(d);
            };
        });
    }, function() {
        var a, b, c, d, e = pa.createElement("div");
        e.setAttribute("className", "t"), e.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        a = e.getElementsByTagName("a")[0], c = pa.createElement("select"), d = c.appendChild(pa.createElement("option")), 
        b = e.getElementsByTagName("input")[0], a.style.cssText = "top:1px", da.getSetAttribute = "t" !== e.className, 
        da.style = /top/.test(a.getAttribute("style")), da.hrefNormalized = "/a" === a.getAttribute("href"), 
        da.checkOn = !!b.value, da.optSelected = d.selected, da.enctype = !!pa.createElement("form").enctype, 
        c.disabled = !0, da.optDisabled = !d.disabled, b = pa.createElement("input"), b.setAttribute("value", ""), 
        da.input = "" === b.getAttribute("value"), b.value = "t", b.setAttribute("type", "radio"), 
        da.radioValue = "t" === b.value, a = b = c = d = e = null;
    }();
    var ub = /\r/g;
    fa.fn.extend({
        val: function(a) {
            var b, c, d, e = this[0];
            return arguments.length ? (d = fa.isFunction(a), this.each(function(c) {
                var e;
                1 === this.nodeType && (e = d ? a.call(this, c, fa(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : fa.isArray(e) && (e = fa.map(e, function(a) {
                    return null == a ? "" : a + "";
                })), (b = fa.valHooks[this.type] || fa.valHooks[this.nodeName.toLowerCase()]) && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
            })) : e ? (b = fa.valHooks[e.type] || fa.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, 
            "string" == typeof c ? c.replace(ub, "") : null == c ? "" : c)) : void 0;
        }
    }), fa.extend({
        valHooks: {
            option: {
                get: function(a) {
                    var b = fa.find.attr(a, "value");
                    return null != b ? b : fa.text(a);
                }
            },
            select: {
                get: function(a) {
                    for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i], 
                    !(!c.selected && i !== e || (da.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && fa.nodeName(c.parentNode, "optgroup"))) {
                        if (b = fa(c).val(), f) return b;
                        g.push(b);
                    }
                    return g;
                },
                set: function(a, b) {
                    for (var c, d, e = a.options, f = fa.makeArray(b), g = e.length; g--; ) if (d = e[g], 
                    fa.inArray(fa.valHooks.option.get(d), f) >= 0) try {
                        d.selected = c = !0;
                    } catch (a) {
                        d.scrollHeight;
                    } else d.selected = !1;
                    return c || (a.selectedIndex = -1), e;
                }
            }
        }
    }), fa.each([ "radio", "checkbox" ], function() {
        fa.valHooks[this] = {
            set: function(a, b) {
                return fa.isArray(b) ? a.checked = fa.inArray(fa(a).val(), b) >= 0 : void 0;
            }
        }, da.checkOn || (fa.valHooks[this].get = function(a) {
            return null === a.getAttribute("value") ? "on" : a.value;
        });
    });
    var vb, wb, xb = fa.expr.attrHandle, yb = /^(?:checked|selected)$/i, zb = da.getSetAttribute, Ab = da.input;
    fa.fn.extend({
        attr: function(a, b) {
            return Da(this, fa.attr, a, b, arguments.length > 1);
        },
        removeAttr: function(a) {
            return this.each(function() {
                fa.removeAttr(this, a);
            });
        }
    }), fa.extend({
        attr: function(a, b, c) {
            var d, e, f = a.nodeType;
            if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === xa ? fa.prop(a, b, c) : (1 === f && fa.isXMLDoc(a) || (b = b.toLowerCase(), 
            d = fa.attrHooks[b] || (fa.expr.match.bool.test(b) ? wb : vb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = fa.find.attr(a, b), 
            null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), 
            c) : void fa.removeAttr(a, b));
        },
        removeAttr: function(a, b) {
            var c, d, e = 0, f = b && b.match(ta);
            if (f && 1 === a.nodeType) for (;c = f[e++]; ) d = fa.propFix[c] || c, fa.expr.match.bool.test(c) ? Ab && zb || !yb.test(c) ? a[d] = !1 : a[fa.camelCase("default-" + c)] = a[d] = !1 : fa.attr(a, c, ""), 
            a.removeAttribute(zb ? c : d);
        },
        attrHooks: {
            type: {
                set: function(a, b) {
                    if (!da.radioValue && "radio" === b && fa.nodeName(a, "input")) {
                        var c = a.value;
                        return a.setAttribute("type", b), c && (a.value = c), b;
                    }
                }
            }
        }
    }), wb = {
        set: function(a, b, c) {
            return !1 === b ? fa.removeAttr(a, c) : Ab && zb || !yb.test(c) ? a.setAttribute(!zb && fa.propFix[c] || c, c) : a[fa.camelCase("default-" + c)] = a[c] = !0, 
            c;
        }
    }, fa.each(fa.expr.match.bool.source.match(/\w+/g), function(a, b) {
        var c = xb[b] || fa.find.attr;
        xb[b] = Ab && zb || !yb.test(b) ? function(a, b, d) {
            var e, f;
            return d || (f = xb[b], xb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, 
            xb[b] = f), e;
        } : function(a, b, c) {
            return c ? void 0 : a[fa.camelCase("default-" + b)] ? b.toLowerCase() : null;
        };
    }), Ab && zb || (fa.attrHooks.value = {
        set: function(a, b, c) {
            return fa.nodeName(a, "input") ? void (a.defaultValue = b) : vb && vb.set(a, b, c);
        }
    }), zb || (vb = {
        set: function(a, b, c) {
            var d = a.getAttributeNode(c);
            return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", 
            "value" === c || b === a.getAttribute(c) ? b : void 0;
        }
    }, xb.id = xb.name = xb.coords = function(a, b, c) {
        var d;
        return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null;
    }, fa.valHooks.button = {
        get: function(a, b) {
            var c = a.getAttributeNode(b);
            return c && c.specified ? c.value : void 0;
        },
        set: vb.set
    }, fa.attrHooks.contenteditable = {
        set: function(a, b, c) {
            vb.set(a, "" !== b && b, c);
        }
    }, fa.each([ "width", "height" ], function(a, b) {
        fa.attrHooks[b] = {
            set: function(a, c) {
                return "" === c ? (a.setAttribute(b, "auto"), c) : void 0;
            }
        };
    })), da.style || (fa.attrHooks.style = {
        get: function(a) {
            return a.style.cssText || void 0;
        },
        set: function(a, b) {
            return a.style.cssText = b + "";
        }
    });
    var Bb = /^(?:input|select|textarea|button|object)$/i, Cb = /^(?:a|area)$/i;
    fa.fn.extend({
        prop: function(a, b) {
            return Da(this, fa.prop, a, b, arguments.length > 1);
        },
        removeProp: function(a) {
            return a = fa.propFix[a] || a, this.each(function() {
                try {
                    this[a] = void 0, delete this[a];
                } catch (a) {}
            });
        }
    }), fa.extend({
        propFix: {
            for: "htmlFor",
            class: "className"
        },
        prop: function(a, b, c) {
            var d, e, f, g = a.nodeType;
            if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !fa.isXMLDoc(a), f && (b = fa.propFix[b] || b, 
            e = fa.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];
        },
        propHooks: {
            tabIndex: {
                get: function(a) {
                    var b = fa.find.attr(a, "tabindex");
                    return b ? parseInt(b, 10) : Bb.test(a.nodeName) || Cb.test(a.nodeName) && a.href ? 0 : -1;
                }
            }
        }
    }), da.hrefNormalized || fa.each([ "href", "src" ], function(a, b) {
        fa.propHooks[b] = {
            get: function(a) {
                return a.getAttribute(b, 4);
            }
        };
    }), da.optSelected || (fa.propHooks.selected = {
        get: function(a) {
            var b = a.parentNode;
            return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null;
        }
    }), fa.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        fa.propFix[this.toLowerCase()] = this;
    }), da.enctype || (fa.propFix.enctype = "encoding");
    var Db = /[\t\r\n\f]/g;
    fa.fn.extend({
        addClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
            if (fa.isFunction(a)) return this.each(function(b) {
                fa(this).addClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(ta) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(Db, " ") : " ")) {
                for (f = 0; e = b[f++]; ) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                g = fa.trim(d), c.className !== g && (c.className = g);
            }
            return this;
        },
        removeClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
            if (fa.isFunction(a)) return this.each(function(b) {
                fa(this).removeClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(ta) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(Db, " ") : "")) {
                for (f = 0; e = b[f++]; ) for (;d.indexOf(" " + e + " ") >= 0; ) d = d.replace(" " + e + " ", " ");
                g = a ? fa.trim(d) : "", c.className !== g && (c.className = g);
            }
            return this;
        },
        toggleClass: function(a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(fa.isFunction(a) ? function(c) {
                fa(this).toggleClass(a.call(this, c, this.className, b), b);
            } : function() {
                if ("string" === c) for (var b, d = 0, e = fa(this), f = a.match(ta) || []; b = f[d++]; ) e.hasClass(b) ? e.removeClass(b) : e.addClass(b); else (c === xa || "boolean" === c) && (this.className && fa._data(this, "__className__", this.className), 
                this.className = this.className || !1 === a ? "" : fa._data(this, "__className__") || "");
            });
        },
        hasClass: function(a) {
            for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(Db, " ").indexOf(b) >= 0) return !0;
            return !1;
        }
    }), fa.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
        fa.fn[b] = function(a, c) {
            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
        };
    }), fa.fn.extend({
        hover: function(a, b) {
            return this.mouseenter(a).mouseleave(b || a);
        },
        bind: function(a, b, c) {
            return this.on(a, null, b, c);
        },
        unbind: function(a, b) {
            return this.off(a, null, b);
        },
        delegate: function(a, b, c, d) {
            return this.on(b, a, c, d);
        },
        undelegate: function(a, b, c) {
            return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
        }
    });
    var Eb = fa.now(), Fb = /\?/, Gb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    fa.parseJSON = function(b) {
        if (a.JSON && a.JSON.parse) return a.JSON.parse(b + "");
        var c, d = null, e = fa.trim(b + "");
        return e && !fa.trim(e.replace(Gb, function(a, b, e, f) {
            return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "");
        })) ? Function("return " + e)() : fa.error("Invalid JSON: " + b);
    }, fa.parseXML = function(b) {
        var c, d;
        if (!b || "string" != typeof b) return null;
        try {
            a.DOMParser ? (d = new DOMParser(), c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), 
            c.async = "false", c.loadXML(b));
        } catch (a) {
            c = void 0;
        }
        return c && c.documentElement && !c.getElementsByTagName("parsererror").length || fa.error("Invalid XML: " + b), 
        c;
    };
    var Hb, Ib, Jb = /#.*$/, Kb = /([?&])_=[^&]*/, Lb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Mb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Nb = /^(?:GET|HEAD)$/, Ob = /^\/\//, Pb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Qb = {}, Rb = {}, Sb = "*/".concat("*");
    try {
        Ib = location.href;
    } catch (a) {
        Ib = pa.createElement("a"), Ib.href = "", Ib = Ib.href;
    }
    Hb = Pb.exec(Ib.toLowerCase()) || [], fa.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Ib,
            type: "GET",
            isLocal: Mb.test(Hb[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Sb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": fa.parseJSON,
                "text xml": fa.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(a, b) {
            return b ? P(P(a, fa.ajaxSettings), b) : P(fa.ajaxSettings, a);
        },
        ajaxPrefilter: N(Qb),
        ajaxTransport: N(Rb),
        ajax: function(a, b) {
            function c(a, b, c, d) {
                var e, k, r, s, u, w = b;
                2 !== t && (t = 2, h && clearTimeout(h), j = void 0, g = d || "", v.readyState = a > 0 ? 4 : 0, 
                e = a >= 200 && 300 > a || 304 === a, c && (s = Q(l, v, c)), s = R(l, s, v, e), 
                e ? (l.ifModified && (u = v.getResponseHeader("Last-Modified"), u && (fa.lastModified[f] = u), 
                (u = v.getResponseHeader("etag")) && (fa.etag[f] = u)), 204 === a || "HEAD" === l.type ? w = "nocontent" : 304 === a ? w = "notmodified" : (w = s.state, 
                k = s.data, r = s.error, e = !r)) : (r = w, (a || !w) && (w = "error", 0 > a && (a = 0))), 
                v.status = a, v.statusText = (b || w) + "", e ? o.resolveWith(m, [ k, w, v ]) : o.rejectWith(m, [ v, w, r ]), 
                v.statusCode(q), q = void 0, i && n.trigger(e ? "ajaxSuccess" : "ajaxError", [ v, l, e ? k : r ]), 
                p.fireWith(m, [ v, w ]), i && (n.trigger("ajaxComplete", [ v, l ]), --fa.active || fa.event.trigger("ajaxStop")));
            }
            "object" == typeof a && (b = a, a = void 0), b = b || {};
            var d, e, f, g, h, i, j, k, l = fa.ajaxSetup({}, b), m = l.context || l, n = l.context && (m.nodeType || m.jquery) ? fa(m) : fa.event, o = fa.Deferred(), p = fa.Callbacks("once memory"), q = l.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                readyState: 0,
                getResponseHeader: function(a) {
                    var b;
                    if (2 === t) {
                        if (!k) for (k = {}; b = Lb.exec(g); ) k[b[1].toLowerCase()] = b[2];
                        b = k[a.toLowerCase()];
                    }
                    return null == b ? null : b;
                },
                getAllResponseHeaders: function() {
                    return 2 === t ? g : null;
                },
                setRequestHeader: function(a, b) {
                    var c = a.toLowerCase();
                    return t || (a = s[c] = s[c] || a, r[a] = b), this;
                },
                overrideMimeType: function(a) {
                    return t || (l.mimeType = a), this;
                },
                statusCode: function(a) {
                    var b;
                    if (a) if (2 > t) for (b in a) q[b] = [ q[b], a[b] ]; else v.always(a[v.status]);
                    return this;
                },
                abort: function(a) {
                    var b = a || u;
                    return j && j.abort(b), c(0, b), this;
                }
            };
            if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, l.url = ((a || l.url || Ib) + "").replace(Jb, "").replace(Ob, Hb[1] + "//"), 
            l.type = b.method || b.type || l.method || l.type, l.dataTypes = fa.trim(l.dataType || "*").toLowerCase().match(ta) || [ "" ], 
            null == l.crossDomain && (d = Pb.exec(l.url.toLowerCase()), l.crossDomain = !(!d || d[1] === Hb[1] && d[2] === Hb[2] && (d[3] || ("http:" === d[1] ? "80" : "443")) === (Hb[3] || ("http:" === Hb[1] ? "80" : "443")))), 
            l.data && l.processData && "string" != typeof l.data && (l.data = fa.param(l.data, l.traditional)), 
            O(Qb, l, b, v), 2 === t) return v;
            i = l.global, i && 0 == fa.active++ && fa.event.trigger("ajaxStart"), l.type = l.type.toUpperCase(), 
            l.hasContent = !Nb.test(l.type), f = l.url, l.hasContent || (l.data && (f = l.url += (Fb.test(f) ? "&" : "?") + l.data, 
            delete l.data), !1 === l.cache && (l.url = Kb.test(f) ? f.replace(Kb, "$1_=" + Eb++) : f + (Fb.test(f) ? "&" : "?") + "_=" + Eb++)), 
            l.ifModified && (fa.lastModified[f] && v.setRequestHeader("If-Modified-Since", fa.lastModified[f]), 
            fa.etag[f] && v.setRequestHeader("If-None-Match", fa.etag[f])), (l.data && l.hasContent && !1 !== l.contentType || b.contentType) && v.setRequestHeader("Content-Type", l.contentType), 
            v.setRequestHeader("Accept", l.dataTypes[0] && l.accepts[l.dataTypes[0]] ? l.accepts[l.dataTypes[0]] + ("*" !== l.dataTypes[0] ? ", " + Sb + "; q=0.01" : "") : l.accepts["*"]);
            for (e in l.headers) v.setRequestHeader(e, l.headers[e]);
            if (l.beforeSend && (!1 === l.beforeSend.call(m, v, l) || 2 === t)) return v.abort();
            u = "abort";
            for (e in {
                success: 1,
                error: 1,
                complete: 1
            }) v[e](l[e]);
            if (j = O(Rb, l, b, v)) {
                v.readyState = 1, i && n.trigger("ajaxSend", [ v, l ]), l.async && l.timeout > 0 && (h = setTimeout(function() {
                    v.abort("timeout");
                }, l.timeout));
                try {
                    t = 1, j.send(r, c);
                } catch (a) {
                    if (!(2 > t)) throw a;
                    c(-1, a);
                }
            } else c(-1, "No Transport");
            return v;
        },
        getJSON: function(a, b, c) {
            return fa.get(a, b, c, "json");
        },
        getScript: function(a, b) {
            return fa.get(a, void 0, b, "script");
        }
    }), fa.each([ "get", "post" ], function(a, b) {
        fa[b] = function(a, c, d, e) {
            return fa.isFunction(c) && (e = e || d, d = c, c = void 0), fa.ajax({
                url: a,
                type: b,
                dataType: e,
                data: c,
                success: d
            });
        };
    }), fa.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(a, b) {
        fa.fn[b] = function(a) {
            return this.on(b, a);
        };
    }), fa._evalUrl = function(a) {
        return fa.ajax({
            url: a,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            throws: !0
        });
    }, fa.fn.extend({
        wrapAll: function(a) {
            if (fa.isFunction(a)) return this.each(function(b) {
                fa(this).wrapAll(a.call(this, b));
            });
            if (this[0]) {
                var b = fa(a, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                    for (var a = this; a.firstChild && 1 === a.firstChild.nodeType; ) a = a.firstChild;
                    return a;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(a) {
            return this.each(fa.isFunction(a) ? function(b) {
                fa(this).wrapInner(a.call(this, b));
            } : function() {
                var b = fa(this), c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a);
            });
        },
        wrap: function(a) {
            var b = fa.isFunction(a);
            return this.each(function(c) {
                fa(this).wrapAll(b ? a.call(this, c) : a);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                fa.nodeName(this, "body") || fa(this).replaceWith(this.childNodes);
            }).end();
        }
    }), fa.expr.filters.hidden = function(a) {
        return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !da.reliableHiddenOffsets() && "none" === (a.style && a.style.display || fa.css(a, "display"));
    }, fa.expr.filters.visible = function(a) {
        return !fa.expr.filters.hidden(a);
    };
    var Tb = /%20/g, Ub = /\[\]$/, Vb = /\r?\n/g, Wb = /^(?:submit|button|image|reset|file)$/i, Xb = /^(?:input|select|textarea|keygen)/i;
    fa.param = function(a, b) {
        var c, d = [], e = function(a, b) {
            b = fa.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
        };
        if (void 0 === b && (b = fa.ajaxSettings && fa.ajaxSettings.traditional), fa.isArray(a) || a.jquery && !fa.isPlainObject(a)) fa.each(a, function() {
            e(this.name, this.value);
        }); else for (c in a) S(c, a[c], b, e);
        return d.join("&").replace(Tb, "+");
    }, fa.fn.extend({
        serialize: function() {
            return fa.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var a = fa.prop(this, "elements");
                return a ? fa.makeArray(a) : this;
            }).filter(function() {
                var a = this.type;
                return this.name && !fa(this).is(":disabled") && Xb.test(this.nodeName) && !Wb.test(a) && (this.checked || !Ea.test(a));
            }).map(function(a, b) {
                var c = fa(this).val();
                return null == c ? null : fa.isArray(c) ? fa.map(c, function(a) {
                    return {
                        name: b.name,
                        value: a.replace(Vb, "\r\n")
                    };
                }) : {
                    name: b.name,
                    value: c.replace(Vb, "\r\n")
                };
            }).get();
        }
    }), fa.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && T() || U();
    } : T;
    var Yb = 0, Zb = {}, $b = fa.ajaxSettings.xhr();
    a.ActiveXObject && fa(a).on("unload", function() {
        for (var a in Zb) Zb[a](void 0, !0);
    }), da.cors = !!$b && "withCredentials" in $b, ($b = da.ajax = !!$b) && fa.ajaxTransport(function(a) {
        if (!a.crossDomain || da.cors) {
            var b;
            return {
                send: function(c, d) {
                    var e, f = a.xhr(), g = ++Yb;
                    if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
                    a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                    for (e in c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                    f.send(a.hasContent && a.data || null), b = function(c, e) {
                        var h, i, j;
                        if (b && (e || 4 === f.readyState)) if (delete Zb[g], b = void 0, f.onreadystatechange = fa.noop, 
                        e) 4 !== f.readyState && f.abort(); else {
                            j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                            try {
                                i = f.statusText;
                            } catch (a) {
                                i = "";
                            }
                            h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
                        }
                        j && d(h, i, j, f.getAllResponseHeaders());
                    }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Zb[g] = b : b();
                },
                abort: function() {
                    b && b(void 0, !0);
                }
            };
        }
    }), fa.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(a) {
                return fa.globalEval(a), a;
            }
        }
    }), fa.ajaxPrefilter("script", function(a) {
        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1);
    }), fa.ajaxTransport("script", function(a) {
        if (a.crossDomain) {
            var b, c = pa.head || fa("head")[0] || pa.documentElement;
            return {
                send: function(d, e) {
                    b = pa.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), 
                    b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
                        (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, 
                        b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"));
                    }, c.insertBefore(b, c.firstChild);
                },
                abort: function() {
                    b && b.onload(void 0, !0);
                }
            };
        }
    });
    var _b = [], ac = /(=)\?(?=&|$)|\?\?/;
    fa.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var a = _b.pop() || fa.expando + "_" + Eb++;
            return this[a] = !0, a;
        }
    }), fa.ajaxPrefilter("json jsonp", function(b, c, d) {
        var e, f, g, h = !1 !== b.jsonp && (ac.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ac.test(b.data) && "data");
        return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = fa.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, 
        h ? b[h] = b[h].replace(ac, "$1" + e) : !1 !== b.jsonp && (b.url += (Fb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), 
        b.converters["script json"] = function() {
            return g || fa.error(e + " was not called"), g[0];
        }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
            g = arguments;
        }, d.always(function() {
            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _b.push(e)), g && fa.isFunction(f) && f(g[0]), 
            g = f = void 0;
        }), "script") : void 0;
    }), fa.parseHTML = function(a, b, c) {
        if (!a || "string" != typeof a) return null;
        "boolean" == typeof b && (c = b, b = !1), b = b || pa;
        var d = ma.exec(a), e = !c && [];
        return d ? [ b.createElement(d[1]) ] : (d = fa.buildFragment([ a ], b, e), e && e.length && fa(e).remove(), 
        fa.merge([], d.childNodes));
    };
    var bc = fa.fn.load;
    fa.fn.load = function(a, b, c) {
        if ("string" != typeof a && bc) return bc.apply(this, arguments);
        var d, e, f, g = this, h = a.indexOf(" ");
        return h >= 0 && (d = a.slice(h, a.length), a = a.slice(0, h)), fa.isFunction(b) ? (c = b, 
        b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && fa.ajax({
            url: a,
            type: f,
            dataType: "html",
            data: b
        }).done(function(a) {
            e = arguments, g.html(d ? fa("<div>").append(fa.parseHTML(a)).find(d) : a);
        }).complete(c && function(a, b) {
            g.each(c, e || [ a.responseText, b, a ]);
        }), this;
    }, fa.expr.filters.animated = function(a) {
        return fa.grep(fa.timers, function(b) {
            return a === b.elem;
        }).length;
    };
    var cc = a.document.documentElement;
    fa.offset = {
        setOffset: function(a, b, c) {
            var d, e, f, g, h, i, j, k = fa.css(a, "position"), l = fa(a), m = {};
            "static" === k && (a.style.position = "relative"), h = l.offset(), f = fa.css(a, "top"), 
            i = fa.css(a, "left"), j = ("absolute" === k || "fixed" === k) && fa.inArray("auto", [ f, i ]) > -1, 
            j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), 
            fa.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), 
            null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m);
        }
    }, fa.fn.extend({
        offset: function(a) {
            if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                fa.offset.setOffset(this, a, b);
            });
            var b, c, d = {
                top: 0,
                left: 0
            }, e = this[0], f = e && e.ownerDocument;
            return f ? (b = f.documentElement, fa.contains(b, e) ? (typeof e.getBoundingClientRect !== xa && (d = e.getBoundingClientRect()), 
            c = V(f), {
                top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
            }) : d) : void 0;
        },
        position: function() {
            if (this[0]) {
                var a, b, c = {
                    top: 0,
                    left: 0
                }, d = this[0];
                return "fixed" === fa.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), 
                b = this.offset(), fa.nodeName(a[0], "html") || (c = a.offset()), c.top += fa.css(a[0], "borderTopWidth", !0), 
                c.left += fa.css(a[0], "borderLeftWidth", !0)), {
                    top: b.top - c.top - fa.css(d, "marginTop", !0),
                    left: b.left - c.left - fa.css(d, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var a = this.offsetParent || cc; a && !fa.nodeName(a, "html") && "static" === fa.css(a, "position"); ) a = a.offsetParent;
                return a || cc;
            });
        }
    }), fa.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(a, b) {
        var c = /Y/.test(b);
        fa.fn[a] = function(d) {
            return Da(this, function(a, d, e) {
                var f = V(a);
                return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? fa(f).scrollLeft() : e, c ? e : fa(f).scrollTop()) : a[d] = e);
            }, a, d, arguments.length, null);
        };
    }), fa.each([ "top", "left" ], function(a, b) {
        fa.cssHooks[b] = A(da.pixelPosition, function(a, c) {
            return c ? (c = bb(a, b), db.test(c) ? fa(a).position()[b] + "px" : c) : void 0;
        });
    }), fa.each({
        Height: "height",
        Width: "width"
    }, function(a, b) {
        fa.each({
            padding: "inner" + a,
            content: b,
            "": "outer" + a
        }, function(c, d) {
            fa.fn[d] = function(d, e) {
                var f = arguments.length && (c || "boolean" != typeof d), g = c || (!0 === d || !0 === e ? "margin" : "border");
                return Da(this, function(b, c, d) {
                    var e;
                    return fa.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, 
                    Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? fa.css(b, c, g) : fa.style(b, c, d, g);
                }, b, f ? d : void 0, f, null);
            };
        });
    }), fa.fn.size = function() {
        return this.length;
    }, fa.fn.andSelf = fa.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return fa;
    });
    var dc = a.jQuery, ec = a.$;
    return fa.noConflict = function(b) {
        return a.$ === fa && (a.$ = ec), b && a.jQuery === fa && (a.jQuery = dc), fa;
    }, typeof b === xa && (a.jQuery = a.$ = fa), fa;
}), function() {
    var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t = {}.hasOwnProperty, u = [].indexOf || function(a) {
        for (var b = 0, c = this.length; b < c; b++) if (b in this && this[b] === a) return b;
        return -1;
    };
    f = {
        is_unordered: !1,
        is_counting: !1,
        is_exclusive: !1,
        is_solitary: !1,
        prevent_default: !1,
        prevent_repeat: !1
    }, r = "meta alt option ctrl shift cmd".split(" "), p = "ctrl", a = {
        debug: !1
    };
    var v = function(a) {
        var b, c;
        for (b in a) t.call(a, b) && !1 !== (c = a[b]) && (this[b] = c);
        this.keys = this.keys || [], this.count = this.count || 0;
    };
    v.prototype.allows_key_repeat = function() {
        return !this.prevent_repeat && "function" == typeof this.on_keydown;
    }, v.prototype.reset = function() {
        return this.count = 0, this.keyup_fired = null;
    };
    var w = function(a, b) {
        var c, d;
        "undefined" != typeof jQuery && null !== jQuery && a instanceof jQuery && (1 !== a.length && o("Warning: your jQuery selector should have exactly one object."), 
        a = a[0]), this.should_force_event_defaults = this.should_suppress_event_defaults = !1, 
        this.sequence_delay = 800, this._registered_combos = [], this._keys_down = [], this._active_combos = [], 
        this._sequence = [], this._sequence_timer = null, this._prevent_capture = !1, this._defaults = b || {};
        for (c in f) t.call(f, c) && (d = f[c], this._defaults[c] = this._defaults[c] || d);
        this.element = a || document.body, c = function(a, b, c) {
            return a.addEventListener ? a.addEventListener(b, c) : a.attachEvent && a.attachEvent("on" + b, c), 
            c;
        };
        var e = this;
        this.keydown_event = c(this.element, "keydown", function(a) {
            return a = a || window.event, e._receive_input(a, !0), e._bug_catcher(a);
        });
        var g = this;
        this.keyup_event = c(this.element, "keyup", function(a) {
            return a = a || window.event, g._receive_input(a, !1);
        });
        var h = this;
        this.blur_event = c(window, "blur", function() {
            var a, b, c, d;
            for (d = h._keys_down, b = 0, c = d.length; b < c; b++) a = d[b], h._key_up(a, {});
            return h._keys_down = [];
        });
    };
    w.prototype.destroy = function() {
        var a;
        return a = function(a, b, c) {
            return null != a.removeEventListener ? a.removeEventListener(b, c) : null != a.removeEvent ? a.removeEvent("on" + b, c) : void 0;
        }, a(this.element, "keydown", this.keydown_event), a(this.element, "keyup", this.keyup_event), 
        a(window, "blur", this.blur_event);
    }, w.prototype._bug_catcher = function(a) {
        var b, c;
        if ("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && "cmd" !== (b = d(null != (c = a.keyCode) ? c : a.key)) && "shift" !== b && "alt" !== b && "caps" !== b && "tab" !== b) return this._receive_input(a, !1);
    }, w.prototype._cmd_bug_check = function(a) {
        return !("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && 0 > u.call(a, "cmd"));
    }, w.prototype._prevent_default = function(a, b) {
        if ((b || this.should_suppress_event_defaults) && !this.should_force_event_defaults && (a.preventDefault ? a.preventDefault() : a.returnValue = !1, 
        a.stopPropagation)) return a.stopPropagation();
    }, w.prototype._get_active_combos = function(a) {
        var b, c;
        return b = [], c = g(this._keys_down, function(b) {
            return b !== a;
        }), c.push(a), this._match_combo_arrays(c, function(a) {
            return function(c) {
                if (a._cmd_bug_check(c.keys)) return b.push(c);
            };
        }(this)), this._fuzzy_match_combo_arrays(c, function(a) {
            return function(c) {
                if (!(0 <= u.call(b, c)) && !c.is_solitary && a._cmd_bug_check(c.keys)) return b.push(c);
            };
        }(this)), b;
    }, w.prototype._get_potential_combos = function(a) {
        var b, c, d, e, f;
        for (c = [], f = this._registered_combos, d = 0, e = f.length; d < e; d++) b = f[d], 
        b.is_sequence || 0 <= u.call(b.keys, a) && this._cmd_bug_check(b.keys) && c.push(b);
        return c;
    }, w.prototype._add_to_active_combos = function(a) {
        var b, c, d, e, f, g, h, i, j, k, l;
        if (g = !1, f = !0, d = !1, 0 <= u.call(this._active_combos, a)) return !0;
        if (this._active_combos.length) for (e = h = 0, k = this._active_combos.length; 0 <= k ? h < k : h > k; e = 0 <= k ? ++h : --h) if ((b = this._active_combos[e]) && b.is_exclusive && a.is_exclusive) {
            if (b = b.keys, !g) for (i = 0, j = b.length; i < j; i++) if (c = b[i], g = !0, 
            0 > u.call(a.keys, c)) {
                g = !1;
                break;
            }
            if (f && !g) for (l = a.keys, i = 0, j = l.length; i < j; i++) if (c = l[i], f = !1, 
            0 > u.call(b, c)) {
                f = !0;
                break;
            }
            g && (d ? null != (b = this._active_combos.splice(e, 1)[0]) && b.reset() : (b = this._active_combos.splice(e, 1, a)[0], 
            null != b && b.reset(), d = !0), f = !1);
        }
        return f && this._active_combos.unshift(a), g || f;
    }, w.prototype._remove_from_active_combos = function(a) {
        var b, c, d;
        for (b = c = 0, d = this._active_combos.length; 0 <= d ? c < d : c > d; b = 0 <= d ? ++c : --c) if (this._active_combos[b] === a) {
            a = this._active_combos.splice(b, 1)[0], a.reset();
            break;
        }
    }, w.prototype._get_possible_sequences = function() {
        var a, b, c, d, e, f, h, i, j, k, l, m;
        for (d = [], k = this._registered_combos, f = 0, j = k.length; f < j; f++) for (a = k[f], 
        b = h = 1, l = this._sequence.length; 1 <= l ? h <= l : h >= l; b = 1 <= l ? ++h : --h) if (e = this._sequence.slice(-b), 
        a.is_sequence) {
            if (0 > u.call(a.keys, "shift") && (e = g(e, function(a) {
                return "shift" !== a;
            }), !e.length)) continue;
            for (b = i = 0, m = e.length; 0 <= m ? i < m : i > m; b = 0 <= m ? ++i : --i) {
                if (a.keys[b] !== e[b]) {
                    c = !1;
                    break;
                }
                c = !0;
            }
            c && d.push(a);
        }
        return d;
    }, w.prototype._add_key_to_sequence = function(a, b) {
        var c, d, e, f;
        if (this._sequence.push(a), d = this._get_possible_sequences(), d.length) {
            for (e = 0, f = d.length; e < f; e++) c = d[e], this._prevent_default(b, c.prevent_default);
            this._sequence_timer && clearTimeout(this._sequence_timer), -1 < this.sequence_delay && (this._sequence_timer = setTimeout(function() {
                return this._sequence = [];
            }, this.sequence_delay));
        } else this._sequence = [];
    }, w.prototype._get_sequence = function(a) {
        var b, c, d, e, f, h, i, j, k, l, m, n;
        for (l = this._registered_combos, h = 0, k = l.length; h < k; h++) if (b = l[h], 
        b.is_sequence) {
            for (c = i = 1, m = this._sequence.length; 1 <= m ? i <= m : i >= m; c = 1 <= m ? ++i : --i) if (f = g(this._sequence, function(a) {
                return 0 <= u.call(b.keys, "shift") || "shift" !== a;
            }).slice(-c), b.keys.length === f.length) for (c = j = 0, n = f.length; 0 <= n ? j < n : j > n; c = 0 <= n ? ++j : --j) if (e = f[c], 
            !(0 > u.call(b.keys, "shift") && "shift" === e || "shift" === a && 0 > u.call(b.keys, "shift"))) {
                if (b.keys[c] !== e) {
                    d = !1;
                    break;
                }
                d = !0;
            }
            if (d) return b.is_exclusive && (this._sequence = []), b;
        }
        return !1;
    }, w.prototype._receive_input = function(a, b) {
        var c, e;
        if (this._prevent_capture) this._keys_down.length && (this._keys_down = []); else if (c = d(null != (e = a.keyCode) ? e : a.key), 
        (b || this._keys_down.length || !("alt" === c || c === p)) && c) return b ? this._key_down(c, a) : this._key_up(c, a);
    }, w.prototype._fire = function(a, b, c, d) {
        if ("function" == typeof b["on_" + a] && this._prevent_default(c, !0 !== b["on_" + a].call(b.this, c, b.count, d)), 
        "release" === a && (b.count = 0), "keyup" === a) return b.keyup_fired = !0;
    }, w.prototype._match_combo_arrays = function(a, d) {
        var e, f, g, h;
        for (h = this._registered_combos, f = 0, g = h.length; f < g; f++) e = h[f], (!e.is_unordered && c(a, e.keys) || e.is_unordered && b(a, e.keys)) && d(e);
    }, w.prototype._fuzzy_match_combo_arrays = function(a, b) {
        var c, d, e, f;
        for (f = this._registered_combos, d = 0, e = f.length; d < e; d++) c = f[d], (!c.is_unordered && j(c.keys, a) || c.is_unordered && i(c.keys, a)) && b(c);
    }, w.prototype._keys_remain = function(a) {
        var b, c, d, e;
        for (e = a.keys, c = 0, d = e.length; c < d; c++) if (a = e[c], 0 <= u.call(this._keys_down, a)) {
            b = !0;
            break;
        }
        return b;
    }, w.prototype._key_down = function(a, b) {
        var c, d, f, g, h;
        (c = e(a, b)) && (a = c), this._add_key_to_sequence(a, b), (c = this._get_sequence(a)) && this._fire("keydown", c, b);
        for (f in q) c = q[f], b[c] && (f === a || 0 <= u.call(this._keys_down, f) || this._keys_down.push(f));
        for (f in q) if (c = q[f], f !== a && 0 <= u.call(this._keys_down, f) && !b[c] && !("cmd" === f && "cmd" !== p)) for (c = d = 0, 
        g = this._keys_down.length; 0 <= g ? d < g : d > g; c = 0 <= g ? ++d : --d) this._keys_down[c] === f && this._keys_down.splice(c, 1);
        for (d = this._get_active_combos(a), f = this._get_potential_combos(a), g = 0, h = d.length; g < h; g++) c = d[g], 
        this._handle_combo_down(c, f, a, b);
        if (f.length) for (d = 0, g = f.length; d < g; d++) c = f[d], this._prevent_default(b, c.prevent_default);
        0 > u.call(this._keys_down, a) && this._keys_down.push(a);
    }, w.prototype._handle_combo_down = function(a, b, c, d) {
        var e, f, g, h, i;
        if (0 > u.call(a.keys, c)) return !1;
        if (this._prevent_default(d, a && a.prevent_default), e = !1, 0 <= u.call(this._keys_down, c) && (e = !0, 
        !a.allows_key_repeat())) return !1;
        if (g = this._add_to_active_combos(a, c), c = a.keyup_fired = !1, a.is_exclusive) for (h = 0, 
        i = b.length; h < i; h++) if (f = b[h], f.is_exclusive && f.keys.length > a.keys.length) {
            c = !0;
            break;
        }
        return !c && (a.is_counting && "function" == typeof a.on_keydown && (a.count += 1), 
        g) ? this._fire("keydown", a, d, e) : void 0;
    }, w.prototype._key_up = function(a, b) {
        var c, d, f, g, h, i;
        if (c = a, (f = e(a, b)) && (a = f), f = n[c], b.shiftKey ? f && 0 <= u.call(this._keys_down, f) || (a = c) : c && 0 <= u.call(this._keys_down, c) || (a = f), 
        (g = this._get_sequence(a)) && this._fire("keyup", g, b), 0 > u.call(this._keys_down, a)) return !1;
        for (g = h = 0, i = this._keys_down.length; 0 <= i ? h < i : h > i; g = 0 <= i ? ++h : --h) if ((d = this._keys_down[g]) === a || d === f || d === c) {
            this._keys_down.splice(g, 1);
            break;
        }
        for (d = this._active_combos.length, f = [], i = this._active_combos, g = 0, h = i.length; g < h; g++) c = i[g], 
        0 <= u.call(c.keys, a) && f.push(c);
        for (g = 0, h = f.length; g < h; g++) c = f[g], this._handle_combo_up(c, b, a);
        if (1 < d) for (h = this._active_combos, d = 0, g = h.length; d < g; d++) void 0 === (c = h[d]) || 0 <= u.call(f, c) || this._keys_remain(c) || this._remove_from_active_combos(c);
    }, w.prototype._handle_combo_up = function(a, c, d) {
        var e, f;
        this._prevent_default(c, a && a.prevent_default), f = this._keys_remain(a), a.keyup_fired || (e = this._keys_down.slice(), 
        e.push(d), a.is_solitary && !b(e, a.keys)) || (this._fire("keyup", a, c), a.is_counting && "function" == typeof a.on_keyup && "function" != typeof a.on_keydown && (a.count += 1)), 
        f || (this._fire("release", a, c), this._remove_from_active_combos(a));
    }, w.prototype.simple_combo = function(a, b) {
        return this.register_combo({
            keys: a,
            on_keydown: b
        });
    }, w.prototype.counting_combo = function(a, b) {
        return this.register_combo({
            keys: a,
            is_counting: !0,
            is_unordered: !1,
            on_keydown: b
        });
    }, w.prototype.sequence_combo = function(a, b) {
        return this.register_combo({
            keys: a,
            on_keydown: b,
            is_sequence: !0,
            is_exclusive: !0
        });
    }, w.prototype.register_combo = function(a) {
        var b, c, d;
        "string" == typeof a.keys && (a.keys = a.keys.split(" ")), d = this._defaults;
        for (b in d) t.call(d, b) && (c = d[b], void 0 === a[b] && (a[b] = c));
        if (a = new v(a), s(a)) return this._registered_combos.push(a), a;
    }, w.prototype.register_many = function(a) {
        var b, c, d, e;
        for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.register_combo(b));
        return e;
    }, w.prototype.unregister_combo = function(a) {
        var d, e, f, g, h, i;
        if (!a) return !1;
        var j = this;
        if (e = function(a) {
            var b, c, d, e;
            for (e = [], b = c = 0, d = j._registered_combos.length; 0 <= d ? c < d : c > d; b = 0 <= d ? ++c : --c) {
                if (a === j._registered_combos[b]) {
                    j._registered_combos.splice(b, 1);
                    break;
                }
                e.push(void 0);
            }
            return e;
        }, a instanceof v) return e(a);
        for ("string" == typeof a && (a = a.split(" ")), h = this._registered_combos, i = [], 
        f = 0, g = h.length; f < g; f++) null != (d = h[f]) && (d.is_unordered && b(a, d.keys) || !d.is_unordered && c(a, d.keys) ? i.push(e(d)) : i.push(void 0));
        return i;
    }, w.prototype.unregister_many = function(a) {
        var b, c, d, e;
        for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.unregister_combo(b));
        return e;
    }, w.prototype.get_registered_combos = function() {
        return this._registered_combos;
    }, w.prototype.reset = function() {
        return this._registered_combos = [];
    }, w.prototype.listen = function() {
        return this._prevent_capture = !1;
    }, w.prototype.stop_listening = function() {
        return this._prevent_capture = !0;
    }, w.prototype.get_meta_key = function() {
        return p;
    }, a.Listener = w, d = function(a) {
        return m[a];
    }, g = function(a, b) {
        var c;
        if (a.filter) return a.filter(b);
        var d, e, f;
        for (f = [], d = 0, e = a.length; d < e; d++) c = a[d], b(c) && f.push(c);
        return f;
    }, b = function(a, b) {
        var c, d, e;
        if (a.length !== b.length) return !1;
        for (d = 0, e = a.length; d < e; d++) if (c = a[d], !(0 <= u.call(b, c))) return !1;
        return !0;
    }, c = function(a, b) {
        var c, d, e;
        if (a.length !== b.length) return !1;
        for (c = d = 0, e = a.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d) if (a[c] !== b[c]) return !1;
        return !0;
    }, i = function(a, b) {
        var c, d, e;
        for (d = 0, e = a.length; d < e; d++) if (c = a[d], 0 > u.call(b, c)) return !1;
        return !0;
    }, h = Array.prototype.indexOf || function(a, b) {
        var c, d, e;
        for (c = d = 0, e = a.length; 0 <= e ? d <= e : d >= e; c = 0 <= e ? ++d : --d) if (a[c] === b) return c;
        return -1;
    }, j = function(a, b) {
        var c, d, e, f;
        for (e = d = 0, f = a.length; e < f; e++) {
            if (c = a[e], !((c = h.call(b, c)) >= d)) return !1;
            d = c;
        }
        return !0;
    }, o = function() {
        if (a.debug) return console.log.apply(console, arguments);
    }, k = function(a) {
        var b, c, d;
        b = !1;
        for (d in m) if (c = m[d], a === c) {
            b = !0;
            break;
        }
        if (!b) for (d in n) if (c = n[d], a === c) {
            b = !0;
            break;
        }
        return b;
    }, s = function(a) {
        var b, c, d, e, g, i, j;
        for (g = !0, a.keys.length || o("You're trying to bind a combo with no keys:", a), 
        c = i = 0, j = a.keys.length; 0 <= j ? i < j : i > j; c = 0 <= j ? ++i : --i) d = a.keys[c], 
        (b = l[d]) && (d = a.keys[c] = b), "meta" === d && a.keys.splice(c, 1, p), "cmd" === d && o('Warning: use the "meta" key rather than "cmd" for Windows compatibility');
        for (j = a.keys, b = 0, i = j.length; b < i; b++) d = j[b], k(d) || (o('Do not recognize the key "' + d + '"'), 
        g = !1);
        if (0 <= u.call(a.keys, "meta") || 0 <= u.call(a.keys, "cmd")) {
            for (b = a.keys.slice(), i = 0, j = r.length; i < j; i++) d = r[i], -1 < (c = h.call(b, d)) && b.splice(c, 1);
            1 < b.length && (o("META and CMD key combos cannot have more than 1 non-modifier keys", a, b), 
            g = !1);
        }
        for (e in a) "undefined" === f[e] && o("The property " + e + " is not a valid combo property. Your combo has still been registered.");
        return g;
    }, e = function(a, b) {
        var c;
        return !!b.shiftKey && (null != (c = n[a]) && c);
    }, q = {
        cmd: "metaKey",
        ctrl: "ctrlKey",
        shift: "shiftKey",
        alt: "altKey"
    }, l = {
        escape: "esc",
        control: "ctrl",
        command: "cmd",
        break: "pause",
        windows: "cmd",
        option: "alt",
        caps_lock: "caps",
        apostrophe: "'",
        semicolon: ";",
        tilde: "~",
        accent: "`",
        scroll_lock: "scroll",
        num_lock: "num"
    }, n = {
        "/": "?",
        ".": ">",
        ",": "<",
        "'": '"',
        ";": ":",
        "[": "{",
        "]": "}",
        "\\": "|",
        "`": "~",
        "=": "+",
        "-": "_",
        1: "!",
        2: "@",
        3: "#",
        4: "$",
        5: "%",
        6: "^",
        7: "&",
        8: "*",
        9: "(",
        "0": ")"
    }, m = {
        "0": "\\",
        8: "backspace",
        9: "tab",
        12: "num",
        13: "enter",
        16: "shift",
        17: "ctrl",
        18: "alt",
        19: "pause",
        20: "caps",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        44: "print",
        45: "insert",
        46: "delete",
        48: "0",
        49: "1",
        50: "2",
        51: "3",
        52: "4",
        53: "5",
        54: "6",
        55: "7",
        56: "8",
        57: "9",
        65: "a",
        66: "b",
        67: "c",
        68: "d",
        69: "e",
        70: "f",
        71: "g",
        72: "h",
        73: "i",
        74: "j",
        75: "k",
        76: "l",
        77: "m",
        78: "n",
        79: "o",
        80: "p",
        81: "q",
        82: "r",
        83: "s",
        84: "t",
        85: "u",
        86: "v",
        87: "w",
        88: "x",
        89: "y",
        90: "z",
        91: "cmd",
        92: "cmd",
        93: "cmd",
        96: "num_0",
        97: "num_1",
        98: "num_2",
        99: "num_3",
        100: "num_4",
        101: "num_5",
        102: "num_6",
        103: "num_7",
        104: "num_8",
        105: "num_9",
        106: "num_multiply",
        107: "num_add",
        108: "num_enter",
        109: "num_subtract",
        110: "num_decimal",
        111: "num_divide",
        112: "f1",
        113: "f2",
        114: "f3",
        115: "f4",
        116: "f5",
        117: "f6",
        118: "f7",
        119: "f8",
        120: "f9",
        121: "f10",
        122: "f11",
        123: "f12",
        124: "print",
        144: "num",
        145: "scroll",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        223: "`",
        224: "cmd",
        225: "alt",
        57392: "ctrl",
        63289: "num",
        59: ";",
        61: "=",
        173: "-"
    }, a._keycode_dictionary = m, a._is_array_in_array_sorted = j, -1 !== navigator.userAgent.indexOf("Mac OS X") && (p = "cmd"), 
    -1 !== navigator.userAgent.indexOf("Opera") && (m[17] = "cmd"), "function" == typeof define && define.amd ? define([], function() {
        return a;
    }) : "undefined" != typeof exports && null !== exports ? exports.keypress = a : window.keypress = a;
}.call(this), function(a, b, c) {
    function d(c, f) {
        if (!b[c]) {
            if (!a[c]) {
                var g = "function" == typeof require && require;
                if (!f && g) return g(c, !0);
                if (e) return e(c, !0);
                throw new Error("Cannot find module '" + c + "'");
            }
            var h = b[c] = {
                exports: {}
            };
            a[c][0].call(h.exports, function(b) {
                var e = a[c][1][b];
                return d(e || b);
            }, h, h.exports);
        }
        return b[c].exports;
    }
    for (var e = "function" == typeof require && require, f = 0; f < c.length; f++) d(c[f]);
}({
    1: [ function(a, b, c) {}, {} ],
    2: [ function(a, b, c) {
        var d = b.exports = function(a) {
            this.pos = 0, this._buf = [], this.size = a;
        };
        d.prototype.get = function(a) {
            if (void 0 == a && (a = 0), !(a >= this.size || a >= this._buf.length)) return this._buf[(this.pos - a - 1) % this.size];
        }, d.prototype.push = function(a) {
            return this._buf[this.pos % this.size] = a, this.pos++;
        };
    }, {} ],
    3: [ function(a, b, c) {
        var d = a("../protocol").chooseProtocol, e = a("events").EventEmitter, f = a("underscore"), g = b.exports = function(a) {
            this.opts = f.defaults(a || {}, {
                host: "127.0.0.1",
                enableGestures: !1,
                port: 6437,
                background: !1,
                requestProtocolVersion: 4
            }), this.host = this.opts.host, this.port = this.opts.port, this.protocolVersionVerified = !1, 
            this.on("ready", function() {
                this.enableGestures(this.opts.enableGestures), this.setBackground(this.opts.background);
            });
        };
        g.prototype.getUrl = function() {
            return "ws://" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
        }, g.prototype.setBackground = function(a) {
            this.opts.background = a, this.protocol && this.protocol.sendBackground && this.background !== this.opts.background && (this.background = this.opts.background, 
            this.protocol.sendBackground(this, this.opts.background));
        }, g.prototype.handleOpen = function() {
            this.connected || (this.connected = !0, this.emit("connect"));
        }, g.prototype.enableGestures = function(a) {
            this.gesturesEnabled = !!a, this.send(this.protocol.encode({
                enableGestures: this.gesturesEnabled
            }));
        }, g.prototype.handleClose = function(a, b) {
            this.connected && (this.disconnect(), 1001 === a && this.opts.requestProtocolVersion > 1 && (this.protocolVersionVerified ? this.protocolVersionVerified = !1 : this.opts.requestProtocolVersion--), 
            this.startReconnection());
        }, g.prototype.startReconnection = function() {
            var a = this;
            this.reconnectionTimer = setInterval(function() {
                a.reconnect();
            }, 1e3);
        }, g.prototype.disconnect = function() {
            if (this.socket) return this.socket.close(), delete this.socket, delete this.protocol, 
            delete this.background, this.connected && (this.connected = !1, this.emit("disconnect")), 
            !0;
        }, g.prototype.reconnect = function() {
            this.connected ? clearInterval(this.reconnectionTimer) : (this.disconnect(), this.connect());
        }, g.prototype.handleData = function(a) {
            var b, c = JSON.parse(a);
            void 0 === this.protocol ? (b = this.protocol = d(c), this.protocolVersionVerified = !0, 
            this.emit("ready")) : b = this.protocol(c), this.emit(b.type, b);
        }, g.prototype.connect = function() {
            if (!this.socket) return this.socket = this.setupSocket(), !0;
        }, g.prototype.send = function(a) {
            this.socket.send(a);
        }, g.prototype.reportFocus = function(a) {
            this.focusedState !== a && (this.focusedState = a, this.emit(this.focusedState ? "focus" : "blur"), 
            this.protocol && this.protocol.sendFocused && this.protocol.sendFocused(this, this.focusedState));
        }, f.extend(g.prototype, e.prototype);
    }, {
        "../protocol": 13,
        events: 19,
        underscore: 22
    } ],
    4: [ function(a, b, c) {
        var d = b.exports = a("./base"), e = a("underscore"), f = b.exports = function(a) {
            d.call(this, a);
            var b = this;
            this.on("ready", function() {
                b.startFocusLoop();
            }), this.on("disconnect", function() {
                b.stopFocusLoop();
            });
        };
        e.extend(f.prototype, d.prototype), f.prototype.setupSocket = function() {
            var a = this, b = new WebSocket(this.getUrl());
            return b.onopen = function() {
                a.handleOpen();
            }, b.onclose = function(b) {
                a.handleClose(b.code, b.reason);
            }, b.onmessage = function(b) {
                a.handleData(b.data);
            }, b;
        }, f.prototype.startFocusLoop = function() {
            if (!this.focusDetectorTimer) {
                var a = this, b = null;
                b = void 0 !== document.hidden ? "hidden" : void 0 !== document.mozHidden ? "mozHidden" : void 0 !== document.msHidden ? "msHidden" : void 0 !== document.webkitHidden ? "webkitHidden" : void 0, 
                void 0 === a.windowVisible && (a.windowVisible = void 0 === b || !1 === document[b]);
                var c = window.addEventListener("focus", function(b) {
                    a.windowVisible = !0, e();
                }), d = window.addEventListener("blur", function(b) {
                    a.windowVisible = !1, e();
                });
                this.on("disconnect", function() {
                    window.removeEventListener("focus", c), window.removeEventListener("blur", d);
                });
                var e = function() {
                    var c = void 0 === b || !1 === document[b];
                    a.reportFocus(c && a.windowVisible);
                };
                this.focusDetectorTimer = setInterval(e, 100);
            }
        }, f.prototype.stopFocusLoop = function() {
            this.focusDetectorTimer && (clearTimeout(this.focusDetectorTimer), delete this.focusDetectorTimer);
        };
    }, {
        "./base": 3,
        underscore: 22
    } ],
    5: [ function(a, b, c) {
        var d = a("__browserify_process"), e = a("./frame"), f = a("./hand"), g = a("./pointable"), h = a("./circular_buffer"), i = a("./pipeline"), j = a("events").EventEmitter, k = a("./gesture").gestureListener, l = a("underscore"), m = b.exports = function(b) {
            var c = void 0 !== d && d.versions && d.versions.node, f = this;
            b = l.defaults(b || {}, {
                inNode: c
            }), this.inNode = b.inNode, b = l.defaults(b || {}, {
                frameEventName: this.useAnimationLoop() ? "animationFrame" : "deviceFrame",
                suppressAnimationLoop: !this.useAnimationLoop(),
                loopWhileDisconnected: !1,
                useAllPlugins: !1
            }), this.animationFrameRequested = !1, this.onAnimationFrame = function() {
                f.emit("animationFrame", f.lastConnectionFrame), f.loopWhileDisconnected && (f.connection.focusedState || f.connection.opts.background) ? window.requestAnimationFrame(f.onAnimationFrame) : f.animationFrameRequested = !1;
            }, this.suppressAnimationLoop = b.suppressAnimationLoop, this.loopWhileDisconnected = b.loopWhileDisconnected, 
            this.frameEventName = b.frameEventName, this.useAllPlugins = b.useAllPlugins, this.history = new h(200), 
            this.lastFrame = e.Invalid, this.lastValidFrame = e.Invalid, this.lastConnectionFrame = e.Invalid, 
            this.accumulatedGestures = [], void 0 === b.connectionType ? this.connectionType = a(this.inBrowser() ? "./connection/browser" : "./connection/node") : this.connectionType = b.connectionType, 
            this.connection = new this.connectionType(b), this.plugins = {}, this._pluginPipelineSteps = {}, 
            this._pluginExtendedMethods = {}, b.useAllPlugins && this.useRegisteredPlugins(), 
            this.setupConnectionEvents();
        };
        m.prototype.gesture = function(a, b) {
            var c = k(this, a);
            return void 0 !== b && c.stop(b), c;
        }, m.prototype.setBackground = function(a) {
            return this.connection.setBackground(a), this;
        }, m.prototype.inBrowser = function() {
            return !this.inNode;
        }, m.prototype.useAnimationLoop = function() {
            return this.inBrowser() && !this.inBackgroundPage();
        }, m.prototype.inBackgroundPage = function() {
            return "undefined" != typeof chrome && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window;
        }, m.prototype.connect = function() {
            return this.connection.connect(), this;
        }, m.prototype.runAnimationLoop = function() {
            this.suppressAnimationLoop || this.animationFrameRequested || (this.animationFrameRequested = !0, 
            window.requestAnimationFrame(this.onAnimationFrame));
        }, m.prototype.disconnect = function() {
            return this.connection.disconnect(), this;
        }, m.prototype.frame = function(a) {
            return this.history.get(a) || e.Invalid;
        }, m.prototype.loop = function(a) {
            switch (a.length) {
              case 1:
                this.on(this.frameEventName, a);
                break;

              case 2:
                var b = this, c = function(d) {
                    a(d, function() {
                        b.lastFrame != d ? c(b.lastFrame) : b.once(b.frameEventName, c);
                    });
                };
                this.once(this.frameEventName, c);
            }
            return this.connect();
        }, m.prototype.addStep = function(a) {
            this.pipeline || (this.pipeline = new i(this)), this.pipeline.addStep(a);
        }, m.prototype.processFrame = function(a) {
            a.gestures && (this.accumulatedGestures = this.accumulatedGestures.concat(a.gestures)), 
            this.lastConnectionFrame = a, this.runAnimationLoop(), this.emit("deviceFrame", a);
        }, m.prototype.processFinishedFrame = function(a) {
            if (this.lastFrame = a, a.valid && (this.lastValidFrame = a), a.controller = this, 
            a.historyIdx = this.history.push(a), a.gestures) {
                a.gestures = this.accumulatedGestures, this.accumulatedGestures = [];
                for (var b = 0; b != a.gestures.length; b++) this.emit("gesture", a.gestures[b], a);
            }
            this.pipeline && ((a = this.pipeline.run(a)) || (a = e.Invalid)), this.emit("frame", a);
        }, m.prototype.setupConnectionEvents = function() {
            var a = this;
            this.connection.on("frame", function(b) {
                a.processFrame(b);
            }), this.on(this.frameEventName, function(b) {
                a.processFinishedFrame(b);
            }), this.connection.on("disconnect", function() {
                a.emit("disconnect");
            }), this.connection.on("ready", function() {
                a.emit("ready");
            }), this.connection.on("connect", function() {
                a.emit("connect");
            }), this.connection.on("focus", function() {
                a.emit("focus"), a.runAnimationLoop();
            }), this.connection.on("blur", function() {
                a.emit("blur");
            }), this.connection.on("protocol", function(b) {
                a.emit("protocol", b);
            }), this.connection.on("deviceConnect", function(b) {
                a.emit(b.state ? "deviceConnected" : "deviceDisconnected");
            });
        }, m._pluginFactories = {}, m.plugin = function(a, b) {
            if (this._pluginFactories[a]) throw 'Plugin "' + a + '" already registered';
            return this._pluginFactories[a] = b;
        }, m.plugins = function() {
            return l.keys(this._pluginFactories);
        }, m.prototype.use = function(a, b) {
            var c, d, h, j, k;
            if (!(d = "function" == typeof a ? a : m._pluginFactories[a])) throw "Leap Plugin " + a + " not found.";
            if (b || (b = {}), this.plugins[a]) return l.extend(this.plugins[a], b), this;
            this.plugins[a] = b, j = d.call(this, b);
            for (h in j) if ("function" == typeof (c = j[h])) this.pipeline || (this.pipeline = new i(this)), 
            this._pluginPipelineSteps[a] || (this._pluginPipelineSteps[a] = []), this._pluginPipelineSteps[a].push(this.pipeline.addWrappedStep(h, c)); else {
                switch (this._pluginExtendedMethods[a] || (this._pluginExtendedMethods[a] = []), 
                h) {
                  case "frame":
                    k = e;
                    break;

                  case "hand":
                    k = f;
                    break;

                  case "pointable":
                    k = g;
                    break;

                  default:
                    throw a + ' specifies invalid object type "' + h + '" for prototypical extension';
                }
                l.extend(k.prototype, c), l.extend(k.Invalid, c), this._pluginExtendedMethods[a].push([ k, c ]);
            }
            return this;
        }, m.prototype.stopUsing = function(a) {
            var b, c, d = this._pluginPipelineSteps[a], e = this._pluginExtendedMethods[a], f = 0;
            if (this.plugins[a]) {
                if (d) for (f = 0; f < d.length; f++) this.pipeline.removeStep(d[f]);
                if (e) for (f = 0; f < e.length; f++) {
                    b = e[f][0], c = e[f][1];
                    for (var g in c) delete b.prototype[g], delete b.Invalid[g];
                }
                return delete this.plugins[a], this;
            }
        }, m.prototype.useRegisteredPlugins = function() {
            for (var a in m._pluginFactories) this.use(a);
        }, l.extend(m.prototype, j.prototype);
    }, {
        "./circular_buffer": 2,
        "./connection/browser": 4,
        "./connection/node": 18,
        "./frame": 6,
        "./gesture": 7,
        "./hand": 8,
        "./pipeline": 11,
        "./pointable": 12,
        __browserify_process: 20,
        events: 19,
        underscore: 22
    } ],
    6: [ function(a, b, c) {
        var d = a("./hand"), e = a("./pointable"), f = a("./gesture").createGesture, g = a("gl-matrix"), h = g.mat3, i = g.vec3, j = a("./interaction_box"), k = a("underscore"), l = b.exports = function(a) {
            this.valid = !0, this.id = a.id, this.timestamp = a.timestamp, this.hands = [], 
            this.handsMap = {}, this.pointables = [], this.tools = [], this.fingers = [], a.interactionBox && (this.interactionBox = new j(a.interactionBox)), 
            this.gestures = [], this.pointablesMap = {}, this._translation = a.t, this._rotation = k.flatten(a.r), 
            this._scaleFactor = a.s, this.data = a, this.type = "frame", this.currentFrameRate = a.currentFrameRate;
            for (var b = {}, c = 0, g = a.hands.length; c != g; c++) {
                var h = new d(a.hands[c]);
                h.frame = this, this.hands.push(h), this.handsMap[h.id] = h, b[h.id] = c;
            }
            for (var i = 0, l = a.pointables.length; i != l; i++) {
                var m = new e(a.pointables[i]);
                if (m.frame = this, this.pointables.push(m), this.pointablesMap[m.id] = m, (m.tool ? this.tools : this.fingers).push(m), 
                void 0 !== m.handId && b.hasOwnProperty(m.handId)) {
                    var h = this.hands[b[m.handId]];
                    h.pointables.push(m), (m.tool ? h.tools : h.fingers).push(m);
                }
            }
            if (a.gestures) for (var n = 0, o = a.gestures.length; n != o; n++) this.gestures.push(f(a.gestures[n]));
        };
        l.prototype.tool = function(a) {
            var b = this.pointable(a);
            return b.tool ? b : e.Invalid;
        }, l.prototype.pointable = function(a) {
            return this.pointablesMap[a] || e.Invalid;
        }, l.prototype.finger = function(a) {
            var b = this.pointable(a);
            return b.tool ? e.Invalid : b;
        }, l.prototype.hand = function(a) {
            return this.handsMap[a] || d.Invalid;
        }, l.prototype.rotationAngle = function(a, b) {
            if (!this.valid || !a.valid) return 0;
            var c = this.rotationMatrix(a), d = .5 * (c[0] + c[4] + c[8] - 1), e = Math.acos(d);
            if (e = isNaN(e) ? 0 : e, void 0 !== b) {
                var f = this.rotationAxis(a);
                e *= i.dot(f, i.normalize(i.create(), b));
            }
            return e;
        }, l.prototype.rotationAxis = function(a) {
            return this.valid && a.valid ? i.normalize(i.create(), [ this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1] ]) : i.create();
        }, l.prototype.rotationMatrix = function(a) {
            if (!this.valid || !a.valid) return h.create();
            var b = h.transpose(h.create(), this._rotation);
            return h.multiply(h.create(), a._rotation, b);
        }, l.prototype.scaleFactor = function(a) {
            return this.valid && a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
        }, l.prototype.translation = function(a) {
            return this.valid && a.valid ? i.subtract(i.create(), this._translation, a._translation) : i.create();
        }, l.prototype.toString = function() {
            var a = "Frame [ id:" + this.id + " | timestamp:" + this.timestamp + " | Hand count:(" + this.hands.length + ") | Pointable count:(" + this.pointables.length + ")";
            return this.gestures && (a += " | Gesture count:(" + this.gestures.length + ")"), 
            a += " ]";
        }, l.prototype.dump = function() {
            var a = "";
            a += "Frame Info:<br/>", a += this.toString(), a += "<br/><br/>Hands:<br/>";
            for (var b = 0, c = this.hands.length; b != c; b++) a += "  " + this.hands[b].toString() + "<br/>";
            a += "<br/><br/>Pointables:<br/>";
            for (var d = 0, e = this.pointables.length; d != e; d++) a += "  " + this.pointables[d].toString() + "<br/>";
            if (this.gestures) {
                a += "<br/><br/>Gestures:<br/>";
                for (var f = 0, g = this.gestures.length; f != g; f++) a += "  " + this.gestures[f].toString() + "<br/>";
            }
            return a += "<br/><br/>Raw JSON:<br/>", a += JSON.stringify(this.data);
        }, l.Invalid = {
            valid: !1,
            hands: [],
            fingers: [],
            tools: [],
            gestures: [],
            pointables: [],
            pointable: function() {
                return e.Invalid;
            },
            finger: function() {
                return e.Invalid;
            },
            hand: function() {
                return d.Invalid;
            },
            toString: function() {
                return "invalid frame";
            },
            dump: function() {
                return this.toString();
            },
            rotationAngle: function() {
                return 0;
            },
            rotationMatrix: function() {
                return h.create();
            },
            rotationAxis: function() {
                return i.create();
            },
            scaleFactor: function() {
                return 1;
            },
            translation: function() {
                return i.create();
            }
        };
    }, {
        "./gesture": 7,
        "./hand": 8,
        "./interaction_box": 10,
        "./pointable": 12,
        "gl-matrix": 21,
        underscore: 22
    } ],
    7: [ function(a, b, c) {
        var d = a("gl-matrix"), e = d.vec3, f = a("events").EventEmitter, g = a("underscore"), h = (c.createGesture = function(a) {
            var b;
            switch (a.type) {
              case "circle":
                b = new i(a);
                break;

              case "swipe":
                b = new j(a);
                break;

              case "screenTap":
                b = new k(a);
                break;

              case "keyTap":
                b = new l(a);
                break;

              default:
                throw "unkown gesture type";
            }
            return b.id = a.id, b.handIds = a.handIds, b.pointableIds = a.pointableIds, b.duration = a.duration, 
            b.state = a.state, b.type = a.type, b;
        }, c.gestureListener = function(a, b) {
            var c = {}, d = {};
            a.on("gesture", function(a, e) {
                if (a.type == b) {
                    if (("start" == a.state || "stop" == a.state) && void 0 === d[a.id]) {
                        var f = new h(a, e);
                        d[a.id] = f, g.each(c, function(a, b) {
                            f.on(b, a);
                        });
                    }
                    d[a.id].update(a, e), "stop" == a.state && delete d[a.id];
                }
            });
            var e = {
                start: function(a) {
                    return c.start = a, e;
                },
                stop: function(a) {
                    return c.stop = a, e;
                },
                complete: function(a) {
                    return c.stop = a, e;
                },
                update: function(a) {
                    return c.update = a, e;
                }
            };
            return e;
        }, c.Gesture = function(a, b) {
            this.gestures = [ a ], this.frames = [ b ];
        });
        h.prototype.update = function(a, b) {
            this.lastGesture = a, this.lastFrame = b, this.gestures.push(a), this.frames.push(b), 
            this.emit(a.state, this);
        }, h.prototype.translation = function() {
            return e.subtract(e.create(), this.lastGesture.startPosition, this.lastGesture.position);
        }, g.extend(h.prototype, f.prototype);
        var i = function(a) {
            this.center = a.center, this.normal = a.normal, this.progress = a.progress, this.radius = a.radius;
        };
        i.prototype.toString = function() {
            return "CircleGesture [" + JSON.stringify(this) + "]";
        };
        var j = function(a) {
            this.startPosition = a.startPosition, this.position = a.position, this.direction = a.direction, 
            this.speed = a.speed;
        };
        j.prototype.toString = function() {
            return "SwipeGesture [" + JSON.stringify(this) + "]";
        };
        var k = function(a) {
            this.position = a.position, this.direction = a.direction, this.progress = a.progress;
        };
        k.prototype.toString = function() {
            return "ScreenTapGesture [" + JSON.stringify(this) + "]";
        };
        var l = function(a) {
            this.position = a.position, this.direction = a.direction, this.progress = a.progress;
        };
        l.prototype.toString = function() {
            return "KeyTapGesture [" + JSON.stringify(this) + "]";
        };
    }, {
        events: 19,
        "gl-matrix": 21,
        underscore: 22
    } ],
    8: [ function(a, b, c) {
        var d = a("./pointable"), e = a("gl-matrix"), f = e.mat3, g = e.vec3, h = a("underscore"), i = b.exports = function(a) {
            this.id = a.id, this.palmPosition = a.palmPosition, this.direction = a.direction, 
            this.palmVelocity = a.palmVelocity, this.palmNormal = a.palmNormal, this.sphereCenter = a.sphereCenter, 
            this.sphereRadius = a.sphereRadius, this.valid = !0, this.pointables = [], this.fingers = [], 
            this.tools = [], this._translation = a.t, this._rotation = h.flatten(a.r), this._scaleFactor = a.s, 
            this.timeVisible = a.timeVisible, this.stabilizedPalmPosition = a.stabilizedPalmPosition;
        };
        i.prototype.finger = function(a) {
            var b = this.frame.finger(a);
            return b && b.handId == this.id ? b : d.Invalid;
        }, i.prototype.rotationAngle = function(a, b) {
            if (!this.valid || !a.valid) return 0;
            if (!a.hand(this.id).valid) return 0;
            var c = this.rotationMatrix(a), d = .5 * (c[0] + c[4] + c[8] - 1), e = Math.acos(d);
            if (e = isNaN(e) ? 0 : e, void 0 !== b) {
                var f = this.rotationAxis(a);
                e *= g.dot(f, g.normalize(g.create(), b));
            }
            return e;
        }, i.prototype.rotationAxis = function(a) {
            if (!this.valid || !a.valid) return g.create();
            var b = a.hand(this.id);
            return b.valid ? g.normalize(g.create(), [ this._rotation[7] - b._rotation[5], this._rotation[2] - b._rotation[6], this._rotation[3] - b._rotation[1] ]) : g.create();
        }, i.prototype.rotationMatrix = function(a) {
            if (!this.valid || !a.valid) return f.create();
            var b = a.hand(this.id);
            if (!b.valid) return f.create();
            var c = f.transpose(f.create(), this._rotation);
            return f.multiply(f.create(), b._rotation, c);
        }, i.prototype.scaleFactor = function(a) {
            if (!this.valid || !a.valid) return 1;
            var b = a.hand(this.id);
            return b.valid ? Math.exp(this._scaleFactor - b._scaleFactor) : 1;
        }, i.prototype.translation = function(a) {
            if (!this.valid || !a.valid) return g.create();
            var b = a.hand(this.id);
            return b.valid ? [ this._translation[0] - b._translation[0], this._translation[1] - b._translation[1], this._translation[2] - b._translation[2] ] : g.create();
        }, i.prototype.toString = function() {
            return "Hand [ id: " + this.id + " | palm velocity:" + this.palmVelocity + " | sphere center:" + this.sphereCenter + " ] ";
        }, i.prototype.pitch = function() {
            return Math.atan2(this.direction[1], -this.direction[2]);
        }, i.prototype.yaw = function() {
            return Math.atan2(this.direction[0], -this.direction[2]);
        }, i.prototype.roll = function() {
            return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
        }, i.Invalid = {
            valid: !1,
            fingers: [],
            tools: [],
            pointables: [],
            pointable: function() {
                return d.Invalid;
            },
            finger: function() {
                return d.Invalid;
            },
            toString: function() {
                return "invalid frame";
            },
            dump: function() {
                return this.toString();
            },
            rotationAngle: function() {
                return 0;
            },
            rotationMatrix: function() {
                return f.create();
            },
            rotationAxis: function() {
                return g.create();
            },
            scaleFactor: function() {
                return 1;
            },
            translation: function() {
                return g.create();
            }
        };
    }, {
        "./pointable": 12,
        "gl-matrix": 21,
        underscore: 22
    } ],
    9: [ function(a, b, c) {
        a("./_header"), b.exports = {
            Controller: a("./controller"),
            Frame: a("./frame"),
            Gesture: a("./gesture"),
            Hand: a("./hand"),
            Pointable: a("./pointable"),
            InteractionBox: a("./interaction_box"),
            CircularBuffer: a("./circular_buffer"),
            UI: a("./ui"),
            glMatrix: a("gl-matrix"),
            mat3: a("gl-matrix").mat3,
            vec3: a("gl-matrix").vec3,
            loopController: void 0,
            version: a("./version.js"),
            loop: function(a, b) {
                return void 0 === b && (b = a, a = {}), a.useAllPlugins || (a.useAllPlugins = !0), 
                this.loopController || (this.loopController = new this.Controller(a)), this.loopController.loop(b), 
                this.loopController;
            },
            plugin: function(a, b) {
                this.Controller.plugin(a, b);
            }
        };
    }, {
        "./_header": 1,
        "./circular_buffer": 2,
        "./controller": 5,
        "./frame": 6,
        "./gesture": 7,
        "./hand": 8,
        "./interaction_box": 10,
        "./pointable": 12,
        "./ui": 14,
        "./version.js": 17,
        "gl-matrix": 21
    } ],
    10: [ function(a, b, c) {
        var d = a("gl-matrix"), e = d.vec3, f = b.exports = function(a) {
            this.valid = !0, this.center = a.center, this.size = a.size, this.width = a.size[0], 
            this.height = a.size[1], this.depth = a.size[2];
        };
        f.prototype.denormalizePoint = function(a) {
            return e.fromValues((a[0] - .5) * this.size[0] + this.center[0], (a[1] - .5) * this.size[1] + this.center[1], (a[2] - .5) * this.size[2] + this.center[2]);
        }, f.prototype.normalizePoint = function(a, b) {
            var c = e.fromValues((a[0] - this.center[0]) / this.size[0] + .5, (a[1] - this.center[1]) / this.size[1] + .5, (a[2] - this.center[2]) / this.size[2] + .5);
            return b && (c[0] = Math.min(Math.max(c[0], 0), 1), c[1] = Math.min(Math.max(c[1], 0), 1), 
            c[2] = Math.min(Math.max(c[2], 0), 1)), c;
        }, f.prototype.toString = function() {
            return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
        }, f.Invalid = {
            valid: !1
        };
    }, {
        "gl-matrix": 21
    } ],
    11: [ function(a, b, c) {
        var d = b.exports = function(a) {
            this.steps = [], this.controller = a;
        };
        d.prototype.addStep = function(a) {
            this.steps.push(a);
        }, d.prototype.run = function(a) {
            for (var b = this.steps.length, c = 0; c != b && a; c++) a = this.steps[c](a);
            return a;
        }, d.prototype.removeStep = function(a) {
            var b = this.steps.indexOf(a);
            if (-1 === b) throw "Step not found in pipeline";
            this.steps.splice(b, 1);
        }, d.prototype.addWrappedStep = function(a, b) {
            var c = this.controller, d = function(d) {
                var e, f, g;
                for (e = "frame" == a ? [ d ] : d[a + "s"] || [], f = 0, g = e.length; f < g; f++) b.call(c, e[f]);
                return d;
            };
            return this.addStep(d), d;
        };
    }, {} ],
    12: [ function(a, b, c) {
        var d = a("gl-matrix"), e = (d.vec3, b.exports = function(a) {
            this.valid = !0, this.id = a.id, this.handId = a.handId, this.length = a.length, 
            this.tool = a.tool, this.width = a.width, this.direction = a.direction, this.stabilizedTipPosition = a.stabilizedTipPosition, 
            this.tipPosition = a.tipPosition, this.tipVelocity = a.tipVelocity, this.touchZone = a.touchZone, 
            this.touchDistance = a.touchDistance, this.timeVisible = a.timeVisible;
        });
        e.prototype.toString = function() {
            return 1 == this.tool ? "Pointable [ id:" + this.id + " " + this.length + "mmx | with:" + this.width + "mm | direction:" + this.direction + " ]" : "Pointable [ id:" + this.id + " " + this.length + "mmx | direction: " + this.direction + " ]";
        }, e.prototype.hand = function() {
            return this.frame.hand(this.handId);
        }, e.Invalid = {
            valid: !1
        };
    }, {
        "gl-matrix": 21
    } ],
    13: [ function(a, b, c) {
        var d = a("./frame"), e = function(a) {
            this.type = a.type, this.state = a.state;
        }, f = (c.chooseProtocol = function(a) {
            var b;
            switch (a.version) {
              case 1:
              case 2:
              case 3:
              case 4:
                b = f(a.version, function(a) {
                    return a.event ? new e(a.event) : new d(a);
                }), b.sendBackground = function(a, c) {
                    a.send(b.encode({
                        background: c
                    }));
                }, b.sendFocused = function(a, c) {
                    a.send(b.encode({
                        focused: c
                    }));
                };
                break;

              default:
                throw "unrecognized version";
            }
            return b;
        }, function(a, b) {
            var c = b;
            return c.encode = function(a) {
                return JSON.stringify(a);
            }, c.version = a, c.versionLong = "Version " + a, c.type = "protocol", c;
        });
    }, {
        "./frame": 6
    } ],
    14: [ function(a, b, c) {
        c.UI = {
            Region: a("./ui/region"),
            Cursor: a("./ui/cursor")
        };
    }, {
        "./ui/cursor": 15,
        "./ui/region": 16
    } ],
    15: [ function(a, b, c) {
        b.exports = function() {
            return function(a) {
                var b = a.pointables.sort(function(a, b) {
                    return a.z - b.z;
                })[0];
                return b && b.valid && (a.cursorPosition = b.tipPosition), a;
            };
        };
    }, {} ],
    16: [ function(a, b, c) {
        var d = a("events").EventEmitter, e = a("underscore"), f = b.exports = function(a, b) {
            this.start = new Vector(a), this.end = new Vector(b), this.enteredFrame = null;
        };
        f.prototype.hasPointables = function(a) {
            for (var b = 0; b != a.pointables.length; b++) {
                var c = a.pointables[b].tipPosition;
                if (c.x >= this.start.x && c.x <= this.end.x && c.y >= this.start.y && c.y <= this.end.y && c.z >= this.start.z && c.z <= this.end.z) return !0;
            }
            return !1;
        }, f.prototype.listener = function(a) {
            var b = this;
            return a && a.nearThreshold && this.setupNearRegion(a.nearThreshold), function(a) {
                return b.updatePosition(a);
            };
        }, f.prototype.clipper = function() {
            var a = this;
            return function(b) {
                return a.updatePosition(b), a.enteredFrame ? b : null;
            };
        }, f.prototype.setupNearRegion = function(a) {
            var b = this.nearRegion = new f([ this.start.x - a, this.start.y - a, this.start.z - a ], [ this.end.x + a, this.end.y + a, this.end.z + a ]), c = this;
            b.on("enter", function(a) {
                c.emit("near", a);
            }), b.on("exit", function(a) {
                c.emit("far", a);
            }), c.on("exit", function(a) {
                c.emit("near", a);
            });
        }, f.prototype.updatePosition = function(a) {
            return this.nearRegion && this.nearRegion.updatePosition(a), this.hasPointables(a) && null == this.enteredFrame ? (this.enteredFrame = a, 
            this.emit("enter", this.enteredFrame)) : this.hasPointables(a) || null == this.enteredFrame || (this.enteredFrame = null, 
            this.emit("exit", this.enteredFrame)), a;
        }, f.prototype.normalize = function(a) {
            return new Vector([ (a.x - this.start.x) / (this.end.x - this.start.x), (a.y - this.start.y) / (this.end.y - this.start.y), (a.z - this.start.z) / (this.end.z - this.start.z) ]);
        }, f.prototype.mapToXY = function(a, b, c) {
            var d = this.normalize(a), e = d.x, f = d.y;
            return e > 1 ? e = 1 : e < -1 && (e = -1), f > 1 ? f = 1 : f < -1 && (f = -1), [ (e + 1) / 2 * b, (1 - f) / 2 * c, d.z ];
        }, e.extend(f.prototype, d.prototype);
    }, {
        events: 19,
        underscore: 22
    } ],
    17: [ function(a, b, c) {
        b.exports = {
            full: "0.4.3",
            major: 0,
            minor: 4,
            dot: 3
        };
    }, {} ],
    18: [ function(a, b, c) {}, {} ],
    19: [ function(a, b, c) {
        function d(a, b) {
            if (a.indexOf) return a.indexOf(b);
            for (var c = 0; c < a.length; c++) if (b === a[c]) return c;
            return -1;
        }
        var e = a("__browserify_process");
        e.EventEmitter || (e.EventEmitter = function() {});
        var f = c.EventEmitter = e.EventEmitter, g = "function" == typeof Array.isArray ? Array.isArray : function(a) {
            return "[object Array]" === Object.prototype.toString.call(a);
        };
        f.prototype.setMaxListeners = function(a) {
            this._events || (this._events = {}), this._events.maxListeners = a;
        }, f.prototype.emit = function(a) {
            if ("error" === a && (!this._events || !this._events.error || g(this._events.error) && !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
            if (!this._events) return !1;
            var b = this._events[a];
            if (!b) return !1;
            if ("function" == typeof b) {
                switch (arguments.length) {
                  case 1:
                    b.call(this);
                    break;

                  case 2:
                    b.call(this, arguments[1]);
                    break;

                  case 3:
                    b.call(this, arguments[1], arguments[2]);
                    break;

                  default:
                    var c = Array.prototype.slice.call(arguments, 1);
                    b.apply(this, c);
                }
                return !0;
            }
            if (g(b)) {
                for (var c = Array.prototype.slice.call(arguments, 1), d = b.slice(), e = 0, f = d.length; e < f; e++) d[e].apply(this, c);
                return !0;
            }
            return !1;
        }, f.prototype.addListener = function(a, b) {
            if ("function" != typeof b) throw new Error("addListener only takes instances of Function");
            if (this._events || (this._events = {}), this.emit("newListener", a, b), this._events[a]) if (g(this._events[a])) {
                if (!this._events[a].warned) {
                    var c;
                    (c = void 0 !== this._events.maxListeners ? this._events.maxListeners : 10) && c > 0 && this._events[a].length > c && (this._events[a].warned = !0, 
                    console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a].length), 
                    console.trace());
                }
                this._events[a].push(b);
            } else this._events[a] = [ this._events[a], b ]; else this._events[a] = b;
            return this;
        }, f.prototype.on = f.prototype.addListener, f.prototype.once = function(a, b) {
            var c = this;
            return c.on(a, function d() {
                c.removeListener(a, d), b.apply(this, arguments);
            }), this;
        }, f.prototype.removeListener = function(a, b) {
            if ("function" != typeof b) throw new Error("removeListener only takes instances of Function");
            if (!this._events || !this._events[a]) return this;
            var c = this._events[a];
            if (g(c)) {
                var e = d(c, b);
                if (e < 0) return this;
                c.splice(e, 1), 0 == c.length && delete this._events[a];
            } else this._events[a] === b && delete this._events[a];
            return this;
        }, f.prototype.removeAllListeners = function(a) {
            return 0 === arguments.length ? (this._events = {}, this) : (a && this._events && this._events[a] && (this._events[a] = null), 
            this);
        }, f.prototype.listeners = function(a) {
            return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), 
            g(this._events[a]) || (this._events[a] = [ this._events[a] ]), this._events[a];
        }, f.listenerCount = function(a, b) {
            return a._events && a._events[b] ? "function" == typeof a._events[b] ? 1 : a._events[b].length : 0;
        };
    }, {
        __browserify_process: 20
    } ],
    20: [ function(a, b, c) {
        var d = b.exports = {};
        d.nextTick = function() {
            var a = "undefined" != typeof window && window.setImmediate, b = "undefined" != typeof window && window.postMessage && window.addEventListener;
            if (a) return function(a) {
                return window.setImmediate(a);
            };
            if (b) {
                var c = [];
                return window.addEventListener("message", function(a) {
                    if (a.source === window && "process-tick" === a.data && (a.stopPropagation(), c.length > 0)) {
                        c.shift()();
                    }
                }, !0), function(a) {
                    c.push(a), window.postMessage("process-tick", "*");
                };
            }
            return function(a) {
                setTimeout(a, 0);
            };
        }(), d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.binding = function(a) {
            throw new Error("process.binding is not supported");
        }, d.cwd = function() {
            return "/";
        }, d.chdir = function(a) {
            throw new Error("process.chdir is not supported");
        };
    }, {} ],
    21: [ function(a, b, c) {
        !function() {
            "use strict";
            var a = {};
            void 0 === c ? "function" == typeof define && "object" == typeof define.amd && define.amd ? (a.exports = {}, 
            define(function() {
                return a.exports;
            })) : a.exports = window : a.exports = c, function(a) {
                var b = {};
                if (!c) var c = 1e-6;
                b.create = function() {
                    return new Float32Array(2);
                }, b.clone = function(a) {
                    var b = new Float32Array(2);
                    return b[0] = a[0], b[1] = a[1], b;
                }, b.fromValues = function(a, b) {
                    var c = new Float32Array(2);
                    return c[0] = a, c[1] = b, c;
                }, b.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a;
                }, b.set = function(a, b, c) {
                    return a[0] = b, a[1] = c, a;
                }, b.add = function(a, b, c) {
                    return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a;
                }, b.sub = b.subtract = function(a, b, c) {
                    return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a;
                }, b.mul = b.multiply = function(a, b, c) {
                    return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a;
                }, b.div = b.divide = function(a, b, c) {
                    return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a;
                }, b.min = function(a, b, c) {
                    return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a;
                }, b.max = function(a, b, c) {
                    return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a;
                }, b.scale = function(a, b, c) {
                    return a[0] = b[0] * c, a[1] = b[1] * c, a;
                }, b.dist = b.distance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1];
                    return Math.sqrt(c * c + d * d);
                }, b.sqrDist = b.squaredDistance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1];
                    return c * c + d * d;
                }, b.len = b.length = function(a) {
                    var b = a[0], c = a[1];
                    return Math.sqrt(b * b + c * c);
                }, b.sqrLen = b.squaredLength = function(a) {
                    var b = a[0], c = a[1];
                    return b * b + c * c;
                }, b.negate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a;
                }, b.normalize = function(a, b) {
                    var c = b[0], d = b[1], e = c * c + d * d;
                    return e > 0 && (e = 1 / Math.sqrt(e), a[0] = b[0] * e, a[1] = b[1] * e), a;
                }, b.dot = function(a, b) {
                    return a[0] * b[0] + a[1] * b[1];
                }, b.cross = function(a, b, c) {
                    var d = b[0] * c[1] - b[1] * c[0];
                    return a[0] = a[1] = 0, a[2] = d, a;
                }, b.lerp = function(a, b, c, d) {
                    var e = b[0], f = b[1];
                    return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a;
                }, b.transformMat2 = function(a, b, c) {
                    var d = b[0], e = b[1];
                    return a[0] = d * c[0] + e * c[1], a[1] = d * c[2] + e * c[3], a;
                }, b.forEach = function() {
                    var a = new Float32Array(2);
                    return function(b, c, d, e, f, g) {
                        var h, i;
                        for (c || (c = 2), d || (d = 0), i = e ? Math.min(e * c + d, b.length) : b.length, 
                        h = d; h < i; h += c) a[0] = b[h], a[1] = b[h + 1], f(a, a, g), b[h] = a[0], b[h + 1] = a[1];
                        return b;
                    };
                }(), b.str = function(a) {
                    return "vec2(" + a[0] + ", " + a[1] + ")";
                }, void 0 !== a && (a.vec2 = b);
                var d = {};
                if (!c) var c = 1e-6;
                d.create = function() {
                    return new Float32Array(3);
                }, d.clone = function(a) {
                    var b = new Float32Array(3);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b;
                }, d.fromValues = function(a, b, c) {
                    var d = new Float32Array(3);
                    return d[0] = a, d[1] = b, d[2] = c, d;
                }, d.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a;
                }, d.set = function(a, b, c, d) {
                    return a[0] = b, a[1] = c, a[2] = d, a;
                }, d.add = function(a, b, c) {
                    return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a;
                }, d.sub = d.subtract = function(a, b, c) {
                    return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a;
                }, d.mul = d.multiply = function(a, b, c) {
                    return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a;
                }, d.div = d.divide = function(a, b, c) {
                    return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a;
                }, d.min = function(a, b, c) {
                    return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), 
                    a;
                }, d.max = function(a, b, c) {
                    return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), 
                    a;
                }, d.scale = function(a, b, c) {
                    return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a;
                }, d.dist = d.distance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2];
                    return Math.sqrt(c * c + d * d + e * e);
                }, d.sqrDist = d.squaredDistance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2];
                    return c * c + d * d + e * e;
                }, d.len = d.length = function(a) {
                    var b = a[0], c = a[1], d = a[2];
                    return Math.sqrt(b * b + c * c + d * d);
                }, d.sqrLen = d.squaredLength = function(a) {
                    var b = a[0], c = a[1], d = a[2];
                    return b * b + c * c + d * d;
                }, d.negate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a;
                }, d.normalize = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = c * c + d * d + e * e;
                    return f > 0 && (f = 1 / Math.sqrt(f), a[0] = b[0] * f, a[1] = b[1] * f, a[2] = b[2] * f), 
                    a;
                }, d.dot = function(a, b) {
                    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                }, d.cross = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = c[0], h = c[1], i = c[2];
                    return a[0] = e * i - f * h, a[1] = f * g - d * i, a[2] = d * h - e * g, a;
                }, d.lerp = function(a, b, c, d) {
                    var e = b[0], f = b[1], g = b[2];
                    return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a[2] = g + d * (c[2] - g), 
                    a;
                }, d.transformMat4 = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2];
                    return a[0] = c[0] * d + c[4] * e + c[8] * f + c[12], a[1] = c[1] * d + c[5] * e + c[9] * f + c[13], 
                    a[2] = c[2] * d + c[6] * e + c[10] * f + c[14], a;
                }, d.transformQuat = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = c[0], h = c[1], i = c[2], j = c[3], k = j * d + h * f - i * e, l = j * e + i * d - g * f, m = j * f + g * e - h * d, n = -g * d - h * e - i * f;
                    return a[0] = k * j + n * -g + l * -i - m * -h, a[1] = l * j + n * -h + m * -g - k * -i, 
                    a[2] = m * j + n * -i + k * -h - l * -g, a;
                }, d.forEach = function() {
                    var a = new Float32Array(3);
                    return function(b, c, d, e, f, g) {
                        var h, i;
                        for (c || (c = 3), d || (d = 0), i = e ? Math.min(e * c + d, b.length) : b.length, 
                        h = d; h < i; h += c) a[0] = b[h], a[1] = b[h + 1], a[2] = b[h + 2], f(a, a, g), 
                        b[h] = a[0], b[h + 1] = a[1], b[h + 2] = a[2];
                        return b;
                    };
                }(), d.str = function(a) {
                    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
                }, void 0 !== a && (a.vec3 = d);
                var e = {};
                if (!c) var c = 1e-6;
                e.create = function() {
                    return new Float32Array(4);
                }, e.clone = function(a) {
                    var b = new Float32Array(4);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
                }, e.fromValues = function(a, b, c, d) {
                    var e = new Float32Array(4);
                    return e[0] = a, e[1] = b, e[2] = c, e[3] = d, e;
                }, e.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
                }, e.set = function(a, b, c, d, e) {
                    return a[0] = b, a[1] = c, a[2] = d, a[3] = e, a;
                }, e.add = function(a, b, c) {
                    return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a[3] = b[3] + c[3], 
                    a;
                }, e.sub = e.subtract = function(a, b, c) {
                    return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a[3] = b[3] - c[3], 
                    a;
                }, e.mul = e.multiply = function(a, b, c) {
                    return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a[3] = b[3] * c[3], 
                    a;
                }, e.div = e.divide = function(a, b, c) {
                    return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a[3] = b[3] / c[3], 
                    a;
                }, e.min = function(a, b, c) {
                    return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), 
                    a[3] = Math.min(b[3], c[3]), a;
                }, e.max = function(a, b, c) {
                    return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), 
                    a[3] = Math.max(b[3], c[3]), a;
                }, e.scale = function(a, b, c) {
                    return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c, a;
                }, e.dist = e.distance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2], f = b[3] - a[3];
                    return Math.sqrt(c * c + d * d + e * e + f * f);
                }, e.sqrDist = e.squaredDistance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2], f = b[3] - a[3];
                    return c * c + d * d + e * e + f * f;
                }, e.len = e.length = function(a) {
                    var b = a[0], c = a[1], d = a[2], e = a[3];
                    return Math.sqrt(b * b + c * c + d * d + e * e);
                }, e.sqrLen = e.squaredLength = function(a) {
                    var b = a[0], c = a[1], d = a[2], e = a[3];
                    return b * b + c * c + d * d + e * e;
                }, e.negate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = -b[3], a;
                }, e.normalize = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = c * c + d * d + e * e + f * f;
                    return g > 0 && (g = 1 / Math.sqrt(g), a[0] = b[0] * g, a[1] = b[1] * g, a[2] = b[2] * g, 
                    a[3] = b[3] * g), a;
                }, e.dot = function(a, b) {
                    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
                }, e.lerp = function(a, b, c, d) {
                    var e = b[0], f = b[1], g = b[2], h = b[3];
                    return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a[2] = g + d * (c[2] - g), 
                    a[3] = h + d * (c[3] - h), a;
                }, e.transformMat4 = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3];
                    return a[0] = c[0] * d + c[4] * e + c[8] * f + c[12] * g, a[1] = c[1] * d + c[5] * e + c[9] * f + c[13] * g, 
                    a[2] = c[2] * d + c[6] * e + c[10] * f + c[14] * g, a[3] = c[3] * d + c[7] * e + c[11] * f + c[15] * g, 
                    a;
                }, e.transformQuat = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = c[0], h = c[1], i = c[2], j = c[3], k = j * d + h * f - i * e, l = j * e + i * d - g * f, m = j * f + g * e - h * d, n = -g * d - h * e - i * f;
                    return a[0] = k * j + n * -g + l * -i - m * -h, a[1] = l * j + n * -h + m * -g - k * -i, 
                    a[2] = m * j + n * -i + k * -h - l * -g, a;
                }, e.forEach = function() {
                    var a = new Float32Array(4);
                    return function(b, c, d, e, f, g) {
                        var h, i;
                        for (c || (c = 4), d || (d = 0), i = e ? Math.min(e * c + d, b.length) : b.length, 
                        h = d; h < i; h += c) a[0] = b[h], a[1] = b[h + 1], a[2] = b[h + 2], a[3] = b[h + 3], 
                        f(a, a, g), b[h] = a[0], b[h + 1] = a[1], b[h + 2] = a[2], b[h + 3] = a[3];
                        return b;
                    };
                }(), e.str = function(a) {
                    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
                }, void 0 !== a && (a.vec4 = e);
                var f = {}, g = new Float32Array([ 1, 0, 0, 1 ]);
                if (!c) var c = 1e-6;
                f.create = function() {
                    return new Float32Array(g);
                }, f.clone = function(a) {
                    var b = new Float32Array(4);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
                }, f.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
                }, f.identity = function(a) {
                    return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
                }, f.transpose = function(a, b) {
                    if (a === b) {
                        var c = b[1];
                        a[1] = b[2], a[2] = c;
                    } else a[0] = b[0], a[1] = b[2], a[2] = b[1], a[3] = b[3];
                    return a;
                }, f.invert = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = c * f - e * d;
                    return g ? (g = 1 / g, a[0] = f * g, a[1] = -d * g, a[2] = -e * g, a[3] = c * g, 
                    a) : null;
                }, f.adjoint = function(a, b) {
                    var c = b[0];
                    return a[0] = b[3], a[1] = -b[1], a[2] = -b[2], a[3] = c, a;
                }, f.determinant = function(a) {
                    return a[0] * a[3] - a[2] * a[1];
                }, f.mul = f.multiply = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3];
                    return a[0] = d * h + e * j, a[1] = d * i + e * k, a[2] = f * h + g * j, a[3] = f * i + g * k, 
                    a;
                }, f.rotate = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = Math.sin(c), i = Math.cos(c);
                    return a[0] = d * i + e * h, a[1] = d * -h + e * i, a[2] = f * i + g * h, a[3] = f * -h + g * i, 
                    a;
                }, f.scale = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1];
                    return a[0] = d * h, a[1] = e * i, a[2] = f * h, a[3] = g * i, a;
                }, f.str = function(a) {
                    return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
                }, void 0 !== a && (a.mat2 = f);
                var h = {}, i = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]);
                if (!c) var c = 1e-6;
                h.create = function() {
                    return new Float32Array(i);
                }, h.clone = function(a) {
                    var b = new Float32Array(9);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], 
                    b[6] = a[6], b[7] = a[7], b[8] = a[8], b;
                }, h.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], 
                    a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
                }, h.identity = function(a) {
                    return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, 
                    a[8] = 1, a;
                }, h.transpose = function(a, b) {
                    if (a === b) {
                        var c = b[1], d = b[2], e = b[5];
                        a[1] = b[3], a[2] = b[6], a[3] = c, a[5] = b[7], a[6] = d, a[7] = e;
                    } else a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], 
                    a[6] = b[2], a[7] = b[5], a[8] = b[8];
                    return a;
                }, h.invert = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8], l = k * g - h * j, m = -k * f + h * i, n = j * f - g * i, o = c * l + d * m + e * n;
                    return o ? (o = 1 / o, a[0] = l * o, a[1] = (-k * d + e * j) * o, a[2] = (h * d - e * g) * o, 
                    a[3] = m * o, a[4] = (k * c - e * i) * o, a[5] = (-h * c + e * f) * o, a[6] = n * o, 
                    a[7] = (-j * c + d * i) * o, a[8] = (g * c - d * f) * o, a) : null;
                }, h.adjoint = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8];
                    return a[0] = g * k - h * j, a[1] = e * j - d * k, a[2] = d * h - e * g, a[3] = h * i - f * k, 
                    a[4] = c * k - e * i, a[5] = e * f - c * h, a[6] = f * j - g * i, a[7] = d * i - c * j, 
                    a[8] = c * g - d * f, a;
                }, h.determinant = function(a) {
                    var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], j = a[8];
                    return b * (j * f - g * i) + c * (-j * e + g * h) + d * (i * e - f * h);
                }, h.mul = h.multiply = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = b[4], i = b[5], j = b[6], k = b[7], l = b[8], m = c[0], n = c[1], o = c[2], p = c[3], q = c[4], r = c[5], s = c[6], t = c[7], u = c[8];
                    return a[0] = m * d + n * g + o * j, a[1] = m * e + n * h + o * k, a[2] = m * f + n * i + o * l, 
                    a[3] = p * d + q * g + r * j, a[4] = p * e + q * h + r * k, a[5] = p * f + q * i + r * l, 
                    a[6] = s * d + t * g + u * j, a[7] = s * e + t * h + u * k, a[8] = s * f + t * i + u * l, 
                    a;
                }, h.str = function(a) {
                    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
                }, void 0 !== a && (a.mat3 = h);
                var j = {}, k = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);
                if (!c) var c = 1e-6;
                j.create = function() {
                    return new Float32Array(k);
                }, j.clone = function(a) {
                    var b = new Float32Array(16);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], 
                    b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], 
                    b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], b;
                }, j.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], 
                    a[6] = b[6], a[7] = b[7], a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], 
                    a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
                }, j.identity = function(a) {
                    return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, 
                    a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, 
                    a;
                }, j.transpose = function(a, b) {
                    if (a === b) {
                        var c = b[1], d = b[2], e = b[3], f = b[6], g = b[7], h = b[11];
                        a[1] = b[4], a[2] = b[8], a[3] = b[12], a[4] = c, a[6] = b[9], a[7] = b[13], a[8] = d, 
                        a[9] = f, a[11] = b[14], a[12] = e, a[13] = g, a[14] = h;
                    } else a[0] = b[0], a[1] = b[4], a[2] = b[8], a[3] = b[12], a[4] = b[1], a[5] = b[5], 
                    a[6] = b[9], a[7] = b[13], a[8] = b[2], a[9] = b[6], a[10] = b[10], a[11] = b[14], 
                    a[12] = b[3], a[13] = b[7], a[14] = b[11], a[15] = b[15];
                    return a;
                }, j.invert = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8], l = b[9], m = b[10], n = b[11], o = b[12], p = b[13], q = b[14], r = b[15], s = c * h - d * g, t = c * i - e * g, u = c * j - f * g, v = d * i - e * h, w = d * j - f * h, x = e * j - f * i, y = k * p - l * o, z = k * q - m * o, A = k * r - n * o, B = l * q - m * p, C = l * r - n * p, D = m * r - n * q, E = s * D - t * C + u * B + v * A - w * z + x * y;
                    return E ? (E = 1 / E, a[0] = (h * D - i * C + j * B) * E, a[1] = (e * C - d * D - f * B) * E, 
                    a[2] = (p * x - q * w + r * v) * E, a[3] = (m * w - l * x - n * v) * E, a[4] = (i * A - g * D - j * z) * E, 
                    a[5] = (c * D - e * A + f * z) * E, a[6] = (q * u - o * x - r * t) * E, a[7] = (k * x - m * u + n * t) * E, 
                    a[8] = (g * C - h * A + j * y) * E, a[9] = (d * A - c * C - f * y) * E, a[10] = (o * w - p * u + r * s) * E, 
                    a[11] = (l * u - k * w - n * s) * E, a[12] = (h * z - g * B - i * y) * E, a[13] = (c * B - d * z + e * y) * E, 
                    a[14] = (p * t - o * v - q * s) * E, a[15] = (k * v - l * t + m * s) * E, a) : null;
                }, j.adjoint = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8], l = b[9], m = b[10], n = b[11], o = b[12], p = b[13], q = b[14], r = b[15];
                    return a[0] = h * (m * r - n * q) - l * (i * r - j * q) + p * (i * n - j * m), a[1] = -(d * (m * r - n * q) - l * (e * r - f * q) + p * (e * n - f * m)), 
                    a[2] = d * (i * r - j * q) - h * (e * r - f * q) + p * (e * j - f * i), a[3] = -(d * (i * n - j * m) - h * (e * n - f * m) + l * (e * j - f * i)), 
                    a[4] = -(g * (m * r - n * q) - k * (i * r - j * q) + o * (i * n - j * m)), a[5] = c * (m * r - n * q) - k * (e * r - f * q) + o * (e * n - f * m), 
                    a[6] = -(c * (i * r - j * q) - g * (e * r - f * q) + o * (e * j - f * i)), a[7] = c * (i * n - j * m) - g * (e * n - f * m) + k * (e * j - f * i), 
                    a[8] = g * (l * r - n * p) - k * (h * r - j * p) + o * (h * n - j * l), a[9] = -(c * (l * r - n * p) - k * (d * r - f * p) + o * (d * n - f * l)), 
                    a[10] = c * (h * r - j * p) - g * (d * r - f * p) + o * (d * j - f * h), a[11] = -(c * (h * n - j * l) - g * (d * n - f * l) + k * (d * j - f * h)), 
                    a[12] = -(g * (l * q - m * p) - k * (h * q - i * p) + o * (h * m - i * l)), a[13] = c * (l * q - m * p) - k * (d * q - e * p) + o * (d * m - e * l), 
                    a[14] = -(c * (h * q - i * p) - g * (d * q - e * p) + o * (d * i - e * h)), a[15] = c * (h * m - i * l) - g * (d * m - e * l) + k * (d * i - e * h), 
                    a;
                }, j.determinant = function(a) {
                    var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], j = a[8], k = a[9], l = a[10], m = a[11], n = a[12], o = a[13], p = a[14], q = a[15];
                    return (b * g - c * f) * (l * q - m * p) - (b * h - d * f) * (k * q - m * o) + (b * i - e * f) * (k * p - l * o) + (c * h - d * g) * (j * q - m * n) - (c * i - e * g) * (j * p - l * n) + (d * i - e * h) * (j * o - k * n);
                }, j.mul = j.multiply = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = b[4], i = b[5], j = b[6], k = b[7], l = b[8], m = b[9], n = b[10], o = b[11], p = b[12], q = b[13], r = b[14], s = b[15], t = c[0], u = c[1], v = c[2], w = c[3];
                    return a[0] = t * d + u * h + v * l + w * p, a[1] = t * e + u * i + v * m + w * q, 
                    a[2] = t * f + u * j + v * n + w * r, a[3] = t * g + u * k + v * o + w * s, t = c[4], 
                    u = c[5], v = c[6], w = c[7], a[4] = t * d + u * h + v * l + w * p, a[5] = t * e + u * i + v * m + w * q, 
                    a[6] = t * f + u * j + v * n + w * r, a[7] = t * g + u * k + v * o + w * s, t = c[8], 
                    u = c[9], v = c[10], w = c[11], a[8] = t * d + u * h + v * l + w * p, a[9] = t * e + u * i + v * m + w * q, 
                    a[10] = t * f + u * j + v * n + w * r, a[11] = t * g + u * k + v * o + w * s, t = c[12], 
                    u = c[13], v = c[14], w = c[15], a[12] = t * d + u * h + v * l + w * p, a[13] = t * e + u * i + v * m + w * q, 
                    a[14] = t * f + u * j + v * n + w * r, a[15] = t * g + u * k + v * o + w * s, a;
                }, j.translate = function(a, b, c) {
                    var d, e, f, g, h, i, j, k, l, m, n, o, p = c[0], q = c[1], r = c[2];
                    return b === a ? (a[12] = b[0] * p + b[4] * q + b[8] * r + b[12], a[13] = b[1] * p + b[5] * q + b[9] * r + b[13], 
                    a[14] = b[2] * p + b[6] * q + b[10] * r + b[14], a[15] = b[3] * p + b[7] * q + b[11] * r + b[15]) : (d = b[0], 
                    e = b[1], f = b[2], g = b[3], h = b[4], i = b[5], j = b[6], k = b[7], l = b[8], 
                    m = b[9], n = b[10], o = b[11], a[0] = d, a[1] = e, a[2] = f, a[3] = g, a[4] = h, 
                    a[5] = i, a[6] = j, a[7] = k, a[8] = l, a[9] = m, a[10] = n, a[11] = o, a[12] = d * p + h * q + l * r + b[12], 
                    a[13] = e * p + i * q + m * r + b[13], a[14] = f * p + j * q + n * r + b[14], a[15] = g * p + k * q + o * r + b[15]), 
                    a;
                }, j.scale = function(a, b, c) {
                    var d = c[0], e = c[1], f = c[2];
                    return a[0] = b[0] * d, a[1] = b[1] * d, a[2] = b[2] * d, a[3] = b[3] * d, a[4] = b[4] * e, 
                    a[5] = b[5] * e, a[6] = b[6] * e, a[7] = b[7] * e, a[8] = b[8] * f, a[9] = b[9] * f, 
                    a[10] = b[10] * f, a[11] = b[11] * f, a[12] = b[12], a[13] = b[13], a[14] = b[14], 
                    a[15] = b[15], a;
                }, j.rotate = function(a, b, d, e) {
                    var f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D = e[0], E = e[1], F = e[2], G = Math.sqrt(D * D + E * E + F * F);
                    return Math.abs(G) < c ? null : (G = 1 / G, D *= G, E *= G, F *= G, f = Math.sin(d), 
                    g = Math.cos(d), h = 1 - g, i = b[0], j = b[1], k = b[2], l = b[3], m = b[4], n = b[5], 
                    o = b[6], p = b[7], q = b[8], r = b[9], s = b[10], t = b[11], u = D * D * h + g, 
                    v = E * D * h + F * f, w = F * D * h - E * f, x = D * E * h - F * f, y = E * E * h + g, 
                    z = F * E * h + D * f, A = D * F * h + E * f, B = E * F * h - D * f, C = F * F * h + g, 
                    a[0] = i * u + m * v + q * w, a[1] = j * u + n * v + r * w, a[2] = k * u + o * v + s * w, 
                    a[3] = l * u + p * v + t * w, a[4] = i * x + m * y + q * z, a[5] = j * x + n * y + r * z, 
                    a[6] = k * x + o * y + s * z, a[7] = l * x + p * y + t * z, a[8] = i * A + m * B + q * C, 
                    a[9] = j * A + n * B + r * C, a[10] = k * A + o * B + s * C, a[11] = l * A + p * B + t * C, 
                    b !== a && (a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a);
                }, j.rotateX = function(a, b, c) {
                    var d = Math.sin(c), e = Math.cos(c), f = b[4], g = b[5], h = b[6], i = b[7], j = b[8], k = b[9], l = b[10], m = b[11];
                    return b !== a && (a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[12] = b[12], 
                    a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[4] = f * e + j * d, a[5] = g * e + k * d, 
                    a[6] = h * e + l * d, a[7] = i * e + m * d, a[8] = j * e - f * d, a[9] = k * e - g * d, 
                    a[10] = l * e - h * d, a[11] = m * e - i * d, a;
                }, j.rotateY = function(a, b, c) {
                    var d = Math.sin(c), e = Math.cos(c), f = b[0], g = b[1], h = b[2], i = b[3], j = b[8], k = b[9], l = b[10], m = b[11];
                    return b !== a && (a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[12] = b[12], 
                    a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = f * e - j * d, a[1] = g * e - k * d, 
                    a[2] = h * e - l * d, a[3] = i * e - m * d, a[8] = f * d + j * e, a[9] = g * d + k * e, 
                    a[10] = h * d + l * e, a[11] = i * d + m * e, a;
                }, j.rotateZ = function(a, b, c) {
                    var d = Math.sin(c), e = Math.cos(c), f = b[0], g = b[1], h = b[2], i = b[3], j = b[4], k = b[5], l = b[6], m = b[7];
                    return b !== a && (a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], 
                    a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = f * e + j * d, a[1] = g * e + k * d, 
                    a[2] = h * e + l * d, a[3] = i * e + m * d, a[4] = j * e - f * d, a[5] = k * e - g * d, 
                    a[6] = l * e - h * d, a[7] = m * e - i * d, a;
                }, j.fromRotationTranslation = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = d + d, i = e + e, j = f + f, k = d * h, l = d * i, m = d * j, n = e * i, o = e * j, p = f * j, q = g * h, r = g * i, s = g * j;
                    return a[0] = 1 - (n + p), a[1] = l + s, a[2] = m - r, a[3] = 0, a[4] = l - s, a[5] = 1 - (k + p), 
                    a[6] = o + q, a[7] = 0, a[8] = m + r, a[9] = o - q, a[10] = 1 - (k + n), a[11] = 0, 
                    a[12] = c[0], a[13] = c[1], a[14] = c[2], a[15] = 1, a;
                }, j.frustum = function(a, b, c, d, e, f, g) {
                    var h = 1 / (c - b), i = 1 / (e - d), j = 1 / (f - g);
                    return a[0] = 2 * f * h, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * f * i, 
                    a[6] = 0, a[7] = 0, a[8] = (c + b) * h, a[9] = (e + d) * i, a[10] = (g + f) * j, 
                    a[11] = -1, a[12] = 0, a[13] = 0, a[14] = g * f * 2 * j, a[15] = 0, a;
                }, j.perspective = function(a, b, c, d, e) {
                    var f = 1 / Math.tan(b / 2), g = 1 / (d - e);
                    return a[0] = f / c, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = f, a[6] = 0, 
                    a[7] = 0, a[8] = 0, a[9] = 0, a[10] = (e + d) * g, a[11] = -1, a[12] = 0, a[13] = 0, 
                    a[14] = 2 * e * d * g, a[15] = 0, a;
                }, j.ortho = function(a, b, c, d, e, f, g) {
                    var h = 1 / (b - c), i = 1 / (d - e), j = 1 / (f - g);
                    return a[0] = -2 * h, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * i, a[6] = 0, 
                    a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * j, a[11] = 0, a[12] = (b + c) * h, a[13] = (e + d) * i, 
                    a[14] = (g + f) * j, a[15] = 1, a;
                }, j.lookAt = function(a, b, d, e) {
                    var f, g, h, i, k, l, m, n, o, p, q = b[0], r = b[1], s = b[2], t = e[0], u = e[1], v = e[2], w = d[0], x = d[1], y = d[2];
                    return Math.abs(q - w) < c && Math.abs(r - x) < c && Math.abs(s - y) < c ? j.identity(a) : (m = q - w, 
                    n = r - x, o = s - y, p = 1 / Math.sqrt(m * m + n * n + o * o), m *= p, n *= p, 
                    o *= p, f = u * o - v * n, g = v * m - t * o, h = t * n - u * m, p = Math.sqrt(f * f + g * g + h * h), 
                    p ? (p = 1 / p, f *= p, g *= p, h *= p) : (f = 0, g = 0, h = 0), i = n * h - o * g, 
                    k = o * f - m * h, l = m * g - n * f, p = Math.sqrt(i * i + k * k + l * l), p ? (p = 1 / p, 
                    i *= p, k *= p, l *= p) : (i = 0, k = 0, l = 0), a[0] = f, a[1] = i, a[2] = m, a[3] = 0, 
                    a[4] = g, a[5] = k, a[6] = n, a[7] = 0, a[8] = h, a[9] = l, a[10] = o, a[11] = 0, 
                    a[12] = -(f * q + g * r + h * s), a[13] = -(i * q + k * r + l * s), a[14] = -(m * q + n * r + o * s), 
                    a[15] = 1, a);
                }, j.str = function(a) {
                    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
                }, void 0 !== a && (a.mat4 = j);
                var l = {}, m = new Float32Array([ 0, 0, 0, 1 ]);
                if (!c) var c = 1e-6;
                l.create = function() {
                    return new Float32Array(m);
                }, l.clone = e.clone, l.fromValues = e.fromValues, l.copy = e.copy, l.set = e.set, 
                l.identity = function(a) {
                    return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
                }, l.setAxisAngle = function(a, b, c) {
                    c *= .5;
                    var d = Math.sin(c);
                    return a[0] = d * b[0], a[1] = d * b[1], a[2] = d * b[2], a[3] = Math.cos(c), a;
                }, l.add = e.add, l.mul = l.multiply = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3];
                    return a[0] = d * k + g * h + e * j - f * i, a[1] = e * k + g * i + f * h - d * j, 
                    a[2] = f * k + g * j + d * i - e * h, a[3] = g * k - d * h - e * i - f * j, a;
                }, l.scale = e.scale, l.rotateX = function(a, b, c) {
                    c *= .5;
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = Math.sin(c), i = Math.cos(c);
                    return a[0] = d * i + g * h, a[1] = e * i + f * h, a[2] = f * i - e * h, a[3] = g * i - d * h, 
                    a;
                }, l.rotateY = function(a, b, c) {
                    c *= .5;
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = Math.sin(c), i = Math.cos(c);
                    return a[0] = d * i - f * h, a[1] = e * i + g * h, a[2] = f * i + d * h, a[3] = g * i - e * h, 
                    a;
                }, l.rotateZ = function(a, b, c) {
                    c *= .5;
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = Math.sin(c), i = Math.cos(c);
                    return a[0] = d * i + e * h, a[1] = e * i - d * h, a[2] = f * i + g * h, a[3] = g * i - f * h, 
                    a;
                }, l.calculateW = function(a, b) {
                    var c = b[0], d = b[1], e = b[2];
                    return a[0] = c, a[1] = d, a[2] = e, a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e)), 
                    a;
                }, l.dot = e.dot, l.lerp = e.lerp, l.slerp = function(a, b, c, d) {
                    var e, f, g, h, i = b[0], j = b[1], k = b[2], l = b[3], m = c[0], n = c[1], o = c[2], p = b[3], q = i * m + j * n + k * o + l * p;
                    return Math.abs(q) >= 1 ? (a !== b && (a[0] = i, a[1] = j, a[2] = k, a[3] = l), 
                    a) : (e = Math.acos(q), f = Math.sqrt(1 - q * q), Math.abs(f) < .001 ? (a[0] = .5 * i + .5 * m, 
                    a[1] = .5 * j + .5 * n, a[2] = .5 * k + .5 * o, a[3] = .5 * l + .5 * p, a) : (g = Math.sin((1 - d) * e) / f, 
                    h = Math.sin(d * e) / f, a[0] = i * g + m * h, a[1] = j * g + n * h, a[2] = k * g + o * h, 
                    a[3] = l * g + p * h, a));
                }, l.invert = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = c * c + d * d + e * e + f * f, h = g ? 1 / g : 0;
                    return a[0] = -c * h, a[1] = -d * h, a[2] = -e * h, a[3] = f * h, a;
                }, l.conjugate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = b[3], a;
                }, l.len = l.length = e.length, l.sqrLen = l.squaredLength = e.squaredLength, l.normalize = e.normalize, 
                l.str = function(a) {
                    return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
                }, void 0 !== a && (a.quat = l);
            }(a.exports);
        }();
    }, {} ],
    22: [ function(a, b, c) {
        (function() {
            var a = this, d = a._, e = {}, f = Array.prototype, g = Object.prototype, h = Function.prototype, i = f.push, j = f.slice, k = f.concat, l = g.toString, m = g.hasOwnProperty, n = f.forEach, o = f.map, p = f.reduce, q = f.reduceRight, r = f.filter, s = f.every, t = f.some, u = f.indexOf, v = f.lastIndexOf, w = Array.isArray, x = Object.keys, y = h.bind, z = function(a) {
                return a instanceof z ? a : this instanceof z ? void (this._wrapped = a) : new z(a);
            };
            void 0 !== c ? (void 0 !== b && b.exports && (c = b.exports = z), c._ = z) : a._ = z, 
            z.VERSION = "1.4.4";
            var A = z.each = z.forEach = function(a, b, c) {
                if (null != a) if (n && a.forEach === n) a.forEach(b, c); else if (a.length === +a.length) {
                    for (var d = 0, f = a.length; d < f; d++) if (b.call(c, a[d], d, a) === e) return;
                } else for (var g in a) if (z.has(a, g) && b.call(c, a[g], g, a) === e) return;
            };
            z.map = z.collect = function(a, b, c) {
                var d = [];
                return null == a ? d : o && a.map === o ? a.map(b, c) : (A(a, function(a, e, f) {
                    d[d.length] = b.call(c, a, e, f);
                }), d);
            };
            var B = "Reduce of empty array with no initial value";
            z.reduce = z.foldl = z.inject = function(a, b, c, d) {
                var e = arguments.length > 2;
                if (null == a && (a = []), p && a.reduce === p) return d && (b = z.bind(b, d)), 
                e ? a.reduce(b, c) : a.reduce(b);
                if (A(a, function(a, f, g) {
                    e ? c = b.call(d, c, a, f, g) : (c = a, e = !0);
                }), !e) throw new TypeError(B);
                return c;
            }, z.reduceRight = z.foldr = function(a, b, c, d) {
                var e = arguments.length > 2;
                if (null == a && (a = []), q && a.reduceRight === q) return d && (b = z.bind(b, d)), 
                e ? a.reduceRight(b, c) : a.reduceRight(b);
                var f = a.length;
                if (f !== +f) {
                    var g = z.keys(a);
                    f = g.length;
                }
                if (A(a, function(h, i, j) {
                    i = g ? g[--f] : --f, e ? c = b.call(d, c, a[i], i, j) : (c = a[i], e = !0);
                }), !e) throw new TypeError(B);
                return c;
            }, z.find = z.detect = function(a, b, c) {
                var d;
                return C(a, function(a, e, f) {
                    if (b.call(c, a, e, f)) return d = a, !0;
                }), d;
            }, z.filter = z.select = function(a, b, c) {
                var d = [];
                return null == a ? d : r && a.filter === r ? a.filter(b, c) : (A(a, function(a, e, f) {
                    b.call(c, a, e, f) && (d[d.length] = a);
                }), d);
            }, z.reject = function(a, b, c) {
                return z.filter(a, function(a, d, e) {
                    return !b.call(c, a, d, e);
                }, c);
            }, z.every = z.all = function(a, b, c) {
                b || (b = z.identity);
                var d = !0;
                return null == a ? d : s && a.every === s ? a.every(b, c) : (A(a, function(a, f, g) {
                    if (!(d = d && b.call(c, a, f, g))) return e;
                }), !!d);
            };
            var C = z.some = z.any = function(a, b, c) {
                b || (b = z.identity);
                var d = !1;
                return null == a ? d : t && a.some === t ? a.some(b, c) : (A(a, function(a, f, g) {
                    if (d || (d = b.call(c, a, f, g))) return e;
                }), !!d);
            };
            z.contains = z.include = function(a, b) {
                return null != a && (u && a.indexOf === u ? -1 != a.indexOf(b) : C(a, function(a) {
                    return a === b;
                }));
            }, z.invoke = function(a, b) {
                var c = j.call(arguments, 2), d = z.isFunction(b);
                return z.map(a, function(a) {
                    return (d ? b : a[b]).apply(a, c);
                });
            }, z.pluck = function(a, b) {
                return z.map(a, function(a) {
                    return a[b];
                });
            }, z.where = function(a, b, c) {
                return z.isEmpty(b) ? c ? null : [] : z[c ? "find" : "filter"](a, function(a) {
                    for (var c in b) if (b[c] !== a[c]) return !1;
                    return !0;
                });
            }, z.findWhere = function(a, b) {
                return z.where(a, b, !0);
            }, z.max = function(a, b, c) {
                if (!b && z.isArray(a) && a[0] === +a[0] && a.length < 65535) return Math.max.apply(Math, a);
                if (!b && z.isEmpty(a)) return -1 / 0;
                var d = {
                    computed: -1 / 0,
                    value: -1 / 0
                };
                return A(a, function(a, e, f) {
                    var g = b ? b.call(c, a, e, f) : a;
                    g >= d.computed && (d = {
                        value: a,
                        computed: g
                    });
                }), d.value;
            }, z.min = function(a, b, c) {
                if (!b && z.isArray(a) && a[0] === +a[0] && a.length < 65535) return Math.min.apply(Math, a);
                if (!b && z.isEmpty(a)) return 1 / 0;
                var d = {
                    computed: 1 / 0,
                    value: 1 / 0
                };
                return A(a, function(a, e, f) {
                    var g = b ? b.call(c, a, e, f) : a;
                    g < d.computed && (d = {
                        value: a,
                        computed: g
                    });
                }), d.value;
            }, z.shuffle = function(a) {
                var b, c = 0, d = [];
                return A(a, function(a) {
                    b = z.random(c++), d[c - 1] = d[b], d[b] = a;
                }), d;
            };
            var D = function(a) {
                return z.isFunction(a) ? a : function(b) {
                    return b[a];
                };
            };
            z.sortBy = function(a, b, c) {
                var d = D(b);
                return z.pluck(z.map(a, function(a, b, e) {
                    return {
                        value: a,
                        index: b,
                        criteria: d.call(c, a, b, e)
                    };
                }).sort(function(a, b) {
                    var c = a.criteria, d = b.criteria;
                    if (c !== d) {
                        if (c > d || void 0 === c) return 1;
                        if (c < d || void 0 === d) return -1;
                    }
                    return a.index < b.index ? -1 : 1;
                }), "value");
            };
            var E = function(a, b, c, d) {
                var e = {}, f = D(b || z.identity);
                return A(a, function(b, g) {
                    var h = f.call(c, b, g, a);
                    d(e, h, b);
                }), e;
            };
            z.groupBy = function(a, b, c) {
                return E(a, b, c, function(a, b, c) {
                    (z.has(a, b) ? a[b] : a[b] = []).push(c);
                });
            }, z.countBy = function(a, b, c) {
                return E(a, b, c, function(a, b) {
                    z.has(a, b) || (a[b] = 0), a[b]++;
                });
            }, z.sortedIndex = function(a, b, c, d) {
                c = null == c ? z.identity : D(c);
                for (var e = c.call(d, b), f = 0, g = a.length; f < g; ) {
                    var h = f + g >>> 1;
                    c.call(d, a[h]) < e ? f = h + 1 : g = h;
                }
                return f;
            }, z.toArray = function(a) {
                return a ? z.isArray(a) ? j.call(a) : a.length === +a.length ? z.map(a, z.identity) : z.values(a) : [];
            }, z.size = function(a) {
                return null == a ? 0 : a.length === +a.length ? a.length : z.keys(a).length;
            }, z.first = z.head = z.take = function(a, b, c) {
                if (null != a) return null == b || c ? a[0] : j.call(a, 0, b);
            }, z.initial = function(a, b, c) {
                return j.call(a, 0, a.length - (null == b || c ? 1 : b));
            }, z.last = function(a, b, c) {
                if (null != a) return null == b || c ? a[a.length - 1] : j.call(a, Math.max(a.length - b, 0));
            }, z.rest = z.tail = z.drop = function(a, b, c) {
                return j.call(a, null == b || c ? 1 : b);
            }, z.compact = function(a) {
                return z.filter(a, z.identity);
            };
            var F = function(a, b, c) {
                return A(a, function(a) {
                    z.isArray(a) ? b ? i.apply(c, a) : F(a, b, c) : c.push(a);
                }), c;
            };
            z.flatten = function(a, b) {
                return F(a, b, []);
            }, z.without = function(a) {
                return z.difference(a, j.call(arguments, 1));
            }, z.uniq = z.unique = function(a, b, c, d) {
                z.isFunction(b) && (d = c, c = b, b = !1);
                var e = c ? z.map(a, c, d) : a, f = [], g = [];
                return A(e, function(c, d) {
                    (b ? d && g[g.length - 1] === c : z.contains(g, c)) || (g.push(c), f.push(a[d]));
                }), f;
            }, z.union = function() {
                return z.uniq(k.apply(f, arguments));
            }, z.intersection = function(a) {
                var b = j.call(arguments, 1);
                return z.filter(z.uniq(a), function(a) {
                    return z.every(b, function(b) {
                        return z.indexOf(b, a) >= 0;
                    });
                });
            }, z.difference = function(a) {
                var b = k.apply(f, j.call(arguments, 1));
                return z.filter(a, function(a) {
                    return !z.contains(b, a);
                });
            }, z.zip = function() {
                for (var a = j.call(arguments), b = z.max(z.pluck(a, "length")), c = new Array(b), d = 0; d < b; d++) c[d] = z.pluck(a, "" + d);
                return c;
            }, z.object = function(a, b) {
                if (null == a) return {};
                for (var c = {}, d = 0, e = a.length; d < e; d++) b ? c[a[d]] = b[d] : c[a[d][0]] = a[d][1];
                return c;
            }, z.indexOf = function(a, b, c) {
                if (null == a) return -1;
                var d = 0, e = a.length;
                if (c) {
                    if ("number" != typeof c) return d = z.sortedIndex(a, b), a[d] === b ? d : -1;
                    d = c < 0 ? Math.max(0, e + c) : c;
                }
                if (u && a.indexOf === u) return a.indexOf(b, c);
                for (;d < e; d++) if (a[d] === b) return d;
                return -1;
            }, z.lastIndexOf = function(a, b, c) {
                if (null == a) return -1;
                var d = null != c;
                if (v && a.lastIndexOf === v) return d ? a.lastIndexOf(b, c) : a.lastIndexOf(b);
                for (var e = d ? c : a.length; e--; ) if (a[e] === b) return e;
                return -1;
            }, z.range = function(a, b, c) {
                arguments.length <= 1 && (b = a || 0, a = 0), c = arguments[2] || 1;
                for (var d = Math.max(Math.ceil((b - a) / c), 0), e = 0, f = new Array(d); e < d; ) f[e++] = a, 
                a += c;
                return f;
            }, z.bind = function(a, b) {
                if (a.bind === y && y) return y.apply(a, j.call(arguments, 1));
                var c = j.call(arguments, 2);
                return function() {
                    return a.apply(b, c.concat(j.call(arguments)));
                };
            }, z.partial = function(a) {
                var b = j.call(arguments, 1);
                return function() {
                    return a.apply(this, b.concat(j.call(arguments)));
                };
            }, z.bindAll = function(a) {
                var b = j.call(arguments, 1);
                return 0 === b.length && (b = z.functions(a)), A(b, function(b) {
                    a[b] = z.bind(a[b], a);
                }), a;
            }, z.memoize = function(a, b) {
                var c = {};
                return b || (b = z.identity), function() {
                    var d = b.apply(this, arguments);
                    return z.has(c, d) ? c[d] : c[d] = a.apply(this, arguments);
                };
            }, z.delay = function(a, b) {
                var c = j.call(arguments, 2);
                return setTimeout(function() {
                    return a.apply(null, c);
                }, b);
            }, z.defer = function(a) {
                return z.delay.apply(z, [ a, 1 ].concat(j.call(arguments, 1)));
            }, z.throttle = function(a, b) {
                var c, d, e, f, g = 0, h = function() {
                    g = new Date(), e = null, f = a.apply(c, d);
                };
                return function() {
                    var i = new Date(), j = b - (i - g);
                    return c = this, d = arguments, j <= 0 ? (clearTimeout(e), e = null, g = i, f = a.apply(c, d)) : e || (e = setTimeout(h, j)), 
                    f;
                };
            }, z.debounce = function(a, b, c) {
                var d, e;
                return function() {
                    var f = this, g = arguments, h = function() {
                        d = null, c || (e = a.apply(f, g));
                    }, i = c && !d;
                    return clearTimeout(d), d = setTimeout(h, b), i && (e = a.apply(f, g)), e;
                };
            }, z.once = function(a) {
                var b, c = !1;
                return function() {
                    return c ? b : (c = !0, b = a.apply(this, arguments), a = null, b);
                };
            }, z.wrap = function(a, b) {
                return function() {
                    var c = [ a ];
                    return i.apply(c, arguments), b.apply(this, c);
                };
            }, z.compose = function() {
                var a = arguments;
                return function() {
                    for (var b = arguments, c = a.length - 1; c >= 0; c--) b = [ a[c].apply(this, b) ];
                    return b[0];
                };
            }, z.after = function(a, b) {
                return a <= 0 ? b() : function() {
                    if (--a < 1) return b.apply(this, arguments);
                };
            }, z.keys = x || function(a) {
                if (a !== Object(a)) throw new TypeError("Invalid object");
                var b = [];
                for (var c in a) z.has(a, c) && (b[b.length] = c);
                return b;
            }, z.values = function(a) {
                var b = [];
                for (var c in a) z.has(a, c) && b.push(a[c]);
                return b;
            }, z.pairs = function(a) {
                var b = [];
                for (var c in a) z.has(a, c) && b.push([ c, a[c] ]);
                return b;
            }, z.invert = function(a) {
                var b = {};
                for (var c in a) z.has(a, c) && (b[a[c]] = c);
                return b;
            }, z.functions = z.methods = function(a) {
                var b = [];
                for (var c in a) z.isFunction(a[c]) && b.push(c);
                return b.sort();
            }, z.extend = function(a) {
                return A(j.call(arguments, 1), function(b) {
                    if (b) for (var c in b) a[c] = b[c];
                }), a;
            }, z.pick = function(a) {
                var b = {}, c = k.apply(f, j.call(arguments, 1));
                return A(c, function(c) {
                    c in a && (b[c] = a[c]);
                }), b;
            }, z.omit = function(a) {
                var b = {}, c = k.apply(f, j.call(arguments, 1));
                for (var d in a) z.contains(c, d) || (b[d] = a[d]);
                return b;
            }, z.defaults = function(a) {
                return A(j.call(arguments, 1), function(b) {
                    if (b) for (var c in b) null == a[c] && (a[c] = b[c]);
                }), a;
            }, z.clone = function(a) {
                return z.isObject(a) ? z.isArray(a) ? a.slice() : z.extend({}, a) : a;
            }, z.tap = function(a, b) {
                return b(a), a;
            };
            var G = function(a, b, c, d) {
                if (a === b) return 0 !== a || 1 / a == 1 / b;
                if (null == a || null == b) return a === b;
                a instanceof z && (a = a._wrapped), b instanceof z && (b = b._wrapped);
                var e = l.call(a);
                if (e != l.call(b)) return !1;
                switch (e) {
                  case "[object String]":
                    return a == String(b);

                  case "[object Number]":
                    return a != +a ? b != +b : 0 == a ? 1 / a == 1 / b : a == +b;

                  case "[object Date]":
                  case "[object Boolean]":
                    return +a == +b;

                  case "[object RegExp]":
                    return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
                }
                if ("object" != typeof a || "object" != typeof b) return !1;
                for (var f = c.length; f--; ) if (c[f] == a) return d[f] == b;
                c.push(a), d.push(b);
                var g = 0, h = !0;
                if ("[object Array]" == e) {
                    if (g = a.length, h = g == b.length) for (;g-- && (h = G(a[g], b[g], c, d)); ) ;
                } else {
                    var i = a.constructor, j = b.constructor;
                    if (i !== j && !(z.isFunction(i) && i instanceof i && z.isFunction(j) && j instanceof j)) return !1;
                    for (var k in a) if (z.has(a, k) && (g++, !(h = z.has(b, k) && G(a[k], b[k], c, d)))) break;
                    if (h) {
                        for (k in b) if (z.has(b, k) && !g--) break;
                        h = !g;
                    }
                }
                return c.pop(), d.pop(), h;
            };
            z.isEqual = function(a, b) {
                return G(a, b, [], []);
            }, z.isEmpty = function(a) {
                if (null == a) return !0;
                if (z.isArray(a) || z.isString(a)) return 0 === a.length;
                for (var b in a) if (z.has(a, b)) return !1;
                return !0;
            }, z.isElement = function(a) {
                return !(!a || 1 !== a.nodeType);
            }, z.isArray = w || function(a) {
                return "[object Array]" == l.call(a);
            }, z.isObject = function(a) {
                return a === Object(a);
            }, A([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(a) {
                z["is" + a] = function(b) {
                    return l.call(b) == "[object " + a + "]";
                };
            }), z.isArguments(arguments) || (z.isArguments = function(a) {
                return !(!a || !z.has(a, "callee"));
            }), "function" != typeof /./ && (z.isFunction = function(a) {
                return "function" == typeof a;
            }), z.isFinite = function(a) {
                return isFinite(a) && !isNaN(parseFloat(a));
            }, z.isNaN = function(a) {
                return z.isNumber(a) && a != +a;
            }, z.isBoolean = function(a) {
                return !0 === a || !1 === a || "[object Boolean]" == l.call(a);
            }, z.isNull = function(a) {
                return null === a;
            }, z.isUndefined = function(a) {
                return void 0 === a;
            }, z.has = function(a, b) {
                return m.call(a, b);
            }, z.noConflict = function() {
                return a._ = d, this;
            }, z.identity = function(a) {
                return a;
            }, z.times = function(a, b, c) {
                for (var d = Array(a), e = 0; e < a; e++) d[e] = b.call(c, e);
                return d;
            }, z.random = function(a, b) {
                return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
            };
            var H = {
                escape: {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#x27;",
                    "/": "&#x2F;"
                }
            };
            H.unescape = z.invert(H.escape);
            var I = {
                escape: new RegExp("[" + z.keys(H.escape).join("") + "]", "g"),
                unescape: new RegExp("(" + z.keys(H.unescape).join("|") + ")", "g")
            };
            z.each([ "escape", "unescape" ], function(a) {
                z[a] = function(b) {
                    return null == b ? "" : ("" + b).replace(I[a], function(b) {
                        return H[a][b];
                    });
                };
            }), z.result = function(a, b) {
                if (null == a) return null;
                var c = a[b];
                return z.isFunction(c) ? c.call(a) : c;
            }, z.mixin = function(a) {
                A(z.functions(a), function(b) {
                    var c = z[b] = a[b];
                    z.prototype[b] = function() {
                        var a = [ this._wrapped ];
                        return i.apply(a, arguments), N.call(this, c.apply(z, a));
                    };
                });
            };
            var J = 0;
            z.uniqueId = function(a) {
                var b = ++J + "";
                return a ? a + b : b;
            }, z.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };
            var K = /(.)^/, L = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                "\t": "t",
                "\u2028": "u2028",
                "\u2029": "u2029"
            }, M = /\\|'|\r|\n|\t|\u2028|\u2029/g;
            z.template = function(a, b, c) {
                var d;
                c = z.defaults({}, c, z.templateSettings);
                var e = new RegExp([ (c.escape || K).source, (c.interpolate || K).source, (c.evaluate || K).source ].join("|") + "|$", "g"), f = 0, g = "__p+='";
                a.replace(e, function(b, c, d, e, h) {
                    return g += a.slice(f, h).replace(M, function(a) {
                        return "\\" + L[a];
                    }), c && (g += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'"), d && (g += "'+\n((__t=(" + d + "))==null?'':__t)+\n'"), 
                    e && (g += "';\n" + e + "\n__p+='"), f = h + b.length, b;
                }), g += "';\n", c.variable || (g = "with(obj||{}){\n" + g + "}\n"), g = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + g + "return __p;\n";
                try {
                    d = new Function(c.variable || "obj", "_", g);
                } catch (a) {
                    throw a.source = g, a;
                }
                if (b) return d(b, z);
                var h = function(a) {
                    return d.call(this, a, z);
                };
                return h.source = "function(" + (c.variable || "obj") + "){\n" + g + "}", h;
            }, z.chain = function(a) {
                return z(a).chain();
            };
            var N = function(a) {
                return this._chain ? z(a).chain() : a;
            };
            z.mixin(z), A([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(a) {
                var b = f[a];
                z.prototype[a] = function() {
                    var c = this._wrapped;
                    return b.apply(c, arguments), "shift" != a && "splice" != a || 0 !== c.length || delete c[0], 
                    N.call(this, c);
                };
            }), A([ "concat", "join", "slice" ], function(a) {
                var b = f[a];
                z.prototype[a] = function() {
                    return N.call(this, b.apply(this._wrapped, arguments));
                };
            }), z.extend(z.prototype, {
                chain: function() {
                    return this._chain = !0, this;
                },
                value: function() {
                    return this._wrapped;
                }
            });
        }).call(this);
    }, {} ],
    23: [ function(a, b, c) {
        "undefined" != typeof window && "function" != typeof window.requestAnimationFrame && (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
            setTimeout(a, 1e3 / 60);
        }), Leap = a("../lib/index");
    }, {
        "../lib/index": 9
    } ]
}, {}, [ 23 ]), function() {
    var a;
    a = function() {
        var a;
        return a = [], a.remove = function() {
            for (var a, b, c = arguments, d = c.length; d && this.length; ) for (a = c[--d]; -1 !== (b = this.indexOf(a)); ) this.splice(b, 1);
            return this;
        }, this.on("deviceDisconnected", function() {
            var b, c, d, e;
            for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.emit("handLost", this.lastConnectionFrame.hand(b)));
            return e;
        }), {
            frame: function(b) {
                var c, d, e, f, g;
                d = b.hands.map(function(a) {
                    return a.id;
                });
                for (var h = 0, i = a.length; h < i; h++) c = a[h], -1 == d.indexOf(c) && (a.remove(c), 
                this.emit("handLost", this.frame(1).hand(c)), h--, i--);
                for (g = [], e = 0, f = d.length; e < f; e++) c = d[e], -1 === a.indexOf(c) ? (a.push(c), 
                g.push(this.emit("handFound", b.hand(c)))) : g.push(void 0);
                return g;
            }
        };
    }, "undefined" != typeof Leap && Leap.Controller ? Leap.Controller.plugin("handEntry", a) : module.exports.handEntry = a;
}.call(this), function() {
    var a;
    a = function() {
        var a;
        return a = {}, {
            hand: {
                data: function(b, c) {
                    var d, e, f;
                    if (a[e = this.id] || (a[e] = []), c) return a[this.id][b] = c;
                    if ("[object String]" === toString.call(b)) return a[this.id][b];
                    f = [];
                    for (d in b) c = b[d], void 0 === c ? f.push(delete a[this.id][d]) : f.push(a[this.id][d] = c);
                    return f;
                },
                hold: function(a) {
                    return a ? this.data({
                        holding: a
                    }) : this.hold(this.hovering());
                },
                holding: function() {
                    return this.data("holding");
                },
                release: function() {
                    var a;
                    return a = this.data("holding"), this.data({
                        holding: void 0
                    }), a;
                },
                hoverFn: function(a) {
                    return this.data({
                        getHover: a
                    });
                },
                hovering: function() {
                    var a;
                    if (a = this.data("getHover")) return this._hovering || (this._hovering = a.call(this));
                }
            }
        };
    }, "undefined" != typeof Leap && Leap.Controller ? Leap.Controller.plugin("handHold", a) : module.exports.handHold = a;
}.call(this), function() {
    var a;
    a = function(a) {
        var b, c, d, e;
        return null == a && (a = {}), a.positioning || (a.positioning = "absolute"), a.scale || (a.scale = 1), 
        a.scaleX || (a.scaleX = 1), a.scaleY || (a.scaleY = 1), a.scaleZ || (a.scaleZ = 1), 
        a.verticalOffset || (a.verticalOffset = 0), b = 6, c = -100, e = {
            absolute: function(d) {
                return [ window.innerWidth / 2 + d[0] * b * a.scale * a.scaleX, window.innerHeight + c + a.verticalOffset - d[1] * b * a.scale * a.scaleY, d[2] * b * a.scale * a.scaleZ ];
            }
        }, d = function(b, c) {
            var d;
            return null == c && (c = !1), d = "function" == typeof a.positioning ? a.positioning.call(this, b) : e[a.positioning].call(this, b), 
            c && (this.screenPositionVec3 = d), d;
        }, {
            hand: {
                screenPosition: function(a) {
                    return d.call(this, a || this.stabilizedPalmPosition, !a);
                }
            },
            pointable: {
                screenPosition: function(a) {
                    return d.call(this, a || this.stabilizedTipPosition, !a);
                }
            }
        };
    }, "undefined" != typeof Leap && Leap.Controller ? Leap.Controller.plugin("screenPosition", a) : module.exports.screenPosition = a;
}.call(this), function(a, b) {
    "object" == typeof exports && "undefined" != typeof module ? b(exports) : "function" == typeof define && define.amd ? define([ "exports" ], b) : b(a.THREE = {});
}(this, function(a) {
    function b() {}
    function c(a, b) {
        this.x = a || 0, this.y = b || 0;
    }
    function d() {
        this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    function e(a, b, c, d) {
        this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1;
    }
    function f(a, b, c) {
        this.x = a || 0, this.y = b || 0, this.z = c || 0;
    }
    function g() {
        this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    function h(a, b, d, e, f, i, j, k, l, m) {
        Object.defineProperty(this, "id", {
            value: bf++
        }), this.uuid = _e.generateUUID(), this.name = "", this.image = void 0 !== a ? a : h.DEFAULT_IMAGE, 
        this.mipmaps = [], this.mapping = void 0 !== b ? b : h.DEFAULT_MAPPING, this.wrapS = void 0 !== d ? d : 1001, 
        this.wrapT = void 0 !== e ? e : 1001, this.magFilter = void 0 !== f ? f : 1006, 
        this.minFilter = void 0 !== i ? i : 1008, this.anisotropy = void 0 !== l ? l : 1, 
        this.format = void 0 !== j ? j : 1023, this.type = void 0 !== k ? k : 1009, this.offset = new c(0, 0), 
        this.repeat = new c(1, 1), this.center = new c(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, 
        this.matrix = new g(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, 
        this.unpackAlignment = 4, this.encoding = void 0 !== m ? m : 3e3, this.version = 0, 
        this.onUpdate = null;
    }
    function i(a, b, c, d) {
        this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1;
    }
    function j(a, b, c) {
        this.width = a, this.height = b, this.scissor = new i(0, 0, a, b), this.scissorTest = !1, 
        this.viewport = new i(0, 0, a, b), c = c || {}, void 0 === c.minFilter && (c.minFilter = 1006), 
        this.texture = new h(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding), 
        this.texture.generateMipmaps = void 0 === c.generateMipmaps || c.generateMipmaps, 
        this.depthBuffer = void 0 === c.depthBuffer || c.depthBuffer, this.stencilBuffer = void 0 === c.stencilBuffer || c.stencilBuffer, 
        this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null;
    }
    function k(a, b, c) {
        j.call(this, a, b, c), this.activeMipMapLevel = this.activeCubeFace = 0;
    }
    function l(a, b, c, d, e, f, g, i, j, k, l, m) {
        h.call(this, null, f, g, i, j, k, d, e, l, m), this.image = {
            data: a,
            width: b,
            height: c
        }, this.magFilter = void 0 !== j ? j : 1003, this.minFilter = void 0 !== k ? k : 1003, 
        this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1;
    }
    function m(a, b) {
        this.min = void 0 !== a ? a : new f(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== b ? b : new f(-1 / 0, -1 / 0, -1 / 0);
    }
    function n(a, b) {
        this.center = void 0 !== a ? a : new f(), this.radius = void 0 !== b ? b : 0;
    }
    function o(a, b) {
        this.normal = void 0 !== a ? a : new f(1, 0, 0), this.constant = void 0 !== b ? b : 0;
    }
    function p(a, b, c, d, e, f) {
        this.planes = [ void 0 !== a ? a : new o(), void 0 !== b ? b : new o(), void 0 !== c ? c : new o(), void 0 !== d ? d : new o(), void 0 !== e ? e : new o(), void 0 !== f ? f : new o() ];
    }
    function q(a, b, c) {
        return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c);
    }
    function r() {
        function a(e, f) {
            !1 !== c && (d(e, f), b.requestAnimationFrame(a));
        }
        var b = null, c = !1, d = null;
        return {
            start: function() {
                !0 !== c && null !== d && (b.requestAnimationFrame(a), c = !0);
            },
            stop: function() {
                c = !1;
            },
            setAnimationLoop: function(a) {
                d = a;
            },
            setContext: function(a) {
                b = a;
            }
        };
    }
    function s(a) {
        function b(b, c) {
            var d = b.array, e = b.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW, f = a.createBuffer();
            return a.bindBuffer(c, f), a.bufferData(c, d, e), b.onUploadCallback(), c = a.FLOAT, 
            d instanceof Float32Array ? c = a.FLOAT : d instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : d instanceof Uint16Array ? c = a.UNSIGNED_SHORT : d instanceof Int16Array ? c = a.SHORT : d instanceof Uint32Array ? c = a.UNSIGNED_INT : d instanceof Int32Array ? c = a.INT : d instanceof Int8Array ? c = a.BYTE : d instanceof Uint8Array && (c = a.UNSIGNED_BYTE), 
            {
                buffer: f,
                type: c,
                bytesPerElement: d.BYTES_PER_ELEMENT,
                version: b.version
            };
        }
        var c = new WeakMap();
        return {
            get: function(a) {
                return a.isInterleavedBufferAttribute && (a = a.data), c.get(a);
            },
            remove: function(b) {
                b.isInterleavedBufferAttribute && (b = b.data);
                var d = c.get(b);
                d && (a.deleteBuffer(d.buffer), c.delete(b));
            },
            update: function(d, e) {
                d.isInterleavedBufferAttribute && (d = d.data);
                var f = c.get(d);
                if (void 0 === f) c.set(d, b(d, e)); else if (f.version < d.version) {
                    var g = d, h = g.array, i = g.updateRange;
                    a.bindBuffer(e, f.buffer), !1 === g.dynamic ? a.bufferData(e, h, a.STATIC_DRAW) : -1 === i.count ? a.bufferSubData(e, 0, h) : 0 === i.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(e, i.offset * h.BYTES_PER_ELEMENT, h.subarray(i.offset, i.offset + i.count)), 
                    i.count = -1), f.version = d.version;
                }
            }
        };
    }
    function t(a, b, c, d) {
        this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || t.DefaultOrder;
    }
    function u() {
        this.mask = 1;
    }
    function v() {
        Object.defineProperty(this, "id", {
            value: hf++
        }), this.uuid = _e.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, 
        this.children = [], this.up = v.DefaultUp.clone();
        var a = new f(), b = new t(), c = new e(), h = new f(1, 1, 1);
        b.onChange(function() {
            c.setFromEuler(b, !1);
        }), c.onChange(function() {
            b.setFromQuaternion(c, void 0, !1);
        }), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: a
            },
            rotation: {
                enumerable: !0,
                value: b
            },
            quaternion: {
                enumerable: !0,
                value: c
            },
            scale: {
                enumerable: !0,
                value: h
            },
            modelViewMatrix: {
                value: new d()
            },
            normalMatrix: {
                value: new g()
            }
        }), this.matrix = new d(), this.matrixWorld = new d(), this.matrixAutoUpdate = v.DefaultMatrixAutoUpdate, 
        this.matrixWorldNeedsUpdate = !1, this.layers = new u(), this.visible = !0, this.receiveShadow = this.castShadow = !1, 
        this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
    }
    function w() {
        v.call(this), this.type = "Camera", this.matrixWorldInverse = new d(), this.projectionMatrix = new d(), 
        this.projectionMatrixInverse = new d();
    }
    function x(a, b, c, d, e, f) {
        w.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, 
        this.left = a, this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, 
        this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix();
    }
    function y(a, b, c, d, e, g) {
        this.a = a, this.b = b, this.c = c, this.normal = d && d.isVector3 ? d : new f(), 
        this.vertexNormals = Array.isArray(d) ? d : [], this.color = e && e.isColor ? e : new q(), 
        this.vertexColors = Array.isArray(e) ? e : [], this.materialIndex = void 0 !== g ? g : 0;
    }
    function z() {
        Object.defineProperty(this, "id", {
            value: jf += 2
        }), this.uuid = _e.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], 
        this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], this.morphTargets = [], 
        this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], 
        this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
    }
    function A(a, b, c) {
        if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = a, this.itemSize = b, this.count = void 0 !== a ? a.length / b : 0, 
        this.normalized = !0 === c, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0;
    }
    function B(a, b, c) {
        A.call(this, new Int8Array(a), b, c);
    }
    function C(a, b, c) {
        A.call(this, new Uint8Array(a), b, c);
    }
    function D(a, b, c) {
        A.call(this, new Uint8ClampedArray(a), b, c);
    }
    function E(a, b, c) {
        A.call(this, new Int16Array(a), b, c);
    }
    function F(a, b, c) {
        A.call(this, new Uint16Array(a), b, c);
    }
    function G(a, b, c) {
        A.call(this, new Int32Array(a), b, c);
    }
    function H(a, b, c) {
        A.call(this, new Uint32Array(a), b, c);
    }
    function I(a, b, c) {
        A.call(this, new Float32Array(a), b, c);
    }
    function J(a, b, c) {
        A.call(this, new Float64Array(a), b, c);
    }
    function K() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], 
        this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], 
        this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
    }
    function L(a) {
        if (0 === a.length) return -1 / 0;
        for (var b = a[0], c = 1, d = a.length; c < d; ++c) a[c] > b && (b = a[c]);
        return b;
    }
    function M() {
        Object.defineProperty(this, "id", {
            value: kf += 2
        }), this.uuid = _e.generateUUID(), this.name = "", this.type = "BufferGeometry", 
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], 
        this.boundingSphere = this.boundingBox = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {};
    }
    function N(a, b, c, d, e, f) {
        z.call(this), this.type = "BoxGeometry", this.parameters = {
            width: a,
            height: b,
            depth: c,
            widthSegments: d,
            heightSegments: e,
            depthSegments: f
        }, this.fromBufferGeometry(new O(a, b, c, d, e, f)), this.mergeVertices();
    }
    function O(a, b, c, d, e, g) {
        function h(a, b, c, d, e, g, h, p, q, r, s) {
            var t = g / q, u = h / r, v = g / 2, w = h / 2, x = p / 2;
            h = q + 1;
            var y, z, A = r + 1, B = g = 0, C = new f();
            for (z = 0; z < A; z++) {
                var D = z * u - w;
                for (y = 0; y < h; y++) C[a] = (y * t - v) * d, C[b] = D * e, C[c] = x, k.push(C.x, C.y, C.z), 
                C[a] = 0, C[b] = 0, C[c] = 0 < p ? 1 : -1, l.push(C.x, C.y, C.z), m.push(y / q), 
                m.push(1 - z / r), g += 1;
            }
            for (z = 0; z < r; z++) for (y = 0; y < q; y++) a = n + y + h * (z + 1), b = n + (y + 1) + h * (z + 1), 
            c = n + (y + 1) + h * z, j.push(n + y + h * z, a, c), j.push(a, b, c), B += 6;
            i.addGroup(o, B, s), o += B, n += g;
        }
        M.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: a,
            height: b,
            depth: c,
            widthSegments: d,
            heightSegments: e,
            depthSegments: g
        };
        var i = this;
        a = a || 1, b = b || 1, c = c || 1, d = Math.floor(d) || 1, e = Math.floor(e) || 1, 
        g = Math.floor(g) || 1;
        var j = [], k = [], l = [], m = [], n = 0, o = 0;
        h("z", "y", "x", -1, -1, c, b, a, g, e, 0), h("z", "y", "x", 1, -1, c, b, -a, g, e, 1), 
        h("x", "z", "y", 1, 1, a, c, b, d, g, 2), h("x", "z", "y", 1, -1, a, c, -b, d, g, 3), 
        h("x", "y", "z", 1, -1, a, b, c, d, e, 4), h("x", "y", "z", -1, -1, a, b, -c, d, e, 5), 
        this.setIndex(j), this.addAttribute("position", new I(k, 3)), this.addAttribute("normal", new I(l, 3)), 
        this.addAttribute("uv", new I(m, 2));
    }
    function P(a, b, c, d) {
        z.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
        }, this.fromBufferGeometry(new Q(a, b, c, d)), this.mergeVertices();
    }
    function Q(a, b, c, d) {
        M.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: a,
            height: b,
            widthSegments: c,
            heightSegments: d
        }, a = a || 1, b = b || 1;
        var e = a / 2, f = b / 2;
        c = Math.floor(c) || 1, d = Math.floor(d) || 1;
        var g = c + 1, h = d + 1, i = a / c, j = b / d, k = [], l = [], m = [], n = [];
        for (a = 0; a < h; a++) {
            var o = a * j - f;
            for (b = 0; b < g; b++) l.push(b * i - e, -o, 0), m.push(0, 0, 1), n.push(b / c), 
            n.push(1 - a / d);
        }
        for (a = 0; a < d; a++) for (b = 0; b < c; b++) e = b + g * (a + 1), f = b + 1 + g * (a + 1), 
        h = b + 1 + g * a, k.push(b + g * a, e, h), k.push(e, f, h);
        this.setIndex(k), this.addAttribute("position", new I(l, 3)), this.addAttribute("normal", new I(m, 3)), 
        this.addAttribute("uv", new I(n, 2));
    }
    function R() {
        Object.defineProperty(this, "id", {
            value: lf++
        }), this.uuid = _e.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, 
        this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = 0, 
        this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, 
        this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, 
        this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, 
        this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, 
        this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, 
        this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, 
        this.visible = !0, this.userData = {}, this.needsUpdate = !0;
    }
    function S(a) {
        R.call(this), this.type = "MeshBasicMaterial", this.color = new q(16777215), this.lightMap = this.map = null, 
        this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, 
        this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, 
        this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
        this.lights = this.morphTargets = this.skinning = !1, this.setValues(a);
    }
    function T(a) {
        R.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, 
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", 
        this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, 
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [ 1, 1, 1 ],
            uv: [ 0, 0 ],
            uv2: [ 0, 0 ]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), 
        this.setValues(a));
    }
    function U(a, b) {
        this.origin = void 0 !== a ? a : new f(), this.direction = void 0 !== b ? b : new f();
    }
    function V(a, b, c) {
        this.a = void 0 !== a ? a : new f(), this.b = void 0 !== b ? b : new f(), this.c = void 0 !== c ? c : new f();
    }
    function W(a, b) {
        v.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new M(), this.material = void 0 !== b ? b : new S({
            color: 16777215 * Math.random()
        }), this.drawMode = 0, this.updateMorphTargets();
    }
    function X(a, b, c, d) {
        function e(a, c) {
            b.buffers.color.setClear(a.r, a.g, a.b, c, d);
        }
        var f, g, h, i = new q(0), j = 0;
        return {
            getClearColor: function() {
                return i;
            },
            setClearColor: function(a, b) {
                i.set(a), j = void 0 !== b ? b : 1, e(i, j);
            },
            getClearAlpha: function() {
                return j;
            },
            setClearAlpha: function(a) {
                j = a, e(i, j);
            },
            render: function(b, d, k, l) {
                d = d.background, null === d ? e(i, j) : d && d.isColor && (e(d, 1), l = !0), (a.autoClear || l) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil), 
                d && d.isCubeTexture ? (void 0 === h && (h = new W(new O(1, 1, 1), new T({
                    uniforms: gf.cube.uniforms,
                    vertexShader: gf.cube.vertexShader,
                    fragmentShader: gf.cube.fragmentShader,
                    side: 1,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1
                })), h.geometry.removeAttribute("normal"), h.geometry.removeAttribute("uv"), h.onBeforeRender = function(a, b, c) {
                    this.matrixWorld.copyPosition(c.matrixWorld);
                }, c.update(h)), h.material.uniforms.tCube.value = d, b.push(h, h.geometry, h.material, 0, null)) : d && d.isTexture && (void 0 === f && (f = new x(-1, 1, 1, -1, 0, 1), 
                g = new W(new Q(2, 2), new S({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), c.update(g)), g.material.map = d, a.renderBufferDirect(f, null, g.geometry, g.material, g, null));
            }
        };
    }
    function Y(a, b, c, d) {
        var e;
        this.setMode = function(a) {
            e = a;
        }, this.render = function(b, d) {
            a.drawArrays(e, b, d), c.update(d, e);
        }, this.renderInstances = function(f, g, h) {
            if (d.isWebGL2) var i = a; else if (null === (i = b.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            i[d.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](e, g, h, f.maxInstancedCount), 
            c.update(h, e, f.maxInstancedCount);
        };
    }
    function Z(a, b, c) {
        function d(b) {
            if ("highp" === b) {
                if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
                b = "mediump";
            }
            return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp";
        }
        var e, f = "undefined" != typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext, g = void 0 !== c.precision ? c.precision : "highp", h = d(g);
        h !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", h, "instead."), 
        g = h), c = !0 === c.logarithmicDepthBuffer, h = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
        var i = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS), j = a.getParameter(a.MAX_TEXTURE_SIZE), k = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE), l = a.getParameter(a.MAX_VERTEX_ATTRIBS), m = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS), n = a.getParameter(a.MAX_VARYING_VECTORS), o = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS), p = 0 < i, q = f || !!b.get("OES_texture_float");
        return {
            isWebGL2: f,
            getMaxAnisotropy: function() {
                if (void 0 !== e) return e;
                var c = b.get("EXT_texture_filter_anisotropic");
                return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            },
            getMaxPrecision: d,
            precision: g,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: i,
            maxTextureSize: j,
            maxCubemapSize: k,
            maxAttributes: l,
            maxVertexUniforms: m,
            maxVaryings: n,
            maxFragmentUniforms: o,
            vertexTextures: p,
            floatFragmentTextures: q,
            floatVertexTextures: p && q
        };
    }
    function $() {
        function a() {
            k.value !== d && (k.value = d, k.needsUpdate = 0 < e), c.numPlanes = e, c.numIntersection = 0;
        }
        function b(a, b, d, e) {
            var f = null !== a ? a.length : 0, g = null;
            if (0 !== f) {
                if (g = k.value, !0 !== e || null === g) for (e = d + 4 * f, b = b.matrixWorldInverse, 
                j.getNormalMatrix(b), (null === g || g.length < e) && (g = new Float32Array(e)), 
                e = 0; e !== f; ++e, d += 4) i.copy(a[e]).applyMatrix4(b, j), i.normal.toArray(g, d), 
                g[d + 3] = i.constant;
                k.value = g, k.needsUpdate = !0;
            }
            return c.numPlanes = f, g;
        }
        var c = this, d = null, e = 0, f = !1, h = !1, i = new o(), j = new g(), k = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = k, this.numIntersection = this.numPlanes = 0, this.init = function(a, c, g) {
            var h = 0 !== a.length || c || 0 !== e || f;
            return f = c, d = b(a, g, 0), e = a.length, h;
        }, this.beginShadows = function() {
            h = !0, b(null);
        }, this.endShadows = function() {
            h = !1, a();
        }, this.setState = function(c, g, i, j, l, m) {
            if (!f || null === c || 0 === c.length || h && !i) h ? b(null) : a(); else {
                i = h ? 0 : e;
                var n = 4 * i, o = l.clippingState || null;
                for (k.value = o, o = b(c, j, n, m), c = 0; c !== n; ++c) o[c] = d[c];
                l.clippingState = o, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += i;
            }
        };
    }
    function _(a) {
        var b = {};
        return {
            get: function(c) {
                if (void 0 !== b[c]) return b[c];
                switch (c) {
                  case "WEBGL_depth_texture":
                    var d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;

                  case "EXT_texture_filter_anisotropic":
                    d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;

                  case "WEBGL_compressed_texture_s3tc":
                    d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;

                  case "WEBGL_compressed_texture_pvrtc":
                    d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;

                  default:
                    d = a.getExtension(c);
                }
                return null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."), 
                b[c] = d;
            }
        };
    }
    function aa(a, b, c) {
        function d(a) {
            var g = a.target;
            a = e[g.id], null !== a.index && b.remove(a.index);
            for (var h in a.attributes) b.remove(a.attributes[h]);
            g.removeEventListener("dispose", d), delete e[g.id], (h = f[a.id]) && (b.remove(h), 
            delete f[a.id]), c.memory.geometries--;
        }
        var e = {}, f = {};
        return {
            get: function(a, b) {
                var f = e[b.id];
                return f || (b.addEventListener("dispose", d), b.isBufferGeometry ? f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = new M().setFromObject(a)), 
                f = b._bufferGeometry), e[b.id] = f, c.memory.geometries++, f);
            },
            update: function(c) {
                var d = c.index, e = c.attributes;
                null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER);
                for (var f in e) b.update(e[f], a.ARRAY_BUFFER);
                c = c.morphAttributes;
                for (f in c) {
                    d = c[f], e = 0;
                    for (var g = d.length; e < g; e++) b.update(d[e], a.ARRAY_BUFFER);
                }
            },
            getWireframeAttribute: function(c) {
                var d = f[c.id];
                if (d) return d;
                d = [];
                var e = c.index, g = c.attributes;
                if (null !== e) {
                    e = e.array, g = 0;
                    for (var h = e.length; g < h; g += 3) {
                        var i = e[g + 0], j = e[g + 1], k = e[g + 2];
                        d.push(i, j, j, k, k, i);
                    }
                } else for (e = g.position.array, g = 0, h = e.length / 3 - 1; g < h; g += 3) i = g + 0, 
                j = g + 1, k = g + 2, d.push(i, j, j, k, k, i);
                return d = new (65535 < L(d) ? H : F)(d, 1), b.update(d, a.ELEMENT_ARRAY_BUFFER), 
                f[c.id] = d;
            }
        };
    }
    function ba(a, b, c, d) {
        var e, f, g;
        this.setMode = function(a) {
            e = a;
        }, this.setIndex = function(a) {
            f = a.type, g = a.bytesPerElement;
        }, this.render = function(b, d) {
            a.drawElements(e, d, f, b * g), c.update(d, e);
        }, this.renderInstances = function(h, i, j) {
            if (d.isWebGL2) var k = a; else if (null === (k = b.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            k[d.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](e, j, f, i * g, h.maxInstancedCount), 
            c.update(j, e, h.maxInstancedCount);
        };
    }
    function ca(a) {
        var b = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: b,
            programs: null,
            autoReset: !0,
            reset: function() {
                b.frame++, b.calls = 0, b.triangles = 0, b.points = 0, b.lines = 0;
            },
            update: function(c, d, e) {
                switch (e = e || 1, b.calls++, d) {
                  case a.TRIANGLES:
                    b.triangles += c / 3 * e;
                    break;

                  case a.TRIANGLE_STRIP:
                  case a.TRIANGLE_FAN:
                    b.triangles += e * (c - 2);
                    break;

                  case a.LINES:
                    b.lines += c / 2 * e;
                    break;

                  case a.LINE_STRIP:
                    b.lines += e * (c - 1);
                    break;

                  case a.LINE_LOOP:
                    b.lines += e * c;
                    break;

                  case a.POINTS:
                    b.points += e * c;
                    break;

                  default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", d);
                }
            }
        };
    }
    function da(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function ea(a) {
        var b = {}, c = new Float32Array(8);
        return {
            update: function(d, e, f, g) {
                var h = d.morphTargetInfluences, i = h.length;
                if (void 0 === (d = b[e.id])) {
                    d = [];
                    for (var j = 0; j < i; j++) d[j] = [ j, 0 ];
                    b[e.id] = d;
                }
                var k = f.morphTargets && e.morphAttributes.position;
                for (f = f.morphNormals && e.morphAttributes.normal, j = 0; j < i; j++) {
                    var l = d[j];
                    0 !== l[1] && (k && e.removeAttribute("morphTarget" + j), f && e.removeAttribute("morphNormal" + j));
                }
                for (j = 0; j < i; j++) l = d[j], l[0] = j, l[1] = h[j];
                for (d.sort(da), j = 0; 8 > j; j++) (l = d[j]) && (h = l[0], i = l[1]) ? (k && e.addAttribute("morphTarget" + j, k[h]), 
                f && e.addAttribute("morphNormal" + j, f[h]), c[j] = i) : c[j] = 0;
                g.getUniforms().setValue(a, "morphTargetInfluences", c);
            }
        };
    }
    function fa(a, b) {
        var c = {};
        return {
            update: function(d) {
                var e = b.render.frame, f = d.geometry, g = a.get(d, f);
                return c[g.id] !== e && (f.isGeometry && g.updateFromObject(d), a.update(g), c[g.id] = e), 
                g;
            },
            dispose: function() {
                c = {};
            }
        };
    }
    function ga(a, b, c, d, e, f, g, i, j, k) {
        a = void 0 !== a ? a : [], h.call(this, a, void 0 !== b ? b : 301, c, d, e, f, g, i, j, k), 
        this.flipY = !1;
    }
    function ha(a, b, c) {
        var d = a[0];
        if (0 >= d || 0 < d) return a;
        var e = b * c, f = of[e];
        if (void 0 === f && (f = new Float32Array(e), of[e] = f), 0 !== b) for (d.toArray(f, 0), 
        d = 1, e = 0; d !== b; ++d) e += c, a[d].toArray(f, e);
        return f;
    }
    function ia(a, b) {
        if (a.length !== b.length) return !1;
        for (var c = 0, d = a.length; c < d; c++) if (a[c] !== b[c]) return !1;
        return !0;
    }
    function ja(a, b) {
        for (var c = 0, d = b.length; c < d; c++) a[c] = b[c];
    }
    function ka(a, b) {
        var c = pf[b];
        void 0 === c && (c = new Int32Array(b), pf[b] = c);
        for (var d = 0; d !== b; ++d) c[d] = a.allocTextureUnit();
        return c;
    }
    function la(a, b) {
        var c = this.cache;
        c[0] !== b && (a.uniform1f(this.addr, b), c[0] = b);
    }
    function ma(a, b) {
        var c = this.cache;
        c[0] !== b && (a.uniform1i(this.addr, b), c[0] = b);
    }
    function na(a, b) {
        var c = this.cache;
        void 0 !== b.x ? c[0] === b.x && c[1] === b.y || (a.uniform2f(this.addr, b.x, b.y), 
        c[0] = b.x, c[1] = b.y) : ia(c, b) || (a.uniform2fv(this.addr, b), ja(c, b));
    }
    function oa(a, b) {
        var c = this.cache;
        void 0 !== b.x ? c[0] === b.x && c[1] === b.y && c[2] === b.z || (a.uniform3f(this.addr, b.x, b.y, b.z), 
        c[0] = b.x, c[1] = b.y, c[2] = b.z) : void 0 !== b.r ? c[0] === b.r && c[1] === b.g && c[2] === b.b || (a.uniform3f(this.addr, b.r, b.g, b.b), 
        c[0] = b.r, c[1] = b.g, c[2] = b.b) : ia(c, b) || (a.uniform3fv(this.addr, b), ja(c, b));
    }
    function pa(a, b) {
        var c = this.cache;
        void 0 !== b.x ? c[0] === b.x && c[1] === b.y && c[2] === b.z && c[3] === b.w || (a.uniform4f(this.addr, b.x, b.y, b.z, b.w), 
        c[0] = b.x, c[1] = b.y, c[2] = b.z, c[3] = b.w) : ia(c, b) || (a.uniform4fv(this.addr, b), 
        ja(c, b));
    }
    function qa(a, b) {
        var c = this.cache, d = b.elements;
        void 0 === d ? ia(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), ja(c, b)) : ia(c, d) || (sf.set(d), 
        a.uniformMatrix2fv(this.addr, !1, sf), ja(c, d));
    }
    function ra(a, b) {
        var c = this.cache, d = b.elements;
        void 0 === d ? ia(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), ja(c, b)) : ia(c, d) || (rf.set(d), 
        a.uniformMatrix3fv(this.addr, !1, rf), ja(c, d));
    }
    function sa(a, b) {
        var c = this.cache, d = b.elements;
        void 0 === d ? ia(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), ja(c, b)) : ia(c, d) || (qf.set(d), 
        a.uniformMatrix4fv(this.addr, !1, qf), ja(c, d));
    }
    function ta(a, b, c) {
        var d = this.cache, e = c.allocTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e), c.setTexture2D(b || mf, e);
    }
    function ua(a, b, c) {
        var d = this.cache, e = c.allocTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e), c.setTextureCube(b || nf, e);
    }
    function va(a, b) {
        var c = this.cache;
        ia(c, b) || (a.uniform2iv(this.addr, b), ja(c, b));
    }
    function wa(a, b) {
        var c = this.cache;
        ia(c, b) || (a.uniform3iv(this.addr, b), ja(c, b));
    }
    function xa(a, b) {
        var c = this.cache;
        ia(c, b) || (a.uniform4iv(this.addr, b), ja(c, b));
    }
    function ya(a) {
        switch (a) {
          case 5126:
            return la;

          case 35664:
            return na;

          case 35665:
            return oa;

          case 35666:
            return pa;

          case 35674:
            return qa;

          case 35675:
            return ra;

          case 35676:
            return sa;

          case 35678:
          case 36198:
            return ta;

          case 35680:
            return ua;

          case 5124:
          case 35670:
            return ma;

          case 35667:
          case 35671:
            return va;

          case 35668:
          case 35672:
            return wa;

          case 35669:
          case 35673:
            return xa;
        }
    }
    function za(a, b) {
        var c = this.cache;
        ia(c, b) || (a.uniform1fv(this.addr, b), ja(c, b));
    }
    function Aa(a, b) {
        var c = this.cache;
        ia(c, b) || (a.uniform1iv(this.addr, b), ja(c, b));
    }
    function Ba(a, b) {
        var c = this.cache;
        b = ha(b, this.size, 2), ia(c, b) || (a.uniform2fv(this.addr, b), this.updateCache(b));
    }
    function Ca(a, b) {
        var c = this.cache;
        b = ha(b, this.size, 3), ia(c, b) || (a.uniform3fv(this.addr, b), this.updateCache(b));
    }
    function Da(a, b) {
        var c = this.cache;
        b = ha(b, this.size, 4), ia(c, b) || (a.uniform4fv(this.addr, b), this.updateCache(b));
    }
    function Ea(a, b) {
        var c = this.cache;
        b = ha(b, this.size, 4), ia(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), this.updateCache(b));
    }
    function Fa(a, b) {
        var c = this.cache;
        b = ha(b, this.size, 9), ia(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), this.updateCache(b));
    }
    function Ga(a, b) {
        var c = this.cache;
        b = ha(b, this.size, 16), ia(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), this.updateCache(b));
    }
    function Ha(a, b, c) {
        var d = this.cache, e = b.length, f = ka(c, e);
        for (!1 === ia(d, f) && (a.uniform1iv(this.addr, f), ja(d, f)), a = 0; a !== e; ++a) c.setTexture2D(b[a] || mf, f[a]);
    }
    function Ia(a, b, c) {
        var d = this.cache, e = b.length, f = ka(c, e);
        for (!1 === ia(d, f) && (a.uniform1iv(this.addr, f), ja(d, f)), a = 0; a !== e; ++a) c.setTextureCube(b[a] || nf, f[a]);
    }
    function Ja(a) {
        switch (a) {
          case 5126:
            return za;

          case 35664:
            return Ba;

          case 35665:
            return Ca;

          case 35666:
            return Da;

          case 35674:
            return Ea;

          case 35675:
            return Fa;

          case 35676:
            return Ga;

          case 35678:
            return Ha;

          case 35680:
            return Ia;

          case 5124:
          case 35670:
            return Aa;

          case 35667:
          case 35671:
            return va;

          case 35668:
          case 35672:
            return wa;

          case 35669:
          case 35673:
            return xa;
        }
    }
    function Ka(a, b, c) {
        this.id = a, this.addr = c, this.cache = [], this.setValue = ya(b.type);
    }
    function La(a, b, c) {
        this.id = a, this.addr = c, this.cache = [], this.size = b.size, this.setValue = Ja(b.type);
    }
    function Ma(a) {
        this.id = a, this.seq = [], this.map = {};
    }
    function Na(a, b, c) {
        this.seq = [], this.map = {}, this.renderer = c, c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
        for (var d = 0; d < c; ++d) {
            var e = a.getActiveUniform(b, d), f = a.getUniformLocation(b, e.name), g = this, h = e.name, i = h.length;
            for (tf.lastIndex = 0; ;) {
                var j = tf.exec(h), k = tf.lastIndex, l = j[1], m = j[3];
                if ("]" === j[2] && (l |= 0), void 0 === m || "[" === m && k + 2 === i) {
                    h = g, e = void 0 === m ? new Ka(l, e, f) : new La(l, e, f), h.seq.push(e), h.map[e.id] = e;
                    break;
                }
                m = g.map[l], void 0 === m && (m = new Ma(l), l = g, g = m, l.seq.push(g), l.map[g.id] = g), 
                g = m;
            }
        }
    }
    function Oa(a) {
        a = a.split("\n");
        for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
        return a.join("\n");
    }
    function Pa(a, b, c) {
        var d = a.createShader(b);
        return a.shaderSource(d, c), a.compileShader(d), !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), 
        "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), Oa(c)), 
        d;
    }
    function Qa(a) {
        switch (a) {
          case 3e3:
            return [ "Linear", "( value )" ];

          case 3001:
            return [ "sRGB", "( value )" ];

          case 3002:
            return [ "RGBE", "( value )" ];

          case 3004:
            return [ "RGBM", "( value, 7.0 )" ];

          case 3005:
            return [ "RGBM", "( value, 16.0 )" ];

          case 3006:
            return [ "RGBD", "( value, 256.0 )" ];

          case 3007:
            return [ "Gamma", "( value, float( GAMMA_FACTOR ) )" ];

          default:
            throw Error("unsupported encoding: " + a);
        }
    }
    function Ra(a, b) {
        return b = Qa(b), "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }";
    }
    function Sa(a, b) {
        return b = Qa(b), "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }";
    }
    function Ta(a, b) {
        switch (b) {
          case 1:
            b = "Linear";
            break;

          case 2:
            b = "Reinhard";
            break;

          case 3:
            b = "Uncharted2";
            break;

          case 4:
            b = "OptimizedCineon";
            break;

          default:
            throw Error("unsupported toneMapping: " + b);
        }
        return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }";
    }
    function Ua(a, b, c) {
        return a = a || {}, [ a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap && !b.objectSpaceNormalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : "" ].filter(Wa).join("\n");
    }
    function Va(a) {
        var b, c = [];
        for (b in a) {
            var d = a[b];
            !1 !== d && c.push("#define " + b + " " + d);
        }
        return c.join("\n");
    }
    function Wa(a) {
        return "" !== a;
    }
    function Xa(a, b) {
        return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights);
    }
    function Ya(a, b) {
        return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection);
    }
    function Za(a) {
        return a.replace(/^[ \t]*#include +<([\w\d.\/]+)>/gm, function(a, b) {
            if (void 0 === (a = cf[b])) throw Error("Can not resolve #include <" + b + ">");
            return Za(a);
        });
    }
    function $a(a) {
        return a.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(a, b, c, d) {
            for (a = "", b = parseInt(b); b < parseInt(c); b++) a += d.replace(/\[ i \]/g, "[ " + b + " ]");
            return a;
        });
    }
    function _a(a, b, c, d, e, f, g) {
        var h = a.context, i = d.defines, j = e.vertexShader, k = e.fragmentShader, l = "SHADOWMAP_TYPE_BASIC";
        1 === f.shadowMapType ? l = "SHADOWMAP_TYPE_PCF" : 2 === f.shadowMapType && (l = "SHADOWMAP_TYPE_PCF_SOFT");
        var m = "ENVMAP_TYPE_CUBE", n = "ENVMAP_MODE_REFLECTION", o = "ENVMAP_BLENDING_MULTIPLY";
        if (f.envMap) {
            switch (d.envMap.mapping) {
              case 301:
              case 302:
                m = "ENVMAP_TYPE_CUBE";
                break;

              case 306:
              case 307:
                m = "ENVMAP_TYPE_CUBE_UV";
                break;

              case 303:
              case 304:
                m = "ENVMAP_TYPE_EQUIREC";
                break;

              case 305:
                m = "ENVMAP_TYPE_SPHERE";
            }
            switch (d.envMap.mapping) {
              case 302:
              case 304:
                n = "ENVMAP_MODE_REFRACTION";
            }
            switch (d.combine) {
              case 0:
                o = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case 1:
                o = "ENVMAP_BLENDING_MIX";
                break;

              case 2:
                o = "ENVMAP_BLENDING_ADD";
            }
        }
        var p = 0 < a.gammaFactor ? a.gammaFactor : 1, q = g.isWebGL2 ? "" : Ua(d.extensions, f, b), r = Va(i), s = h.createProgram();
        d.isRawShaderMaterial ? (i = [ r ].filter(Wa).join("\n"), 0 < i.length && (i += "\n"), 
        b = [ q, r ].filter(Wa).join("\n"), 0 < b.length && (b += "\n")) : (i = [ "precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, r, f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + f.maxBones, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + n : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.displacementMap && f.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals && !1 === f.flatShading ? "#define USE_MORPHNORMALS" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + l : "", f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (g.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n" ].filter(Wa).join("\n"), 
        b = [ q, "precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, r, f.alphaTest ? "#define ALPHATEST " + f.alphaTest + (f.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + p, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + m : "", f.envMap ? "#define " + n : "", f.envMap ? "#define " + o : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.gradientMap ? "#define USE_GRADIENTMAP" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + l : "", f.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (g.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", f.envMap && (g.isWebGL2 || b.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== f.toneMapping ? "#define TONE_MAPPING" : "", 0 !== f.toneMapping ? cf.tonemapping_pars_fragment : "", 0 !== f.toneMapping ? Ta("toneMapping", f.toneMapping) : "", f.dithering ? "#define DITHERING" : "", f.outputEncoding || f.mapEncoding || f.envMapEncoding || f.emissiveMapEncoding ? cf.encodings_pars_fragment : "", f.mapEncoding ? Ra("mapTexelToLinear", f.mapEncoding) : "", f.envMapEncoding ? Ra("envMapTexelToLinear", f.envMapEncoding) : "", f.emissiveMapEncoding ? Ra("emissiveMapTexelToLinear", f.emissiveMapEncoding) : "", f.outputEncoding ? Sa("linearToOutputTexel", f.outputEncoding) : "", f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n" ].filter(Wa).join("\n")), 
        j = Za(j), j = Xa(j, f), j = Ya(j, f), k = Za(k), k = Xa(k, f), k = Ya(k, f), j = $a(j), 
        k = $a(k), g.isWebGL2 && !d.isRawShaderMaterial && (g = !1, l = /^\s*#version\s+300\s+es\s*\n/, 
        d.isShaderMaterial && null !== j.match(l) && null !== k.match(l) && (g = !0, j = j.replace(l, ""), 
        k = k.replace(l, "")), i = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + i, 
        b = [ "#version 300 es\n\n#define varying in", g ? "" : "out highp vec4 pc_fragColor;", g ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad" ].join("\n") + "\n" + b), 
        k = b + k, j = Pa(h, h.VERTEX_SHADER, i + j), k = Pa(h, h.FRAGMENT_SHADER, k), h.attachShader(s, j), 
        h.attachShader(s, k), void 0 !== d.index0AttributeName ? h.bindAttribLocation(s, 0, d.index0AttributeName) : !0 === f.morphTargets && h.bindAttribLocation(s, 0, "position"), 
        h.linkProgram(s), f = h.getProgramInfoLog(s).trim(), g = h.getShaderInfoLog(j).trim(), 
        l = h.getShaderInfoLog(k).trim(), n = m = !0, !1 === h.getProgramParameter(s, h.LINK_STATUS) ? (m = !1, 
        console.error("THREE.WebGLProgram: shader error: ", h.getError(), "gl.VALIDATE_STATUS", h.getProgramParameter(s, h.VALIDATE_STATUS), "gl.getProgramInfoLog", f, g, l)) : "" !== f ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", f) : "" !== g && "" !== l || (n = !1), 
        n && (this.diagnostics = {
            runnable: m,
            material: d,
            programLog: f,
            vertexShader: {
                log: g,
                prefix: i
            },
            fragmentShader: {
                log: l,
                prefix: b
            }
        }), h.deleteShader(j), h.deleteShader(k);
        var t;
        this.getUniforms = function() {
            return void 0 === t && (t = new Na(h, s, a)), t;
        };
        var u;
        return this.getAttributes = function() {
            if (void 0 === u) {
                for (var a = {}, b = h.getProgramParameter(s, h.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) {
                    var d = h.getActiveAttrib(s, c).name;
                    a[d] = h.getAttribLocation(s, d);
                }
                u = a;
            }
            return u;
        }, this.destroy = function() {
            h.deleteProgram(s), this.program = void 0;
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), 
                    this.getAttributes();
                }
            }
        }), this.name = e.name, this.id = uf++, this.code = c, this.usedTimes = 1, this.program = s, 
        this.vertexShader = j, this.fragmentShader = k, this;
    }
    function ab(a, b, c) {
        function d(a, b) {
            if (a) a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), 
            c = a.texture.encoding); else var c = 3e3;
            return 3e3 === c && b && (c = 3007), c;
        }
        var e = [], f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }, g = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function(b, e, g, h, i, j, k) {
            var l = f[b.type];
            if (k.isSkinnedMesh) {
                var m = k.skeleton.bones;
                if (c.floatVertexTextures) m = 1024; else {
                    var n = Math.min(Math.floor((c.maxVertexUniforms - 20) / 4), m.length);
                    n < m.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + m.length + " bones. This GPU supports " + n + "."), 
                    m = 0) : m = n;
                }
            } else m = 0;
            n = c.precision, null !== b.precision && (n = c.getMaxPrecision(b.precision)) !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", n, "instead.");
            var o = a.getRenderTarget();
            return {
                shaderID: l,
                precision: n,
                supportsVertexTextures: c.vertexTextures,
                outputEncoding: d(o ? o.texture : null, a.gammaOutput),
                map: !!b.map,
                mapEncoding: d(b.map, a.gammaInput),
                envMap: !!b.envMap,
                envMapMode: b.envMap && b.envMap.mapping,
                envMapEncoding: d(b.envMap, a.gammaInput),
                envMapCubeUV: !!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping),
                lightMap: !!b.lightMap,
                aoMap: !!b.aoMap,
                emissiveMap: !!b.emissiveMap,
                emissiveMapEncoding: d(b.emissiveMap, a.gammaInput),
                bumpMap: !!b.bumpMap,
                normalMap: !!b.normalMap,
                objectSpaceNormalMap: 1 === b.normalMapType,
                displacementMap: !!b.displacementMap,
                roughnessMap: !!b.roughnessMap,
                metalnessMap: !!b.metalnessMap,
                specularMap: !!b.specularMap,
                alphaMap: !!b.alphaMap,
                gradientMap: !!b.gradientMap,
                combine: b.combine,
                vertexColors: b.vertexColors,
                fog: !!h,
                useFog: b.fog,
                fogExp: h && h.isFogExp2,
                flatShading: b.flatShading,
                sizeAttenuation: b.sizeAttenuation,
                logarithmicDepthBuffer: c.logarithmicDepthBuffer,
                skinning: b.skinning && 0 < m,
                maxBones: m,
                useVertexTexture: c.floatVertexTextures,
                morphTargets: b.morphTargets,
                morphNormals: b.morphNormals,
                maxMorphTargets: a.maxMorphTargets,
                maxMorphNormals: a.maxMorphNormals,
                numDirLights: e.directional.length,
                numPointLights: e.point.length,
                numSpotLights: e.spot.length,
                numRectAreaLights: e.rectArea.length,
                numHemiLights: e.hemi.length,
                numClippingPlanes: i,
                numClipIntersection: j,
                dithering: b.dithering,
                shadowMapEnabled: a.shadowMap.enabled && k.receiveShadow && 0 < g.length,
                shadowMapType: a.shadowMap.type,
                toneMapping: a.toneMapping,
                physicallyCorrectLights: a.physicallyCorrectLights,
                premultipliedAlpha: b.premultipliedAlpha,
                alphaTest: b.alphaTest,
                doubleSided: 2 === b.side,
                flipSided: 1 === b.side,
                depthPacking: void 0 !== b.depthPacking && b.depthPacking
            };
        }, this.getProgramCode = function(b, c) {
            var d = [];
            if (c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader), d.push(b.vertexShader)), 
            void 0 !== b.defines) for (var e in b.defines) d.push(e), d.push(b.defines[e]);
            for (e = 0; e < g.length; e++) d.push(c[g[e]]);
            return d.push(b.onBeforeCompile.toString()), d.push(a.gammaOutput), d.join();
        }, this.acquireProgram = function(d, f, g, h) {
            for (var i, j = 0, k = e.length; j < k; j++) {
                var l = e[j];
                if (l.code === h) {
                    i = l, ++i.usedTimes;
                    break;
                }
            }
            return void 0 === i && (i = new _a(a, b, h, d, f, g, c), e.push(i)), i;
        }, this.releaseProgram = function(a) {
            if (0 == --a.usedTimes) {
                var b = e.indexOf(a);
                e[b] = e[e.length - 1], e.pop(), a.destroy();
            }
        }, this.programs = e;
    }
    function bb() {
        var a = new WeakMap();
        return {
            get: function(b) {
                var c = a.get(b);
                return void 0 === c && (c = {}, a.set(b, c)), c;
            },
            remove: function(b) {
                a.delete(b);
            },
            update: function(b, c, d) {
                a.get(b)[c] = d;
            },
            dispose: function() {
                a = new WeakMap();
            }
        };
    }
    function cb(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
    }
    function db(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;
    }
    function eb() {
        var a = [], b = 0, c = [], d = [];
        return {
            opaque: c,
            transparent: d,
            init: function() {
                b = 0, c.length = 0, d.length = 0;
            },
            push: function(e, f, g, h, i) {
                var j = a[b];
                void 0 === j ? (j = {
                    id: e.id,
                    object: e,
                    geometry: f,
                    material: g,
                    program: g.program,
                    renderOrder: e.renderOrder,
                    z: h,
                    group: i
                }, a[b] = j) : (j.id = e.id, j.object = e, j.geometry = f, j.material = g, j.program = g.program, 
                j.renderOrder = e.renderOrder, j.z = h, j.group = i), (!0 === g.transparent ? d : c).push(j), 
                b++;
            },
            sort: function() {
                1 < c.length && c.sort(cb), 1 < d.length && d.sort(db);
            }
        };
    }
    function fb() {
        var a = {};
        return {
            get: function(b, c) {
                return b = b.id + "," + c.id, c = a[b], void 0 === c && (c = new eb(), a[b] = c), 
                c;
            },
            dispose: function() {
                a = {};
            }
        };
    }
    function gb() {
        var a = {};
        return {
            get: function(b) {
                if (void 0 !== a[b.id]) return a[b.id];
                switch (b.type) {
                  case "DirectionalLight":
                    var d = {
                        direction: new f(),
                        color: new q(),
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new c()
                    };
                    break;

                  case "SpotLight":
                    d = {
                        position: new f(),
                        direction: new f(),
                        color: new q(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new c()
                    };
                    break;

                  case "PointLight":
                    d = {
                        position: new f(),
                        color: new q(),
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new c(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;

                  case "HemisphereLight":
                    d = {
                        direction: new f(),
                        skyColor: new q(),
                        groundColor: new q()
                    };
                    break;

                  case "RectAreaLight":
                    d = {
                        color: new q(),
                        position: new f(),
                        halfWidth: new f(),
                        halfHeight: new f()
                    };
                }
                return a[b.id] = d;
            }
        };
    }
    function hb() {
        var a = new gb(), b = {
            id: vf++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [ 0, 0, 0 ],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }, c = new f(), e = new d(), g = new d();
        return {
            setup: function(d, f, h) {
                var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0;
                h = h.matrixWorldInverse;
                for (var q = 0, r = d.length; q < r; q++) {
                    var s = d[q], t = s.color, u = s.intensity, v = s.distance, w = s.shadow && s.shadow.map ? s.shadow.map.texture : null;
                    if (s.isAmbientLight) i += t.r * u, j += t.g * u, k += t.b * u; else if (s.isDirectionalLight) {
                        var x = a.get(s);
                        x.color.copy(s.color).multiplyScalar(s.intensity), x.direction.setFromMatrixPosition(s.matrixWorld), 
                        c.setFromMatrixPosition(s.target.matrixWorld), x.direction.sub(c), x.direction.transformDirection(h), 
                        (x.shadow = s.castShadow) && (t = s.shadow, x.shadowBias = t.bias, x.shadowRadius = t.radius, 
                        x.shadowMapSize = t.mapSize), b.directionalShadowMap[l] = w, b.directionalShadowMatrix[l] = s.shadow.matrix, 
                        b.directional[l] = x, l++;
                    } else s.isSpotLight ? (x = a.get(s), x.position.setFromMatrixPosition(s.matrixWorld), 
                    x.position.applyMatrix4(h), x.color.copy(t).multiplyScalar(u), x.distance = v, x.direction.setFromMatrixPosition(s.matrixWorld), 
                    c.setFromMatrixPosition(s.target.matrixWorld), x.direction.sub(c), x.direction.transformDirection(h), 
                    x.coneCos = Math.cos(s.angle), x.penumbraCos = Math.cos(s.angle * (1 - s.penumbra)), 
                    x.decay = 0 === s.distance ? 0 : s.decay, (x.shadow = s.castShadow) && (t = s.shadow, 
                    x.shadowBias = t.bias, x.shadowRadius = t.radius, x.shadowMapSize = t.mapSize), 
                    b.spotShadowMap[n] = w, b.spotShadowMatrix[n] = s.shadow.matrix, b.spot[n] = x, 
                    n++) : s.isRectAreaLight ? (x = a.get(s), x.color.copy(t).multiplyScalar(u), x.position.setFromMatrixPosition(s.matrixWorld), 
                    x.position.applyMatrix4(h), g.identity(), e.copy(s.matrixWorld), e.premultiply(h), 
                    g.extractRotation(e), x.halfWidth.set(.5 * s.width, 0, 0), x.halfHeight.set(0, .5 * s.height, 0), 
                    x.halfWidth.applyMatrix4(g), x.halfHeight.applyMatrix4(g), b.rectArea[o] = x, o++) : s.isPointLight ? (x = a.get(s), 
                    x.position.setFromMatrixPosition(s.matrixWorld), x.position.applyMatrix4(h), x.color.copy(s.color).multiplyScalar(s.intensity), 
                    x.distance = s.distance, x.decay = 0 === s.distance ? 0 : s.decay, (x.shadow = s.castShadow) && (t = s.shadow, 
                    x.shadowBias = t.bias, x.shadowRadius = t.radius, x.shadowMapSize = t.mapSize, x.shadowCameraNear = t.camera.near, 
                    x.shadowCameraFar = t.camera.far), b.pointShadowMap[m] = w, b.pointShadowMatrix[m] = s.shadow.matrix, 
                    b.point[m] = x, m++) : s.isHemisphereLight && (x = a.get(s), x.direction.setFromMatrixPosition(s.matrixWorld), 
                    x.direction.transformDirection(h), x.direction.normalize(), x.skyColor.copy(s.color).multiplyScalar(u), 
                    x.groundColor.copy(s.groundColor).multiplyScalar(u), b.hemi[p] = x, p++);
                }
                b.ambient[0] = i, b.ambient[1] = j, b.ambient[2] = k, b.directional.length = l, 
                b.spot.length = n, b.rectArea.length = o, b.point.length = m, b.hemi.length = p, 
                b.hash.stateID = b.id, b.hash.directionalLength = l, b.hash.pointLength = m, b.hash.spotLength = n, 
                b.hash.rectAreaLength = o, b.hash.hemiLength = p, b.hash.shadowsLength = f.length;
            },
            state: b
        };
    }
    function ib() {
        var a = new hb(), b = [], c = [];
        return {
            init: function() {
                b.length = 0, c.length = 0;
            },
            state: {
                lightsArray: b,
                shadowsArray: c,
                lights: a
            },
            setupLights: function(d) {
                a.setup(b, c, d);
            },
            pushLight: function(a) {
                b.push(a);
            },
            pushShadow: function(a) {
                c.push(a);
            }
        };
    }
    function jb() {
        var a = {};
        return {
            get: function(b, c) {
                if (void 0 === a[b.id]) {
                    var d = new ib();
                    a[b.id] = {}, a[b.id][c.id] = d;
                } else void 0 === a[b.id][c.id] ? (d = new ib(), a[b.id][c.id] = d) : d = a[b.id][c.id];
                return d;
            },
            dispose: function() {
                a = {};
            }
        };
    }
    function kb(a) {
        R.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, 
        this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, 
        this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, 
        this.setValues(a);
    }
    function lb(a) {
        R.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new f(), 
        this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, 
        this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, 
        this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(a);
    }
    function mb(a, b, e) {
        function g(b, c, d, e, f, g) {
            var h = b.geometry, i = r, j = b.customDepthMaterial;
            return d && (i = s, j = b.customDistanceMaterial), j ? i = j : (j = !1, c.morphTargets && (h && h.isBufferGeometry ? j = h.morphAttributes && h.morphAttributes.position && 0 < h.morphAttributes.position.length : h && h.isGeometry && (j = h.morphTargets && 0 < h.morphTargets.length)), 
            b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), 
            b = b.isSkinnedMesh && c.skinning, h = 0, j && (h |= 1), b && (h |= 2), i = i[h]), 
            a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (h = i.uuid, 
            j = c.uuid, b = t[h], void 0 === b && (b = {}, t[h] = b), h = b[j], void 0 === h && (h = i.clone(), 
            b[j] = h), i = h), i.visible = c.visible, i.wireframe = c.wireframe, i.side = null != c.shadowSide ? c.shadowSide : u[c.side], 
            i.clipShadows = c.clipShadows, i.clippingPlanes = c.clippingPlanes, i.clipIntersection = c.clipIntersection, 
            i.wireframeLinewidth = c.wireframeLinewidth, i.linewidth = c.linewidth, d && i.isMeshDistanceMaterial && (i.referencePosition.copy(e), 
            i.nearDistance = f, i.farDistance = g), i;
        }
        function h(c, d, e, f) {
            if (!1 !== c.visible) {
                if (c.layers.test(d.layers) && (c.isMesh || c.isLine || c.isPoints) && c.castShadow && (!c.frustumCulled || k.intersectsObject(c))) {
                    c.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, c.matrixWorld);
                    var i = b.update(c), j = c.material;
                    if (Array.isArray(j)) for (var l = i.groups, m = 0, n = l.length; m < n; m++) {
                        var o = l[m], p = j[o.materialIndex];
                        p && p.visible && (p = g(c, p, f, q, e.near, e.far), a.renderBufferDirect(e, null, i, p, c, o));
                    } else j.visible && (p = g(c, j, f, q, e.near, e.far), a.renderBufferDirect(e, null, i, p, c, null));
                }
                for (c = c.children, i = 0, j = c.length; i < j; i++) h(c[i], d, e, f);
            }
        }
        var k = new p(), l = new d(), m = new c(), n = new c(e, e), o = new f(), q = new f(), r = Array(4), s = Array(4), t = {}, u = {
            0: 1,
            1: 0,
            2: 2
        }, v = [ new f(1, 0, 0), new f(-1, 0, 0), new f(0, 0, 1), new f(0, 0, -1), new f(0, 1, 0), new f(0, -1, 0) ], w = [ new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 0, 1), new f(0, 0, -1) ], x = [ new i(), new i(), new i(), new i(), new i(), new i() ];
        for (e = 0; 4 !== e; ++e) {
            var y = 0 != (1 & e), z = 0 != (2 & e), A = new kb({
                depthPacking: 3201,
                morphTargets: y,
                skinning: z
            });
            r[e] = A, y = new lb({
                morphTargets: y,
                skinning: z
            }), s[e] = y;
        }
        var B = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(b, c, d) {
            if (!1 !== B.enabled && (!1 !== B.autoUpdate || !1 !== B.needsUpdate) && 0 !== b.length) {
                var e = a.state;
                e.disable(a.context.BLEND), e.buffers.color.setClear(1, 1, 1, 1), e.buffers.depth.setTest(!0), 
                e.setScissorTest(!1);
                for (var f, g = 0, i = b.length; g < i; g++) {
                    var p = b[g];
                    f = p.shadow;
                    var r = p && p.isPointLight;
                    if (void 0 === f) console.warn("THREE.WebGLShadowMap:", p, "has no shadow."); else {
                        var s = f.camera;
                        if (m.copy(f.mapSize), m.min(n), r) {
                            var t = m.x, u = m.y;
                            x[0].set(2 * t, u, t, u), x[1].set(0, u, t, u), x[2].set(3 * t, u, t, u), x[3].set(t, u, t, u), 
                            x[4].set(3 * t, 0, t, u), x[5].set(t, 0, t, u), m.x *= 4, m.y *= 2;
                        }
                        for (null === f.map && (f.map = new j(m.x, m.y, {
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        }), f.map.texture.name = p.name + ".shadowMap", s.updateProjectionMatrix()), f.isSpotLightShadow && f.update(p), 
                        t = f.map, u = f.matrix, q.setFromMatrixPosition(p.matrixWorld), s.position.copy(q), 
                        r ? (f = 6, u.makeTranslation(-q.x, -q.y, -q.z)) : (f = 1, o.setFromMatrixPosition(p.target.matrixWorld), 
                        s.lookAt(o), s.updateMatrixWorld(), u.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), 
                        u.multiply(s.projectionMatrix), u.multiply(s.matrixWorldInverse)), a.setRenderTarget(t), 
                        a.clear(), p = 0; p < f; p++) r && (o.copy(s.position), o.add(v[p]), s.up.copy(w[p]), 
                        s.lookAt(o), s.updateMatrixWorld(), e.viewport(x[p])), l.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), 
                        k.setFromMatrix(l), h(c, d, s, r);
                    }
                }
                B.needsUpdate = !1;
            }
        };
    }
    function nb(a, b, c, d) {
        function e(b, c, d) {
            var e = new Uint8Array(4), f = a.createTexture();
            for (a.bindTexture(b, f), a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST), 
            b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);
            return f;
        }
        function f(c, e) {
            s[c] = 1, 0 === t[c] && (a.enableVertexAttribArray(c), t[c] = 1), u[c] !== e && ((d.isWebGL2 ? a : b.get("ANGLE_instanced_arrays"))[d.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](c, e), 
            u[c] = e);
        }
        function g(b) {
            !0 !== v[b] && (a.enable(b), v[b] = !0);
        }
        function h(b) {
            !1 !== v[b] && (a.disable(b), v[b] = !1);
        }
        function j(b, d, e, f, i, j, k, l) {
            if (0 === b) y && (h(a.BLEND), y = !1); else if (y || (g(a.BLEND), y = !0), 5 !== b) {
                if (b !== z || l !== G) {
                    if (100 === A && 100 === D || (a.blendEquation(a.FUNC_ADD), D = A = 100), l) switch (b) {
                      case 1:
                        a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA);
                        break;

                      case 2:
                        a.blendFunc(a.ONE, a.ONE);
                        break;

                      case 3:
                        a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA);
                        break;

                      case 4:
                        a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA);
                        break;

                      default:
                        console.error("THREE.WebGLState: Invalid blending: ", b);
                    } else switch (b) {
                      case 1:
                        a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA);
                        break;

                      case 2:
                        a.blendFunc(a.SRC_ALPHA, a.ONE);
                        break;

                      case 3:
                        a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR);
                        break;

                      case 4:
                        a.blendFunc(a.ZERO, a.SRC_COLOR);
                        break;

                      default:
                        console.error("THREE.WebGLState: Invalid blending: ", b);
                    }
                    F = E = C = B = null, z = b, G = l;
                }
            } else i = i || d, j = j || e, k = k || f, d === A && i === D || (a.blendEquationSeparate(c.convert(d), c.convert(i)), 
            A = d, D = i), e === B && f === C && j === E && k === F || (a.blendFuncSeparate(c.convert(e), c.convert(f), c.convert(j), c.convert(k)), 
            B = e, C = f, E = j, F = k), z = b, G = null;
        }
        function k(b) {
            H !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), H = b);
        }
        function l(b) {
            0 !== b ? (g(a.CULL_FACE), b !== I && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : h(a.CULL_FACE), 
            I = b;
        }
        function m(b, c, d) {
            b ? (g(a.POLYGON_OFFSET_FILL), (K !== c || L !== d) && (a.polygonOffset(c, d), K = c, 
            L = d)) : h(a.POLYGON_OFFSET_FILL);
        }
        function n(b) {
            void 0 === b && (b = a.TEXTURE0 + M - 1), O !== b && (a.activeTexture(b), O = b);
        }
        var o = new function() {
            var b = !1, c = new i(), d = null, e = new i(0, 0, 0, 0);
            return {
                setMask: function(c) {
                    d === c || b || (a.colorMask(c, c, c, c), d = c);
                },
                setLocked: function(a) {
                    b = a;
                },
                setClear: function(b, d, f, g, h) {
                    !0 === h && (b *= g, d *= g, f *= g), c.set(b, d, f, g), !1 === e.equals(c) && (a.clearColor(b, d, f, g), 
                    e.copy(c));
                },
                reset: function() {
                    b = !1, d = null, e.set(-1, 0, 0, 0);
                }
            };
        }(), p = new function() {
            var b = !1, c = null, d = null, e = null;
            return {
                setTest: function(b) {
                    b ? g(a.DEPTH_TEST) : h(a.DEPTH_TEST);
                },
                setMask: function(d) {
                    c === d || b || (a.depthMask(d), c = d);
                },
                setFunc: function(b) {
                    if (d !== b) {
                        if (b) switch (b) {
                          case 0:
                            a.depthFunc(a.NEVER);
                            break;

                          case 1:
                            a.depthFunc(a.ALWAYS);
                            break;

                          case 2:
                            a.depthFunc(a.LESS);
                            break;

                          case 3:
                            a.depthFunc(a.LEQUAL);
                            break;

                          case 4:
                            a.depthFunc(a.EQUAL);
                            break;

                          case 5:
                            a.depthFunc(a.GEQUAL);
                            break;

                          case 6:
                            a.depthFunc(a.GREATER);
                            break;

                          case 7:
                            a.depthFunc(a.NOTEQUAL);
                            break;

                          default:
                            a.depthFunc(a.LEQUAL);
                        } else a.depthFunc(a.LEQUAL);
                        d = b;
                    }
                },
                setLocked: function(a) {
                    b = a;
                },
                setClear: function(b) {
                    e !== b && (a.clearDepth(b), e = b);
                },
                reset: function() {
                    b = !1, e = d = c = null;
                }
            };
        }(), q = new function() {
            var b = !1, c = null, d = null, e = null, f = null, i = null, j = null, k = null, l = null;
            return {
                setTest: function(b) {
                    b ? g(a.STENCIL_TEST) : h(a.STENCIL_TEST);
                },
                setMask: function(d) {
                    c === d || b || (a.stencilMask(d), c = d);
                },
                setFunc: function(b, c, g) {
                    d === b && e === c && f === g || (a.stencilFunc(b, c, g), d = b, e = c, f = g);
                },
                setOp: function(b, c, d) {
                    i === b && j === c && k === d || (a.stencilOp(b, c, d), i = b, j = c, k = d);
                },
                setLocked: function(a) {
                    b = a;
                },
                setClear: function(b) {
                    l !== b && (a.clearStencil(b), l = b);
                },
                reset: function() {
                    b = !1, l = k = j = i = f = e = d = c = null;
                }
            };
        }(), r = a.getParameter(a.MAX_VERTEX_ATTRIBS), s = new Uint8Array(r), t = new Uint8Array(r), u = new Uint8Array(r), v = {}, w = null, x = null, y = null, z = null, A = null, B = null, C = null, D = null, E = null, F = null, G = !1, H = null, I = null, J = null, K = null, L = null, M = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS), N = !1;
        r = 0, r = a.getParameter(a.VERSION), -1 !== r.indexOf("WebGL") ? (r = parseFloat(/^WebGL ([0-9])/.exec(r)[1]), 
        N = 1 <= r) : -1 !== r.indexOf("OpenGL ES") && (r = parseFloat(/^OpenGL ES ([0-9])/.exec(r)[1]), 
        N = 2 <= r);
        var O = null, P = {}, Q = new i(), R = new i(), S = {};
        return S[a.TEXTURE_2D] = e(a.TEXTURE_2D, a.TEXTURE_2D, 1), S[a.TEXTURE_CUBE_MAP] = e(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6), 
        o.setClear(0, 0, 0, 1), p.setClear(1), q.setClear(0), g(a.DEPTH_TEST), p.setFunc(3), 
        k(!1), l(1), g(a.CULL_FACE), j(0), {
            buffers: {
                color: o,
                depth: p,
                stencil: q
            },
            initAttributes: function() {
                for (var a = 0, b = s.length; a < b; a++) s[a] = 0;
            },
            enableAttribute: function(a) {
                f(a, 0);
            },
            enableAttributeAndDivisor: f,
            disableUnusedAttributes: function() {
                for (var b = 0, c = t.length; b !== c; ++b) t[b] !== s[b] && (a.disableVertexAttribArray(b), 
                t[b] = 0);
            },
            enable: g,
            disable: h,
            getCompressedTextureFormats: function() {
                if (null === w && (w = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1") || b.get("WEBGL_compressed_texture_astc"))) for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) w.push(c[d]);
                return w;
            },
            useProgram: function(b) {
                return x !== b && (a.useProgram(b), x = b, !0);
            },
            setBlending: j,
            setMaterial: function(b, c) {
                2 === b.side ? h(a.CULL_FACE) : g(a.CULL_FACE);
                var d = 1 === b.side;
                c && (d = !d), k(d), 1 === b.blending && !1 === b.transparent ? j(0) : j(b.blending, b.blendEquation, b.blendSrc, b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha), 
                p.setFunc(b.depthFunc), p.setTest(b.depthTest), p.setMask(b.depthWrite), o.setMask(b.colorWrite), 
                m(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits);
            },
            setFlipSided: k,
            setCullFace: l,
            setLineWidth: function(b) {
                b !== J && (N && a.lineWidth(b), J = b);
            },
            setPolygonOffset: m,
            setScissorTest: function(b) {
                b ? g(a.SCISSOR_TEST) : h(a.SCISSOR_TEST);
            },
            activeTexture: n,
            bindTexture: function(b, c) {
                null === O && n();
                var d = P[O];
                void 0 === d && (d = {
                    type: void 0,
                    texture: void 0
                }, P[O] = d), d.type === b && d.texture === c || (a.bindTexture(b, c || S[b]), d.type = b, 
                d.texture = c);
            },
            compressedTexImage2D: function() {
                try {
                    a.compressedTexImage2D.apply(a, arguments);
                } catch (a) {
                    console.error("THREE.WebGLState:", a);
                }
            },
            texImage2D: function() {
                try {
                    a.texImage2D.apply(a, arguments);
                } catch (a) {
                    console.error("THREE.WebGLState:", a);
                }
            },
            scissor: function(b) {
                !1 === Q.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), Q.copy(b));
            },
            viewport: function(b) {
                !1 === R.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), R.copy(b));
            },
            reset: function() {
                for (var b = 0; b < t.length; b++) 1 === t[b] && (a.disableVertexAttribArray(b), 
                t[b] = 0);
                v = {}, O = w = null, P = {}, I = H = z = x = null, o.reset(), p.reset(), q.reset();
            }
        };
    }
    function ob(a, b, c, d, e, f, g) {
        function h(a, b) {
            if (a.width > b || a.height > b) {
                if ("data" in a) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + a.width + "x" + a.height + ").");
                b /= Math.max(a.width, a.height);
                var c = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return c.width = Math.floor(a.width * b), c.height = Math.floor(a.height * b), c.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, c.width, c.height), 
                console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + c.width + "x" + c.height), 
                c;
            }
            return a;
        }
        function i(a) {
            return _e.isPowerOfTwo(a.width) && _e.isPowerOfTwo(a.height);
        }
        function j(a, b) {
            return a.generateMipmaps && b && 1003 !== a.minFilter && 1006 !== a.minFilter;
        }
        function k(b, c, e, f) {
            a.generateMipmap(b), d.get(c).__maxMipLevel = Math.log(Math.max(e, f)) * Math.LOG2E;
        }
        function l(b, c) {
            if (!e.isWebGL2) return b;
            if (b === a.RGB) {
                if (c === a.FLOAT) return a.RGB32F;
                if (c === a.HALF_FLOAT) return a.RGB16F;
                if (c === a.UNSIGNED_BYTE) return a.RGB8;
            }
            if (b === a.RGBA) {
                if (c === a.FLOAT) return a.RGBA32F;
                if (c === a.HALF_FLOAT) return a.RGBA16F;
                if (c === a.UNSIGNED_BYTE) return a.RGBA8;
            }
            return b;
        }
        function m(b) {
            return 1003 === b || 1004 === b || 1005 === b ? a.NEAREST : a.LINEAR;
        }
        function n(b) {
            b = b.target, b.removeEventListener("dispose", n);
            a: {
                var c = d.get(b);
                if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube); else {
                    if (void 0 === c.__webglInit) break a;
                    a.deleteTexture(c.__webglTexture);
                }
                d.remove(b);
            }
            b.isVideoTexture && delete u[b.id], g.memory.textures--;
        }
        function o(b) {
            b = b.target, b.removeEventListener("dispose", o);
            var c = d.get(b), e = d.get(b.texture);
            if (b) {
                if (void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture), b.depthTexture && b.depthTexture.dispose(), 
                b.isWebGLRenderTargetCube) for (e = 0; 6 > e; e++) a.deleteFramebuffer(c.__webglFramebuffer[e]), 
                c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]); else a.deleteFramebuffer(c.__webglFramebuffer), 
                c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
                d.remove(b.texture), d.remove(b);
            }
            g.memory.textures--;
        }
        function p(b, m) {
            var o = d.get(b);
            if (b.isVideoTexture) {
                var p = b.id, r = g.render.frame;
                u[p] !== r && (u[p] = r, b.update());
            }
            if (0 < b.version && o.__version !== b.version) if (void 0 === (p = b.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
                if (!1 !== p.complete) {
                    void 0 === o.__webglInit && (o.__webglInit = !0, b.addEventListener("dispose", n), 
                    o.__webglTexture = a.createTexture(), g.memory.textures++), c.activeTexture(a.TEXTURE0 + m), 
                    c.bindTexture(a.TEXTURE_2D, o.__webglTexture), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY), 
                    a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha), a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment), 
                    m = h(b.image, e.maxTextureSize), (e.isWebGL2 ? 0 : 1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter) && !1 === i(m) && (m instanceof HTMLImageElement || m instanceof HTMLCanvasElement || m instanceof ImageBitmap) && (void 0 === t && (t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), 
                    t.width = _e.floorPowerOfTwo(m.width), t.height = _e.floorPowerOfTwo(m.height), 
                    t.getContext("2d").drawImage(m, 0, 0, t.width, t.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + m.width + "x" + m.height + "). Resized to " + t.width + "x" + t.height), 
                    m = t), p = i(m), r = f.convert(b.format);
                    var s = f.convert(b.type), v = l(r, s);
                    q(a.TEXTURE_2D, b, p);
                    var w = b.mipmaps;
                    if (b.isDepthTexture) {
                        if (v = a.DEPTH_COMPONENT, 1015 === b.type) {
                            if (!e.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
                            v = a.DEPTH_COMPONENT32F;
                        } else e.isWebGL2 && (v = a.DEPTH_COMPONENT16);
                        1026 === b.format && v === a.DEPTH_COMPONENT && 1012 !== b.type && 1014 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), 
                        b.type = 1012, s = f.convert(b.type)), 1027 === b.format && (v = a.DEPTH_STENCIL, 
                        1020 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), 
                        b.type = 1020, s = f.convert(b.type))), c.texImage2D(a.TEXTURE_2D, 0, v, m.width, m.height, 0, r, s, null);
                    } else if (b.isDataTexture) if (0 < w.length && p) {
                        for (var x = 0, y = w.length; x < y; x++) {
                            var z = w[x];
                            c.texImage2D(a.TEXTURE_2D, x, v, z.width, z.height, 0, r, s, z.data);
                        }
                        b.generateMipmaps = !1, o.__maxMipLevel = w.length - 1;
                    } else c.texImage2D(a.TEXTURE_2D, 0, v, m.width, m.height, 0, r, s, m.data), o.__maxMipLevel = 0; else if (b.isCompressedTexture) {
                        for (x = 0, y = w.length; x < y; x++) z = w[x], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(r) ? c.compressedTexImage2D(a.TEXTURE_2D, x, v, z.width, z.height, 0, z.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(a.TEXTURE_2D, x, v, z.width, z.height, 0, r, s, z.data);
                        o.__maxMipLevel = w.length - 1;
                    } else if (0 < w.length && p) {
                        for (x = 0, y = w.length; x < y; x++) z = w[x], c.texImage2D(a.TEXTURE_2D, x, v, r, s, z);
                        b.generateMipmaps = !1, o.__maxMipLevel = w.length - 1;
                    } else c.texImage2D(a.TEXTURE_2D, 0, v, r, s, m), o.__maxMipLevel = 0;
                    return j(b, p) && k(a.TEXTURE_2D, b, m.width, m.height), o.__version = b.version, 
                    void (b.onUpdate && b.onUpdate(b));
                }
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
            c.activeTexture(a.TEXTURE0 + m), c.bindTexture(a.TEXTURE_2D, o.__webglTexture);
        }
        function q(c, g, h) {
            h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f.convert(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f.convert(g.wrapT)), 
            a.texParameteri(c, a.TEXTURE_MAG_FILTER, f.convert(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f.convert(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), 
            a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), 
            a.texParameteri(c, a.TEXTURE_MAG_FILTER, m(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, m(g.minFilter)), 
            1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), 
            !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === (e.isWebGL2 || b.get("OES_texture_half_float_linear")) || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), 
            d.get(g).__currentAnisotropy = g.anisotropy);
        }
        function r(b, e, g, h) {
            var i = f.convert(e.texture.format), j = f.convert(e.texture.type), k = l(i, j);
            c.texImage2D(h, 0, k, e.width, e.height, 0, i, j, null), a.bindFramebuffer(a.FRAMEBUFFER, b), 
            a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0), 
            a.bindFramebuffer(a.FRAMEBUFFER, null);
        }
        function s(b, c) {
            a.bindRenderbuffer(a.RENDERBUFFER, b), c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height), 
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), 
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height), 
            a.bindRenderbuffer(a.RENDERBUFFER, null);
        }
        var t, u = {};
        this.setTexture2D = p, this.setTextureCube = function(b, m) {
            var o = d.get(b);
            if (6 === b.image.length) if (0 < b.version && o.__version !== b.version) {
                o.__image__webglTextureCube || (b.addEventListener("dispose", n), o.__image__webglTextureCube = a.createTexture(), 
                g.memory.textures++), c.activeTexture(a.TEXTURE0 + m), c.bindTexture(a.TEXTURE_CUBE_MAP, o.__image__webglTextureCube), 
                a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY), m = b && b.isCompressedTexture;
                for (var p = b.image[0] && b.image[0].isDataTexture, r = [], s = 0; 6 > s; s++) r[s] = m || p ? p ? b.image[s].image : b.image[s] : h(b.image[s], e.maxCubemapSize);
                var t = r[0], u = i(t), v = f.convert(b.format), w = f.convert(b.type), x = l(v, w);
                for (q(a.TEXTURE_CUBE_MAP, b, u), s = 0; 6 > s; s++) if (m) for (var y, z = r[s].mipmaps, A = 0, B = z.length; A < B; A++) y = z[A], 
                1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(v) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + s, A, x, y.width, y.height, 0, y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + s, A, x, y.width, y.height, 0, v, w, y.data); else p ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, x, r[s].width, r[s].height, 0, v, w, r[s].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, x, v, w, r[s]);
                o.__maxMipLevel = m ? z.length - 1 : 0, j(b, u) && k(a.TEXTURE_CUBE_MAP, b, t.width, t.height), 
                o.__version = b.version, b.onUpdate && b.onUpdate(b);
            } else c.activeTexture(a.TEXTURE0 + m), c.bindTexture(a.TEXTURE_CUBE_MAP, o.__image__webglTextureCube);
        }, this.setTextureCubeDynamic = function(b, e) {
            c.activeTexture(a.TEXTURE0 + e), c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture);
        }, this.setupRenderTarget = function(b) {
            var e = d.get(b), f = d.get(b.texture);
            b.addEventListener("dispose", o), f.__webglTexture = a.createTexture(), g.memory.textures++;
            var h = !0 === b.isWebGLRenderTargetCube, l = i(b);
            if (h) {
                e.__webglFramebuffer = [];
                for (var m = 0; 6 > m; m++) e.__webglFramebuffer[m] = a.createFramebuffer();
            } else e.__webglFramebuffer = a.createFramebuffer();
            if (h) {
                for (c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture), q(a.TEXTURE_CUBE_MAP, b.texture, l), 
                m = 0; 6 > m; m++) r(e.__webglFramebuffer[m], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + m);
                j(b.texture, l) && k(a.TEXTURE_CUBE_MAP, b.texture, b.width, b.height), c.bindTexture(a.TEXTURE_CUBE_MAP, null);
            } else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), q(a.TEXTURE_2D, b.texture, l), 
            r(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), j(b.texture, l) && k(a.TEXTURE_2D, b.texture, b.width, b.height), 
            c.bindTexture(a.TEXTURE_2D, null);
            if (b.depthBuffer) {
                if (e = d.get(b), f = !0 === b.isWebGLRenderTargetCube, b.depthTexture) {
                    if (f) throw Error("target.depthTexture not supported in Cube render targets");
                    if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                    if (a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), !b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (d.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, 
                    b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0), p(b.depthTexture, 0), 
                    e = d.get(b.depthTexture).__webglTexture, 1026 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0); else {
                        if (1027 !== b.depthTexture.format) throw Error("Unknown depthTexture format");
                        a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0);
                    }
                } else if (f) for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++) a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer[f]), 
                e.__webglDepthbuffer[f] = a.createRenderbuffer(), s(e.__webglDepthbuffer[f], b); else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), 
                e.__webglDepthbuffer = a.createRenderbuffer(), s(e.__webglDepthbuffer, b);
                a.bindFramebuffer(a.FRAMEBUFFER, null);
            }
        }, this.updateRenderTargetMipmap = function(b) {
            var e = b.texture, f = i(b);
            if (j(e, f)) {
                f = b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D;
                var g = d.get(e).__webglTexture;
                c.bindTexture(f, g), k(f, e, b.width, b.height), c.bindTexture(f, null);
            }
        };
    }
    function pb(a, b, c) {
        return {
            convert: function(d) {
                if (1e3 === d) return a.REPEAT;
                if (1001 === d) return a.CLAMP_TO_EDGE;
                if (1002 === d) return a.MIRRORED_REPEAT;
                if (1003 === d) return a.NEAREST;
                if (1004 === d) return a.NEAREST_MIPMAP_NEAREST;
                if (1005 === d) return a.NEAREST_MIPMAP_LINEAR;
                if (1006 === d) return a.LINEAR;
                if (1007 === d) return a.LINEAR_MIPMAP_NEAREST;
                if (1008 === d) return a.LINEAR_MIPMAP_LINEAR;
                if (1009 === d) return a.UNSIGNED_BYTE;
                if (1017 === d) return a.UNSIGNED_SHORT_4_4_4_4;
                if (1018 === d) return a.UNSIGNED_SHORT_5_5_5_1;
                if (1019 === d) return a.UNSIGNED_SHORT_5_6_5;
                if (1010 === d) return a.BYTE;
                if (1011 === d) return a.SHORT;
                if (1012 === d) return a.UNSIGNED_SHORT;
                if (1013 === d) return a.INT;
                if (1014 === d) return a.UNSIGNED_INT;
                if (1015 === d) return a.FLOAT;
                if (1016 === d) {
                    if (c.isWebGL2) return a.HALF_FLOAT;
                    var e = b.get("OES_texture_half_float");
                    if (null !== e) return e.HALF_FLOAT_OES;
                }
                if (1021 === d) return a.ALPHA;
                if (1022 === d) return a.RGB;
                if (1023 === d) return a.RGBA;
                if (1024 === d) return a.LUMINANCE;
                if (1025 === d) return a.LUMINANCE_ALPHA;
                if (1026 === d) return a.DEPTH_COMPONENT;
                if (1027 === d) return a.DEPTH_STENCIL;
                if (100 === d) return a.FUNC_ADD;
                if (101 === d) return a.FUNC_SUBTRACT;
                if (102 === d) return a.FUNC_REVERSE_SUBTRACT;
                if (200 === d) return a.ZERO;
                if (201 === d) return a.ONE;
                if (202 === d) return a.SRC_COLOR;
                if (203 === d) return a.ONE_MINUS_SRC_COLOR;
                if (204 === d) return a.SRC_ALPHA;
                if (205 === d) return a.ONE_MINUS_SRC_ALPHA;
                if (206 === d) return a.DST_ALPHA;
                if (207 === d) return a.ONE_MINUS_DST_ALPHA;
                if (208 === d) return a.DST_COLOR;
                if (209 === d) return a.ONE_MINUS_DST_COLOR;
                if (210 === d) return a.SRC_ALPHA_SATURATE;
                if ((33776 === d || 33777 === d || 33778 === d || 33779 === d) && null !== (e = b.get("WEBGL_compressed_texture_s3tc"))) {
                    if (33776 === d) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === d) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === d) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === d) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
                if ((35840 === d || 35841 === d || 35842 === d || 35843 === d) && null !== (e = b.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (35840 === d) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === d) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === d) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === d) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
                if (36196 === d && null !== (e = b.get("WEBGL_compressed_texture_etc1"))) return e.COMPRESSED_RGB_ETC1_WEBGL;
                if ((37808 === d || 37809 === d || 37810 === d || 37811 === d || 37812 === d || 37813 === d || 37814 === d || 37815 === d || 37816 === d || 37817 === d || 37818 === d || 37819 === d || 37820 === d || 37821 === d) && null !== (e = b.get("WEBGL_compressed_texture_astc"))) return d;
                if (103 === d || 104 === d) {
                    if (c.isWebGL2) {
                        if (103 === d) return a.MIN;
                        if (104 === d) return a.MAX;
                    }
                    if (null !== (e = b.get("EXT_blend_minmax"))) {
                        if (103 === d) return e.MIN_EXT;
                        if (104 === d) return e.MAX_EXT;
                    }
                }
                if (1020 === d) {
                    if (c.isWebGL2) return a.UNSIGNED_INT_24_8;
                    if (null !== (e = b.get("WEBGL_depth_texture"))) return e.UNSIGNED_INT_24_8_WEBGL;
                }
                return 0;
            }
        };
    }
    function qb() {
        v.call(this), this.type = "Group";
    }
    function rb(a, b, c, d) {
        w.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== a ? a : 50, 
        this.zoom = 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, 
        this.focus = 10, this.aspect = void 0 !== b ? b : 1, this.view = null, this.filmGauge = 35, 
        this.filmOffset = 0, this.updateProjectionMatrix();
    }
    function sb(a) {
        rb.call(this), this.cameras = a || [];
    }
    function tb(a) {
        function b() {
            return null !== h && !0 === h.isPresenting;
        }
        function c() {
            if (b()) {
                var c = h.getEyeParameters("left"), d = c.renderWidth;
                c = c.renderHeight, x = a.getPixelRatio(), w = a.getSize(), a.setDrawingBufferSize(2 * d, c, 1), 
                z.start();
            } else g.enabled && a.setDrawingBufferSize(w.width, w.height, x), z.stop();
        }
        var g = this, h = null, j = null, k = null, l = [], m = new d(), n = new d(), o = "stage";
        "undefined" != typeof window && "VRFrameData" in window && (j = new window.VRFrameData(), 
        window.addEventListener("vrdisplaypresentchange", c, !1));
        var p = new d(), q = new e(), s = new f(), t = new rb();
        t.bounds = new i(0, 0, .5, 1), t.layers.enable(1);
        var u = new rb();
        u.bounds = new i(.5, 0, .5, 1), u.layers.enable(2);
        var v = new sb([ t, u ]);
        v.layers.enable(1), v.layers.enable(2);
        var w, x, y = [];
        this.enabled = !1, this.getController = function(a) {
            var b = l[a];
            return void 0 === b && (b = new qb(), b.matrixAutoUpdate = !1, b.visible = !1, l[a] = b), 
            b;
        }, this.getDevice = function() {
            return h;
        }, this.setDevice = function(a) {
            void 0 !== a && (h = a), z.setContext(a);
        }, this.setFrameOfReferenceType = function(a) {
            o = a;
        }, this.setPoseTarget = function(a) {
            void 0 !== a && (k = a);
        }, this.getCamera = function(a) {
            var b = "stage" === o ? 1.6 : 0;
            if (null === h) return a.position.set(0, b, 0), a;
            if (h.depthNear = a.near, h.depthFar = a.far, h.getFrameData(j), "stage" === o) {
                var c = h.stageParameters;
                c ? m.fromArray(c.sittingToStandingTransform) : m.makeTranslation(0, b, 0);
            }
            if (b = j.pose, c = null !== k ? k : a, c.matrix.copy(m), c.matrix.decompose(c.position, c.quaternion, c.scale), 
            null !== b.orientation && (q.fromArray(b.orientation), c.quaternion.multiply(q)), 
            null !== b.position && (q.setFromRotationMatrix(m), s.fromArray(b.position), s.applyQuaternion(q), 
            c.position.add(s)), c.updateMatrixWorld(), !1 === h.isPresenting) return a;
            t.near = a.near, u.near = a.near, t.far = a.far, u.far = a.far, v.matrixWorld.copy(a.matrixWorld), 
            v.matrixWorldInverse.copy(a.matrixWorldInverse), t.matrixWorldInverse.fromArray(j.leftViewMatrix), 
            u.matrixWorldInverse.fromArray(j.rightViewMatrix), n.getInverse(m), "stage" === o && (t.matrixWorldInverse.multiply(n), 
            u.matrixWorldInverse.multiply(n)), a = c.parent, null !== a && (p.getInverse(a.matrixWorld), 
            t.matrixWorldInverse.multiply(p), u.matrixWorldInverse.multiply(p)), t.matrixWorld.getInverse(t.matrixWorldInverse), 
            u.matrixWorld.getInverse(u.matrixWorldInverse), t.projectionMatrix.fromArray(j.leftProjectionMatrix), 
            u.projectionMatrix.fromArray(j.rightProjectionMatrix), v.projectionMatrix.copy(t.projectionMatrix), 
            a = h.getLayers(), a.length && (a = a[0], null !== a.leftBounds && 4 === a.leftBounds.length && t.bounds.fromArray(a.leftBounds), 
            null !== a.rightBounds && 4 === a.rightBounds.length && u.bounds.fromArray(a.rightBounds));
            a: for (a = 0; a < l.length; a++) {
                b = l[a];
                b: {
                    c = a;
                    for (var d = navigator.getGamepads && navigator.getGamepads(), e = 0, f = 0, g = d.length; e < g; e++) {
                        var i = d[e];
                        if (i && ("Daydream Controller" === i.id || "Gear VR Controller" === i.id || "Oculus Go Controller" === i.id || "OpenVR Gamepad" === i.id || i.id.startsWith("Oculus Touch") || i.id.startsWith("Spatial Controller"))) {
                            if (f === c) {
                                c = i;
                                break b;
                            }
                            f++;
                        }
                    }
                    c = void 0;
                }
                if (void 0 !== c && void 0 !== c.pose) {
                    if (null === c.pose) break a;
                    d = c.pose, !1 === d.hasPosition && b.position.set(.2, -.6, -.05), null !== d.position && b.position.fromArray(d.position), 
                    null !== d.orientation && b.quaternion.fromArray(d.orientation), b.matrix.compose(b.position, b.quaternion, b.scale), 
                    b.matrix.premultiply(m), b.matrix.decompose(b.position, b.quaternion, b.scale), 
                    b.matrixWorldNeedsUpdate = !0, b.visible = !0, d = "Daydream Controller" === c.id ? 0 : 1, 
                    y[a] !== c.buttons[d].pressed && (y[a] = c.buttons[d].pressed, !0 === y[a] ? b.dispatchEvent({
                        type: "selectstart"
                    }) : (b.dispatchEvent({
                        type: "selectend"
                    }), b.dispatchEvent({
                        type: "select"
                    })));
                } else b.visible = !1;
            }
            return v;
        }, this.getStandingMatrix = function() {
            return m;
        }, this.isPresenting = b;
        var z = new r();
        this.setAnimationLoop = function(a) {
            z.setAnimationLoop(a);
        }, this.submitFrame = function() {
            b() && h.submitFrame();
        }, this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", c);
        };
    }
    function ub(a) {
        function b() {
            return null !== h && null !== j;
        }
        function c(a) {
            var b = m[n.indexOf(a.inputSource)];
            b && b.dispatchEvent({
                type: a.type
            });
        }
        function d() {
            a.setFramebuffer(null), t.stop();
        }
        function e(a, b) {
            null === b ? a.matrixWorld.copy(a.matrix) : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix), 
            a.matrixWorldInverse.getInverse(a.matrixWorld);
        }
        var f = a.context, g = null, h = null, j = null, k = "stage", l = null, m = [], n = [], o = new rb();
        o.layers.enable(1), o.viewport = new i();
        var p = new rb();
        p.layers.enable(2), p.viewport = new i();
        var q = new sb([ o, p ]);
        q.layers.enable(1), q.layers.enable(2), this.enabled = !1, this.getController = function(a) {
            var b = m[a];
            return void 0 === b && (b = new qb(), b.matrixAutoUpdate = !1, b.visible = !1, m[a] = b), 
            b;
        }, this.getDevice = function() {
            return g;
        }, this.setDevice = function(a) {
            void 0 !== a && (g = a), a instanceof XRDevice && f.setCompatibleXRDevice(a);
        }, this.setFrameOfReferenceType = function(a) {
            k = a;
        }, this.setSession = function(b) {
            null !== (h = b) && (h.addEventListener("select", c), h.addEventListener("selectstart", c), 
            h.addEventListener("selectend", c), h.addEventListener("end", d), h.baseLayer = new XRWebGLLayer(h, f), 
            h.requestFrameOfReference(k).then(function(b) {
                j = b, a.setFramebuffer(h.baseLayer.framebuffer), t.setContext(h), t.start();
            }), n = h.getInputSources(), h.addEventListener("inputsourceschange", function() {
                n = h.getInputSources(), console.log(n);
            }));
        }, this.getCamera = function(a) {
            if (b()) {
                var c = a.parent, d = q.cameras;
                e(q, c);
                for (var f = 0; f < d.length; f++) e(d[f], c);
                for (a.matrixWorld.copy(q.matrixWorld), a = a.children, f = 0, c = a.length; f < c; f++) a[f].updateMatrixWorld(!0);
                return q;
            }
            return a;
        }, this.isPresenting = b;
        var s = null, t = new r();
        t.setAnimationLoop(function(a, b) {
            if (null !== (l = b.getDevicePose(j))) for (var c = h.baseLayer, d = b.views, e = 0; e < d.length; e++) {
                var f = d[e], g = c.getViewport(f), i = l.getViewMatrix(f), k = q.cameras[e];
                k.matrix.fromArray(i).getInverse(k.matrix), k.projectionMatrix.fromArray(f.projectionMatrix), 
                k.viewport.set(g.x, g.y, g.width, g.height), 0 === e && (q.matrix.copy(k.matrix), 
                q.projectionMatrix.copy(k.projectionMatrix));
            }
            for (e = 0; e < m.length; e++) c = m[e], (d = n[e]) && null !== (d = b.getInputPose(d, j)) ? ("targetRay" in d ? c.matrix.elements = d.targetRay.transformMatrix : "pointerMatrix" in d && (c.matrix.elements = d.pointerMatrix), 
            c.matrix.decompose(c.position, c.rotation, c.scale), c.visible = !0) : c.visible = !1;
            s && s(a);
        }), this.setAnimationLoop = function(a) {
            s = a;
        }, this.dispose = function() {}, this.getStandingMatrix = function() {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), 
            new THREE.Matrix4();
        }, this.submitFrame = function() {};
    }
    function vb(a) {
        function b() {
            ra = new _(qa), sa = new Z(qa, ra, a), sa.isWebGL2 || (ra.get("WEBGL_depth_texture"), 
            ra.get("OES_texture_float"), ra.get("OES_texture_half_float"), ra.get("OES_texture_half_float_linear"), 
            ra.get("OES_standard_derivatives"), ra.get("OES_element_index_uint"), ra.get("ANGLE_instanced_arrays")), 
            ra.get("OES_texture_float_linear"), Ha = new pb(qa, ra, sa), ta = new nb(qa, ra, Ha, sa), 
            ta.scissor(T.copy(ia).multiplyScalar(ga)), ta.viewport(S.copy(ha).multiplyScalar(ga)), 
            ua = new ca(qa), va = new bb(), wa = new ob(qa, ra, ta, va, sa, Ha, ua), xa = new s(qa), 
            ya = new aa(qa, xa, ua), za = new fa(ya, ua), Ea = new ea(qa), Aa = new ab(I, ra, sa), 
            Ba = new fb(), Ca = new jb(), Da = new X(I, ta, za, D), Fa = new Y(qa, ra, ua, sa), 
            Ga = new ba(qa, ra, ua, sa), ua.programs = Aa.programs, I.context = qa, I.capabilities = sa, 
            I.extensions = ra, I.properties = va, I.renderLists = Ba, I.state = ta, I.info = ua;
        }
        function c(a) {
            a.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), J = !0;
        }
        function e() {
            console.log("THREE.WebGLRenderer: Context Restored."), J = !1, b();
        }
        function g(a) {
            a = a.target, a.removeEventListener("dispose", g), h(a), va.remove(a);
        }
        function h(a) {
            var b = va.get(a).program;
            a.program = void 0, void 0 !== b && Aa.releaseProgram(b);
        }
        function j(a, b) {
            a.render(function(a) {
                I.renderBufferImmediate(a, b);
            });
        }
        function k(a, b, c) {
            if (!1 !== a.visible) {
                if (a.layers.test(b.layers)) if (a.isLight) H.pushLight(a), a.castShadow && H.pushShadow(a); else if (a.isSprite) {
                    if (!a.frustumCulled || ka.intersectsSprite(a)) {
                        c && pa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(oa);
                        var d = za.update(a), e = a.material;
                        G.push(a, d, e, pa.z, null);
                    }
                } else if (a.isImmediateRenderObject) c && pa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(oa), 
                G.push(a, null, a.material, pa.z, null); else if ((a.isMesh || a.isLine || a.isPoints) && (a.isSkinnedMesh && a.skeleton.update(), 
                !a.frustumCulled || ka.intersectsObject(a))) if (c && pa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(oa), 
                d = za.update(a), e = a.material, Array.isArray(e)) for (var f = d.groups, g = 0, h = f.length; g < h; g++) {
                    var i = f[g], j = e[i.materialIndex];
                    j && j.visible && G.push(a, d, j, pa.z, i);
                } else e.visible && G.push(a, d, e, pa.z, null);
                for (a = a.children, g = 0, h = a.length; g < h; g++) k(a[g], b, c);
            }
        }
        function m(a, b, c, d) {
            for (var e = 0, f = a.length; e < f; e++) {
                var g = a[e], h = g.object, i = g.geometry, j = void 0 === d ? g.material : d;
                if (g = g.group, c.isArrayCamera) {
                    R = c;
                    for (var k = c.cameras, l = 0, m = k.length; l < m; l++) {
                        var o = k[l];
                        if (h.layers.test(o.layers)) {
                            if ("viewport" in o) ta.viewport(S.copy(o.viewport)); else {
                                var p = o.bounds;
                                ta.viewport(S.set(p.x * W, p.y * da, p.z * W, p.w * da).multiplyScalar(ga));
                            }
                            H.setupLights(o), n(h, b, o, i, j, g);
                        }
                    }
                } else R = null, n(h, b, c, i, j, g);
            }
        }
        function n(a, b, c, d, e, f) {
            if (a.onBeforeRender(I, b, c, d, e, f), H = Ca.get(b, R || c), a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), 
            a.normalMatrix.getNormalMatrix(a.modelViewMatrix), a.isImmediateRenderObject) {
                ta.setMaterial(e);
                var g = q(c, b.fog, e, a);
                O = w = null, P = !1, j(a, g);
            } else I.renderBufferDirect(c, b.fog, d, e, a, f);
            a.onAfterRender(I, b, c, d, e, f), H = Ca.get(b, R || c);
        }
        function o(a, b, c) {
            var d = va.get(a), e = H.state.lights, f = d.lightsHash, i = e.state.hash;
            c = Aa.getParameters(a, e.state, H.state.shadowsArray, b, la.numPlanes, la.numIntersection, c);
            var j = Aa.getProgramCode(a, c), k = d.program, l = !0;
            if (void 0 === k) a.addEventListener("dispose", g); else if (k.code !== j) h(a); else {
                if (f.stateID !== i.stateID || f.directionalLength !== i.directionalLength || f.pointLength !== i.pointLength || f.spotLength !== i.spotLength || f.rectAreaLength !== i.rectAreaLength || f.hemiLength !== i.hemiLength || f.shadowsLength !== i.shadowsLength) f.stateID = i.stateID, 
                f.directionalLength = i.directionalLength, f.pointLength = i.pointLength, f.spotLength = i.spotLength, 
                f.rectAreaLength = i.rectAreaLength, f.hemiLength = i.hemiLength, f.shadowsLength = i.shadowsLength; else if (void 0 !== c.shaderID) return;
                l = !1;
            }
            if (l && (c.shaderID ? (j = gf[c.shaderID], d.shader = {
                name: a.type,
                uniforms: df.clone(j.uniforms),
                vertexShader: j.vertexShader,
                fragmentShader: j.fragmentShader
            }) : d.shader = {
                name: a.type,
                uniforms: a.uniforms,
                vertexShader: a.vertexShader,
                fragmentShader: a.fragmentShader
            }, a.onBeforeCompile(d.shader, I), j = Aa.getProgramCode(a, c), k = Aa.acquireProgram(a, d.shader, c, j), 
            d.program = k, a.program = k), c = k.getAttributes(), a.morphTargets) for (j = a.numSupportedMorphTargets = 0; j < I.maxMorphTargets; j++) 0 <= c["morphTarget" + j] && a.numSupportedMorphTargets++;
            if (a.morphNormals) for (j = a.numSupportedMorphNormals = 0; j < I.maxMorphNormals; j++) 0 <= c["morphNormal" + j] && a.numSupportedMorphNormals++;
            c = d.shader.uniforms, (a.isShaderMaterial || a.isRawShaderMaterial) && !0 !== a.clipping || (d.numClippingPlanes = la.numPlanes, 
            d.numIntersection = la.numIntersection, c.clippingPlanes = la.uniform), d.fog = b, 
            void 0 === f && (d.lightsHash = f = {}), f.stateID = i.stateID, f.directionalLength = i.directionalLength, 
            f.pointLength = i.pointLength, f.spotLength = i.spotLength, f.rectAreaLength = i.rectAreaLength, 
            f.hemiLength = i.hemiLength, f.shadowsLength = i.shadowsLength, a.lights && (c.ambientLightColor.value = e.state.ambient, 
            c.directionalLights.value = e.state.directional, c.spotLights.value = e.state.spot, 
            c.rectAreaLights.value = e.state.rectArea, c.pointLights.value = e.state.point, 
            c.hemisphereLights.value = e.state.hemi, c.directionalShadowMap.value = e.state.directionalShadowMap, 
            c.directionalShadowMatrix.value = e.state.directionalShadowMatrix, c.spotShadowMap.value = e.state.spotShadowMap, 
            c.spotShadowMatrix.value = e.state.spotShadowMatrix, c.pointShadowMap.value = e.state.pointShadowMap, 
            c.pointShadowMatrix.value = e.state.pointShadowMatrix), a = d.program.getUniforms(), 
            a = Na.seqWithValue(a.seq, c), d.uniformsList = a;
        }
        function q(a, b, c, d) {
            V = 0;
            var e = va.get(c), f = e.lightsHash, g = H.state.lights.state.hash;
            ma && (na || a !== Q) && la.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === Q && c.id === N), 
            !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : !c.lights || f.stateID === g.stateID && f.directionalLength === g.directionalLength && f.pointLength === g.pointLength && f.spotLength === g.spotLength && f.rectAreaLength === g.rectAreaLength && f.hemiLength === g.hemiLength && f.shadowsLength === g.shadowsLength ? void 0 === e.numClippingPlanes || e.numClippingPlanes === la.numPlanes && e.numIntersection === la.numIntersection || (c.needsUpdate = !0) : c.needsUpdate = !0), 
            c.needsUpdate && (o(c, b, d), c.needsUpdate = !1);
            var h = !1, i = !1, j = !1;
            f = e.program, g = f.getUniforms();
            var k = e.shader.uniforms;
            if (ta.useProgram(f.program) && (j = i = h = !0), c.id !== N && (N = c.id, i = !0), 
            (h || Q !== a) && (g.setValue(qa, "projectionMatrix", a.projectionMatrix), sa.logarithmicDepthBuffer && g.setValue(qa, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)), 
            Q !== a && (Q = a, j = i = !0), (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) && void 0 !== (h = g.map.cameraPosition) && h.setValue(qa, pa.setFromMatrixPosition(a.matrixWorld)), 
            (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && g.setValue(qa, "viewMatrix", a.matrixWorldInverse)), 
            c.skinning && (g.setOptional(qa, d, "bindMatrix"), g.setOptional(qa, d, "bindMatrixInverse"), 
            a = d.skeleton)) if (h = a.bones, sa.floatVertexTextures) {
                if (void 0 === a.boneTexture) {
                    h = Math.sqrt(4 * h.length), h = _e.ceilPowerOfTwo(h), h = Math.max(h, 4);
                    var m = new Float32Array(h * h * 4);
                    m.set(a.boneMatrices);
                    var n = new l(m, h, h, 1023, 1015);
                    n.needsUpdate = !0, a.boneMatrices = m, a.boneTexture = n, a.boneTextureSize = h;
                }
                g.setValue(qa, "boneTexture", a.boneTexture), g.setValue(qa, "boneTextureSize", a.boneTextureSize);
            } else g.setOptional(qa, a, "boneMatrices");
            return i && (g.setValue(qa, "toneMappingExposure", I.toneMappingExposure), g.setValue(qa, "toneMappingWhitePoint", I.toneMappingWhitePoint), 
            c.lights && (i = j, k.ambientLightColor.needsUpdate = i, k.directionalLights.needsUpdate = i, 
            k.pointLights.needsUpdate = i, k.spotLights.needsUpdate = i, k.rectAreaLights.needsUpdate = i, 
            k.hemisphereLights.needsUpdate = i), b && c.fog && (k.fogColor.value = b.color, 
            b.isFog ? (k.fogNear.value = b.near, k.fogFar.value = b.far) : b.isFogExp2 && (k.fogDensity.value = b.density)), 
            c.isMeshBasicMaterial ? t(k, c) : c.isMeshLambertMaterial ? (t(k, c), c.emissiveMap && (k.emissiveMap.value = c.emissiveMap)) : c.isMeshPhongMaterial ? (t(k, c), 
            c.isMeshToonMaterial ? (u(k, c), c.gradientMap && (k.gradientMap.value = c.gradientMap)) : u(k, c)) : c.isMeshStandardMaterial ? (t(k, c), 
            c.isMeshPhysicalMaterial ? (v(k, c), k.reflectivity.value = c.reflectivity, k.clearCoat.value = c.clearCoat, 
            k.clearCoatRoughness.value = c.clearCoatRoughness) : v(k, c)) : c.isMeshDepthMaterial ? (t(k, c), 
            c.displacementMap && (k.displacementMap.value = c.displacementMap, k.displacementScale.value = c.displacementScale, 
            k.displacementBias.value = c.displacementBias)) : c.isMeshDistanceMaterial ? (t(k, c), 
            c.displacementMap && (k.displacementMap.value = c.displacementMap, k.displacementScale.value = c.displacementScale, 
            k.displacementBias.value = c.displacementBias), k.referencePosition.value.copy(c.referencePosition), 
            k.nearDistance.value = c.nearDistance, k.farDistance.value = c.farDistance) : c.isMeshNormalMaterial ? (t(k, c), 
            c.bumpMap && (k.bumpMap.value = c.bumpMap, k.bumpScale.value = c.bumpScale, 1 === c.side && (k.bumpScale.value *= -1)), 
            c.normalMap && (k.normalMap.value = c.normalMap, k.normalScale.value.copy(c.normalScale), 
            1 === c.side && k.normalScale.value.negate()), c.displacementMap && (k.displacementMap.value = c.displacementMap, 
            k.displacementScale.value = c.displacementScale, k.displacementBias.value = c.displacementBias)) : c.isLineBasicMaterial ? (k.diffuse.value = c.color, 
            k.opacity.value = c.opacity, c.isLineDashedMaterial && (k.dashSize.value = c.dashSize, 
            k.totalSize.value = c.dashSize + c.gapSize, k.scale.value = c.scale)) : c.isPointsMaterial ? (k.diffuse.value = c.color, 
            k.opacity.value = c.opacity, k.size.value = c.size * ga, k.scale.value = .5 * da, 
            k.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), 
            k.uvTransform.value.copy(c.map.matrix))) : c.isSpriteMaterial ? (k.diffuse.value = c.color, 
            k.opacity.value = c.opacity, k.rotation.value = c.rotation, k.map.value = c.map, 
            null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), k.uvTransform.value.copy(c.map.matrix))) : c.isShadowMaterial && (k.color.value = c.color, 
            k.opacity.value = c.opacity), void 0 !== k.ltc_1 && (k.ltc_1.value = ff.LTC_1), 
            void 0 !== k.ltc_2 && (k.ltc_2.value = ff.LTC_2), Na.upload(qa, e.uniformsList, k, I)), 
            c.isShaderMaterial && !0 === c.uniformsNeedUpdate && (Na.upload(qa, e.uniformsList, k, I), 
            c.uniformsNeedUpdate = !1), c.isSpriteMaterial && g.setValue(qa, "center", d.center), 
            g.setValue(qa, "modelViewMatrix", d.modelViewMatrix), g.setValue(qa, "normalMatrix", d.normalMatrix), 
            g.setValue(qa, "modelMatrix", d.matrixWorld), f;
        }
        function t(a, b) {
            if (a.opacity.value = b.opacity, b.color && (a.diffuse.value = b.color), b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity), 
            b.map && (a.map.value = b.map), b.alphaMap && (a.alphaMap.value = b.alphaMap), b.specularMap && (a.specularMap.value = b.specularMap), 
            b.envMap && (a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap && b.envMap.isCubeTexture ? -1 : 1, 
            a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio, 
            a.maxMipLevel.value = va.get(b.envMap).__maxMipLevel), b.lightMap && (a.lightMap.value = b.lightMap, 
            a.lightMapIntensity.value = b.lightMapIntensity), b.aoMap && (a.aoMap.value = b.aoMap, 
            a.aoMapIntensity.value = b.aoMapIntensity), b.map) var c = b.map; else b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap);
            void 0 !== c && (c.isWebGLRenderTarget && (c = c.texture), !0 === c.matrixAutoUpdate && c.updateMatrix(), 
            a.uvTransform.value.copy(c.matrix));
        }
        function u(a, b) {
            a.specular.value = b.specular, a.shininess.value = Math.max(b.shininess, 1e-4), 
            b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, 
            a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1)), b.normalMap && (a.normalMap.value = b.normalMap, 
            a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale.value.negate()), 
            b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, 
            a.displacementBias.value = b.displacementBias);
        }
        function v(a, b) {
            a.roughness.value = b.roughness, a.metalness.value = b.metalness, b.roughnessMap && (a.roughnessMap.value = b.roughnessMap), 
            b.metalnessMap && (a.metalnessMap.value = b.metalnessMap), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), 
            b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1)), 
            b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), 
            1 === b.side && a.normalScale.value.negate()), b.displacementMap && (a.displacementMap.value = b.displacementMap, 
            a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), 
            b.envMap && (a.envMapIntensity.value = b.envMapIntensity);
        }
        var w;
        console.log("THREE.WebGLRenderer", "96"), a = a || {};
        var x = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), y = void 0 !== a.context ? a.context : null, z = void 0 !== a.alpha && a.alpha, A = void 0 === a.depth || a.depth, B = void 0 === a.stencil || a.stencil, C = void 0 !== a.antialias && a.antialias, D = void 0 === a.premultipliedAlpha || a.premultipliedAlpha, E = void 0 !== a.preserveDrawingBuffer && a.preserveDrawingBuffer, F = void 0 !== a.powerPreference ? a.powerPreference : "default", G = null, H = null;
        this.domElement = x, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, 
        this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, 
        this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, 
        this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var I = this, J = !1, K = null, L = null, M = null, N = -1, O = w = null, P = !1, Q = null, R = null, S = new i(), T = new i(), U = null, V = 0, W = x.width, da = x.height, ga = 1, ha = new i(0, 0, W, da), ia = new i(0, 0, W, da), ja = !1, ka = new p(), la = new $(), ma = !1, na = !1, oa = new d(), pa = new f();
        try {
            z = {
                alpha: z,
                depth: A,
                stencil: B,
                antialias: C,
                premultipliedAlpha: D,
                preserveDrawingBuffer: E,
                powerPreference: F
            }, x.addEventListener("webglcontextlost", c, !1), x.addEventListener("webglcontextrestored", e, !1);
            var qa = y || x.getContext("webgl", z) || x.getContext("experimental-webgl", z);
            if (null === qa) {
                if (null !== x.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.");
            }
            void 0 === qa.getShaderPrecisionFormat && (qa.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                };
            });
        } catch (a) {
            console.error("THREE.WebGLRenderer: " + a.message);
        }
        var ra, sa, ta, ua, va, wa, xa, ya, za, Aa, Ba, Ca, Da, Ea, Fa, Ga, Ha;
        b();
        var Ia = "xr" in navigator ? new ub(I) : new tb(I);
        this.vr = Ia;
        var Ja = new mb(I, za, sa.maxTextureSize);
        this.shadowMap = Ja, this.getContext = function() {
            return qa;
        }, this.getContextAttributes = function() {
            return qa.getContextAttributes();
        }, this.forceContextLoss = function() {
            var a = ra.get("WEBGL_lose_context");
            a && a.loseContext();
        }, this.forceContextRestore = function() {
            var a = ra.get("WEBGL_lose_context");
            a && a.restoreContext();
        }, this.getPixelRatio = function() {
            return ga;
        }, this.setPixelRatio = function(a) {
            void 0 !== a && (ga = a, this.setSize(W, da, !1));
        }, this.getSize = function() {
            return {
                width: W,
                height: da
            };
        }, this.setSize = function(a, b, c) {
            Ia.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (W = a, 
            da = b, x.width = a * ga, x.height = b * ga, !1 !== c && (x.style.width = a + "px", 
            x.style.height = b + "px"), this.setViewport(0, 0, a, b));
        }, this.getDrawingBufferSize = function() {
            return {
                width: W * ga,
                height: da * ga
            };
        }, this.setDrawingBufferSize = function(a, b, c) {
            W = a, da = b, ga = c, x.width = a * c, x.height = b * c, this.setViewport(0, 0, a, b);
        }, this.getCurrentViewport = function() {
            return S;
        }, this.setViewport = function(a, b, c, d) {
            ha.set(a, da - b - d, c, d), ta.viewport(S.copy(ha).multiplyScalar(ga));
        }, this.setScissor = function(a, b, c, d) {
            ia.set(a, da - b - d, c, d), ta.scissor(T.copy(ia).multiplyScalar(ga));
        }, this.setScissorTest = function(a) {
            ta.setScissorTest(ja = a);
        }, this.getClearColor = function() {
            return Da.getClearColor();
        }, this.setClearColor = function() {
            Da.setClearColor.apply(Da, arguments);
        }, this.getClearAlpha = function() {
            return Da.getClearAlpha();
        }, this.setClearAlpha = function() {
            Da.setClearAlpha.apply(Da, arguments);
        }, this.clear = function(a, b, c) {
            var d = 0;
            (void 0 === a || a) && (d |= qa.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= qa.DEPTH_BUFFER_BIT), 
            (void 0 === c || c) && (d |= qa.STENCIL_BUFFER_BIT), qa.clear(d);
        }, this.clearColor = function() {
            this.clear(!0, !1, !1);
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1);
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0);
        }, this.clearTarget = function(a, b, c, d) {
            this.setRenderTarget(a), this.clear(b, c, d);
        }, this.dispose = function() {
            x.removeEventListener("webglcontextlost", c, !1), x.removeEventListener("webglcontextrestored", e, !1), 
            Ba.dispose(), Ca.dispose(), va.dispose(), za.dispose(), Ia.dispose(), La.stop();
        }, this.renderBufferImmediate = function(a, b) {
            ta.initAttributes();
            var c = va.get(a);
            a.hasPositions && !c.position && (c.position = qa.createBuffer()), a.hasNormals && !c.normal && (c.normal = qa.createBuffer()), 
            a.hasUvs && !c.uv && (c.uv = qa.createBuffer()), a.hasColors && !c.color && (c.color = qa.createBuffer()), 
            b = b.getAttributes(), a.hasPositions && (qa.bindBuffer(qa.ARRAY_BUFFER, c.position), 
            qa.bufferData(qa.ARRAY_BUFFER, a.positionArray, qa.DYNAMIC_DRAW), ta.enableAttribute(b.position), 
            qa.vertexAttribPointer(b.position, 3, qa.FLOAT, !1, 0, 0)), a.hasNormals && (qa.bindBuffer(qa.ARRAY_BUFFER, c.normal), 
            qa.bufferData(qa.ARRAY_BUFFER, a.normalArray, qa.DYNAMIC_DRAW), ta.enableAttribute(b.normal), 
            qa.vertexAttribPointer(b.normal, 3, qa.FLOAT, !1, 0, 0)), a.hasUvs && (qa.bindBuffer(qa.ARRAY_BUFFER, c.uv), 
            qa.bufferData(qa.ARRAY_BUFFER, a.uvArray, qa.DYNAMIC_DRAW), ta.enableAttribute(b.uv), 
            qa.vertexAttribPointer(b.uv, 2, qa.FLOAT, !1, 0, 0)), a.hasColors && (qa.bindBuffer(qa.ARRAY_BUFFER, c.color), 
            qa.bufferData(qa.ARRAY_BUFFER, a.colorArray, qa.DYNAMIC_DRAW), ta.enableAttribute(b.color), 
            qa.vertexAttribPointer(b.color, 3, qa.FLOAT, !1, 0, 0)), ta.disableUnusedAttributes(), 
            qa.drawArrays(qa.TRIANGLES, 0, a.count), a.count = 0;
        }, this.renderBufferDirect = function(a, b, c, d, e, f) {
            var g = e.isMesh && 0 > e.normalMatrix.determinant();
            ta.setMaterial(d, g);
            var h = q(a, b, d, e), i = !1;
            w === c.id && O === h.id && P === (!0 === d.wireframe) || (w = c.id, O = h.id, P = !0 === d.wireframe, 
            i = !0), e.morphTargetInfluences && (Ea.update(e, c, d, h), i = !0), g = c.index;
            var j = c.attributes.position;
            if (b = 1, !0 === d.wireframe && (g = ya.getWireframeAttribute(c), b = 2), a = Fa, 
            null !== g) {
                var k = xa.get(g);
                a = Ga, a.setIndex(k);
            }
            if (i) {
                if (c && c.isInstancedBufferGeometry & !sa.isWebGL2 && null === ra.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else {
                    ta.initAttributes(), i = c.attributes, h = h.getAttributes();
                    var l = d.defaultAttributeValues;
                    for (x in h) {
                        var m = h[x];
                        if (0 <= m) {
                            var n = i[x];
                            if (void 0 !== n) {
                                var o = n.normalized, p = n.itemSize, r = xa.get(n);
                                if (void 0 !== r) {
                                    var s = r.buffer, t = r.type;
                                    if (r = r.bytesPerElement, n.isInterleavedBufferAttribute) {
                                        var u = n.data, v = u.stride;
                                        n = n.offset, u && u.isInstancedInterleavedBuffer ? (ta.enableAttributeAndDivisor(m, u.meshPerAttribute), 
                                        void 0 === c.maxInstancedCount && (c.maxInstancedCount = u.meshPerAttribute * u.count)) : ta.enableAttribute(m), 
                                        qa.bindBuffer(qa.ARRAY_BUFFER, s), qa.vertexAttribPointer(m, p, t, o, v * r, n * r);
                                    } else n.isInstancedBufferAttribute ? (ta.enableAttributeAndDivisor(m, n.meshPerAttribute), 
                                    void 0 === c.maxInstancedCount && (c.maxInstancedCount = n.meshPerAttribute * n.count)) : ta.enableAttribute(m), 
                                    qa.bindBuffer(qa.ARRAY_BUFFER, s), qa.vertexAttribPointer(m, p, t, o, 0, 0);
                                }
                            } else if (void 0 !== l && void 0 !== (o = l[x])) switch (o.length) {
                              case 2:
                                qa.vertexAttrib2fv(m, o);
                                break;

                              case 3:
                                qa.vertexAttrib3fv(m, o);
                                break;

                              case 4:
                                qa.vertexAttrib4fv(m, o);
                                break;

                              default:
                                qa.vertexAttrib1fv(m, o);
                            }
                        }
                    }
                    ta.disableUnusedAttributes();
                }
                null !== g && qa.bindBuffer(qa.ELEMENT_ARRAY_BUFFER, k.buffer);
            }
            k = 1 / 0, null !== g ? k = g.count : void 0 !== j && (k = j.count), g = c.drawRange.start * b, 
            j = null !== f ? f.start * b : 0;
            var x = Math.max(g, j);
            if (0 !== (f = Math.max(0, Math.min(k, g + c.drawRange.count * b, j + (null !== f ? f.count * b : 1 / 0)) - 1 - x + 1))) {
                if (e.isMesh) if (!0 === d.wireframe) ta.setLineWidth(d.wireframeLinewidth * (null === L ? ga : 1)), 
                a.setMode(qa.LINES); else switch (e.drawMode) {
                  case 0:
                    a.setMode(qa.TRIANGLES);
                    break;

                  case 1:
                    a.setMode(qa.TRIANGLE_STRIP);
                    break;

                  case 2:
                    a.setMode(qa.TRIANGLE_FAN);
                } else e.isLine ? (d = d.linewidth, void 0 === d && (d = 1), ta.setLineWidth(d * (null === L ? ga : 1)), 
                e.isLineSegments ? a.setMode(qa.LINES) : e.isLineLoop ? a.setMode(qa.LINE_LOOP) : a.setMode(qa.LINE_STRIP)) : e.isPoints ? a.setMode(qa.POINTS) : e.isSprite && a.setMode(qa.TRIANGLES);
                c && c.isInstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, x, f) : a.render(x, f);
            }
        }, this.compile = function(a, b) {
            H = Ca.get(a, b), H.init(), a.traverse(function(a) {
                a.isLight && (H.pushLight(a), a.castShadow && H.pushShadow(a));
            }), H.setupLights(b), a.traverse(function(b) {
                if (b.material) if (Array.isArray(b.material)) for (var c = 0; c < b.material.length; c++) o(b.material[c], a.fog, b); else o(b.material, a.fog, b);
            });
        };
        var Ka = null, La = new r();
        La.setAnimationLoop(function(a) {
            Ia.isPresenting() || Ka && Ka(a);
        }), "undefined" != typeof window && La.setContext(window), this.setAnimationLoop = function(a) {
            Ka = a, Ia.setAnimationLoop(a), La.start();
        }, this.render = function(a, b, c, d) {
            if (b && b.isCamera) {
                if (!J) {
                    O = w = null, P = !1, N = -1, Q = null, !0 === a.autoUpdate && a.updateMatrixWorld(), 
                    null === b.parent && b.updateMatrixWorld(), Ia.enabled && (b = Ia.getCamera(b)), 
                    H = Ca.get(a, b), H.init(), a.onBeforeRender(I, a, b, c), oa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), 
                    ka.setFromMatrix(oa), na = this.localClippingEnabled, ma = la.init(this.clippingPlanes, na, b), 
                    G = Ba.get(a, b), G.init(), k(a, b, I.sortObjects), !0 === I.sortObjects && G.sort(), 
                    ma && la.beginShadows(), Ja.render(H.state.shadowsArray, a, b), H.setupLights(b), 
                    ma && la.endShadows(), this.info.autoReset && this.info.reset(), void 0 === c && (c = null), 
                    this.setRenderTarget(c), Da.render(G, a, b, d), d = G.opaque;
                    var e = G.transparent;
                    if (a.overrideMaterial) {
                        var f = a.overrideMaterial;
                        d.length && m(d, a, b, f), e.length && m(e, a, b, f);
                    } else d.length && m(d, a, b), e.length && m(e, a, b);
                    c && wa.updateRenderTargetMipmap(c), ta.buffers.depth.setTest(!0), ta.buffers.depth.setMask(!0), 
                    ta.buffers.color.setMask(!0), ta.setPolygonOffset(!1), a.onAfterRender(I, a, b), 
                    Ia.enabled && Ia.submitFrame(), H = G = null;
                }
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        }, this.allocTextureUnit = function() {
            var a = V;
            return a >= sa.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + a + " texture units while this GPU supports only " + sa.maxTextures), 
            V += 1, a;
        }, this.setTexture2D = function() {
            var a = !1;
            return function(b, c) {
                b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), 
                a = !0), b = b.texture), wa.setTexture2D(b, c);
            };
        }(), this.setTexture = function() {
            var a = !1;
            return function(b, c) {
                a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), 
                a = !0), wa.setTexture2D(b, c);
            };
        }(), this.setTextureCube = function() {
            var a = !1;
            return function(b, c) {
                b && b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), 
                a = !0), b = b.texture), b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? wa.setTextureCube(b, c) : wa.setTextureCubeDynamic(b, c);
            };
        }(), this.setFramebuffer = function(a) {
            K = a;
        }, this.getRenderTarget = function() {
            return L;
        }, this.setRenderTarget = function(a) {
            (L = a) && void 0 === va.get(a).__webglFramebuffer && wa.setupRenderTarget(a);
            var b = K, c = !1;
            a ? (b = va.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube && (b = b[a.activeCubeFace], 
            c = !0), S.copy(a.viewport), T.copy(a.scissor), U = a.scissorTest) : (S.copy(ha).multiplyScalar(ga), 
            T.copy(ia).multiplyScalar(ga), U = ja), M !== b && (qa.bindFramebuffer(qa.FRAMEBUFFER, b), 
            M = b), ta.viewport(S), ta.scissor(T), ta.setScissorTest(U), c && (c = va.get(a.texture), 
            qa.framebufferTexture2D(qa.FRAMEBUFFER, qa.COLOR_ATTACHMENT0, qa.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, c.__webglTexture, a.activeMipMapLevel));
        }, this.readRenderTargetPixels = function(a, b, c, d, e, f) {
            if (a && a.isWebGLRenderTarget) {
                var g = va.get(a).__webglFramebuffer;
                if (g) {
                    var h = !1;
                    g !== M && (qa.bindFramebuffer(qa.FRAMEBUFFER, g), h = !0);
                    try {
                        var i = a.texture, j = i.format, k = i.type;
                        1023 !== j && Ha.convert(j) !== qa.getParameter(qa.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === k || Ha.convert(k) === qa.getParameter(qa.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === k && (sa.isWebGL2 || ra.get("OES_texture_float") || ra.get("WEBGL_color_buffer_float")) || 1016 === k && (sa.isWebGL2 ? ra.get("EXT_color_buffer_float") : ra.get("EXT_color_buffer_half_float")) ? qa.checkFramebufferStatus(qa.FRAMEBUFFER) === qa.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && qa.readPixels(b, c, d, e, Ha.convert(j), Ha.convert(k), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    } finally {
                        h && qa.bindFramebuffer(qa.FRAMEBUFFER, M);
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        }, this.copyFramebufferToTexture = function(a, b, c) {
            var d = b.image.width, e = b.image.height, f = Ha.convert(b.format);
            this.setTexture2D(b, 0), qa.copyTexImage2D(qa.TEXTURE_2D, c || 0, f, a.x, a.y, d, e, 0);
        }, this.copyTextureToTexture = function(a, b, c, d) {
            var e = b.image.width, f = b.image.height, g = Ha.convert(c.format), h = Ha.convert(c.type);
            this.setTexture2D(c, 0), b.isDataTexture ? qa.texSubImage2D(qa.TEXTURE_2D, d || 0, a.x, a.y, e, f, g, h, b.image.data) : qa.texSubImage2D(qa.TEXTURE_2D, d || 0, a.x, a.y, g, h, b.image);
        };
    }
    function wb(a, b) {
        this.name = "", this.color = new q(a), this.density = void 0 !== b ? b : 25e-5;
    }
    function xb(a, b, c) {
        this.name = "", this.color = new q(a), this.near = void 0 !== b ? b : 1, this.far = void 0 !== c ? c : 1e3;
    }
    function yb() {
        v.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, 
        this.autoUpdate = !0;
    }
    function zb(a, b) {
        this.array = a, this.stride = b, this.count = void 0 !== a ? a.length / b : 0, this.dynamic = !1, 
        this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0;
    }
    function Ab(a, b, c, d) {
        this.data = a, this.itemSize = b, this.offset = c, this.normalized = !0 === d;
    }
    function Bb(a) {
        R.call(this), this.type = "SpriteMaterial", this.color = new q(16777215), this.map = null, 
        this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, 
        this.setValues(a);
    }
    function Cb(a) {
        if (v.call(this), this.type = "Sprite", void 0 === wf) {
            wf = new M();
            var b = new Float32Array([ -.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1 ]);
            b = new zb(b, 5), wf.setIndex([ 0, 1, 2, 0, 2, 3 ]), wf.addAttribute("position", new Ab(b, 3, 0, !1)), 
            wf.addAttribute("uv", new Ab(b, 2, 3, !1));
        }
        this.geometry = wf, this.material = void 0 !== a ? a : new Bb(), this.center = new c(.5, .5);
    }
    function Db() {
        v.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        });
    }
    function Eb(a, b) {
        if (a = a || [], this.bones = a.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), 
        void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (console.warn("THREE.Skeleton boneInverses is the wrong length."), 
        this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++) this.boneInverses.push(new d());
    }
    function Fb() {
        v.call(this), this.type = "Bone";
    }
    function Gb(a, b) {
        W.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new d(), 
        this.bindMatrixInverse = new d(), a = this.initBones(), a = new Eb(a), this.bind(a, this.matrixWorld), 
        this.normalizeSkinWeights();
    }
    function Hb(a) {
        R.call(this), this.type = "LineBasicMaterial", this.color = new q(16777215), this.linewidth = 1, 
        this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(a);
    }
    function Ib(a, b, c) {
        1 === c && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), 
        v.call(this), this.type = "Line", this.geometry = void 0 !== a ? a : new M(), this.material = void 0 !== b ? b : new Hb({
            color: 16777215 * Math.random()
        });
    }
    function Jb(a, b) {
        Ib.call(this, a, b), this.type = "LineSegments";
    }
    function Kb(a, b) {
        Ib.call(this, a, b), this.type = "LineLoop";
    }
    function Lb(a) {
        R.call(this), this.type = "PointsMaterial", this.color = new q(16777215), this.map = null, 
        this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, 
        this.setValues(a);
    }
    function Mb(a, b) {
        v.call(this), this.type = "Points", this.geometry = void 0 !== a ? a : new M(), 
        this.material = void 0 !== b ? b : new Lb({
            color: 16777215 * Math.random()
        });
    }
    function Nb(a, b, c, d, e, f, g, i, j) {
        h.call(this, a, b, c, d, e, f, g, i, j), this.generateMipmaps = !1;
    }
    function Ob(a, b, c, d, e, f, g, i, j, k, l, m) {
        h.call(this, null, f, g, i, j, k, d, e, l, m), this.image = {
            width: b,
            height: c
        }, this.mipmaps = a, this.generateMipmaps = this.flipY = !1;
    }
    function Pb(a, b, c, d, e, f, g, i, j) {
        h.call(this, a, b, c, d, e, f, g, i, j), this.needsUpdate = !0;
    }
    function Qb(a, b, c, d, e, f, g, i, j, k) {
        if (1026 !== (k = void 0 !== k ? k : 1026) && 1027 !== k) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === c && 1026 === k && (c = 1012), void 0 === c && 1027 === k && (c = 1020), 
        h.call(this, null, d, e, f, g, i, k, c, j), this.image = {
            width: a,
            height: b
        }, this.magFilter = void 0 !== g ? g : 1003, this.minFilter = void 0 !== i ? i : 1003, 
        this.generateMipmaps = this.flipY = !1;
    }
    function Rb(a) {
        M.call(this), this.type = "WireframeGeometry";
        var b, c, d, e = [], g = [ 0, 0 ], h = {}, i = [ "a", "b", "c" ];
        if (a && a.isGeometry) {
            var j = a.faces, k = 0;
            for (c = j.length; k < c; k++) {
                var l = j[k];
                for (b = 0; 3 > b; b++) {
                    var m = l[i[b]], n = l[i[(b + 1) % 3]];
                    g[0] = Math.min(m, n), g[1] = Math.max(m, n), m = g[0] + "," + g[1], void 0 === h[m] && (h[m] = {
                        index1: g[0],
                        index2: g[1]
                    });
                }
            }
            for (m in h) k = h[m], i = a.vertices[k.index1], e.push(i.x, i.y, i.z), i = a.vertices[k.index2], 
            e.push(i.x, i.y, i.z);
        } else if (a && a.isBufferGeometry) if (i = new f(), null !== a.index) {
            j = a.attributes.position, l = a.index;
            var o = a.groups;
            for (0 === o.length && (o = [ {
                start: 0,
                count: l.count,
                materialIndex: 0
            } ]), a = 0, d = o.length; a < d; ++a) for (k = o[a], b = k.start, c = k.count, 
            k = b, c = b + c; k < c; k += 3) for (b = 0; 3 > b; b++) m = l.getX(k + b), n = l.getX(k + (b + 1) % 3), 
            g[0] = Math.min(m, n), g[1] = Math.max(m, n), m = g[0] + "," + g[1], void 0 === h[m] && (h[m] = {
                index1: g[0],
                index2: g[1]
            });
            for (m in h) k = h[m], i.fromBufferAttribute(j, k.index1), e.push(i.x, i.y, i.z), 
            i.fromBufferAttribute(j, k.index2), e.push(i.x, i.y, i.z);
        } else for (j = a.attributes.position, k = 0, c = j.count / 3; k < c; k++) for (b = 0; 3 > b; b++) h = 3 * k + b, 
        i.fromBufferAttribute(j, h), e.push(i.x, i.y, i.z), h = 3 * k + (b + 1) % 3, i.fromBufferAttribute(j, h), 
        e.push(i.x, i.y, i.z);
        this.addAttribute("position", new I(e, 3));
    }
    function Sb(a, b, c) {
        z.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: a,
            slices: b,
            stacks: c
        }, this.fromBufferGeometry(new Tb(a, b, c)), this.mergeVertices();
    }
    function Tb(a, b, c) {
        M.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: a,
            slices: b,
            stacks: c
        };
        var d, e, g = [], h = [], i = [], j = [], k = new f(), l = new f(), m = new f(), n = new f(), o = new f();
        3 > a.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var p = b + 1;
        for (d = 0; d <= c; d++) {
            var q = d / c;
            for (e = 0; e <= b; e++) {
                var r = e / b;
                a(r, q, l), h.push(l.x, l.y, l.z), 0 <= r - 1e-5 ? (a(r - 1e-5, q, m), n.subVectors(l, m)) : (a(r + 1e-5, q, m), 
                n.subVectors(m, l)), 0 <= q - 1e-5 ? (a(r, q - 1e-5, m), o.subVectors(l, m)) : (a(r, q + 1e-5, m), 
                o.subVectors(m, l)), k.crossVectors(n, o).normalize(), i.push(k.x, k.y, k.z), j.push(r, q);
            }
        }
        for (d = 0; d < c; d++) for (e = 0; e < b; e++) a = d * p + e + 1, k = (d + 1) * p + e + 1, 
        l = (d + 1) * p + e, g.push(d * p + e, a, l), g.push(a, k, l);
        this.setIndex(g), this.addAttribute("position", new I(h, 3)), this.addAttribute("normal", new I(i, 3)), 
        this.addAttribute("uv", new I(j, 2));
    }
    function Ub(a, b, c, d) {
        z.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: a,
            indices: b,
            radius: c,
            detail: d
        }, this.fromBufferGeometry(new Vb(a, b, c, d)), this.mergeVertices();
    }
    function Vb(a, b, d, e) {
        function g(a) {
            j.push(a.x, a.y, a.z);
        }
        function h(b, c) {
            b *= 3, c.x = a[b + 0], c.y = a[b + 1], c.z = a[b + 2];
        }
        function i(a, b, c, d) {
            0 > d && 1 === a.x && (k[b] = a.x - 1), 0 === c.x && 0 === c.z && (k[b] = d / 2 / Math.PI + .5);
        }
        M.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: a,
            indices: b,
            radius: d,
            detail: e
        }, d = d || 1, e = e || 0;
        var j = [], k = [];
        !function(a) {
            for (var c = new f(), d = new f(), e = new f(), i = 0; i < b.length; i += 3) {
                h(b[i + 0], c), h(b[i + 1], d), h(b[i + 2], e);
                var j, k, l = c, m = d, n = e, o = Math.pow(2, a), p = [];
                for (k = 0; k <= o; k++) {
                    p[k] = [];
                    var q = l.clone().lerp(n, k / o), r = m.clone().lerp(n, k / o), s = o - k;
                    for (j = 0; j <= s; j++) p[k][j] = 0 === j && k === o ? q : q.clone().lerp(r, j / s);
                }
                for (k = 0; k < o; k++) for (j = 0; j < 2 * (o - k) - 1; j++) l = Math.floor(j / 2), 
                0 == j % 2 ? (g(p[k][l + 1]), g(p[k + 1][l]), g(p[k][l])) : (g(p[k][l + 1]), g(p[k + 1][l + 1]), 
                g(p[k + 1][l]));
            }
        }(e), function(a) {
            for (var b = new f(), c = 0; c < j.length; c += 3) b.x = j[c + 0], b.y = j[c + 1], 
            b.z = j[c + 2], b.normalize().multiplyScalar(a), j[c + 0] = b.x, j[c + 1] = b.y, 
            j[c + 2] = b.z;
        }(d), function() {
            for (var a = new f(), b = 0; b < j.length; b += 3) a.x = j[b + 0], a.y = j[b + 1], 
            a.z = j[b + 2], k.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
            a = new f(), b = new f();
            for (var d = new f(), e = new f(), g = new c(), h = new c(), l = new c(), m = 0, n = 0; m < j.length; m += 9, 
            n += 6) {
                a.set(j[m + 0], j[m + 1], j[m + 2]), b.set(j[m + 3], j[m + 4], j[m + 5]), d.set(j[m + 6], j[m + 7], j[m + 8]), 
                g.set(k[n + 0], k[n + 1]), h.set(k[n + 2], k[n + 3]), l.set(k[n + 4], k[n + 5]), 
                e.copy(a).add(b).add(d).divideScalar(3);
                var o = Math.atan2(e.z, -e.x);
                i(g, n + 0, a, o), i(h, n + 2, b, o), i(l, n + 4, d, o);
            }
            for (a = 0; a < k.length; a += 6) b = k[a + 0], d = k[a + 2], e = k[a + 4], g = Math.min(b, d, e), 
            .9 < Math.max(b, d, e) && .1 > g && (.2 > b && (k[a + 0] += 1), .2 > d && (k[a + 2] += 1), 
            .2 > e && (k[a + 4] += 1));
        }(), this.addAttribute("position", new I(j, 3)), this.addAttribute("normal", new I(j.slice(), 3)), 
        this.addAttribute("uv", new I(k, 2)), 0 === e ? this.computeVertexNormals() : this.normalizeNormals();
    }
    function Wb(a, b) {
        z.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: a,
            detail: b
        }, this.fromBufferGeometry(new Xb(a, b)), this.mergeVertices();
    }
    function Xb(a, b) {
        Vb.call(this, [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ], [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ], a, b), 
        this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: a,
            detail: b
        };
    }
    function Yb(a, b) {
        z.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: a,
            detail: b
        }, this.fromBufferGeometry(new Zb(a, b)), this.mergeVertices();
    }
    function Zb(a, b) {
        Vb.call(this, [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ], [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ], a, b), 
        this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: a,
            detail: b
        };
    }
    function $b(a, b) {
        z.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: a,
            detail: b
        }, this.fromBufferGeometry(new _b(a, b)), this.mergeVertices();
    }
    function _b(a, b) {
        var c = (1 + Math.sqrt(5)) / 2;
        Vb.call(this, [ -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1 ], [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ], a, b), 
        this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: a,
            detail: b
        };
    }
    function ac(a, b) {
        z.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: a,
            detail: b
        }, this.fromBufferGeometry(new bc(a, b)), this.mergeVertices();
    }
    function bc(a, b) {
        var c = (1 + Math.sqrt(5)) / 2, d = 1 / c;
        Vb.call(this, [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d ], [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ], a, b), 
        this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: a,
            detail: b
        };
    }
    function cc(a, b, c, d, e, f) {
        z.call(this), this.type = "TubeGeometry", this.parameters = {
            path: a,
            tubularSegments: b,
            radius: c,
            radialSegments: d,
            closed: e
        }, void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed."), 
        a = new dc(a, b, c, d, e), this.tangents = a.tangents, this.normals = a.normals, 
        this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices();
    }
    function dc(a, b, d, e, g) {
        function h(c) {
            o = a.getPointAt(c / b, o);
            var f = i.normals[c];
            for (c = i.binormals[c], k = 0; k <= e; k++) {
                var g = k / e * Math.PI * 2, h = Math.sin(g);
                g = -Math.cos(g), m.x = g * f.x + h * c.x, m.y = g * f.y + h * c.y, m.z = g * f.z + h * c.z, 
                m.normalize(), q.push(m.x, m.y, m.z), l.x = o.x + d * m.x, l.y = o.y + d * m.y, 
                l.z = o.z + d * m.z, p.push(l.x, l.y, l.z);
            }
        }
        M.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: a,
            tubularSegments: b,
            radius: d,
            radialSegments: e,
            closed: g
        }, b = b || 64, d = d || 1, e = e || 8, g = g || !1;
        var i = a.computeFrenetFrames(b, g);
        this.tangents = i.tangents, this.normals = i.normals, this.binormals = i.binormals;
        var j, k, l = new f(), m = new f(), n = new c(), o = new f(), p = [], q = [], r = [], s = [];
        for (j = 0; j < b; j++) h(j);
        for (h(!1 === g ? b : 0), j = 0; j <= b; j++) for (k = 0; k <= e; k++) n.x = j / b, 
        n.y = k / e, r.push(n.x, n.y);
        !function() {
            for (k = 1; k <= b; k++) for (j = 1; j <= e; j++) {
                var a = (e + 1) * k + (j - 1), c = (e + 1) * k + j, d = (e + 1) * (k - 1) + j;
                s.push((e + 1) * (k - 1) + (j - 1), a, d), s.push(a, c, d);
            }
        }(), this.setIndex(s), this.addAttribute("position", new I(p, 3)), this.addAttribute("normal", new I(q, 3)), 
        this.addAttribute("uv", new I(r, 2));
    }
    function ec(a, b, c, d, e, f, g) {
        z.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: a,
            tube: b,
            tubularSegments: c,
            radialSegments: d,
            p: e,
            q: f
        }, void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), 
        this.fromBufferGeometry(new fc(a, b, c, d, e, f)), this.mergeVertices();
    }
    function fc(a, b, c, d, e, g) {
        function h(a, b, c, d, e) {
            var f = Math.sin(a);
            b = c / b * a, c = Math.cos(b), e.x = d * (2 + c) * .5 * Math.cos(a), e.y = d * (2 + c) * f * .5, 
            e.z = d * Math.sin(b) * .5;
        }
        M.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: a,
            tube: b,
            tubularSegments: c,
            radialSegments: d,
            p: e,
            q: g
        }, a = a || 1, b = b || .4, c = Math.floor(c) || 64, d = Math.floor(d) || 8, e = e || 2, 
        g = g || 3;
        var i, j = [], k = [], l = [], m = [], n = new f(), o = new f(), p = new f(), q = new f(), r = new f(), s = new f(), t = new f();
        for (i = 0; i <= c; ++i) {
            var u = i / c * e * Math.PI * 2;
            for (h(u, e, g, a, p), h(u + .01, e, g, a, q), s.subVectors(q, p), t.addVectors(q, p), 
            r.crossVectors(s, t), t.crossVectors(r, s), r.normalize(), t.normalize(), u = 0; u <= d; ++u) {
                var v = u / d * Math.PI * 2, w = -b * Math.cos(v);
                v = b * Math.sin(v), n.x = p.x + (w * t.x + v * r.x), n.y = p.y + (w * t.y + v * r.y), 
                n.z = p.z + (w * t.z + v * r.z), k.push(n.x, n.y, n.z), o.subVectors(n, p).normalize(), 
                l.push(o.x, o.y, o.z), m.push(i / c), m.push(u / d);
            }
        }
        for (u = 1; u <= c; u++) for (i = 1; i <= d; i++) a = (d + 1) * u + (i - 1), b = (d + 1) * u + i, 
        e = (d + 1) * (u - 1) + i, j.push((d + 1) * (u - 1) + (i - 1), a, e), j.push(a, b, e);
        this.setIndex(j), this.addAttribute("position", new I(k, 3)), this.addAttribute("normal", new I(l, 3)), 
        this.addAttribute("uv", new I(m, 2));
    }
    function gc(a, b, c, d, e) {
        z.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: e
        }, this.fromBufferGeometry(new hc(a, b, c, d, e)), this.mergeVertices();
    }
    function hc(a, b, c, d, e) {
        M.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: e
        }, a = a || 1, b = b || .4, c = Math.floor(c) || 8, d = Math.floor(d) || 6, e = e || 2 * Math.PI;
        var g, h, i = [], j = [], k = [], l = [], m = new f(), n = new f(), o = new f();
        for (g = 0; g <= c; g++) for (h = 0; h <= d; h++) {
            var p = h / d * e, q = g / c * Math.PI * 2;
            n.x = (a + b * Math.cos(q)) * Math.cos(p), n.y = (a + b * Math.cos(q)) * Math.sin(p), 
            n.z = b * Math.sin(q), j.push(n.x, n.y, n.z), m.x = a * Math.cos(p), m.y = a * Math.sin(p), 
            o.subVectors(n, m).normalize(), k.push(o.x, o.y, o.z), l.push(h / d), l.push(g / c);
        }
        for (g = 1; g <= c; g++) for (h = 1; h <= d; h++) a = (d + 1) * (g - 1) + h - 1, 
        b = (d + 1) * (g - 1) + h, e = (d + 1) * g + h, i.push((d + 1) * g + h - 1, a, e), 
        i.push(a, b, e);
        this.setIndex(i), this.addAttribute("position", new I(j, 3)), this.addAttribute("normal", new I(k, 3)), 
        this.addAttribute("uv", new I(l, 2));
    }
    function ic(a, b, c, d, e) {
        for (var f, g = 0, h = b, i = c - d; h < c; h += d) g += (a[i] - a[h]) * (a[h + 1] + a[i + 1]), 
        i = h;
        if (e === 0 < g) for (e = b; e < c; e += d) f = vc(e, a[e], a[e + 1], f); else for (e = c - d; e >= b; e -= d) f = vc(e, a[e], a[e + 1], f);
        return f && rc(f, f.next) && (wc(f), f = f.next), f;
    }
    function jc(a, b) {
        if (!a) return a;
        b || (b = a);
        do {
            var c = !1;
            if (a.steiner || !rc(a, a.next) && 0 !== qc(a.prev, a, a.next)) a = a.next; else {
                if (wc(a), (a = b = a.prev) === a.next) break;
                c = !0;
            }
        } while (c || a !== b);
        return b;
    }
    function kc(a, b, c, d, e, f, g) {
        if (a) {
            if (!g && f) {
                var h = a, i = h;
                do {
                    null === i.z && (i.z = nc(i.x, i.y, d, e, f)), i.prevZ = i.prev, i = i.nextZ = i.next;
                } while (i !== h);
                i.prevZ.nextZ = null, i.prevZ = null, h = i;
                var j, k, l, m, n = 1;
                do {
                    i = h;
                    var o = h = null;
                    for (k = 0; i; ) {
                        k++;
                        var p = i;
                        for (j = l = 0; j < n && (l++, p = p.nextZ); j++) ;
                        for (m = n; 0 < l || 0 < m && p; ) 0 !== l && (0 === m || !p || i.z <= p.z) ? (j = i, 
                        i = i.nextZ, l--) : (j = p, p = p.nextZ, m--), o ? o.nextZ = j : h = j, j.prevZ = o, 
                        o = j;
                        i = p;
                    }
                    o.nextZ = null, n *= 2;
                } while (1 < k);
            }
            for (h = a; a.prev !== a.next; ) {
                if (i = a.prev, p = a.next, f) a: {
                    o = a, m = d;
                    var q = e, r = f;
                    if (k = o.prev, l = o, n = o.next, 0 <= qc(k, l, n)) o = !1; else {
                        var s = k.x > l.x ? k.x > n.x ? k.x : n.x : l.x > n.x ? l.x : n.x, t = k.y > l.y ? k.y > n.y ? k.y : n.y : l.y > n.y ? l.y : n.y;
                        for (j = nc(k.x < l.x ? k.x < n.x ? k.x : n.x : l.x < n.x ? l.x : n.x, k.y < l.y ? k.y < n.y ? k.y : n.y : l.y < n.y ? l.y : n.y, m, q, r), 
                        m = nc(s, t, m, q, r), q = o.nextZ; q && q.z <= m; ) {
                            if (q !== o.prev && q !== o.next && pc(k.x, k.y, l.x, l.y, n.x, n.y, q.x, q.y) && 0 <= qc(q.prev, q, q.next)) {
                                o = !1;
                                break a;
                            }
                            q = q.nextZ;
                        }
                        for (q = o.prevZ; q && q.z >= j; ) {
                            if (q !== o.prev && q !== o.next && pc(k.x, k.y, l.x, l.y, n.x, n.y, q.x, q.y) && 0 <= qc(q.prev, q, q.next)) {
                                o = !1;
                                break a;
                            }
                            q = q.prevZ;
                        }
                        o = !0;
                    }
                } else a: if (o = a, k = o.prev, l = o, n = o.next, 0 <= qc(k, l, n)) o = !1; else {
                    for (j = o.next.next; j !== o.prev; ) {
                        if (pc(k.x, k.y, l.x, l.y, n.x, n.y, j.x, j.y) && 0 <= qc(j.prev, j, j.next)) {
                            o = !1;
                            break a;
                        }
                        j = j.next;
                    }
                    o = !0;
                }
                if (o) b.push(i.i / c), b.push(a.i / c), b.push(p.i / c), wc(a), h = a = p.next; else if ((a = p) === h) {
                    if (g) {
                        if (1 === g) {
                            g = b, h = c, i = a;
                            do {
                                p = i.prev, o = i.next.next, !rc(p, o) && sc(p, i, i.next, o) && tc(p, o) && tc(o, p) && (g.push(p.i / h), 
                                g.push(i.i / h), g.push(o.i / h), wc(i), wc(i.next), i = a = o), i = i.next;
                            } while (i !== a);
                            a = i, kc(a, b, c, d, e, f, 2);
                        } else if (2 === g) a: {
                            g = a;
                            do {
                                for (h = g.next.next; h !== g.prev; ) {
                                    if (i = g.i !== h.i) {
                                        if (i = g, p = h, o = i.next.i !== p.i && i.prev.i !== p.i) {
                                            b: {
                                                o = i;
                                                do {
                                                    if (o.i !== i.i && o.next.i !== i.i && o.i !== p.i && o.next.i !== p.i && sc(o, o.next, i, p)) {
                                                        o = !0;
                                                        break b;
                                                    }
                                                    o = o.next;
                                                } while (o !== i);
                                                o = !1;
                                            }
                                            o = !o;
                                        }
                                        if (o = o && tc(i, p) && tc(p, i)) {
                                            o = i, k = !1, l = (i.x + p.x) / 2, p = (i.y + p.y) / 2;
                                            do {
                                                o.y > p != o.next.y > p && o.next.y !== o.y && l < (o.next.x - o.x) * (p - o.y) / (o.next.y - o.y) + o.x && (k = !k), 
                                                o = o.next;
                                            } while (o !== i);
                                            o = k;
                                        }
                                        i = o;
                                    }
                                    if (i) {
                                        a = uc(g, h), g = jc(g, g.next), a = jc(a, a.next), kc(g, b, c, d, e, f), kc(a, b, c, d, e, f);
                                        break a;
                                    }
                                    h = h.next;
                                }
                                g = g.next;
                            } while (g !== a);
                        }
                    } else kc(jc(a), b, c, d, e, f, 1);
                    break;
                }
            }
        }
    }
    function lc(a, b) {
        return a.x - b.x;
    }
    function mc(a, b) {
        var c = b, d = a.x, e = a.y, f = -1 / 0;
        do {
            if (e <= c.y && e >= c.next.y && c.next.y !== c.y) {
                var g = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
                if (g <= d && g > f) {
                    if (f = g, g === d) {
                        if (e === c.y) return c;
                        if (e === c.next.y) return c.next;
                    }
                    var h = c.x < c.next.x ? c : c.next;
                }
            }
            c = c.next;
        } while (c !== b);
        if (!h) return null;
        if (d === f) return h.prev;
        b = h, g = h.x;
        var i = h.y, j = 1 / 0;
        for (c = h.next; c !== b; ) {
            if (d >= c.x && c.x >= g && d !== c.x && pc(e < i ? d : f, e, g, i, e < i ? f : d, e, c.x, c.y)) {
                var k = Math.abs(e - c.y) / (d - c.x);
                (k < j || k === j && c.x > h.x) && tc(c, a) && (h = c, j = k);
            }
            c = c.next;
        }
        return h;
    }
    function nc(a, b, c, d, e) {
        return a = 32767 * (a - c) * e, b = 32767 * (b - d) * e, a = 16711935 & (a | a << 8), 
        a = 252645135 & (a | a << 4), a = 858993459 & (a | a << 2), b = 16711935 & (b | b << 8), 
        b = 252645135 & (b | b << 4), b = 858993459 & (b | b << 2), 1431655765 & (a | a << 1) | (1431655765 & (b | b << 1)) << 1;
    }
    function oc(a) {
        var b = a, c = a;
        do {
            b.x < c.x && (c = b), b = b.next;
        } while (b !== a);
        return c;
    }
    function pc(a, b, c, d, e, f, g, h) {
        return 0 <= (e - g) * (b - h) - (a - g) * (f - h) && 0 <= (a - g) * (d - h) - (c - g) * (b - h) && 0 <= (c - g) * (f - h) - (e - g) * (d - h);
    }
    function qc(a, b, c) {
        return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
    }
    function rc(a, b) {
        return a.x === b.x && a.y === b.y;
    }
    function sc(a, b, c, d) {
        return !!(rc(a, b) && rc(c, d) || rc(a, d) && rc(c, b)) || 0 < qc(a, b, c) != 0 < qc(a, b, d) && 0 < qc(c, d, a) != 0 < qc(c, d, b);
    }
    function tc(a, b) {
        return 0 > qc(a.prev, a, a.next) ? 0 <= qc(a, b, a.next) && 0 <= qc(a, a.prev, b) : 0 > qc(a, b, a.prev) || 0 > qc(a, a.next, b);
    }
    function uc(a, b) {
        var c = new xc(a.i, a.x, a.y), d = new xc(b.i, b.x, b.y), e = a.next, f = b.prev;
        return a.next = b, b.prev = a, c.next = e, e.prev = c, d.next = c, c.prev = d, f.next = d, 
        d.prev = f, d;
    }
    function vc(a, b, c, d) {
        return a = new xc(a, b, c), d ? (a.next = d.next, a.prev = d, d.next.prev = a, d.next = a) : (a.prev = a, 
        a.next = a), a;
    }
    function wc(a) {
        a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), 
        a.nextZ && (a.nextZ.prevZ = a.prevZ);
    }
    function xc(a, b, c) {
        this.i = a, this.x = b, this.y = c, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, 
        this.steiner = !1;
    }
    function yc(a) {
        var b = a.length;
        2 < b && a[b - 1].equals(a[0]) && a.pop();
    }
    function zc(a, b) {
        for (var c = 0; c < b.length; c++) a.push(b[c].x), a.push(b[c].y);
    }
    function Ac(a, b) {
        z.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: a,
            options: b
        }, this.fromBufferGeometry(new Bc(a, b)), this.mergeVertices();
    }
    function Bc(a, b) {
        function d(a) {
            function d(a, b, c) {
                return b || console.error("THREE.ExtrudeGeometry: vec does not exist"), b.clone().multiplyScalar(c).add(a);
            }
            function i(a, b, d) {
                var e = a.x - b.x, f = a.y - b.y, g = d.x - a.x, h = d.y - a.y, i = e * e + f * f;
                if (Math.abs(e * h - f * g) > Number.EPSILON) {
                    var j = Math.sqrt(i), k = Math.sqrt(g * g + h * h);
                    if (i = b.x - f / j, b = b.y + e / j, h = ((d.x - h / k - i) * h - (d.y + g / k - b) * g) / (e * h - f * g), 
                    g = i + e * h - a.x, e = b + f * h - a.y, 2 >= (f = g * g + e * e)) return new c(g, e);
                    f = Math.sqrt(f / 2);
                } else a = !1, e > Number.EPSILON ? g > Number.EPSILON && (a = !0) : e < -Number.EPSILON ? g < -Number.EPSILON && (a = !0) : Math.sign(f) === Math.sign(h) && (a = !0), 
                a ? (g = -f, f = Math.sqrt(i)) : (g = e, e = f, f = Math.sqrt(i / 2));
                return new c(g / f, e / f);
            }
            function j(a, b) {
                for (O = a.length; 0 <= --O; ) {
                    var c = O, d = O - 1;
                    0 > d && (d = a.length - 1);
                    var f, h = q + 2 * v;
                    for (f = 0; f < h; f++) {
                        var i = M * f, j = M * (f + 1), k = b + d + i, l = b + d + j;
                        j = b + c + j, m(b + c + i), m(k), m(j), m(k), m(l), m(j), i = g.length / 3, i = x.generateSideWallUV(e, g, i - 6, i - 3, i - 2, i - 1), 
                        n(i[0]), n(i[1]), n(i[3]), n(i[1]), n(i[2]), n(i[3]);
                    }
                }
            }
            function k(a, b, c) {
                o.push(a), o.push(b), o.push(c);
            }
            function l(a, b, c) {
                m(a), m(b), m(c), a = g.length / 3, a = x.generateTopUV(e, g, a - 3, a - 2, a - 1), 
                n(a[0]), n(a[1]), n(a[2]);
            }
            function m(a) {
                g.push(o[3 * a]), g.push(o[3 * a + 1]), g.push(o[3 * a + 2]);
            }
            function n(a) {
                h.push(a.x), h.push(a.y);
            }
            var o = [], p = void 0 !== b.curveSegments ? b.curveSegments : 12, q = void 0 !== b.steps ? b.steps : 1, r = void 0 !== b.depth ? b.depth : 100, s = void 0 === b.bevelEnabled || b.bevelEnabled, t = void 0 !== b.bevelThickness ? b.bevelThickness : 6, u = void 0 !== b.bevelSize ? b.bevelSize : t - 2, v = void 0 !== b.bevelSegments ? b.bevelSegments : 3, w = b.extrudePath, x = void 0 !== b.UVGenerator ? b.UVGenerator : zf;
            void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), 
            r = b.amount);
            var y = !1;
            if (w) {
                var z = w.getSpacedPoints(q);
                y = !0, s = !1;
                var A = w.computeFrenetFrames(q, !1), B = new f(), C = new f(), D = new f();
            }
            s || (u = t = v = 0);
            var E;
            p = a.extractPoints(p), a = p.shape;
            var F = p.holes;
            if (!yf.isClockWise(a)) {
                a = a.reverse();
                var G = 0;
                for (E = F.length; G < E; G++) {
                    var H = F[G];
                    yf.isClockWise(H) && (F[G] = H.reverse());
                }
            }
            var I = yf.triangulateShape(a, F), J = a;
            for (G = 0, E = F.length; G < E; G++) H = F[G], a = a.concat(H);
            var K, L, M = a.length, N = I.length;
            p = [];
            var O = 0, P = J.length, Q = P - 1;
            for (K = O + 1; O < P; O++, Q++, K++) Q === P && (Q = 0), K === P && (K = 0), p[O] = i(J[O], J[Q], J[K]);
            w = [];
            var R = p.concat();
            for (G = 0, E = F.length; G < E; G++) {
                H = F[G];
                var S = [];
                for (O = 0, P = H.length, Q = P - 1, K = O + 1; O < P; O++, Q++, K++) Q === P && (Q = 0), 
                K === P && (K = 0), S[O] = i(H[O], H[Q], H[K]);
                w.push(S), R = R.concat(S);
            }
            for (Q = 0; Q < v; Q++) {
                P = Q / v;
                var T = t * Math.cos(P * Math.PI / 2);
                for (K = u * Math.sin(P * Math.PI / 2), O = 0, P = J.length; O < P; O++) {
                    var U = d(J[O], p[O], K);
                    k(U.x, U.y, -T);
                }
                for (G = 0, E = F.length; G < E; G++) for (H = F[G], S = w[G], O = 0, P = H.length; O < P; O++) U = d(H[O], S[O], K), 
                k(U.x, U.y, -T);
            }
            for (K = u, O = 0; O < M; O++) U = s ? d(a[O], R[O], K) : a[O], y ? (C.copy(A.normals[0]).multiplyScalar(U.x), 
            B.copy(A.binormals[0]).multiplyScalar(U.y), D.copy(z[0]).add(C).add(B), k(D.x, D.y, D.z)) : k(U.x, U.y, 0);
            for (P = 1; P <= q; P++) for (O = 0; O < M; O++) U = s ? d(a[O], R[O], K) : a[O], 
            y ? (C.copy(A.normals[P]).multiplyScalar(U.x), B.copy(A.binormals[P]).multiplyScalar(U.y), 
            D.copy(z[P]).add(C).add(B), k(D.x, D.y, D.z)) : k(U.x, U.y, r / q * P);
            for (Q = v - 1; 0 <= Q; Q--) {
                for (P = Q / v, T = t * Math.cos(P * Math.PI / 2), K = u * Math.sin(P * Math.PI / 2), 
                O = 0, P = J.length; O < P; O++) U = d(J[O], p[O], K), k(U.x, U.y, r + T);
                for (G = 0, E = F.length; G < E; G++) for (H = F[G], S = w[G], O = 0, P = H.length; O < P; O++) U = d(H[O], S[O], K), 
                y ? k(U.x, U.y + z[q - 1].y, z[q - 1].x + T) : k(U.x, U.y, r + T);
            }
            !function() {
                var a = g.length / 3;
                if (s) {
                    var b = 0 * M;
                    for (O = 0; O < N; O++) L = I[O], l(L[2] + b, L[1] + b, L[0] + b);
                    for (b = M * (q + 2 * v), O = 0; O < N; O++) L = I[O], l(L[0] + b, L[1] + b, L[2] + b);
                } else {
                    for (O = 0; O < N; O++) L = I[O], l(L[2], L[1], L[0]);
                    for (O = 0; O < N; O++) L = I[O], l(L[0] + M * q, L[1] + M * q, L[2] + M * q);
                }
                e.addGroup(a, g.length / 3 - a, 0);
            }(), function() {
                var a = g.length / 3, b = 0;
                for (j(J, b), b += J.length, G = 0, E = F.length; G < E; G++) H = F[G], j(H, b), 
                b += H.length;
                e.addGroup(a, g.length / 3 - a, 1);
            }();
        }
        M.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: a,
            options: b
        }, a = Array.isArray(a) ? a : [ a ];
        for (var e = this, g = [], h = [], i = 0, j = a.length; i < j; i++) d(a[i]);
        this.addAttribute("position", new I(g, 3)), this.addAttribute("uv", new I(h, 2)), 
        this.computeVertexNormals();
    }
    function Cc(a, b, c) {
        if (c.shapes = [], Array.isArray(a)) for (var d = 0, e = a.length; d < e; d++) c.shapes.push(a[d].uuid); else c.shapes.push(a.uuid);
        return void 0 !== b.extrudePath && (c.options.extrudePath = b.extrudePath.toJSON()), 
        c;
    }
    function Dc(a, b) {
        z.call(this), this.type = "TextGeometry", this.parameters = {
            text: a,
            parameters: b
        }, this.fromBufferGeometry(new Ec(a, b)), this.mergeVertices();
    }
    function Ec(a, b) {
        b = b || {};
        var c = b.font;
        if (!c || !c.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), 
        new z();
        a = c.generateShapes(a, b.size), b.depth = void 0 !== b.height ? b.height : 50, 
        void 0 === b.bevelThickness && (b.bevelThickness = 10), void 0 === b.bevelSize && (b.bevelSize = 8), 
        void 0 === b.bevelEnabled && (b.bevelEnabled = !1), Bc.call(this, a, b), this.type = "TextBufferGeometry";
    }
    function Fc(a, b, c, d, e, f, g) {
        z.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: f,
            thetaLength: g
        }, this.fromBufferGeometry(new Gc(a, b, c, d, e, f, g)), this.mergeVertices();
    }
    function Gc(a, b, c, d, e, g, h) {
        M.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: c,
            phiStart: d,
            phiLength: e,
            thetaStart: g,
            thetaLength: h
        }, a = a || 1, b = Math.max(3, Math.floor(b) || 8), c = Math.max(2, Math.floor(c) || 6), 
        d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, g = void 0 !== g ? g : 0, 
        h = void 0 !== h ? h : Math.PI;
        var i, j, k = g + h, l = 0, m = [], n = new f(), o = new f(), p = [], q = [], r = [], s = [];
        for (j = 0; j <= c; j++) {
            var t = [], u = j / c;
            for (i = 0; i <= b; i++) {
                var v = i / b;
                n.x = -a * Math.cos(d + v * e) * Math.sin(g + u * h), n.y = a * Math.cos(g + u * h), 
                n.z = a * Math.sin(d + v * e) * Math.sin(g + u * h), q.push(n.x, n.y, n.z), o.set(n.x, n.y, n.z).normalize(), 
                r.push(o.x, o.y, o.z), s.push(v, 1 - u), t.push(l++);
            }
            m.push(t);
        }
        for (j = 0; j < c; j++) for (i = 0; i < b; i++) a = m[j][i + 1], d = m[j][i], e = m[j + 1][i], 
        h = m[j + 1][i + 1], (0 !== j || 0 < g) && p.push(a, d, h), (j !== c - 1 || k < Math.PI) && p.push(d, e, h);
        this.setIndex(p), this.addAttribute("position", new I(q, 3)), this.addAttribute("normal", new I(r, 3)), 
        this.addAttribute("uv", new I(s, 2));
    }
    function Hc(a, b, c, d, e, f) {
        z.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: c,
            phiSegments: d,
            thetaStart: e,
            thetaLength: f
        }, this.fromBufferGeometry(new Ic(a, b, c, d, e, f)), this.mergeVertices();
    }
    function Ic(a, b, d, e, g, h) {
        M.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: d,
            phiSegments: e,
            thetaStart: g,
            thetaLength: h
        }, a = a || .5, b = b || 1, g = void 0 !== g ? g : 0, h = void 0 !== h ? h : 2 * Math.PI, 
        d = void 0 !== d ? Math.max(3, d) : 8, e = void 0 !== e ? Math.max(1, e) : 1;
        var i, j, k = [], l = [], m = [], n = [], o = a, p = (b - a) / e, q = new f(), r = new c();
        for (i = 0; i <= e; i++) {
            for (j = 0; j <= d; j++) a = g + j / d * h, q.x = o * Math.cos(a), q.y = o * Math.sin(a), 
            l.push(q.x, q.y, q.z), m.push(0, 0, 1), r.x = (q.x / b + 1) / 2, r.y = (q.y / b + 1) / 2, 
            n.push(r.x, r.y);
            o += p;
        }
        for (i = 0; i < e; i++) for (b = i * (d + 1), j = 0; j < d; j++) a = j + b, g = a + d + 1, 
        h = a + d + 2, o = a + 1, k.push(a, g, o), k.push(g, h, o);
        this.setIndex(k), this.addAttribute("position", new I(l, 3)), this.addAttribute("normal", new I(m, 3)), 
        this.addAttribute("uv", new I(n, 2));
    }
    function Jc(a, b, c, d) {
        z.call(this), this.type = "LatheGeometry", this.parameters = {
            points: a,
            segments: b,
            phiStart: c,
            phiLength: d
        }, this.fromBufferGeometry(new Kc(a, b, c, d)), this.mergeVertices();
    }
    function Kc(a, b, d, e) {
        M.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: a,
            segments: b,
            phiStart: d,
            phiLength: e
        }, b = Math.floor(b) || 12, d = d || 0, e = e || 2 * Math.PI, e = _e.clamp(e, 0, 2 * Math.PI);
        var g, h = [], i = [], j = [], k = 1 / b, l = new f(), m = new c();
        for (g = 0; g <= b; g++) {
            var n = d + g * k * e, o = Math.sin(n), p = Math.cos(n);
            for (n = 0; n <= a.length - 1; n++) l.x = a[n].x * o, l.y = a[n].y, l.z = a[n].x * p, 
            i.push(l.x, l.y, l.z), m.x = g / b, m.y = n / (a.length - 1), j.push(m.x, m.y);
        }
        for (g = 0; g < b; g++) for (n = 0; n < a.length - 1; n++) d = n + g * a.length, 
        k = d + a.length, l = d + a.length + 1, m = d + 1, h.push(d, k, m), h.push(k, l, m);
        if (this.setIndex(h), this.addAttribute("position", new I(i, 3)), this.addAttribute("uv", new I(j, 2)), 
        this.computeVertexNormals(), e === 2 * Math.PI) for (e = this.attributes.normal.array, 
        h = new f(), i = new f(), j = new f(), d = b * a.length * 3, n = g = 0; g < a.length; g++, 
        n += 3) h.x = e[n + 0], h.y = e[n + 1], h.z = e[n + 2], i.x = e[d + n + 0], i.y = e[d + n + 1], 
        i.z = e[d + n + 2], j.addVectors(h, i).normalize(), e[n + 0] = e[d + n + 0] = j.x, 
        e[n + 1] = e[d + n + 1] = j.y, e[n + 2] = e[d + n + 2] = j.z;
    }
    function Lc(a, b) {
        z.call(this), this.type = "ShapeGeometry", "object" == typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), 
        b = b.curveSegments), this.parameters = {
            shapes: a,
            curveSegments: b
        }, this.fromBufferGeometry(new Mc(a, b)), this.mergeVertices();
    }
    function Mc(a, b) {
        function c(a) {
            var c, h = e.length / 3;
            a = a.extractPoints(b);
            var j = a.shape, k = a.holes;
            if (!1 === yf.isClockWise(j)) for (j = j.reverse(), a = 0, c = k.length; a < c; a++) {
                var l = k[a];
                !0 === yf.isClockWise(l) && (k[a] = l.reverse());
            }
            var m = yf.triangulateShape(j, k);
            for (a = 0, c = k.length; a < c; a++) l = k[a], j = j.concat(l);
            for (a = 0, c = j.length; a < c; a++) l = j[a], e.push(l.x, l.y, 0), f.push(0, 0, 1), 
            g.push(l.x, l.y);
            for (a = 0, c = m.length; a < c; a++) j = m[a], d.push(j[0] + h, j[1] + h, j[2] + h), 
            i += 3;
        }
        M.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: a,
            curveSegments: b
        }, b = b || 12;
        var d = [], e = [], f = [], g = [], h = 0, i = 0;
        if (!1 === Array.isArray(a)) c(a); else for (var j = 0; j < a.length; j++) c(a[j]), 
        this.addGroup(h, i, j), h += i, i = 0;
        this.setIndex(d), this.addAttribute("position", new I(e, 3)), this.addAttribute("normal", new I(f, 3)), 
        this.addAttribute("uv", new I(g, 2));
    }
    function Nc(a, b) {
        if (b.shapes = [], Array.isArray(a)) for (var c = 0, d = a.length; c < d; c++) b.shapes.push(a[c].uuid); else b.shapes.push(a.uuid);
        return b;
    }
    function Oc(a, b) {
        M.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: b
        };
        var c = [];
        b = Math.cos(_e.DEG2RAD * (void 0 !== b ? b : 1));
        var d = [ 0, 0 ], e = {}, f = [ "a", "b", "c" ];
        if (a.isBufferGeometry) {
            var g = new z();
            g.fromBufferGeometry(a);
        } else g = a.clone();
        g.mergeVertices(), g.computeFaceNormals(), a = g.vertices, g = g.faces;
        for (var h = 0, i = g.length; h < i; h++) for (var j = g[h], k = 0; 3 > k; k++) {
            var l = j[f[k]], m = j[f[(k + 1) % 3]];
            d[0] = Math.min(l, m), d[1] = Math.max(l, m), l = d[0] + "," + d[1], void 0 === e[l] ? e[l] = {
                index1: d[0],
                index2: d[1],
                face1: h,
                face2: void 0
            } : e[l].face2 = h;
        }
        for (l in e) d = e[l], (void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <= b) && (f = a[d.index1], 
        c.push(f.x, f.y, f.z), f = a[d.index2], c.push(f.x, f.y, f.z));
        this.addAttribute("position", new I(c, 3));
    }
    function Pc(a, b, c, d, e, f, g, h) {
        z.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: c,
            radialSegments: d,
            heightSegments: e,
            openEnded: f,
            thetaStart: g,
            thetaLength: h
        }, this.fromBufferGeometry(new Qc(a, b, c, d, e, f, g, h)), this.mergeVertices();
    }
    function Qc(a, b, d, e, g, h, i, j) {
        function k(d) {
            var g, h = new c(), k = new f(), r = 0, u = !0 === d ? a : b, v = !0 === d ? 1 : -1, w = q;
            for (g = 1; g <= e; g++) n.push(0, s * v, 0), o.push(0, v, 0), p.push(.5, .5), q++;
            var x = q;
            for (g = 0; g <= e; g++) {
                var y = g / e * j + i, z = Math.cos(y);
                y = Math.sin(y), k.x = u * y, k.y = s * v, k.z = u * z, n.push(k.x, k.y, k.z), o.push(0, v, 0), 
                h.x = .5 * z + .5, h.y = .5 * y * v + .5, p.push(h.x, h.y), q++;
            }
            for (g = 0; g < e; g++) h = w + g, k = x + g, !0 === d ? m.push(k, k + 1, h) : m.push(k + 1, k, h), 
            r += 3;
            l.addGroup(t, r, !0 === d ? 1 : 2), t += r;
        }
        M.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: d,
            radialSegments: e,
            heightSegments: g,
            openEnded: h,
            thetaStart: i,
            thetaLength: j
        };
        var l = this;
        a = void 0 !== a ? a : 1, b = void 0 !== b ? b : 1, d = d || 1, e = Math.floor(e) || 8, 
        g = Math.floor(g) || 1, h = void 0 !== h && h, i = void 0 !== i ? i : 0, j = void 0 !== j ? j : 2 * Math.PI;
        var m = [], n = [], o = [], p = [], q = 0, r = [], s = d / 2, t = 0;
        !function() {
            var c, h, k = new f(), u = new f(), v = 0, w = (b - a) / d;
            for (h = 0; h <= g; h++) {
                var x = [], y = h / g, z = y * (b - a) + a;
                for (c = 0; c <= e; c++) {
                    var A = c / e, B = A * j + i, C = Math.sin(B);
                    B = Math.cos(B), u.x = z * C, u.y = -y * d + s, u.z = z * B, n.push(u.x, u.y, u.z), 
                    k.set(C, w, B).normalize(), o.push(k.x, k.y, k.z), p.push(A, 1 - y), x.push(q++);
                }
                r.push(x);
            }
            for (c = 0; c < e; c++) for (h = 0; h < g; h++) k = r[h + 1][c], u = r[h + 1][c + 1], 
            w = r[h][c + 1], m.push(r[h][c], k, w), m.push(k, u, w), v += 6;
            l.addGroup(t, v, 0), t += v;
        }(), !1 === h && (0 < a && k(!0), 0 < b && k(!1)), this.setIndex(m), this.addAttribute("position", new I(n, 3)), 
        this.addAttribute("normal", new I(o, 3)), this.addAttribute("uv", new I(p, 2));
    }
    function Rc(a, b, c, d, e, f, g) {
        Pc.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeGeometry", this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: g
        };
    }
    function Sc(a, b, c, d, e, f, g) {
        Qc.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeBufferGeometry", this.parameters = {
            radius: a,
            height: b,
            radialSegments: c,
            heightSegments: d,
            openEnded: e,
            thetaStart: f,
            thetaLength: g
        };
    }
    function Tc(a, b, c, d) {
        z.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: a,
            segments: b,
            thetaStart: c,
            thetaLength: d
        }, this.fromBufferGeometry(new Uc(a, b, c, d)), this.mergeVertices();
    }
    function Uc(a, b, d, e) {
        M.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: a,
            segments: b,
            thetaStart: d,
            thetaLength: e
        }, a = a || 1, b = void 0 !== b ? Math.max(3, b) : 8, d = void 0 !== d ? d : 0, 
        e = void 0 !== e ? e : 2 * Math.PI;
        var g, h = [], i = [], j = [], k = [], l = new f(), m = new c();
        i.push(0, 0, 0), j.push(0, 0, 1), k.push(.5, .5);
        var n = 0;
        for (g = 3; n <= b; n++, g += 3) {
            var o = d + n / b * e;
            l.x = a * Math.cos(o), l.y = a * Math.sin(o), i.push(l.x, l.y, l.z), j.push(0, 0, 1), 
            m.x = (i[g] / a + 1) / 2, m.y = (i[g + 1] / a + 1) / 2, k.push(m.x, m.y);
        }
        for (g = 1; g <= b; g++) h.push(g, g + 1, 0);
        this.setIndex(h), this.addAttribute("position", new I(i, 3)), this.addAttribute("normal", new I(j, 3)), 
        this.addAttribute("uv", new I(k, 2));
    }
    function Vc(a) {
        R.call(this), this.type = "ShadowMaterial", this.color = new q(0), this.transparent = !0, 
        this.setValues(a);
    }
    function Wc(a) {
        T.call(this, a), this.type = "RawShaderMaterial";
    }
    function Xc(a) {
        R.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new q(16777215), this.metalness = this.roughness = .5, 
        this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, 
        this.aoMapIntensity = 1, this.emissive = new q(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, 
        this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new c(1, 1), 
        this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, 
        this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, 
        this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
        this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a);
    }
    function Yc(a) {
        Xc.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, 
        this.setValues(a);
    }
    function Zc(a) {
        R.call(this), this.type = "MeshPhongMaterial", this.color = new q(16777215), this.specular = new q(1118481), 
        this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, 
        this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new q(0), this.emissiveIntensity = 1, 
        this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, 
        this.normalMapType = 0, this.normalScale = new c(1, 1), this.displacementMap = null, 
        this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, 
        this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, 
        this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
        this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a);
    }
    function $c(a) {
        Zc.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(a);
    }
    function _c(a) {
        R.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, 
        this.normalMap = null, this.normalMapType = 0, this.normalScale = new c(1, 1), this.displacementMap = null, 
        this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, 
        this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, 
        this.setValues(a);
    }
    function ad(a) {
        R.call(this), this.type = "MeshLambertMaterial", this.color = new q(16777215), this.lightMap = this.map = null, 
        this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new q(0), 
        this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, 
        this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, 
        this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
        this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a);
    }
    function bd(a) {
        Hb.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, 
        this.gapSize = 1, this.setValues(a);
    }
    function cd(a, b, c) {
        var d = this, e = !1, f = 0, g = 0, h = void 0;
        this.onStart = void 0, this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function(a) {
            g++, !1 === e && void 0 !== d.onStart && d.onStart(a, f, g), e = !0;
        }, this.itemEnd = function(a) {
            f++, void 0 !== d.onProgress && d.onProgress(a, f, g), f === g && (e = !1, void 0 !== d.onLoad) && d.onLoad();
        }, this.itemError = function(a) {
            void 0 !== d.onError && d.onError(a);
        }, this.resolveURL = function(a) {
            return h ? h(a) : a;
        }, this.setURLModifier = function(a) {
            return h = a, this;
        };
    }
    function dd(a) {
        this.manager = void 0 !== a ? a : Df;
    }
    function ed(a) {
        this.manager = void 0 !== a ? a : Df, this._parser = null;
    }
    function fd(a) {
        this.manager = void 0 !== a ? a : Df, this._parser = null;
    }
    function gd(a) {
        this.manager = void 0 !== a ? a : Df;
    }
    function hd(a) {
        this.manager = void 0 !== a ? a : Df;
    }
    function id(a) {
        this.manager = void 0 !== a ? a : Df;
    }
    function jd() {
        this.type = "Curve", this.arcLengthDivisions = 200;
    }
    function kd(a, b, c, d, e, f, g, h) {
        jd.call(this), this.type = "EllipseCurve", this.aX = a || 0, this.aY = b || 0, this.xRadius = c || 1, 
        this.yRadius = d || 1, this.aStartAngle = e || 0, this.aEndAngle = f || 2 * Math.PI, 
        this.aClockwise = g || !1, this.aRotation = h || 0;
    }
    function ld(a, b, c, d, e, f) {
        kd.call(this, a, b, c, c, d, e, f), this.type = "ArcCurve";
    }
    function md() {
        var a = 0, b = 0, c = 0, d = 0;
        return {
            initCatmullRom: function(e, f, g, h, i) {
                e = i * (g - e), h = i * (h - f), a = f, b = e, c = -3 * f + 3 * g - 2 * e - h, 
                d = 2 * f - 2 * g + e + h;
            },
            initNonuniformCatmullRom: function(e, f, g, h, i, j, k) {
                e = ((f - e) / i - (g - e) / (i + j) + (g - f) / j) * j, h = ((g - f) / j - (h - f) / (j + k) + (h - g) / k) * j, 
                a = f, b = e, c = -3 * f + 3 * g - 2 * e - h, d = 2 * f - 2 * g + e + h;
            },
            calc: function(e) {
                var f = e * e;
                return a + b * e + c * f + d * f * e;
            }
        };
    }
    function nd(a, b, c, d) {
        jd.call(this), this.type = "CatmullRomCurve3", this.points = a || [], this.closed = b || !1, 
        this.curveType = c || "centripetal", this.tension = d || .5;
    }
    function od(a, b, c, d, e) {
        b = .5 * (d - b), e = .5 * (e - c);
        var f = a * a;
        return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c;
    }
    function pd(a, b, c, d) {
        var e = 1 - a;
        return e * e * b + 2 * (1 - a) * a * c + a * a * d;
    }
    function qd(a, b, c, d, e) {
        var f = 1 - a, g = 1 - a;
        return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e;
    }
    function rd(a, b, d, e) {
        jd.call(this), this.type = "CubicBezierCurve", this.v0 = a || new c(), this.v1 = b || new c(), 
        this.v2 = d || new c(), this.v3 = e || new c();
    }
    function sd(a, b, c, d) {
        jd.call(this), this.type = "CubicBezierCurve3", this.v0 = a || new f(), this.v1 = b || new f(), 
        this.v2 = c || new f(), this.v3 = d || new f();
    }
    function td(a, b) {
        jd.call(this), this.type = "LineCurve", this.v1 = a || new c(), this.v2 = b || new c();
    }
    function ud(a, b) {
        jd.call(this), this.type = "LineCurve3", this.v1 = a || new f(), this.v2 = b || new f();
    }
    function vd(a, b, d) {
        jd.call(this), this.type = "QuadraticBezierCurve", this.v0 = a || new c(), this.v1 = b || new c(), 
        this.v2 = d || new c();
    }
    function wd(a, b, c) {
        jd.call(this), this.type = "QuadraticBezierCurve3", this.v0 = a || new f(), this.v1 = b || new f(), 
        this.v2 = c || new f();
    }
    function xd(a) {
        jd.call(this), this.type = "SplineCurve", this.points = a || [];
    }
    function yd() {
        jd.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
    }
    function zd(a) {
        yd.call(this), this.type = "Path", this.currentPoint = new c(), a && this.setFromPoints(a);
    }
    function Ad(a) {
        zd.call(this, a), this.uuid = _e.generateUUID(), this.type = "Shape", this.holes = [];
    }
    function Bd(a, b) {
        v.call(this), this.type = "Light", this.color = new q(a), this.intensity = void 0 !== b ? b : 1, 
        this.receiveShadow = void 0;
    }
    function Cd(a, b, c) {
        Bd.call(this, a, c), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(v.DefaultUp), 
        this.updateMatrix(), this.groundColor = new q(b);
    }
    function Dd(a) {
        this.camera = a, this.bias = 0, this.radius = 1, this.mapSize = new c(512, 512), 
        this.map = null, this.matrix = new d();
    }
    function Ed() {
        Dd.call(this, new rb(50, 1, .5, 500));
    }
    function Fd(a, b, c, d, e, f) {
        Bd.call(this, a, b), this.type = "SpotLight", this.position.copy(v.DefaultUp), this.updateMatrix(), 
        this.target = new v(), Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI;
            },
            set: function(a) {
                this.intensity = a / Math.PI;
            }
        }), this.distance = void 0 !== c ? c : 0, this.angle = void 0 !== d ? d : Math.PI / 3, 
        this.penumbra = void 0 !== e ? e : 0, this.decay = void 0 !== f ? f : 1, this.shadow = new Ed();
    }
    function Gd(a, b, c, d) {
        Bd.call(this, a, b), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI;
            },
            set: function(a) {
                this.intensity = a / (4 * Math.PI);
            }
        }), this.distance = void 0 !== c ? c : 0, this.decay = void 0 !== d ? d : 1, this.shadow = new Dd(new rb(90, 1, .5, 500));
    }
    function Hd() {
        Dd.call(this, new x(-5, 5, 5, -5, .5, 500));
    }
    function Id(a, b) {
        Bd.call(this, a, b), this.type = "DirectionalLight", this.position.copy(v.DefaultUp), 
        this.updateMatrix(), this.target = new v(), this.shadow = new Hd();
    }
    function Jd(a, b) {
        Bd.call(this, a, b), this.type = "AmbientLight", this.castShadow = void 0;
    }
    function Kd(a, b, c, d) {
        Bd.call(this, a, b), this.type = "RectAreaLight", this.width = void 0 !== c ? c : 10, 
        this.height = void 0 !== d ? d : 10;
    }
    function Ld(a, b, c, d) {
        this.parameterPositions = a, this._cachedIndex = 0, this.resultBuffer = void 0 !== d ? d : new b.constructor(c), 
        this.sampleValues = b, this.valueSize = c;
    }
    function Md(a, b, c, d) {
        Ld.call(this, a, b, c, d), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
    }
    function Nd(a, b, c, d) {
        Ld.call(this, a, b, c, d);
    }
    function Od(a, b, c, d) {
        Ld.call(this, a, b, c, d);
    }
    function Pd(a, b, c, d) {
        if (void 0 === a) throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === b || 0 === b.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
        this.name = a, this.times = Kf.convertArray(b, this.TimeBufferType), this.values = Kf.convertArray(c, this.ValueBufferType), 
        this.setInterpolation(d || this.DefaultInterpolation);
    }
    function Qd(a, b, c) {
        Pd.call(this, a, b, c);
    }
    function Rd(a, b, c, d) {
        Pd.call(this, a, b, c, d);
    }
    function Sd(a, b, c, d) {
        Pd.call(this, a, b, c, d);
    }
    function Td(a, b, c, d) {
        Ld.call(this, a, b, c, d);
    }
    function Ud(a, b, c, d) {
        Pd.call(this, a, b, c, d);
    }
    function Vd(a, b, c, d) {
        Pd.call(this, a, b, c, d);
    }
    function Wd(a, b, c, d) {
        Pd.call(this, a, b, c, d);
    }
    function Xd(a, b, c) {
        this.name = a, this.tracks = c, this.duration = void 0 !== b ? b : -1, this.uuid = _e.generateUUID(), 
        0 > this.duration && this.resetDuration();
    }
    function Yd(a) {
        switch (a.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return Sd;

          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Wd;

          case "color":
            return Rd;

          case "quaternion":
            return Ud;

          case "bool":
          case "boolean":
            return Qd;

          case "string":
            return Vd;
        }
        throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
    }
    function Zd(a) {
        if (void 0 === a.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var b = Yd(a.type);
        if (void 0 === a.times) {
            var c = [], d = [];
            Kf.flattenJSON(a.keys, c, d, "value"), a.times = c, a.values = d;
        }
        return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation);
    }
    function $d(a) {
        this.manager = void 0 !== a ? a : Df, this.textures = {};
    }
    function _d(a) {
        this.manager = void 0 !== a ? a : Df;
    }
    function ae() {}
    function be(a) {
        "boolean" == typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), 
        a = void 0), this.manager = void 0 !== a ? a : Df, this.withCredentials = !1;
    }
    function ce(a) {
        this.manager = void 0 !== a ? a : Df, this.texturePath = "";
    }
    function de(a) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), 
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), 
        this.manager = void 0 !== a ? a : Df, this.options = void 0;
    }
    function ee() {
        this.type = "ShapePath", this.color = new q(), this.subPaths = [], this.currentPath = null;
    }
    function fe(a) {
        this.type = "Font", this.data = a;
    }
    function ge(a) {
        this.manager = void 0 !== a ? a : Df;
    }
    function he(a) {
        this.manager = void 0 !== a ? a : Df;
    }
    function ie() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new rb(), 
        this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new rb(), 
        this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
    }
    function je(a, b, c) {
        v.call(this), this.type = "CubeCamera";
        var d = new rb(90, 1, a, b);
        d.up.set(0, -1, 0), d.lookAt(new f(1, 0, 0)), this.add(d);
        var e = new rb(90, 1, a, b);
        e.up.set(0, -1, 0), e.lookAt(new f(-1, 0, 0)), this.add(e);
        var g = new rb(90, 1, a, b);
        g.up.set(0, 0, 1), g.lookAt(new f(0, 1, 0)), this.add(g);
        var h = new rb(90, 1, a, b);
        h.up.set(0, 0, -1), h.lookAt(new f(0, -1, 0)), this.add(h);
        var i = new rb(90, 1, a, b);
        i.up.set(0, -1, 0), i.lookAt(new f(0, 0, 1)), this.add(i);
        var j = new rb(90, 1, a, b);
        j.up.set(0, -1, 0), j.lookAt(new f(0, 0, -1)), this.add(j), this.renderTarget = new k(c, c, {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }), this.renderTarget.texture.name = "CubeCamera", this.update = function(a, b) {
            null === this.parent && this.updateMatrixWorld();
            var c = this.renderTarget, f = c.texture.generateMipmaps;
            c.texture.generateMipmaps = !1, c.activeCubeFace = 0, a.render(b, d, c), c.activeCubeFace = 1, 
            a.render(b, e, c), c.activeCubeFace = 2, a.render(b, g, c), c.activeCubeFace = 3, 
            a.render(b, h, c), c.activeCubeFace = 4, a.render(b, i, c), c.texture.generateMipmaps = f, 
            c.activeCubeFace = 5, a.render(b, j, c), a.setRenderTarget(null);
        }, this.clear = function(a, b, c, d) {
            for (var e = this.renderTarget, f = 0; 6 > f; f++) e.activeCubeFace = f, a.setRenderTarget(e), 
            a.clear(b, c, d);
            a.setRenderTarget(null);
        };
    }
    function ke() {
        v.call(this), this.type = "AudioListener", this.context = Rf.getContext(), this.gain = this.context.createGain(), 
        this.gain.connect(this.context.destination), this.filter = null;
    }
    function le(a) {
        v.call(this), this.type = "Audio", this.context = a.context, this.gain = this.context.createGain(), 
        this.gain.connect(a.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, 
        this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, 
        this.sourceType = "empty", this.filters = [];
    }
    function me(a) {
        le.call(this, a), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
    }
    function ne(a, b) {
        this.analyser = a.context.createAnalyser(), this.analyser.fftSize = void 0 !== b ? b : 2048, 
        this.data = new Uint8Array(this.analyser.frequencyBinCount), a.getOutput().connect(this.analyser);
    }
    function oe(a, b, c) {
        switch (this.binding = a, this.valueSize = c, a = Float64Array, b) {
          case "quaternion":
            b = this._slerp;
            break;

          case "string":
          case "bool":
            a = Array, b = this._select;
            break;

          default:
            b = this._lerp;
        }
        this.buffer = new a(4 * c), this._mixBufferRegion = b, this.referenceCount = this.useCount = this.cumulativeWeight = 0;
    }
    function pe(a, b, c) {
        c = c || qe.parseTrackName(b), this._targetGroup = a, this._bindings = a.subscribe_(b, c);
    }
    function qe(a, b, c) {
        this.path = b, this.parsedPath = c || qe.parseTrackName(b), this.node = qe.findNode(a, this.parsedPath.nodeName) || a, 
        this.rootNode = a;
    }
    function re() {
        this.uuid = _e.generateUUID(), this._objects = Array.prototype.slice.call(arguments), 
        this.nCachedObjects_ = 0;
        var a = {};
        this._indicesByUUID = a;
        for (var b = 0, c = arguments.length; b !== c; ++b) a[arguments[b].uuid] = b;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var d = this;
        this.stats = {
            objects: {
                get total() {
                    return d._objects.length;
                },
                get inUse() {
                    return this.total - d.nCachedObjects_;
                }
            },
            get bindingsPerObject() {
                return d._bindings.length;
            }
        };
    }
    function se(a, b, c) {
        this._mixer = a, this._clip = b, this._localRoot = c || null, a = b.tracks, b = a.length, 
        c = Array(b);
        for (var d = {
            endingStart: 2400,
            endingEnd: 2400
        }, e = 0; e !== b; ++e) {
            var f = a[e].createInterpolant(null);
            c[e] = f, f.settings = d;
        }
        this._interpolantSettings = d, this._interpolants = c, this._propertyBindings = Array(b), 
        this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, 
        this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, 
        this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, 
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
    }
    function te(a) {
        this._root = a, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1;
    }
    function ue(a, b) {
        "string" == typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), 
        a = b), this.value = a;
    }
    function ve() {
        M.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
    }
    function we(a, b, c) {
        zb.call(this, a, b), this.meshPerAttribute = c || 1;
    }
    function xe(a, b, c, d) {
        "number" == typeof c && (d = c, c = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), 
        A.call(this, a, b, c), this.meshPerAttribute = d || 1;
    }
    function ye(a, b, c, d) {
        this.ray = new U(a, b), this.near = c || 0, this.far = d || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), 
                    this.Points;
                }
            }
        });
    }
    function ze(a, b) {
        return a.distance - b.distance;
    }
    function Ae(a, b, c, d) {
        if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
            a = a.children, d = 0;
            for (var e = a.length; d < e; d++) Ae(a[d], b, c, !0);
        }
    }
    function Be(a) {
        this.autoStart = void 0 === a || a, this.elapsedTime = this.oldTime = this.startTime = 0, 
        this.running = !1;
    }
    function Ce(a, b, c) {
        return this.radius = void 0 !== a ? a : 1, this.phi = void 0 !== b ? b : 0, this.theta = void 0 !== c ? c : 0, 
        this;
    }
    function De(a, b, c) {
        return this.radius = void 0 !== a ? a : 1, this.theta = void 0 !== b ? b : 0, this.y = void 0 !== c ? c : 0, 
        this;
    }
    function Ee(a, b) {
        this.min = void 0 !== a ? a : new c(1 / 0, 1 / 0), this.max = void 0 !== b ? b : new c(-1 / 0, -1 / 0);
    }
    function Fe(a, b) {
        this.start = void 0 !== a ? a : new f(), this.end = void 0 !== b ? b : new f();
    }
    function Ge(a) {
        v.call(this), this.material = a, this.render = function() {};
    }
    function He(a, b, c, d) {
        this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16711680, 
        d = void 0 !== d ? d : 1, b = 0, (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count), 
        c = new M(), b = new I(6 * b, 3), c.addAttribute("position", b), Jb.call(this, c, new Hb({
            color: a,
            linewidth: d
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function Ie(a, b) {
        v.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
        this.matrixAutoUpdate = !1, this.color = b, a = new M(), b = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1 ];
        for (var c = 0, d = 1; 32 > c; c++, d++) {
            var e = c / 32 * Math.PI * 2, f = d / 32 * Math.PI * 2;
            b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1);
        }
        a.addAttribute("position", new I(b, 3)), b = new Hb({
            fog: !1
        }), this.cone = new Jb(a, b), this.add(this.cone), this.update();
    }
    function Je(a) {
        var b = [];
        a && a.isBone && b.push(a);
        for (var c = 0; c < a.children.length; c++) b.push.apply(b, Je(a.children[c]));
        return b;
    }
    function Ke(a) {
        for (var b = Je(a), c = new M(), d = [], e = [], f = new q(0, 0, 1), g = new q(0, 1, 0), h = 0; h < b.length; h++) {
            var i = b[h];
            i.parent && i.parent.isBone && (d.push(0, 0, 0), d.push(0, 0, 0), e.push(f.r, f.g, f.b), 
            e.push(g.r, g.g, g.b));
        }
        c.addAttribute("position", new I(d, 3)), c.addAttribute("color", new I(e, 3)), d = new Hb({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), Jb.call(this, c, d), this.root = a, this.bones = b, this.matrix = a.matrixWorld, 
        this.matrixAutoUpdate = !1;
    }
    function Le(a, b, c) {
        this.light = a, this.light.updateMatrixWorld(), this.color = c, a = new Gc(b, 4, 2), 
        b = new S({
            wireframe: !0,
            fog: !1
        }), W.call(this, a, b), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, 
        this.update();
    }
    function Me(a, b) {
        v.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
        this.matrixAutoUpdate = !1, this.color = b, a = new Hb({
            fog: !1
        }), b = new M(), b.addAttribute("position", new A(new Float32Array(15), 3)), this.line = new Ib(b, a), 
        this.add(this.line), this.update();
    }
    function Ne(a, b, c) {
        v.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
        this.matrixAutoUpdate = !1, this.color = c, a = new Zb(b), a.rotateY(.5 * Math.PI), 
        this.material = new S({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = 2), b = a.getAttribute("position"), 
        b = new Float32Array(3 * b.count), a.addAttribute("color", new A(b, 3)), this.add(new W(a, this.material)), 
        this.update();
    }
    function Oe(a, b, c, d) {
        a = a || 10, b = b || 10, c = new q(void 0 !== c ? c : 4473924), d = new q(void 0 !== d ? d : 8947848);
        var e = b / 2, f = a / b, g = a / 2;
        a = [];
        for (var h = [], i = 0, j = 0, k = -g; i <= b; i++, k += f) {
            a.push(-g, 0, k, g, 0, k), a.push(k, 0, -g, k, 0, g);
            var l = i === e ? c : d;
            l.toArray(h, j), j += 3, l.toArray(h, j), j += 3, l.toArray(h, j), j += 3, l.toArray(h, j), 
            j += 3;
        }
        b = new M(), b.addAttribute("position", new I(a, 3)), b.addAttribute("color", new I(h, 3)), 
        c = new Hb({
            vertexColors: 2
        }), Jb.call(this, b, c);
    }
    function Pe(a, b, c, d, e, f) {
        a = a || 10, b = b || 16, c = c || 8, d = d || 64, e = new q(void 0 !== e ? e : 4473924), 
        f = new q(void 0 !== f ? f : 8947848);
        var g, h = [], i = [];
        for (g = 0; g <= b; g++) {
            var j = g / b * 2 * Math.PI, k = Math.sin(j) * a;
            j = Math.cos(j) * a, h.push(0, 0, 0), h.push(k, 0, j);
            var l = 1 & g ? e : f;
            i.push(l.r, l.g, l.b), i.push(l.r, l.g, l.b);
        }
        for (g = 0; g <= c; g++) {
            l = 1 & g ? e : f;
            var m = a - a / c * g;
            for (b = 0; b < d; b++) j = b / d * 2 * Math.PI, k = Math.sin(j) * m, j = Math.cos(j) * m, 
            h.push(k, 0, j), i.push(l.r, l.g, l.b), j = (b + 1) / d * 2 * Math.PI, k = Math.sin(j) * m, 
            j = Math.cos(j) * m, h.push(k, 0, j), i.push(l.r, l.g, l.b);
        }
        a = new M(), a.addAttribute("position", new I(h, 3)), a.addAttribute("color", new I(i, 3)), 
        h = new Hb({
            vertexColors: 2
        }), Jb.call(this, a, h);
    }
    function Qe(a, b, c, d) {
        this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16776960, 
        d = void 0 !== d ? d : 1, b = 0, (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), 
        c = new M(), b = new I(6 * b, 3), c.addAttribute("position", b), Jb.call(this, c, new Hb({
            color: a,
            linewidth: d
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function Re(a, b, c) {
        v.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
        this.matrixAutoUpdate = !1, this.color = c, void 0 === b && (b = 1), a = new M(), 
        a.addAttribute("position", new I([ -b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0 ], 3)), 
        b = new Hb({
            fog: !1
        }), this.lightPlane = new Ib(a, b), this.add(this.lightPlane), a = new M(), a.addAttribute("position", new I([ 0, 0, 0, 0, 0, 1 ], 3)), 
        this.targetLine = new Ib(a, b), this.add(this.targetLine), this.update();
    }
    function Se(a) {
        function b(a, b, d) {
            c(a, d), c(b, d);
        }
        function c(a, b) {
            f.push(0, 0, 0), g.push(b.r, b.g, b.b), void 0 === h[a] && (h[a] = []), h[a].push(f.length / 3 - 1);
        }
        var d = new M(), e = new Hb({
            color: 16777215,
            vertexColors: 1
        }), f = [], g = [], h = {}, i = new q(16755200), j = new q(16711680), k = new q(43775), l = new q(16777215), m = new q(3355443);
        b("n1", "n2", i), b("n2", "n4", i), b("n4", "n3", i), b("n3", "n1", i), b("f1", "f2", i), 
        b("f2", "f4", i), b("f4", "f3", i), b("f3", "f1", i), b("n1", "f1", i), b("n2", "f2", i), 
        b("n3", "f3", i), b("n4", "f4", i), b("p", "n1", j), b("p", "n2", j), b("p", "n3", j), 
        b("p", "n4", j), b("u1", "u2", k), b("u2", "u3", k), b("u3", "u1", k), b("c", "t", l), 
        b("p", "c", m), b("cn1", "cn2", m), b("cn3", "cn4", m), b("cf1", "cf2", m), b("cf3", "cf4", m), 
        d.addAttribute("position", new I(f, 3)), d.addAttribute("color", new I(g, 3)), Jb.call(this, d, e), 
        this.camera = a, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), 
        this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = h, this.update();
    }
    function Te(a, b) {
        this.object = a, void 0 === b && (b = 16776960), a = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]);
        var c = new Float32Array(24), d = new M();
        d.setIndex(new A(a, 1)), d.addAttribute("position", new A(c, 3)), Jb.call(this, d, new Hb({
            color: b
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function Ue(a, b) {
        this.type = "Box3Helper", this.box = a, a = void 0 !== b ? b : 16776960, b = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]);
        var c = new M();
        c.setIndex(new A(b, 1)), c.addAttribute("position", new I([ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 ], 3)), 
        Jb.call(this, c, new Hb({
            color: a
        })), this.geometry.computeBoundingSphere();
    }
    function Ve(a, b, c) {
        this.type = "PlaneHelper", this.plane = a, this.size = void 0 === b ? 1 : b, a = void 0 !== c ? c : 16776960, 
        b = new M(), b.addAttribute("position", new I([ 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ], 3)), 
        b.computeBoundingSphere(), Ib.call(this, b, new Hb({
            color: a
        })), b = new M(), b.addAttribute("position", new I([ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1 ], 3)), 
        b.computeBoundingSphere(), this.add(new W(b, new S({
            color: a,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })));
    }
    function We(a, b, c, d, e, f) {
        v.call(this), void 0 === d && (d = 16776960), void 0 === c && (c = 1), void 0 === e && (e = .2 * c), 
        void 0 === f && (f = .2 * e), void 0 === Sf && (Sf = new M(), Sf.addAttribute("position", new I([ 0, 0, 0, 0, 1, 0 ], 3)), 
        Tf = new Qc(0, .5, 1, 5, 1), Tf.translate(0, -.5, 0)), this.position.copy(b), this.line = new Ib(Sf, new Hb({
            color: d
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new W(Tf, new S({
            color: d
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(a), 
        this.setLength(c, e, f);
    }
    function Xe(a) {
        a = a || 1;
        var b = [ 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a ];
        a = new M(), a.addAttribute("position", new I(b, 3)), a.addAttribute("color", new I([ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ], 3)), 
        b = new Hb({
            vertexColors: 2
        }), Jb.call(this, a, b);
    }
    function Ye(a) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), 
        nd.call(this, a), this.type = "catmullrom", this.closed = !0;
    }
    function Ze(a) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), 
        nd.call(this, a), this.type = "catmullrom";
    }
    function $e(a) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), 
        nd.call(this, a), this.type = "catmullrom";
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(a) {
        return "number" == typeof a && isFinite(a) && Math.floor(a) === a;
    }), void 0 === Math.sign && (Math.sign = function(a) {
        return 0 > a ? -1 : 0 < a ? 1 : +a;
    }), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        }
    }), void 0 === Object.assign && function() {
        Object.assign = function(a) {
            if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
            for (var b = Object(a), c = 1; c < arguments.length; c++) {
                var d = arguments[c];
                if (void 0 !== d && null !== d) for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]);
            }
            return b;
        };
    }(), Object.assign(b.prototype, {
        addEventListener: function(a, b) {
            void 0 === this._listeners && (this._listeners = {});
            var c = this._listeners;
            void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b);
        },
        hasEventListener: function(a, b) {
            if (void 0 === this._listeners) return !1;
            var c = this._listeners;
            return void 0 !== c[a] && -1 !== c[a].indexOf(b);
        },
        removeEventListener: function(a, b) {
            void 0 !== this._listeners && void 0 !== (a = this._listeners[a]) && -1 !== (b = a.indexOf(b)) && a.splice(b, 1);
        },
        dispatchEvent: function(a) {
            if (void 0 !== this._listeners) {
                var b = this._listeners[a.type];
                if (void 0 !== b) {
                    a.target = this, b = b.slice(0);
                    for (var c = 0, d = b.length; c < d; c++) b[c].call(this, a);
                }
            }
        }
    });
    var _e = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var a = [], b = 0; 256 > b; b++) a[b] = (16 > b ? "0" : "") + b.toString(16);
            return function() {
                var b = 4294967295 * Math.random() | 0, c = 4294967295 * Math.random() | 0, d = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0;
                return (a[255 & b] + a[b >> 8 & 255] + a[b >> 16 & 255] + a[b >> 24 & 255] + "-" + a[255 & c] + a[c >> 8 & 255] + "-" + a[c >> 16 & 15 | 64] + a[c >> 24 & 255] + "-" + a[63 & d | 128] + a[d >> 8 & 255] + "-" + a[d >> 16 & 255] + a[d >> 24 & 255] + a[255 & e] + a[e >> 8 & 255] + a[e >> 16 & 255] + a[e >> 24 & 255]).toUpperCase();
            };
        }(),
        clamp: function(a, b, c) {
            return Math.max(b, Math.min(c, a));
        },
        euclideanModulo: function(a, b) {
            return (a % b + b) % b;
        },
        mapLinear: function(a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b);
        },
        lerp: function(a, b, c) {
            return (1 - c) * a + c * b;
        },
        smoothstep: function(a, b, c) {
            return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b)) * a * (3 - 2 * a);
        },
        smootherstep: function(a, b, c) {
            return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b)) * a * a * (a * (6 * a - 15) + 10);
        },
        randInt: function(a, b) {
            return a + Math.floor(Math.random() * (b - a + 1));
        },
        randFloat: function(a, b) {
            return a + Math.random() * (b - a);
        },
        randFloatSpread: function(a) {
            return a * (.5 - Math.random());
        },
        degToRad: function(a) {
            return a * _e.DEG2RAD;
        },
        radToDeg: function(a) {
            return a * _e.RAD2DEG;
        },
        isPowerOfTwo: function(a) {
            return 0 == (a & a - 1) && 0 !== a;
        },
        ceilPowerOfTwo: function(a) {
            return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
        },
        floorPowerOfTwo: function(a) {
            return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
        }
    };
    Object.defineProperties(c.prototype, {
        width: {
            get: function() {
                return this.x;
            },
            set: function(a) {
                this.x = a;
            }
        },
        height: {
            get: function() {
                return this.y;
            },
            set: function(a) {
                this.y = a;
            }
        }
    }), Object.assign(c.prototype, {
        isVector2: !0,
        set: function(a, b) {
            return this.x = a, this.y = b, this;
        },
        setScalar: function(a) {
            return this.y = this.x = a, this;
        },
        setX: function(a) {
            return this.x = a, this;
        },
        setY: function(a) {
            return this.y = a, this;
        },
        setComponent: function(a, b) {
            switch (a) {
              case 0:
                this.x = b;
                break;

              case 1:
                this.y = b;
                break;

              default:
                throw Error("index is out of range: " + a);
            }
            return this;
        },
        getComponent: function(a) {
            switch (a) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              default:
                throw Error("index is out of range: " + a);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y);
        },
        copy: function(a) {
            return this.x = a.x, this.y = a.y, this;
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this);
        },
        addScalar: function(a) {
            return this.x += a, this.y += a, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this;
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b, this.y += a.y * b, this;
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this);
        },
        subScalar: function(a) {
            return this.x -= a, this.y -= a, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this;
        },
        multiply: function(a) {
            return this.x *= a.x, this.y *= a.y, this;
        },
        multiplyScalar: function(a) {
            return this.x *= a, this.y *= a, this;
        },
        divide: function(a) {
            return this.x /= a.x, this.y /= a.y, this;
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a);
        },
        applyMatrix3: function(a) {
            var b = this.x, c = this.y;
            return a = a.elements, this.x = a[0] * b + a[3] * c + a[6], this.y = a[1] * b + a[4] * c + a[7], 
            this;
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this;
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this;
        },
        clamp: function(a, b) {
            return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), 
            this;
        },
        clampScalar: function() {
            var a = new c(), b = new c();
            return function(c, d) {
                return a.set(c, c), b.set(d, d), this.clamp(a, b);
            };
        }(),
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
            this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this;
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y;
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        angle: function() {
            var a = Math.atan2(this.y, this.x);
            return 0 > a && (a += 2 * Math.PI), a;
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a));
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x;
            return a = this.y - a.y, b * b + a * a;
        },
        manhattanDistanceTo: function(a) {
            return Math.abs(this.x - a.x) + Math.abs(this.y - a.y);
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a);
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this;
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a);
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y;
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this;
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
            a;
        },
        fromBufferAttribute: function(a, b, c) {
            return void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), 
            this.x = a.getX(b), this.y = a.getY(b), this;
        },
        rotateAround: function(a, b) {
            var c = Math.cos(b);
            b = Math.sin(b);
            var d = this.x - a.x, e = this.y - a.y;
            return this.x = d * c - e * b + a.x, this.y = d * b + e * c + a.y, this;
        }
    }), Object.assign(d.prototype, {
        isMatrix4: !0,
        set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
            var q = this.elements;
            return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, 
            q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, 
            this;
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        clone: function() {
            return new d().fromArray(this.elements);
        },
        copy: function(a) {
            var b = this.elements;
            return a = a.elements, b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], 
            b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], 
            b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], this;
        },
        copyPosition: function(a) {
            var b = this.elements;
            return a = a.elements, b[12] = a[12], b[13] = a[13], b[14] = a[14], this;
        },
        extractBasis: function(a, b, c) {
            return a.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), 
            this;
        },
        makeBasis: function(a, b, c) {
            return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), 
            this;
        },
        extractRotation: function() {
            var a = new f();
            return function(b) {
                var c = this.elements, d = b.elements, e = 1 / a.setFromMatrixColumn(b, 0).length(), f = 1 / a.setFromMatrixColumn(b, 1).length();
                return b = 1 / a.setFromMatrixColumn(b, 2).length(), c[0] = d[0] * e, c[1] = d[1] * e, 
                c[2] = d[2] * e, c[3] = 0, c[4] = d[4] * f, c[5] = d[5] * f, c[6] = d[6] * f, c[7] = 0, 
                c[8] = d[8] * b, c[9] = d[9] * b, c[10] = d[10] * b, c[11] = 0, c[12] = 0, c[13] = 0, 
                c[14] = 0, c[15] = 1, this;
            };
        }(),
        makeRotationFromEuler: function(a) {
            a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c);
            c = Math.sin(c);
            var g = Math.cos(d);
            d = Math.sin(d);
            var h = Math.cos(e);
            if (e = Math.sin(e), "XYZ" === a.order) {
                a = f * h;
                var i = f * e, j = c * h, k = c * e;
                b[0] = g * h, b[4] = -g * e, b[8] = d, b[1] = i + j * d, b[5] = a - k * d, b[9] = -c * g, 
                b[2] = k - a * d, b[6] = j + i * d, b[10] = f * g;
            } else "YXZ" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a + k * c, 
            b[4] = j * c - i, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = i * c - j, 
            b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, i = g * e, j = d * h, 
            k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = j + i * c, b[1] = i + j * c, 
            b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, 
            i = f * e, j = c * h, k = c * e, b[0] = g * h, b[4] = j * d - i, b[8] = a * d + k, 
            b[1] = g * e, b[5] = k * d + a, b[9] = i * d - j, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, 
            i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = j * e + i, 
            b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = i * e + j, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, 
            i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, 
            b[5] = f * h, b[9] = i * e - j, b[2] = j * e - i, b[6] = c * h, b[10] = k * e + a);
            return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, 
            this;
        },
        makeRotationFromQuaternion: function() {
            var a = new f(0, 0, 0), b = new f(1, 1, 1);
            return function(c) {
                return this.compose(a, c, b);
            };
        }(),
        lookAt: function() {
            var a = new f(), b = new f(), c = new f();
            return function(d, e, f) {
                var g = this.elements;
                return c.subVectors(d, e), 0 === c.lengthSq() && (c.z = 1), c.normalize(), a.crossVectors(f, c), 
                0 === a.lengthSq() && (1 === Math.abs(f.z) ? c.x += 1e-4 : c.z += 1e-4, c.normalize(), 
                a.crossVectors(f, c)), a.normalize(), b.crossVectors(c, a), g[0] = a.x, g[4] = b.x, 
                g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, g[6] = b.z, g[10] = c.z, 
                this;
            };
        }(),
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), 
            this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
        },
        premultiply: function(a) {
            return this.multiplyMatrices(a, this);
        },
        multiplyMatrices: function(a, b) {
            var c = a.elements, d = b.elements;
            b = this.elements, a = c[0];
            var e = c[4], f = c[8], g = c[12], h = c[1], i = c[5], j = c[9], k = c[13], l = c[2], m = c[6], n = c[10], o = c[14], p = c[3], q = c[7], r = c[11];
            c = c[15];
            var s = d[0], t = d[4], u = d[8], v = d[12], w = d[1], x = d[5], y = d[9], z = d[13], A = d[2], B = d[6], C = d[10], D = d[14], E = d[3], F = d[7], G = d[11];
            return d = d[15], b[0] = a * s + e * w + f * A + g * E, b[4] = a * t + e * x + f * B + g * F, 
            b[8] = a * u + e * y + f * C + g * G, b[12] = a * v + e * z + f * D + g * d, b[1] = h * s + i * w + j * A + k * E, 
            b[5] = h * t + i * x + j * B + k * F, b[9] = h * u + i * y + j * C + k * G, b[13] = h * v + i * z + j * D + k * d, 
            b[2] = l * s + m * w + n * A + o * E, b[6] = l * t + m * x + n * B + o * F, b[10] = l * u + m * y + n * C + o * G, 
            b[14] = l * v + m * z + n * D + o * d, b[3] = p * s + q * w + r * A + c * E, b[7] = p * t + q * x + r * B + c * F, 
            b[11] = p * u + q * y + r * C + c * G, b[15] = p * v + q * z + r * D + c * d, this;
        },
        multiplyScalar: function(a) {
            var b = this.elements;
            return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, 
            b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, 
            b[11] *= a, b[15] *= a, this;
        },
        applyToBufferAttribute: function() {
            var a = new f();
            return function(b) {
                for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), 
                a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z);
                return b;
            };
        }(),
        determinant: function() {
            var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], i = a[13], j = a[2], k = a[6], l = a[10], m = a[14];
            return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j);
        },
        transpose: function() {
            var a = this.elements, b = a[1];
            return a[1] = a[4], a[4] = b, b = a[2], a[2] = a[8], a[8] = b, b = a[6], a[6] = a[9], 
            a[9] = b, b = a[3], a[3] = a[12], a[12] = b, b = a[7], a[7] = a[13], a[13] = b, 
            b = a[11], a[11] = a[14], a[14] = b, this;
        },
        setPosition: function(a) {
            var b = this.elements;
            return b[12] = a.x, b[13] = a.y, b[14] = a.z, this;
        },
        getInverse: function(a, b) {
            var c = this.elements, d = a.elements;
            a = d[0];
            var e = d[1], f = d[2], g = d[3], h = d[4], i = d[5], j = d[6], k = d[7], l = d[8], m = d[9], n = d[10], o = d[11], p = d[12], q = d[13], r = d[14];
            d = d[15];
            var s = m * r * k - q * n * k + q * j * o - i * r * o - m * j * d + i * n * d, t = p * n * k - l * r * k - p * j * o + h * r * o + l * j * d - h * n * d, u = l * q * k - p * m * k + p * i * o - h * q * o - l * i * d + h * m * d, v = p * m * j - l * q * j - p * i * n + h * q * n + l * i * r - h * m * r, w = a * s + e * t + f * u + g * v;
            if (0 === w) {
                if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), 
                this.identity();
            }
            return b = 1 / w, c[0] = s * b, c[1] = (q * n * g - m * r * g - q * f * o + e * r * o + m * f * d - e * n * d) * b, 
            c[2] = (i * r * g - q * j * g + q * f * k - e * r * k - i * f * d + e * j * d) * b, 
            c[3] = (m * j * g - i * n * g - m * f * k + e * n * k + i * f * o - e * j * o) * b, 
            c[4] = t * b, c[5] = (l * r * g - p * n * g + p * f * o - a * r * o - l * f * d + a * n * d) * b, 
            c[6] = (p * j * g - h * r * g - p * f * k + a * r * k + h * f * d - a * j * d) * b, 
            c[7] = (h * n * g - l * j * g + l * f * k - a * n * k - h * f * o + a * j * o) * b, 
            c[8] = u * b, c[9] = (p * m * g - l * q * g - p * e * o + a * q * o + l * e * d - a * m * d) * b, 
            c[10] = (h * q * g - p * i * g + p * e * k - a * q * k - h * e * d + a * i * d) * b, 
            c[11] = (l * i * g - h * m * g - l * e * k + a * m * k + h * e * o - a * i * o) * b, 
            c[12] = v * b, c[13] = (l * q * f - p * m * f + p * e * n - a * q * n - l * e * r + a * m * r) * b, 
            c[14] = (p * i * f - h * q * f - p * e * j + a * q * j + h * e * r - a * i * r) * b, 
            c[15] = (h * m * f - l * i * f + l * e * j - a * m * j - h * e * n + a * i * n) * b, 
            this;
        },
        scale: function(a) {
            var b = this.elements, c = a.x, d = a.y;
            return a = a.z, b[0] *= c, b[4] *= d, b[8] *= a, b[1] *= c, b[5] *= d, b[9] *= a, 
            b[2] *= c, b[6] *= d, b[10] *= a, b[3] *= c, b[7] *= d, b[11] *= a, this;
        },
        getMaxScaleOnAxis: function() {
            var a = this.elements;
            return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]));
        },
        makeTranslation: function(a, b, c) {
            return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this;
        },
        makeRotationX: function(a) {
            var b = Math.cos(a);
            return a = Math.sin(a), this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), 
            this;
        },
        makeRotationY: function(a) {
            var b = Math.cos(a);
            return a = Math.sin(a), this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), 
            this;
        },
        makeRotationZ: function(a) {
            var b = Math.cos(a);
            return a = Math.sin(a), this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 
            this;
        },
        makeRotationAxis: function(a, b) {
            var c = Math.cos(b);
            b = Math.sin(b);
            var d = 1 - c, e = a.x, f = a.y;
            a = a.z;
            var g = d * e, h = d * f;
            return this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0, 0, 0, 1), 
            this;
        },
        makeScale: function(a, b, c) {
            return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this;
        },
        makeShear: function(a, b, c) {
            return this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1), this;
        },
        compose: function(a, b, c) {
            var d = this.elements, e = b._x, f = b._y, g = b._z, h = b._w, i = e + e, j = f + f, k = g + g;
            b = e * i;
            var l = e * j;
            e *= k;
            var m = f * j;
            f *= k, g *= k, i *= h, j *= h, h *= k, k = c.x;
            var n = c.y;
            return c = c.z, d[0] = (1 - (m + g)) * k, d[1] = (l + h) * k, d[2] = (e - j) * k, 
            d[3] = 0, d[4] = (l - h) * n, d[5] = (1 - (b + g)) * n, d[6] = (f + i) * n, d[7] = 0, 
            d[8] = (e + j) * c, d[9] = (f - i) * c, d[10] = (1 - (b + m)) * c, d[11] = 0, d[12] = a.x, 
            d[13] = a.y, d[14] = a.z, d[15] = 1, this;
        },
        decompose: function() {
            var a = new f(), b = new d();
            return function(c, d, e) {
                var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), i = a.set(f[8], f[9], f[10]).length();
                0 > this.determinant() && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14], b.copy(this), 
                c = 1 / g, f = 1 / h;
                var j = 1 / i;
                return b.elements[0] *= c, b.elements[1] *= c, b.elements[2] *= c, b.elements[4] *= f, 
                b.elements[5] *= f, b.elements[6] *= f, b.elements[8] *= j, b.elements[9] *= j, 
                b.elements[10] *= j, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = i, this;
            };
        }(),
        makePerspective: function(a, b, c, d, e, f) {
            void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var g = this.elements;
            return g[0] = 2 * e / (b - a), g[4] = 0, g[8] = (b + a) / (b - a), g[12] = 0, g[1] = 0, 
            g[5] = 2 * e / (c - d), g[9] = (c + d) / (c - d), g[13] = 0, g[2] = 0, g[6] = 0, 
            g[10] = -(f + e) / (f - e), g[14] = -2 * f * e / (f - e), g[3] = 0, g[7] = 0, g[11] = -1, 
            g[15] = 0, this;
        },
        makeOrthographic: function(a, b, c, d, e, f) {
            var g = this.elements, h = 1 / (b - a), i = 1 / (c - d), j = 1 / (f - e);
            return g[0] = 2 * h, g[4] = 0, g[8] = 0, g[12] = -(b + a) * h, g[1] = 0, g[5] = 2 * i, 
            g[9] = 0, g[13] = -(c + d) * i, g[2] = 0, g[6] = 0, g[10] = -2 * j, g[14] = -(f + e) * j, 
            g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this;
        },
        equals: function(a) {
            var b = this.elements;
            a = a.elements;
            for (var c = 0; 16 > c; c++) if (b[c] !== a[c]) return !1;
            return !0;
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
            return this;
        },
        toArray: function(a, b) {
            void 0 === a && (a = []), void 0 === b && (b = 0);
            var c = this.elements;
            return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], 
            a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], 
            a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], 
            a[b + 15] = c[15], a;
        }
    }), Object.assign(e, {
        slerp: function(a, b, c, d) {
            return c.copy(a).slerp(b, d);
        },
        slerpFlat: function(a, b, c, d, e, f, g) {
            var h = c[d + 0], i = c[d + 1], j = c[d + 2];
            c = c[d + 3], d = e[f + 0];
            var k = e[f + 1], l = e[f + 2];
            if (e = e[f + 3], c !== e || h !== d || i !== k || j !== l) {
                f = 1 - g;
                var m = h * d + i * k + j * l + c * e, n = 0 <= m ? 1 : -1, o = 1 - m * m;
                o > Number.EPSILON && (o = Math.sqrt(o), m = Math.atan2(o, m * n), f = Math.sin(f * m) / o, 
                g = Math.sin(g * m) / o), n *= g, h = h * f + d * n, i = i * f + k * n, j = j * f + l * n, 
                c = c * f + e * n, f === 1 - g && (g = 1 / Math.sqrt(h * h + i * i + j * j + c * c), 
                h *= g, i *= g, j *= g, c *= g);
            }
            a[b] = h, a[b + 1] = i, a[b + 2] = j, a[b + 3] = c;
        }
    }), Object.defineProperties(e.prototype, {
        x: {
            get: function() {
                return this._x;
            },
            set: function(a) {
                this._x = a, this.onChangeCallback();
            }
        },
        y: {
            get: function() {
                return this._y;
            },
            set: function(a) {
                this._y = a, this.onChangeCallback();
            }
        },
        z: {
            get: function() {
                return this._z;
            },
            set: function(a) {
                this._z = a, this.onChangeCallback();
            }
        },
        w: {
            get: function() {
                return this._w;
            },
            set: function(a) {
                this._w = a, this.onChangeCallback();
            }
        }
    }), Object.assign(e.prototype, {
        set: function(a, b, c, d) {
            return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), 
            this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function(a) {
            return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), 
            this;
        },
        setFromEuler: function(a, b) {
            if (!a || !a.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var c = a._x, d = a._y, e = a._z;
            a = a.order;
            var f = Math.cos, g = Math.sin, h = f(c / 2), i = f(d / 2);
            return f = f(e / 2), c = g(c / 2), d = g(d / 2), e = g(e / 2), "XYZ" === a ? (this._x = c * i * f + h * d * e, 
            this._y = h * d * f - c * i * e, this._z = h * i * e + c * d * f, this._w = h * i * f - c * d * e) : "YXZ" === a ? (this._x = c * i * f + h * d * e, 
            this._y = h * d * f - c * i * e, this._z = h * i * e - c * d * f, this._w = h * i * f + c * d * e) : "ZXY" === a ? (this._x = c * i * f - h * d * e, 
            this._y = h * d * f + c * i * e, this._z = h * i * e + c * d * f, this._w = h * i * f - c * d * e) : "ZYX" === a ? (this._x = c * i * f - h * d * e, 
            this._y = h * d * f + c * i * e, this._z = h * i * e - c * d * f, this._w = h * i * f + c * d * e) : "YZX" === a ? (this._x = c * i * f + h * d * e, 
            this._y = h * d * f + c * i * e, this._z = h * i * e - c * d * f, this._w = h * i * f - c * d * e) : "XZY" === a && (this._x = c * i * f - h * d * e, 
            this._y = h * d * f - c * i * e, this._z = h * i * e + c * d * f, this._w = h * i * f + c * d * e), 
            !1 !== b && this.onChangeCallback(), this;
        },
        setFromAxisAngle: function(a, b) {
            b /= 2;
            var c = Math.sin(b);
            return this._x = a.x * c, this._y = a.y * c, this._z = a.z * c, this._w = Math.cos(b), 
            this.onChangeCallback(), this;
        },
        setFromRotationMatrix: function(a) {
            var b = a.elements, c = b[0];
            a = b[4];
            var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], i = b[6];
            b = b[10];
            var j = c + f + b;
            return 0 < j ? (c = .5 / Math.sqrt(j + 1), this._w = .25 / c, this._x = (i - g) * c, 
            this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), 
            this._w = (i - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), 
            this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), 
            this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + i) / c, this._z = .25 * c), 
            this.onChangeCallback(), this;
        },
        setFromUnitVectors: function() {
            var a, b = new f();
            return function(c, d) {
                return void 0 === b && (b = new f()), a = c.dot(d) + 1, 1e-6 > a ? (a = 0, Math.abs(c.x) > Math.abs(c.z) ? b.set(-c.y, c.x, 0) : b.set(0, -c.z, c.y)) : b.crossVectors(c, d), 
                this._x = b.x, this._y = b.y, this._z = b.z, this._w = a, this.normalize();
            };
        }(),
        angleTo: function(a) {
            return 2 * Math.acos(Math.abs(_e.clamp(this.dot(a), -1, 1)));
        },
        rotateTowards: function(a, b) {
            var c = this.angleTo(a);
            return 0 === c ? this : (this.slerp(a, Math.min(1, b / c)), this);
        },
        inverse: function() {
            return this.conjugate();
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
        },
        dot: function(a) {
            return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },
        normalize: function() {
            var a = this.length();
            return 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, 
            this._y *= a, this._z *= a, this._w *= a), this.onChangeCallback(), this;
        },
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), 
            this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
        },
        premultiply: function(a) {
            return this.multiplyQuaternions(a, this);
        },
        multiplyQuaternions: function(a, b) {
            var c = a._x, d = a._y, e = a._z;
            a = a._w;
            var f = b._x, g = b._y, h = b._z;
            return b = b._w, this._x = c * b + a * f + d * h - e * g, this._y = d * b + a * g + e * f - c * h, 
            this._z = e * b + a * h + c * g - d * f, this._w = a * b - c * f - d * g - e * h, 
            this.onChangeCallback(), this;
        },
        slerp: function(a, b) {
            if (0 === b) return this;
            if (1 === b) return this.copy(a);
            var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
            if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, 
            g = -g) : this.copy(a), 1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, 
            this;
            if ((a = 1 - g * g) <= Number.EPSILON) return g = 1 - b, this._w = g * f + b * this._w, 
            this._x = g * c + b * this._x, this._y = g * d + b * this._y, this._z = g * e + b * this._z, 
            this.normalize();
            a = Math.sqrt(a);
            var h = Math.atan2(a, g);
            return g = Math.sin((1 - b) * h) / a, b = Math.sin(b * h) / a, this._w = f * g + this._w * b, 
            this._x = c * g + this._x * b, this._y = d * g + this._y * b, this._z = e * g + this._z * b, 
            this.onChangeCallback(), this;
        },
        equals: function(a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], 
            this._w = a[b + 3], this.onChangeCallback(), this;
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, 
            a[b + 2] = this._z, a[b + 3] = this._w, a;
        },
        onChange: function(a) {
            return this.onChangeCallback = a, this;
        },
        onChangeCallback: function() {}
    }), Object.assign(f.prototype, {
        isVector3: !0,
        set: function(a, b, c) {
            return this.x = a, this.y = b, this.z = c, this;
        },
        setScalar: function(a) {
            return this.z = this.y = this.x = a, this;
        },
        setX: function(a) {
            return this.x = a, this;
        },
        setY: function(a) {
            return this.y = a, this;
        },
        setZ: function(a) {
            return this.z = a, this;
        },
        setComponent: function(a, b) {
            switch (a) {
              case 0:
                this.x = b;
                break;

              case 1:
                this.y = b;
                break;

              case 2:
                this.z = b;
                break;

              default:
                throw Error("index is out of range: " + a);
            }
            return this;
        },
        getComponent: function(a) {
            switch (a) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              default:
                throw Error("index is out of range: " + a);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z);
        },
        copy: function(a) {
            return this.x = a.x, this.y = a.y, this.z = a.z, this;
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this);
        },
        addScalar: function(a) {
            return this.x += a, this.y += a, this.z += a, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this;
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this);
        },
        subScalar: function(a) {
            return this.x -= a, this.y -= a, this.z -= a, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
        },
        multiply: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), 
            this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this);
        },
        multiplyScalar: function(a) {
            return this.x *= a, this.y *= a, this.z *= a, this;
        },
        multiplyVectors: function(a, b) {
            return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
        },
        applyEuler: function() {
            var a = new e();
            return function(b) {
                return b && b.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), 
                this.applyQuaternion(a.setFromEuler(b));
            };
        }(),
        applyAxisAngle: function() {
            var a = new e();
            return function(b, c) {
                return this.applyQuaternion(a.setFromAxisAngle(b, c));
            };
        }(),
        applyMatrix3: function(a) {
            var b = this.x, c = this.y, d = this.z;
            return a = a.elements, this.x = a[0] * b + a[3] * c + a[6] * d, this.y = a[1] * b + a[4] * c + a[7] * d, 
            this.z = a[2] * b + a[5] * c + a[8] * d, this;
        },
        applyMatrix4: function(a) {
            var b = this.x, c = this.y, d = this.z;
            a = a.elements;
            var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
            return this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e, this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e, 
            this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e, this;
        },
        applyQuaternion: function(a) {
            var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
            a = a.w;
            var h = a * b + f * d - g * c, i = a * c + g * b - e * d, j = a * d + e * c - f * b;
            return b = -e * b - f * c - g * d, this.x = h * a + b * -e + i * -g - j * -f, this.y = i * a + b * -f + j * -e - h * -g, 
            this.z = j * a + b * -g + h * -f - i * -e, this;
        },
        project: function(a) {
            return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix);
        },
        unproject: function() {
            var a = new d();
            return function(b) {
                return this.applyMatrix4(a.getInverse(b.projectionMatrix)).applyMatrix4(b.matrixWorld);
            };
        }(),
        transformDirection: function(a) {
            var b = this.x, c = this.y, d = this.z;
            return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d, this.y = a[1] * b + a[5] * c + a[9] * d, 
            this.z = a[2] * b + a[6] * c + a[10] * d, this.normalize();
        },
        divide: function(a) {
            return this.x /= a.x, this.y /= a.y, this.z /= a.z, this;
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a);
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), 
            this;
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), 
            this;
        },
        clamp: function(a, b) {
            return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), 
            this.z = Math.max(a.z, Math.min(b.z, this.z)), this;
        },
        clampScalar: function() {
            var a = new f(), b = new f();
            return function(c, d) {
                return a.set(c, c, c), b.set(d, d, d), this.clamp(a, b);
            };
        }(),
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
            this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
            this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
            this;
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a);
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, 
            this;
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a);
        },
        cross: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), 
            this.crossVectors(a, b)) : this.crossVectors(this, a);
        },
        crossVectors: function(a, b) {
            var c = a.x, d = a.y;
            a = a.z;
            var e = b.x, f = b.y;
            return b = b.z, this.x = d * b - a * f, this.y = a * e - c * b, this.z = c * f - d * e, 
            this;
        },
        projectOnVector: function(a) {
            var b = a.dot(this) / a.lengthSq();
            return this.copy(a).multiplyScalar(b);
        },
        projectOnPlane: function() {
            var a = new f();
            return function(b) {
                return a.copy(this).projectOnVector(b), this.sub(a);
            };
        }(),
        reflect: function() {
            var a = new f();
            return function(b) {
                return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
            };
        }(),
        angleTo: function(a) {
            return a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq()), Math.acos(_e.clamp(a, -1, 1));
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a));
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x, c = this.y - a.y;
            return a = this.z - a.z, b * b + c * c + a * a;
        },
        manhattanDistanceTo: function(a) {
            return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z);
        },
        setFromSpherical: function(a) {
            return this.setFromSphericalCoords(a.radius, a.phi, a.theta);
        },
        setFromSphericalCoords: function(a, b, c) {
            var d = Math.sin(b) * a;
            return this.x = d * Math.sin(c), this.y = Math.cos(b) * a, this.z = d * Math.cos(c), 
            this;
        },
        setFromCylindrical: function(a) {
            return this.setFromCylindricalCoords(a.radius, a.theta, a.y);
        },
        setFromCylindricalCoords: function(a, b, c) {
            return this.x = a * Math.sin(b), this.y = c, this.z = a * Math.cos(b), this;
        },
        setFromMatrixPosition: function(a) {
            return a = a.elements, this.x = a[12], this.y = a[13], this.z = a[14], this;
        },
        setFromMatrixScale: function(a) {
            var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length();
            return a = this.setFromMatrixColumn(a, 2).length(), this.x = b, this.y = c, this.z = a, 
            this;
        },
        setFromMatrixColumn: function(a, b) {
            return this.fromArray(a.elements, 4 * b);
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z;
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], 
            this;
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
            a[b + 2] = this.z, a;
        },
        fromBufferAttribute: function(a, b, c) {
            return void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), 
            this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this;
        }
    }), Object.assign(g.prototype, {
        isMatrix3: !0,
        set: function(a, b, c, d, e, f, g, h, i) {
            var j = this.elements;
            return j[0] = a, j[1] = d, j[2] = g, j[3] = b, j[4] = e, j[5] = h, j[6] = c, j[7] = f, 
            j[8] = i, this;
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        },
        clone: function() {
            return new this.constructor().fromArray(this.elements);
        },
        copy: function(a) {
            var b = this.elements;
            return a = a.elements, b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], 
            b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], this;
        },
        setFromMatrix4: function(a) {
            return a = a.elements, this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]), 
            this;
        },
        applyToBufferAttribute: function() {
            var a = new f();
            return function(b) {
                for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), 
                a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z);
                return b;
            };
        }(),
        multiply: function(a) {
            return this.multiplyMatrices(this, a);
        },
        premultiply: function(a) {
            return this.multiplyMatrices(a, this);
        },
        multiplyMatrices: function(a, b) {
            var c = a.elements, d = b.elements;
            b = this.elements, a = c[0];
            var e = c[3], f = c[6], g = c[1], h = c[4], i = c[7], j = c[2], k = c[5];
            c = c[8];
            var l = d[0], m = d[3], n = d[6], o = d[1], p = d[4], q = d[7], r = d[2], s = d[5];
            return d = d[8], b[0] = a * l + e * o + f * r, b[3] = a * m + e * p + f * s, b[6] = a * n + e * q + f * d, 
            b[1] = g * l + h * o + i * r, b[4] = g * m + h * p + i * s, b[7] = g * n + h * q + i * d, 
            b[2] = j * l + k * o + c * r, b[5] = j * m + k * p + c * s, b[8] = j * n + k * q + c * d, 
            this;
        },
        multiplyScalar: function(a) {
            var b = this.elements;
            return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, 
            b[5] *= a, b[8] *= a, this;
        },
        determinant: function() {
            var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7];
            return a = a[8], b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h;
        },
        getInverse: function(a, b) {
            a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var c = a.elements;
            a = this.elements;
            var d = c[0], e = c[1], f = c[2], g = c[3], h = c[4], i = c[5], j = c[6], k = c[7];
            c = c[8];
            var l = c * h - i * k, m = i * j - c * g, n = k * g - h * j, o = d * l + e * m + f * n;
            if (0 === o) {
                if (!0 === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), 
                this.identity();
            }
            return b = 1 / o, a[0] = l * b, a[1] = (f * k - c * e) * b, a[2] = (i * e - f * h) * b, 
            a[3] = m * b, a[4] = (c * d - f * j) * b, a[5] = (f * g - i * d) * b, a[6] = n * b, 
            a[7] = (e * j - k * d) * b, a[8] = (h * d - e * g) * b, this;
        },
        transpose: function() {
            var a = this.elements, b = a[1];
            return a[1] = a[3], a[3] = b, b = a[2], a[2] = a[6], a[6] = b, b = a[5], a[5] = a[7], 
            a[7] = b, this;
        },
        getNormalMatrix: function(a) {
            return this.setFromMatrix4(a).getInverse(this).transpose();
        },
        transposeIntoArray: function(a) {
            var b = this.elements;
            return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], 
            a[6] = b[2], a[7] = b[5], a[8] = b[8], this;
        },
        setUvTransform: function(a, b, c, d, e, f, g) {
            var h = Math.cos(e);
            e = Math.sin(e), this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g + b, 0, 0, 1);
        },
        scale: function(a, b) {
            var c = this.elements;
            return c[0] *= a, c[3] *= a, c[6] *= a, c[1] *= b, c[4] *= b, c[7] *= b, this;
        },
        rotate: function(a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            var c = this.elements, d = c[0], e = c[3], f = c[6], g = c[1], h = c[4], i = c[7];
            return c[0] = b * d + a * g, c[3] = b * e + a * h, c[6] = b * f + a * i, c[1] = -a * d + b * g, 
            c[4] = -a * e + b * h, c[7] = -a * f + b * i, this;
        },
        translate: function(a, b) {
            var c = this.elements;
            return c[0] += a * c[2], c[3] += a * c[5], c[6] += a * c[8], c[1] += b * c[2], c[4] += b * c[5], 
            c[7] += b * c[8], this;
        },
        equals: function(a) {
            var b = this.elements;
            a = a.elements;
            for (var c = 0; 9 > c; c++) if (b[c] !== a[c]) return !1;
            return !0;
        },
        fromArray: function(a, b) {
            void 0 === b && (b = 0);
            for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
            return this;
        },
        toArray: function(a, b) {
            void 0 === a && (a = []), void 0 === b && (b = 0);
            var c = this.elements;
            return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], 
            a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a;
        }
    });
    var af = {
        getDataURL: function(a) {
            if (a instanceof HTMLCanvasElement) var b = a; else {
                b = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), b.width = a.width, 
                b.height = a.height;
                var c = b.getContext("2d");
                a instanceof ImageData ? c.putImageData(a, 0, 0) : c.drawImage(a, 0, 0, a.width, a.height);
            }
            return 2048 < b.width || 2048 < b.height ? b.toDataURL("image/jpeg", .6) : b.toDataURL("image/png");
        }
    }, bf = 0;
    h.DEFAULT_IMAGE = void 0, h.DEFAULT_MAPPING = 300, h.prototype = Object.assign(Object.create(b.prototype), {
        constructor: h,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.name = a.name, this.image = a.image, this.mipmaps = a.mipmaps.slice(0), 
            this.mapping = a.mapping, this.wrapS = a.wrapS, this.wrapT = a.wrapT, this.magFilter = a.magFilter, 
            this.minFilter = a.minFilter, this.anisotropy = a.anisotropy, this.format = a.format, 
            this.type = a.type, this.offset.copy(a.offset), this.repeat.copy(a.repeat), this.center.copy(a.center), 
            this.rotation = a.rotation, this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrix.copy(a.matrix), 
            this.generateMipmaps = a.generateMipmaps, this.premultiplyAlpha = a.premultiplyAlpha, 
            this.flipY = a.flipY, this.unpackAlignment = a.unpackAlignment, this.encoding = a.encoding, 
            this;
        },
        toJSON: function(a) {
            var b = void 0 === a || "string" == typeof a;
            if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
            var c = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [ this.repeat.x, this.repeat.y ],
                offset: [ this.offset.x, this.offset.y ],
                center: [ this.center.x, this.center.y ],
                rotation: this.rotation,
                wrap: [ this.wrapS, this.wrapT ],
                format: this.format,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var d = this.image;
                if (void 0 === d.uuid && (d.uuid = _e.generateUUID()), !b && void 0 === a.images[d.uuid]) {
                    if (Array.isArray(d)) for (var e = [], f = 0, g = d.length; f < g; f++) e.push(af.getDataURL(d[f])); else e = af.getDataURL(d);
                    a.images[d.uuid] = {
                        uuid: d.uuid,
                        url: e
                    };
                }
                c.image = d.uuid;
            }
            return b || (a.textures[this.uuid] = c), c;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        },
        transformUv: function(a) {
            if (300 !== this.mapping) return a;
            if (a.applyMatrix3(this.matrix), 0 > a.x || 1 < a.x) switch (this.wrapS) {
              case 1e3:
                a.x -= Math.floor(a.x);
                break;

              case 1001:
                a.x = 0 > a.x ? 0 : 1;
                break;

              case 1002:
                a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x);
            }
            if (0 > a.y || 1 < a.y) switch (this.wrapT) {
              case 1e3:
                a.y -= Math.floor(a.y);
                break;

              case 1001:
                a.y = 0 > a.y ? 0 : 1;
                break;

              case 1002:
                a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y);
            }
            return this.flipY && (a.y = 1 - a.y), a;
        }
    }), Object.defineProperty(h.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++;
        }
    }), Object.assign(i.prototype, {
        isVector4: !0,
        set: function(a, b, c, d) {
            return this.x = a, this.y = b, this.z = c, this.w = d, this;
        },
        setScalar: function(a) {
            return this.w = this.z = this.y = this.x = a, this;
        },
        setX: function(a) {
            return this.x = a, this;
        },
        setY: function(a) {
            return this.y = a, this;
        },
        setZ: function(a) {
            return this.z = a, this;
        },
        setW: function(a) {
            return this.w = a, this;
        },
        setComponent: function(a, b) {
            switch (a) {
              case 0:
                this.x = b;
                break;

              case 1:
                this.y = b;
                break;

              case 2:
                this.z = b;
                break;

              case 3:
                this.w = b;
                break;

              default:
                throw Error("index is out of range: " + a);
            }
            return this;
        },
        getComponent: function(a) {
            switch (a) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              case 3:
                return this.w;

              default:
                throw Error("index is out of range: " + a);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function(a) {
            return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, 
            this;
        },
        add: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, 
            this);
        },
        addScalar: function(a) {
            return this.x += a, this.y += a, this.z += a, this.w += a, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, 
            this;
        },
        addScaledVector: function(a, b) {
            return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, 
            this;
        },
        sub: function(a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, 
            this);
        },
        subScalar: function(a) {
            return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, 
            this;
        },
        multiplyScalar: function(a) {
            return this.x *= a, this.y *= a, this.z *= a, this.w *= a, this;
        },
        applyMatrix4: function(a) {
            var b = this.x, c = this.y, d = this.z, e = this.w;
            return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e, this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e, 
            this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e, this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e, 
            this;
        },
        divideScalar: function(a) {
            return this.multiplyScalar(1 / a);
        },
        setAxisAngleFromQuaternion: function(a) {
            this.w = 2 * Math.acos(a.w);
            var b = Math.sqrt(1 - a.w * a.w);
            return 1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, 
            this.z = a.z / b), this;
        },
        setAxisAngleFromRotationMatrix: function(a) {
            a = a.elements;
            var b = a[0], c = a[4], d = a[8], e = a[1], f = a[5], g = a[9], h = a[2], i = a[6], j = a[10];
            return .01 > Math.abs(c - e) && .01 > Math.abs(d - h) && .01 > Math.abs(g - i) ? .1 > Math.abs(c + e) && .1 > Math.abs(d + h) && .1 > Math.abs(g + i) && .1 > Math.abs(b + f + j - 3) ? (this.set(1, 0, 0, 0), 
            this) : (a = Math.PI, b = (b + 1) / 2, f = (f + 1) / 2, j = (j + 1) / 2, c = (c + e) / 4, 
            d = (d + h) / 4, g = (g + i) / 4, b > f && b > j ? .01 > b ? (i = 0, c = h = .707106781) : (i = Math.sqrt(b), 
            h = c / i, c = d / i) : f > j ? .01 > f ? (i = .707106781, h = 0, c = .707106781) : (h = Math.sqrt(f), 
            i = c / h, c = g / h) : .01 > j ? (h = i = .707106781, c = 0) : (c = Math.sqrt(j), 
            i = d / c, h = g / c), this.set(i, h, c, a), this) : (a = Math.sqrt((i - g) * (i - g) + (d - h) * (d - h) + (e - c) * (e - c)), 
            .001 > Math.abs(a) && (a = 1), this.x = (i - g) / a, this.y = (d - h) / a, this.z = (e - c) / a, 
            this.w = Math.acos((b + f + j - 1) / 2), this);
        },
        min: function(a) {
            return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), 
            this.w = Math.min(this.w, a.w), this;
        },
        max: function(a) {
            return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), 
            this.w = Math.max(this.w, a.w), this;
        },
        clamp: function(a, b) {
            return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), 
            this.z = Math.max(a.z, Math.min(b.z, this.z)), this.w = Math.max(a.w, Math.min(b.w, this.w)), 
            this;
        },
        clampScalar: function() {
            var a, b;
            return function(c, d) {
                return void 0 === a && (a = new i(), b = new i()), a.set(c, c, c, c), b.set(d, d, d, d), 
                this.clamp(a, b);
            };
        }(),
        clampLength: function(a, b) {
            var c = this.length();
            return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
            this.w = Math.floor(this.w), this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
            this.w = Math.ceil(this.w), this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
            this.w = Math.round(this.w), this;
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), 
            this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function(a) {
            return this.normalize().multiplyScalar(a);
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, 
            this.w += (a.w - this.w) * b, this;
        },
        lerpVectors: function(a, b, c) {
            return this.subVectors(b, a).multiplyScalar(c).add(a);
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], 
            this.w = a[b + 3], this;
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
            a[b + 2] = this.z, a[b + 3] = this.w, a;
        },
        fromBufferAttribute: function(a, b, c) {
            return void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), 
            this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this.w = a.getW(b), 
            this;
        }
    }), j.prototype = Object.assign(Object.create(b.prototype), {
        constructor: j,
        isWebGLRenderTarget: !0,
        setSize: function(a, b) {
            this.width === a && this.height === b || (this.width = a, this.height = b, this.dispose()), 
            this.viewport.set(0, 0, a, b), this.scissor.set(0, 0, a, b);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.width = a.width, this.height = a.height, this.viewport.copy(a.viewport), 
            this.texture = a.texture.clone(), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, 
            this.depthTexture = a.depthTexture, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), k.prototype = Object.create(j.prototype), k.prototype.constructor = k, k.prototype.isWebGLRenderTargetCube = !0, 
    l.prototype = Object.create(h.prototype), l.prototype.constructor = l, l.prototype.isDataTexture = !0, 
    Object.assign(m.prototype, {
        isBox3: !0,
        set: function(a, b) {
            return this.min.copy(a), this.max.copy(b), this;
        },
        setFromArray: function(a) {
            for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -1 / 0, f = -1 / 0, g = -1 / 0, h = 0, i = a.length; h < i; h += 3) {
                var j = a[h], k = a[h + 1], l = a[h + 2];
                j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), 
                l > g && (g = l);
            }
            return this.min.set(b, c, d), this.max.set(e, f, g), this;
        },
        setFromBufferAttribute: function(a) {
            for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -1 / 0, f = -1 / 0, g = -1 / 0, h = 0, i = a.count; h < i; h++) {
                var j = a.getX(h), k = a.getY(h), l = a.getZ(h);
                j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), 
                l > g && (g = l);
            }
            return this.min.set(b, c, d), this.max.set(e, f, g), this;
        },
        setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
            return this;
        },
        setFromCenterAndSize: function() {
            var a = new f();
            return function(b, c) {
                return c = a.copy(c).multiplyScalar(.5), this.min.copy(b).sub(c), this.max.copy(b).add(c), 
                this;
            };
        }(),
        setFromObject: function(a) {
            return this.makeEmpty(), this.expandByObject(a);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.min.copy(a.min), this.max.copy(a.max), this;
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, 
            this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        },
        getCenter: function(a) {
            return void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), 
            a = new f()), this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(a) {
            return void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), 
            a = new f()), this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min);
        },
        expandByPoint: function(a) {
            return this.min.min(a), this.max.max(a), this;
        },
        expandByVector: function(a) {
            return this.min.sub(a), this.max.add(a), this;
        },
        expandByScalar: function(a) {
            return this.min.addScalar(-a), this.max.addScalar(a), this;
        },
        expandByObject: function() {
            function a(a) {
                var f = a.geometry;
                if (void 0 !== f) if (f.isGeometry) for (f = f.vertices, c = 0, d = f.length; c < d; c++) e.copy(f[c]), 
                e.applyMatrix4(a.matrixWorld), b.expandByPoint(e); else if (f.isBufferGeometry && void 0 !== (f = f.attributes.position)) for (c = 0, 
                d = f.count; c < d; c++) e.fromBufferAttribute(f, c).applyMatrix4(a.matrixWorld), 
                b.expandByPoint(e);
            }
            var b, c, d, e = new f();
            return function(c) {
                return b = this, c.updateMatrixWorld(!0), c.traverse(a), this;
            };
        }(),
        containsPoint: function(a) {
            return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z);
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z;
        },
        getParameter: function(a, b) {
            return void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), 
            b = new f()), b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
        },
        intersectsBox: function(a) {
            return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z);
        },
        intersectsSphere: function() {
            var a = new f();
            return function(b) {
                return this.clampPoint(b.center, a), a.distanceToSquared(b.center) <= b.radius * b.radius;
            };
        }(),
        intersectsPlane: function(a) {
            if (0 < a.normal.x) var b = a.normal.x * this.min.x, c = a.normal.x * this.max.x; else b = a.normal.x * this.max.x, 
            c = a.normal.x * this.min.x;
            return 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, 
            c += a.normal.y * this.min.y), 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, 
            c += a.normal.z * this.min.z), b <= a.constant && c >= a.constant;
        },
        intersectsTriangle: function() {
            function a(a) {
                var e, f = 0;
                for (e = a.length - 3; f <= e; f += 3) {
                    i.fromArray(a, f);
                    var g = k.x * Math.abs(i.x) + k.y * Math.abs(i.y) + k.z * Math.abs(i.z), h = b.dot(i), j = c.dot(i), l = d.dot(i);
                    if (Math.max(-Math.max(h, j, l), Math.min(h, j, l)) > g) return !1;
                }
                return !0;
            }
            var b = new f(), c = new f(), d = new f(), e = new f(), g = new f(), h = new f(), i = new f(), j = new f(), k = new f(), l = new f();
            return function(f) {
                return !this.isEmpty() && (this.getCenter(j), k.subVectors(this.max, j), b.subVectors(f.a, j), 
                c.subVectors(f.b, j), d.subVectors(f.c, j), e.subVectors(c, b), g.subVectors(d, c), 
                h.subVectors(b, d), f = [ 0, -e.z, e.y, 0, -g.z, g.y, 0, -h.z, h.y, e.z, 0, -e.x, g.z, 0, -g.x, h.z, 0, -h.x, -e.y, e.x, 0, -g.y, g.x, 0, -h.y, h.x, 0 ], 
                !!a(f) && (f = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], !!a(f) && (l.crossVectors(e, g), f = [ l.x, l.y, l.z ], 
                a(f))));
            };
        }(),
        clampPoint: function(a, b) {
            return void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), 
            b = new f()), b.copy(a).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var a = new f();
            return function(b) {
                return a.copy(b).clamp(this.min, this.max).sub(b).length();
            };
        }(),
        getBoundingSphere: function() {
            var a = new f();
            return function(b) {
                return void 0 === b && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), 
                b = new n()), this.getCenter(b.center), b.radius = .5 * this.getSize(a).length(), 
                b;
            };
        }(),
        intersect: function(a) {
            return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), 
            this;
        },
        union: function(a) {
            return this.min.min(a.min), this.max.max(a.max), this;
        },
        applyMatrix4: function() {
            var a = [ new f(), new f(), new f(), new f(), new f(), new f(), new f(), new f() ];
            return function(b) {
                return this.isEmpty() ? this : (a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), 
                a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), 
                a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), 
                a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), 
                a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), this.setFromPoints(a), 
                this);
            };
        }(),
        translate: function(a) {
            return this.min.add(a), this.max.add(a), this;
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max);
        }
    }), Object.assign(n.prototype, {
        set: function(a, b) {
            return this.center.copy(a), this.radius = b, this;
        },
        setFromPoints: function() {
            var a = new m();
            return function(b, c) {
                var d = this.center;
                void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
                for (var e = c = 0, f = b.length; e < f; e++) c = Math.max(c, d.distanceToSquared(b[e]));
                return this.radius = Math.sqrt(c), this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.center.copy(a.center), this.radius = a.radius, this;
        },
        empty: function() {
            return 0 >= this.radius;
        },
        containsPoint: function(a) {
            return a.distanceToSquared(this.center) <= this.radius * this.radius;
        },
        distanceToPoint: function(a) {
            return a.distanceTo(this.center) - this.radius;
        },
        intersectsSphere: function(a) {
            var b = this.radius + a.radius;
            return a.center.distanceToSquared(this.center) <= b * b;
        },
        intersectsBox: function(a) {
            return a.intersectsSphere(this);
        },
        intersectsPlane: function(a) {
            return Math.abs(a.distanceToPoint(this.center)) <= this.radius;
        },
        clampPoint: function(a, b) {
            var c = this.center.distanceToSquared(a);
            return void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), 
            b = new f()), b.copy(a), c > this.radius * this.radius && (b.sub(this.center).normalize(), 
            b.multiplyScalar(this.radius).add(this.center)), b;
        },
        getBoundingBox: function(a) {
            return void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), 
            a = new m()), a.set(this.center, this.center), a.expandByScalar(this.radius), a;
        },
        applyMatrix4: function(a) {
            return this.center.applyMatrix4(a), this.radius *= a.getMaxScaleOnAxis(), this;
        },
        translate: function(a) {
            return this.center.add(a), this;
        },
        equals: function(a) {
            return a.center.equals(this.center) && a.radius === this.radius;
        }
    }), Object.assign(o.prototype, {
        set: function(a, b) {
            return this.normal.copy(a), this.constant = b, this;
        },
        setComponents: function(a, b, c, d) {
            return this.normal.set(a, b, c), this.constant = d, this;
        },
        setFromNormalAndCoplanarPoint: function(a, b) {
            return this.normal.copy(a), this.constant = -b.dot(this.normal), this;
        },
        setFromCoplanarPoints: function() {
            var a = new f(), b = new f();
            return function(c, d, e) {
                return d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(), this.setFromNormalAndCoplanarPoint(d, c), 
                this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.normal.copy(a.normal), this.constant = a.constant, this;
        },
        normalize: function() {
            var a = 1 / this.normal.length();
            return this.normal.multiplyScalar(a), this.constant *= a, this;
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this;
        },
        distanceToPoint: function(a) {
            return this.normal.dot(a) + this.constant;
        },
        distanceToSphere: function(a) {
            return this.distanceToPoint(a.center) - a.radius;
        },
        projectPoint: function(a, b) {
            return void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), 
            b = new f()), b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a);
        },
        intersectLine: function() {
            var a = new f();
            return function(b, c) {
                void 0 === c && (console.warn("THREE.Plane: .intersectLine() target is now required"), 
                c = new f());
                var d = b.delta(a), e = this.normal.dot(d);
                if (0 === e) {
                    if (0 === this.distanceToPoint(b.start)) return c.copy(b.start);
                } else if (!(0 > (e = -(b.start.dot(this.normal) + this.constant) / e) || 1 < e)) return c.copy(d).multiplyScalar(e).add(b.start);
            };
        }(),
        intersectsLine: function(a) {
            var b = this.distanceToPoint(a.start);
            return a = this.distanceToPoint(a.end), 0 > b && 0 < a || 0 > a && 0 < b;
        },
        intersectsBox: function(a) {
            return a.intersectsPlane(this);
        },
        intersectsSphere: function(a) {
            return a.intersectsPlane(this);
        },
        coplanarPoint: function(a) {
            return void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), 
            a = new f()), a.copy(this.normal).multiplyScalar(-this.constant);
        },
        applyMatrix4: function() {
            var a = new f(), b = new g();
            return function(c, d) {
                return d = d || b.getNormalMatrix(c), c = this.coplanarPoint(a).applyMatrix4(c), 
                d = this.normal.applyMatrix3(d).normalize(), this.constant = -c.dot(d), this;
            };
        }(),
        translate: function(a) {
            return this.constant -= a.dot(this.normal), this;
        },
        equals: function(a) {
            return a.normal.equals(this.normal) && a.constant === this.constant;
        }
    }), Object.assign(p.prototype, {
        set: function(a, b, c, d, e, f) {
            var g = this.planes;
            return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), 
            this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
            return this;
        },
        setFromMatrix: function(a) {
            var b = this.planes, c = a.elements;
            a = c[0];
            var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], i = c[6], j = c[7], k = c[8], l = c[9], m = c[10], n = c[11], o = c[12], p = c[13], q = c[14];
            return c = c[15], b[0].setComponents(f - a, j - g, n - k, c - o).normalize(), b[1].setComponents(f + a, j + g, n + k, c + o).normalize(), 
            b[2].setComponents(f + d, j + h, n + l, c + p).normalize(), b[3].setComponents(f - d, j - h, n - l, c - p).normalize(), 
            b[4].setComponents(f - e, j - i, n - m, c - q).normalize(), b[5].setComponents(f + e, j + i, n + m, c + q).normalize(), 
            this;
        },
        intersectsObject: function() {
            var a = new n();
            return function(b) {
                var c = b.geometry;
                return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld), 
                this.intersectsSphere(a);
            };
        }(),
        intersectsSprite: function() {
            var a = new n();
            return function(b) {
                return a.center.set(0, 0, 0), a.radius = .7071067811865476, a.applyMatrix4(b.matrixWorld), 
                this.intersectsSphere(a);
            };
        }(),
        intersectsSphere: function(a) {
            var b = this.planes, c = a.center;
            a = -a.radius;
            for (var d = 0; 6 > d; d++) if (b[d].distanceToPoint(c) < a) return !1;
            return !0;
        },
        intersectsBox: function() {
            var a = new f();
            return function(b) {
                for (var c = this.planes, d = 0; 6 > d; d++) {
                    var e = c[d];
                    if (a.x = 0 < e.normal.x ? b.max.x : b.min.x, a.y = 0 < e.normal.y ? b.max.y : b.min.y, 
                    a.z = 0 < e.normal.z ? b.max.z : b.min.z, 0 > e.distanceToPoint(a)) return !1;
                }
                return !0;
            };
        }(),
        containsPoint: function(a) {
            for (var b = this.planes, c = 0; 6 > c; c++) if (0 > b[c].distanceToPoint(a)) return !1;
            return !0;
        }
    });
    var cf = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "\nvec3 transformed = vec3( position );\n",
        beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
        bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n"
    }, df = {
        merge: function(a) {
            for (var b = {}, c = 0; c < a.length; c++) {
                var d, e = this.clone(a[c]);
                for (d in e) b[d] = e[d];
            }
            return b;
        },
        clone: function(a) {
            var b, c = {};
            for (b in a) {
                c[b] = {};
                for (var d in a[b]) {
                    var e = a[b][d];
                    e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? c[b][d] = e.clone() : Array.isArray(e) ? c[b][d] = e.slice() : c[b][d] = e;
                }
            }
            return c;
        }
    }, ef = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(q.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(a) {
            return a && a.isColor ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), 
            this;
        },
        setScalar: function(a) {
            return this.b = this.g = this.r = a, this;
        },
        setHex: function(a) {
            return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, 
            this.b = (255 & a) / 255, this;
        },
        setRGB: function(a, b, c) {
            return this.r = a, this.g = b, this.b = c, this;
        },
        setHSL: function() {
            function a(a, b, c) {
                return 0 > c && (c += 1), 1 < c && --c, c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;
            }
            return function(b, c, d) {
                return b = _e.euclideanModulo(b, 1), c = _e.clamp(c, 0, 1), d = _e.clamp(d, 0, 1), 
                0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, 
                d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3)), 
                this;
            };
        }(),
        setStyle: function(a) {
            function b(b) {
                void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.");
            }
            var c;
            if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
                var d = c[2];
                switch (c[1]) {
                  case "rgb":
                  case "rgba":
                    if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, 
                    this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, 
                    b(c[5]), this;
                    if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, 
                    this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, 
                    b(c[5]), this;
                    break;

                  case "hsl":
                  case "hsla":
                    if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
                        d = parseFloat(c[1]) / 360;
                        var e = parseInt(c[2], 10) / 100, f = parseInt(c[3], 10) / 100;
                        return b(c[5]), this.setHSL(d, e, f);
                    }
                }
            } else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
                if (c = c[1], 3 === (d = c.length)) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, 
                this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, 
                this;
                if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, 
                this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this;
            }
            return a && 0 < a.length && (c = ef[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a)), 
            this;
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b);
        },
        copy: function(a) {
            return this.r = a.r, this.g = a.g, this.b = a.b, this;
        },
        copyGammaToLinear: function(a, b) {
            return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), 
            this.b = Math.pow(a.b, b), this;
        },
        copyLinearToGamma: function(a, b) {
            return void 0 === b && (b = 2), b = 0 < b ? 1 / b : 1, this.r = Math.pow(a.r, b), 
            this.g = Math.pow(a.g, b), this.b = Math.pow(a.b, b), this;
        },
        convertGammaToLinear: function(a) {
            return this.copyGammaToLinear(this, a), this;
        },
        convertLinearToGamma: function(a) {
            return this.copyLinearToGamma(this, a), this;
        },
        copySRGBToLinear: function() {
            function a(a) {
                return .04045 > a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014, 2.4);
            }
            return function(b) {
                return this.r = a(b.r), this.g = a(b.g), this.b = a(b.b), this;
            };
        }(),
        copyLinearToSRGB: function() {
            function a(a) {
                return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055;
            }
            return function(b) {
                return this.r = a(b.r), this.g = a(b.g), this.b = a(b.b), this;
            };
        }(),
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this), this;
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this), this;
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function(a) {
            void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), 
            a = {
                h: 0,
                s: 0,
                l: 0
            });
            var b, c = this.r, d = this.g, e = this.b, f = Math.max(c, d, e), g = Math.min(c, d, e), h = (g + f) / 2;
            if (g === f) g = b = 0; else {
                var i = f - g;
                switch (g = .5 >= h ? i / (f + g) : i / (2 - f - g), f) {
                  case c:
                    b = (d - e) / i + (d < e ? 6 : 0);
                    break;

                  case d:
                    b = (e - c) / i + 2;
                    break;

                  case e:
                    b = (c - d) / i + 4;
                }
                b /= 6;
            }
            return a.h = b, a.s = g, a.l = h, a;
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
        },
        offsetHSL: function() {
            var a = {};
            return function(b, c, d) {
                return this.getHSL(a), a.h += b, a.s += c, a.l += d, this.setHSL(a.h, a.s, a.l), 
                this;
            };
        }(),
        add: function(a) {
            return this.r += a.r, this.g += a.g, this.b += a.b, this;
        },
        addColors: function(a, b) {
            return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this;
        },
        addScalar: function(a) {
            return this.r += a, this.g += a, this.b += a, this;
        },
        sub: function(a) {
            return this.r = Math.max(0, this.r - a.r), this.g = Math.max(0, this.g - a.g), this.b = Math.max(0, this.b - a.b), 
            this;
        },
        multiply: function(a) {
            return this.r *= a.r, this.g *= a.g, this.b *= a.b, this;
        },
        multiplyScalar: function(a) {
            return this.r *= a, this.g *= a, this.b *= a, this;
        },
        lerp: function(a, b) {
            return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, 
            this;
        },
        lerpHSL: function() {
            var a = {
                h: 0,
                s: 0,
                l: 0
            }, b = {
                h: 0,
                s: 0,
                l: 0
            };
            return function(c, d) {
                this.getHSL(a), c.getHSL(b), c = _e.lerp(a.h, b.h, d);
                var e = _e.lerp(a.s, b.s, d);
                return d = _e.lerp(a.l, b.l, d), this.setHSL(c, e, d), this;
            };
        }(),
        equals: function(a) {
            return a.r === this.r && a.g === this.g && a.b === this.b;
        },
        fromArray: function(a, b) {
            return void 0 === b && (b = 0), this.r = a[b], this.g = a[b + 1], this.b = a[b + 2], 
            this;
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, 
            a[b + 2] = this.b, a;
        },
        toJSON: function() {
            return this.getHex();
        }
    });
    var ff = {
        common: {
            diffuse: {
                value: new q(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new g()
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new c(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new q(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new q(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new g()
            }
        },
        sprite: {
            diffuse: {
                value: new q(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new c(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new g()
            }
        }
    }, gf = {
        basic: {
            uniforms: df.merge([ ff.common, ff.specularmap, ff.envmap, ff.aomap, ff.lightmap, ff.fog ]),
            vertexShader: cf.meshbasic_vert,
            fragmentShader: cf.meshbasic_frag
        },
        lambert: {
            uniforms: df.merge([ ff.common, ff.specularmap, ff.envmap, ff.aomap, ff.lightmap, ff.emissivemap, ff.fog, ff.lights, {
                emissive: {
                    value: new q(0)
                }
            } ]),
            vertexShader: cf.meshlambert_vert,
            fragmentShader: cf.meshlambert_frag
        },
        phong: {
            uniforms: df.merge([ ff.common, ff.specularmap, ff.envmap, ff.aomap, ff.lightmap, ff.emissivemap, ff.bumpmap, ff.normalmap, ff.displacementmap, ff.gradientmap, ff.fog, ff.lights, {
                emissive: {
                    value: new q(0)
                },
                specular: {
                    value: new q(1118481)
                },
                shininess: {
                    value: 30
                }
            } ]),
            vertexShader: cf.meshphong_vert,
            fragmentShader: cf.meshphong_frag
        },
        standard: {
            uniforms: df.merge([ ff.common, ff.envmap, ff.aomap, ff.lightmap, ff.emissivemap, ff.bumpmap, ff.normalmap, ff.displacementmap, ff.roughnessmap, ff.metalnessmap, ff.fog, ff.lights, {
                emissive: {
                    value: new q(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            } ]),
            vertexShader: cf.meshphysical_vert,
            fragmentShader: cf.meshphysical_frag
        },
        points: {
            uniforms: df.merge([ ff.points, ff.fog ]),
            vertexShader: cf.points_vert,
            fragmentShader: cf.points_frag
        },
        dashed: {
            uniforms: df.merge([ ff.common, ff.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            } ]),
            vertexShader: cf.linedashed_vert,
            fragmentShader: cf.linedashed_frag
        },
        depth: {
            uniforms: df.merge([ ff.common, ff.displacementmap ]),
            vertexShader: cf.depth_vert,
            fragmentShader: cf.depth_frag
        },
        normal: {
            uniforms: df.merge([ ff.common, ff.bumpmap, ff.normalmap, ff.displacementmap, {
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: cf.normal_vert,
            fragmentShader: cf.normal_frag
        },
        sprite: {
            uniforms: df.merge([ ff.sprite, ff.fog ]),
            vertexShader: cf.sprite_vert,
            fragmentShader: cf.sprite_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: cf.cube_vert,
            fragmentShader: cf.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: cf.equirect_vert,
            fragmentShader: cf.equirect_frag
        },
        distanceRGBA: {
            uniforms: df.merge([ ff.common, ff.displacementmap, {
                referencePosition: {
                    value: new f()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            } ]),
            vertexShader: cf.distanceRGBA_vert,
            fragmentShader: cf.distanceRGBA_frag
        },
        shadow: {
            uniforms: df.merge([ ff.lights, ff.fog, {
                color: {
                    value: new q(0)
                },
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: cf.shadow_vert,
            fragmentShader: cf.shadow_frag
        }
    };
    gf.physical = {
        uniforms: df.merge([ gf.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        } ]),
        vertexShader: cf.meshphysical_vert,
        fragmentShader: cf.meshphysical_frag
    }, t.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), t.DefaultOrder = "XYZ", 
    Object.defineProperties(t.prototype, {
        x: {
            get: function() {
                return this._x;
            },
            set: function(a) {
                this._x = a, this.onChangeCallback();
            }
        },
        y: {
            get: function() {
                return this._y;
            },
            set: function(a) {
                this._y = a, this.onChangeCallback();
            }
        },
        z: {
            get: function() {
                return this._z;
            },
            set: function(a) {
                this._z = a, this.onChangeCallback();
            }
        },
        order: {
            get: function() {
                return this._order;
            },
            set: function(a) {
                this._order = a, this.onChangeCallback();
            }
        }
    }), Object.assign(t.prototype, {
        isEuler: !0,
        set: function(a, b, c, d) {
            return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), 
            this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function(a) {
            return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), 
            this;
        },
        setFromRotationMatrix: function(a, b, c) {
            var d = _e.clamp, e = a.elements;
            a = e[0];
            var f = e[4], g = e[8], h = e[1], i = e[5], j = e[9], k = e[2], l = e[6];
            return e = e[10], b = b || this._order, "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), 
            .99999 > Math.abs(g) ? (this._x = Math.atan2(-j, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(l, i), 
            this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(j, -1, 1)), .99999 > Math.abs(j) ? (this._y = Math.atan2(g, e), 
            this._z = Math.atan2(h, i)) : (this._y = Math.atan2(-k, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(l, -1, 1)), 
            .99999 > Math.abs(l) ? (this._y = Math.atan2(-k, e), this._z = Math.atan2(-f, i)) : (this._y = 0, 
            this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)), 
            .99999 > Math.abs(k) ? (this._x = Math.atan2(l, e), this._z = Math.atan2(h, a)) : (this._x = 0, 
            this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), 
            .99999 > Math.abs(h) ? (this._x = Math.atan2(-j, i), this._y = Math.atan2(-k, a)) : (this._x = 0, 
            this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), 
            .99999 > Math.abs(f) ? (this._x = Math.atan2(l, i), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-j, e), 
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b), 
            this._order = b, !1 !== c && this.onChangeCallback(), this;
        },
        setFromQuaternion: function() {
            var a = new d();
            return function(b, c, d) {
                return a.makeRotationFromQuaternion(b), this.setFromRotationMatrix(a, c, d);
            };
        }(),
        setFromVector3: function(a, b) {
            return this.set(a.x, a.y, a.z, b || this._order);
        },
        reorder: function() {
            var a = new e();
            return function(b) {
                return a.setFromEuler(this), this.setFromQuaternion(a, b);
            };
        }(),
        equals: function(a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
        },
        fromArray: function(a) {
            return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), 
            this.onChangeCallback(), this;
        },
        toArray: function(a, b) {
            return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, 
            a[b + 2] = this._z, a[b + 3] = this._order, a;
        },
        toVector3: function(a) {
            return a ? a.set(this._x, this._y, this._z) : new f(this._x, this._y, this._z);
        },
        onChange: function(a) {
            return this.onChangeCallback = a, this;
        },
        onChangeCallback: function() {}
    }), Object.assign(u.prototype, {
        set: function(a) {
            this.mask = 1 << a | 0;
        },
        enable: function(a) {
            this.mask = this.mask | 1 << a | 0;
        },
        toggle: function(a) {
            this.mask ^= 1 << a | 0;
        },
        disable: function(a) {
            this.mask &= ~(1 << a | 0);
        },
        test: function(a) {
            return 0 != (this.mask & a.mask);
        }
    });
    var hf = 0;
    v.DefaultUp = new f(0, 1, 0), v.DefaultMatrixAutoUpdate = !0, v.prototype = Object.assign(Object.create(b.prototype), {
        constructor: v,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(a) {
            this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function(a) {
            return this.quaternion.premultiply(a), this;
        },
        setRotationFromAxisAngle: function(a, b) {
            this.quaternion.setFromAxisAngle(a, b);
        },
        setRotationFromEuler: function(a) {
            this.quaternion.setFromEuler(a, !0);
        },
        setRotationFromMatrix: function(a) {
            this.quaternion.setFromRotationMatrix(a);
        },
        setRotationFromQuaternion: function(a) {
            this.quaternion.copy(a);
        },
        rotateOnAxis: function() {
            var a = new e();
            return function(b, c) {
                return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this;
            };
        }(),
        rotateOnWorldAxis: function() {
            var a = new e();
            return function(b, c) {
                return a.setFromAxisAngle(b, c), this.quaternion.premultiply(a), this;
            };
        }(),
        rotateX: function() {
            var a = new f(1, 0, 0);
            return function(b) {
                return this.rotateOnAxis(a, b);
            };
        }(),
        rotateY: function() {
            var a = new f(0, 1, 0);
            return function(b) {
                return this.rotateOnAxis(a, b);
            };
        }(),
        rotateZ: function() {
            var a = new f(0, 0, 1);
            return function(b) {
                return this.rotateOnAxis(a, b);
            };
        }(),
        translateOnAxis: function() {
            var a = new f();
            return function(b, c) {
                return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), 
                this;
            };
        }(),
        translateX: function() {
            var a = new f(1, 0, 0);
            return function(b) {
                return this.translateOnAxis(a, b);
            };
        }(),
        translateY: function() {
            var a = new f(0, 1, 0);
            return function(b) {
                return this.translateOnAxis(a, b);
            };
        }(),
        translateZ: function() {
            var a = new f(0, 0, 1);
            return function(b) {
                return this.translateOnAxis(a, b);
            };
        }(),
        localToWorld: function(a) {
            return a.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function() {
            var a = new d();
            return function(b) {
                return b.applyMatrix4(a.getInverse(this.matrixWorld));
            };
        }(),
        lookAt: function() {
            var a = new e(), b = new d(), c = new f(), g = new f();
            return function(d, e, f) {
                d.isVector3 ? c.copy(d) : c.set(d, e, f), d = this.parent, this.updateWorldMatrix(!0, !1), 
                g.setFromMatrixPosition(this.matrixWorld), this.isCamera ? b.lookAt(g, c, this.up) : b.lookAt(c, g, this.up), 
                this.quaternion.setFromRotationMatrix(b), d && (b.extractRotation(d.matrixWorld), 
                a.setFromRotationMatrix(b), this.quaternion.premultiply(a.inverse()));
            };
        }(),
        add: function(a) {
            if (1 < arguments.length) {
                for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
                return this;
            }
            return a === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), 
            this) : (a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, 
            a.dispatchEvent({
                type: "added"
            }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a), 
            this);
        },
        remove: function(a) {
            if (1 < arguments.length) {
                for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
                return this;
            }
            return b = this.children.indexOf(a), -1 !== b && (a.parent = null, a.dispatchEvent({
                type: "removed"
            }), this.children.splice(b, 1)), this;
        },
        getObjectById: function(a) {
            return this.getObjectByProperty("id", a);
        },
        getObjectByName: function(a) {
            return this.getObjectByProperty("name", a);
        },
        getObjectByProperty: function(a, b) {
            if (this[a] === b) return this;
            for (var c = 0, d = this.children.length; c < d; c++) {
                var e = this.children[c].getObjectByProperty(a, b);
                if (void 0 !== e) return e;
            }
        },
        getWorldPosition: function(a) {
            return void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), 
            a = new f()), this.updateMatrixWorld(!0), a.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: function() {
            var a = new f(), b = new f();
            return function(c) {
                return void 0 === c && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), 
                c = new e()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, c, b), c;
            };
        }(),
        getWorldScale: function() {
            var a = new f(), b = new e();
            return function(c) {
                return void 0 === c && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), 
                c = new f()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, b, c), c;
            };
        }(),
        getWorldDirection: function(a) {
            void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), 
            a = new f()), this.updateMatrixWorld(!0);
            var b = this.matrixWorld.elements;
            return a.set(b[8], b[9], b[10]).normalize();
        },
        raycast: function() {},
        traverse: function(a) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a);
        },
        traverseVisible: function(a) {
            if (!1 !== this.visible) {
                a(this);
                for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a);
            }
        },
        traverseAncestors: function(a) {
            var b = this.parent;
            null !== b && (a(b), b.traverseAncestors(a));
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        },
        updateMatrixWorld: function(a) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || a) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
            this.matrixWorldNeedsUpdate = !1, a = !0);
            for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a);
        },
        updateWorldMatrix: function(a, b) {
            var c = this.parent;
            if (!0 === a && null !== c && c.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), 
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
            !0 === b) for (a = this.children, b = 0, c = a.length; b < c; b++) a[b].updateWorldMatrix(!1, !0);
        },
        toJSON: function(a) {
            function b(b, c) {
                return void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)), c.uuid;
            }
            function c(a) {
                var b, c = [];
                for (b in a) {
                    var d = a[b];
                    delete d.metadata, c.push(d);
                }
                return c;
            }
            var d = void 0 === a || "string" == typeof a, e = {};
            d && (a = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, e.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var f = {};
            if (f.uuid = this.uuid, f.type = this.type, "" !== this.name && (f.name = this.name), 
            !0 === this.castShadow && (f.castShadow = !0), !0 === this.receiveShadow && (f.receiveShadow = !0), 
            !1 === this.visible && (f.visible = !1), !1 === this.frustumCulled && (f.frustumCulled = !1), 
            0 !== this.renderOrder && (f.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData), 
            f.layers = this.layers.mask, f.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (f.matrixAutoUpdate = !1), 
            this.isMesh || this.isLine || this.isPoints) {
                f.geometry = b(a.geometries, this.geometry);
                var g = this.geometry.parameters;
                if (void 0 !== g && void 0 !== g.shapes) if (g = g.shapes, Array.isArray(g)) for (var h = 0, i = g.length; h < i; h++) b(a.shapes, g[h]); else b(a.shapes, g);
            }
            if (void 0 !== this.material) if (Array.isArray(this.material)) {
                for (g = [], h = 0, i = this.material.length; h < i; h++) g.push(b(a.materials, this.material[h]));
                f.material = g;
            } else f.material = b(a.materials, this.material);
            if (0 < this.children.length) for (f.children = [], h = 0; h < this.children.length; h++) f.children.push(this.children[h].toJSON(a).object);
            if (d) {
                d = c(a.geometries), h = c(a.materials), i = c(a.textures);
                var j = c(a.images);
                g = c(a.shapes), 0 < d.length && (e.geometries = d), 0 < h.length && (e.materials = h), 
                0 < i.length && (e.textures = i), 0 < j.length && (e.images = j), 0 < g.length && (e.shapes = g);
            }
            return e.object = f, e;
        },
        clone: function(a) {
            return new this.constructor().copy(this, a);
        },
        copy: function(a, b) {
            if (void 0 === b && (b = !0), this.name = a.name, this.up.copy(a.up), this.position.copy(a.position), 
            this.quaternion.copy(a.quaternion), this.scale.copy(a.scale), this.matrix.copy(a.matrix), 
            this.matrixWorld.copy(a.matrixWorld), this.matrixAutoUpdate = a.matrixAutoUpdate, 
            this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate, this.layers.mask = a.layers.mask, 
            this.visible = a.visible, this.castShadow = a.castShadow, this.receiveShadow = a.receiveShadow, 
            this.frustumCulled = a.frustumCulled, this.renderOrder = a.renderOrder, this.userData = JSON.parse(JSON.stringify(a.userData)), 
            !0 === b) for (b = 0; b < a.children.length; b++) this.add(a.children[b].clone());
            return this;
        }
    }), w.prototype = Object.assign(Object.create(v.prototype), {
        constructor: w,
        isCamera: !0,
        copy: function(a, b) {
            return v.prototype.copy.call(this, a, b), this.matrixWorldInverse.copy(a.matrixWorldInverse), 
            this.projectionMatrix.copy(a.projectionMatrix), this.projectionMatrixInverse.copy(a.projectionMatrixInverse), 
            this;
        },
        getWorldDirection: function(a) {
            void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), 
            a = new f()), this.updateMatrixWorld(!0);
            var b = this.matrixWorld.elements;
            return a.set(-b[8], -b[9], -b[10]).normalize();
        },
        updateMatrixWorld: function(a) {
            v.prototype.updateMatrixWorld.call(this, a), this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    }), x.prototype = Object.assign(Object.create(w.prototype), {
        constructor: x,
        isOrthographicCamera: !0,
        copy: function(a, b) {
            return w.prototype.copy.call(this, a, b), this.left = a.left, this.right = a.right, 
            this.top = a.top, this.bottom = a.bottom, this.near = a.near, this.far = a.far, 
            this.zoom = a.zoom, this.view = null === a.view ? null : Object.assign({}, a.view), 
            this;
        },
        setViewOffset: function(a, b, c, d, e, f) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = a, this.view.fullHeight = b, this.view.offsetX = c, 
            this.view.offsetY = d, this.view.width = e, this.view.height = f, this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2, e = c - a;
            if (c += a, a = d + b, b = d - b, null !== this.view && this.view.enabled) {
                c = this.zoom / (this.view.width / this.view.fullWidth), b = this.zoom / (this.view.height / this.view.fullHeight);
                var f = (this.right - this.left) / this.view.width;
                d = (this.top - this.bottom) / this.view.height, e += this.view.offsetX / c * f, 
                c = e + this.view.width / c * f, a -= this.view.offsetY / b * d, b = a - this.view.height / b * d;
            }
            this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function(a) {
            return a = v.prototype.toJSON.call(this, a), a.object.zoom = this.zoom, a.object.left = this.left, 
            a.object.right = this.right, a.object.top = this.top, a.object.bottom = this.bottom, 
            a.object.near = this.near, a.object.far = this.far, null !== this.view && (a.object.view = Object.assign({}, this.view)), 
            a;
        }
    }), Object.assign(y.prototype, {
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            this.a = a.a, this.b = a.b, this.c = a.c, this.normal.copy(a.normal), this.color.copy(a.color), 
            this.materialIndex = a.materialIndex;
            for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
            for (b = 0, c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
            return this;
        }
    });
    var jf = 0;
    z.prototype = Object.assign(Object.create(b.prototype), {
        constructor: z,
        isGeometry: !0,
        applyMatrix: function(a) {
            for (var b = new g().getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
            for (c = 0, d = this.faces.length; c < d; c++) {
                a = this.faces[c], a.normal.applyMatrix3(b).normalize();
                for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize();
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this;
        },
        rotateX: function() {
            var a = new d();
            return function(b) {
                return a.makeRotationX(b), this.applyMatrix(a), this;
            };
        }(),
        rotateY: function() {
            var a = new d();
            return function(b) {
                return a.makeRotationY(b), this.applyMatrix(a), this;
            };
        }(),
        rotateZ: function() {
            var a = new d();
            return function(b) {
                return a.makeRotationZ(b), this.applyMatrix(a), this;
            };
        }(),
        translate: function() {
            var a = new d();
            return function(b, c, d) {
                return a.makeTranslation(b, c, d), this.applyMatrix(a), this;
            };
        }(),
        scale: function() {
            var a = new d();
            return function(b, c, d) {
                return a.makeScale(b, c, d), this.applyMatrix(a), this;
            };
        }(),
        lookAt: function() {
            var a = new v();
            return function(b) {
                a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix);
            };
        }(),
        fromBufferGeometry: function(a) {
            function b(a, b, c, e) {
                e = new y(a, b, c, void 0 !== i ? [ m[a].clone(), m[b].clone(), m[c].clone() ] : [], void 0 !== j ? [ d.colors[a].clone(), d.colors[b].clone(), d.colors[c].clone() ] : [], e), 
                d.faces.push(e), void 0 !== k && d.faceVertexUvs[0].push([ n[a].clone(), n[b].clone(), n[c].clone() ]), 
                void 0 !== l && d.faceVertexUvs[1].push([ o[a].clone(), o[b].clone(), o[c].clone() ]);
            }
            var d = this, e = null !== a.index ? a.index.array : void 0, g = a.attributes, h = g.position.array, i = void 0 !== g.normal ? g.normal.array : void 0, j = void 0 !== g.color ? g.color.array : void 0, k = void 0 !== g.uv ? g.uv.array : void 0, l = void 0 !== g.uv2 ? g.uv2.array : void 0;
            void 0 !== l && (this.faceVertexUvs[1] = []);
            for (var m = [], n = [], o = [], p = g = 0; g < h.length; g += 3, p += 2) d.vertices.push(new f(h[g], h[g + 1], h[g + 2])), 
            void 0 !== i && m.push(new f(i[g], i[g + 1], i[g + 2])), void 0 !== j && d.colors.push(new q(j[g], j[g + 1], j[g + 2])), 
            void 0 !== k && n.push(new c(k[p], k[p + 1])), void 0 !== l && o.push(new c(l[p], l[p + 1]));
            var r = a.groups;
            if (0 < r.length) for (g = 0; g < r.length; g++) {
                h = r[g];
                var s = h.start, t = h.count;
                for (p = s, s += t; p < s; p += 3) void 0 !== e ? b(e[p], e[p + 1], e[p + 2], h.materialIndex) : b(p, p + 1, p + 2, h.materialIndex);
            } else if (void 0 !== e) for (g = 0; g < e.length; g += 3) b(e[g], e[g + 1], e[g + 2]); else for (g = 0; g < h.length / 3; g += 3) b(g, g + 1, g + 2);
            return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), 
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this;
        },
        center: function() {
            var a = new f();
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(a).negate(), this.translate(a.x, a.y, a.z), 
                this;
            };
        }(),
        normalize: function() {
            this.computeBoundingSphere();
            var a = this.boundingSphere.center, b = this.boundingSphere.radius;
            b = 0 === b ? 1 : 1 / b;
            var c = new d();
            return c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1), 
            this.applyMatrix(c), this;
        },
        computeFaceNormals: function() {
            for (var a = new f(), b = new f(), c = 0, d = this.faces.length; c < d; c++) {
                var e = this.faces[c], g = this.vertices[e.a], h = this.vertices[e.b];
                a.subVectors(this.vertices[e.c], h), b.subVectors(g, h), a.cross(b), a.normalize(), 
                e.normal.copy(a);
            }
        },
        computeVertexNormals: function(a) {
            void 0 === a && (a = !0);
            var b, c = Array(this.vertices.length), d = 0;
            for (b = this.vertices.length; d < b; d++) c[d] = new f();
            if (a) {
                var e = new f(), g = new f();
                for (a = 0, d = this.faces.length; a < d; a++) {
                    b = this.faces[a];
                    var h = this.vertices[b.a], i = this.vertices[b.b], j = this.vertices[b.c];
                    e.subVectors(j, i), g.subVectors(h, i), e.cross(g), c[b.a].add(e), c[b.b].add(e), 
                    c[b.c].add(e);
                }
            } else for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++) b = this.faces[a], 
            c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal);
            for (d = 0, b = this.vertices.length; d < b; d++) c[d].normalize();
            for (a = 0, d = this.faces.length; a < d; a++) b = this.faces[a], h = b.vertexNormals, 
            3 === h.length ? (h[0].copy(c[b.a]), h[1].copy(c[b.b]), h[2].copy(c[b.c])) : (h[0] = c[b.a].clone(), 
            h[1] = c[b.b].clone(), h[2] = c[b.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0);
        },
        computeFlatVertexNormals: function() {
            var a;
            this.computeFaceNormals();
            var b = 0;
            for (a = this.faces.length; b < a; b++) {
                var c = this.faces[b], d = c.vertexNormals;
                3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), 
                d[1] = c.normal.clone(), d[2] = c.normal.clone());
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0);
        },
        computeMorphNormals: function() {
            var a, b, c = 0;
            for (b = this.faces.length; c < b; c++) {
                var d = this.faces[c];
                d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = d.normal.clone(), 
                d.__originalVertexNormals || (d.__originalVertexNormals = []);
                var e = 0;
                for (a = d.vertexNormals.length; e < a; e++) d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone();
            }
            var g = new z();
            for (g.faces = this.faces, e = 0, a = this.morphTargets.length; e < a; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [], 
                    d = this.morphNormals[e].faceNormals;
                    var h = this.morphNormals[e].vertexNormals;
                    for (c = 0, b = this.faces.length; c < b; c++) {
                        var i = new f(), j = {
                            a: new f(),
                            b: new f(),
                            c: new f()
                        };
                        d.push(i), h.push(j);
                    }
                }
                for (h = this.morphNormals[e], g.vertices = this.morphTargets[e].vertices, g.computeFaceNormals(), 
                g.computeVertexNormals(), c = 0, b = this.faces.length; c < b; c++) d = this.faces[c], 
                i = h.faceNormals[c], j = h.vertexNormals[c], i.copy(d.normal), j.a.copy(d.vertexNormals[0]), 
                j.b.copy(d.vertexNormals[1]), j.c.copy(d.vertexNormals[2]);
            }
            for (c = 0, b = this.faces.length; c < b; c++) d = this.faces[c], d.normal = d.__originalFaceNormal, 
            d.vertexNormals = d.__originalVertexNormals;
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new m()), this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new n()), this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function(a, b, c) {
            if (a && a.isGeometry) {
                var d, e = this.vertices.length, f = this.vertices, h = a.vertices, i = this.faces, j = a.faces, k = this.faceVertexUvs[0], l = a.faceVertexUvs[0], m = this.colors, n = a.colors;
                void 0 === c && (c = 0), void 0 !== b && (d = new g().getNormalMatrix(b)), a = 0;
                for (var o = h.length; a < o; a++) {
                    var p = h[a].clone();
                    void 0 !== b && p.applyMatrix4(b), f.push(p);
                }
                for (a = 0, o = n.length; a < o; a++) m.push(n[a].clone());
                for (a = 0, o = j.length; a < o; a++) {
                    h = j[a];
                    var q = h.vertexNormals;
                    for (n = h.vertexColors, m = new y(h.a + e, h.b + e, h.c + e), m.normal.copy(h.normal), 
                    void 0 !== d && m.normal.applyMatrix3(d).normalize(), b = 0, f = q.length; b < f; b++) p = q[b].clone(), 
                    void 0 !== d && p.applyMatrix3(d).normalize(), m.vertexNormals.push(p);
                    for (m.color.copy(h.color), b = 0, f = n.length; b < f; b++) p = n[b], m.vertexColors.push(p.clone());
                    m.materialIndex = h.materialIndex + c, i.push(m);
                }
                for (a = 0, o = l.length; a < o; a++) if (c = l[a], d = [], void 0 !== c) {
                    for (b = 0, f = c.length; b < f; b++) d.push(c[b].clone());
                    k.push(d);
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
        },
        mergeMesh: function(a) {
            a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a);
        },
        mergeVertices: function() {
            var a, b = {}, c = [], d = [], e = Math.pow(10, 4), f = 0;
            for (a = this.vertices.length; f < a; f++) {
                var g = this.vertices[f];
                g = Math.round(g.x * e) + "_" + Math.round(g.y * e) + "_" + Math.round(g.z * e), 
                void 0 === b[g] ? (b[g] = f, c.push(this.vertices[f]), d[f] = c.length - 1) : d[f] = d[b[g]];
            }
            for (b = [], f = 0, a = this.faces.length; f < a; f++) for (e = this.faces[f], e.a = d[e.a], 
            e.b = d[e.b], e.c = d[e.c], e = [ e.a, e.b, e.c ], g = 0; 3 > g; g++) if (e[g] === e[(g + 1) % 3]) {
                b.push(f);
                break;
            }
            for (f = b.length - 1; 0 <= f; f--) for (e = b[f], this.faces.splice(e, 1), d = 0, 
            a = this.faceVertexUvs.length; d < a; d++) this.faceVertexUvs[d].splice(e, 1);
            return f = this.vertices.length - c.length, this.vertices = c, f;
        },
        setFromPoints: function(a) {
            this.vertices = [];
            for (var b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                this.vertices.push(new f(d.x, d.y, d.z || 0));
            }
            return this;
        },
        sortFacesByMaterialIndex: function() {
            for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
            a.sort(function(a, b) {
                return a.materialIndex - b.materialIndex;
            });
            var d, e, f = this.faceVertexUvs[0], g = this.faceVertexUvs[1];
            for (f && f.length === b && (d = []), g && g.length === b && (e = []), c = 0; c < b; c++) {
                var h = a[c]._id;
                d && d.push(f[h]), e && e.push(g[h]);
            }
            d && (this.faceVertexUvs[0] = d), e && (this.faceVertexUvs[1] = e);
        },
        toJSON: function() {
            function a(a, b, c) {
                return c ? a | 1 << b : a & ~(1 << b);
            }
            function b(a) {
                var b = a.x.toString() + a.y.toString() + a.z.toString();
                return void 0 !== j[b] ? j[b] : (j[b] = i.length / 3, i.push(a.x, a.y, a.z), j[b]);
            }
            function c(a) {
                var b = a.r.toString() + a.g.toString() + a.b.toString();
                return void 0 !== l[b] ? l[b] : (l[b] = k.length, k.push(a.getHex()), l[b]);
            }
            function d(a) {
                var b = a.x.toString() + a.y.toString();
                return void 0 !== n[b] ? n[b] : (n[b] = m.length / 2, m.push(a.x, a.y), n[b]);
            }
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 
            void 0 !== this.parameters) {
                var f, g = this.parameters;
                for (f in g) void 0 !== g[f] && (e[f] = g[f]);
                return e;
            }
            for (g = [], f = 0; f < this.vertices.length; f++) {
                var h = this.vertices[f];
                g.push(h.x, h.y, h.z);
            }
            h = [];
            var i = [], j = {}, k = [], l = {}, m = [], n = {};
            for (f = 0; f < this.faces.length; f++) {
                var o = this.faces[f], p = void 0 !== this.faceVertexUvs[0][f], q = 0 < o.normal.length(), r = 0 < o.vertexNormals.length, s = 1 !== o.color.r || 1 !== o.color.g || 1 !== o.color.b, t = 0 < o.vertexColors.length, u = 0;
                u = a(u, 0, 0), u = a(u, 1, !0), u = a(u, 2, !1), u = a(u, 3, p), u = a(u, 4, q), 
                u = a(u, 5, r), u = a(u, 6, s), u = a(u, 7, t), h.push(u), h.push(o.a, o.b, o.c), 
                h.push(o.materialIndex), p && (p = this.faceVertexUvs[0][f], h.push(d(p[0]), d(p[1]), d(p[2]))), 
                q && h.push(b(o.normal)), r && (q = o.vertexNormals, h.push(b(q[0]), b(q[1]), b(q[2]))), 
                s && h.push(c(o.color)), t && (o = o.vertexColors, h.push(c(o[0]), c(o[1]), c(o[2])));
            }
            return e.data = {}, e.data.vertices = g, e.data.normals = i, 0 < k.length && (e.data.colors = k), 
            0 < m.length && (e.data.uvs = [ m ]), e.data.faces = h, e;
        },
        clone: function() {
            return new z().copy(this);
        },
        copy: function(a) {
            var b, c, d;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], 
            this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], 
            this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = a.name;
            var e = a.vertices, f = 0;
            for (b = e.length; f < b; f++) this.vertices.push(e[f].clone());
            for (e = a.colors, f = 0, b = e.length; f < b; f++) this.colors.push(e[f].clone());
            for (e = a.faces, f = 0, b = e.length; f < b; f++) this.faces.push(e[f].clone());
            for (f = 0, b = a.faceVertexUvs.length; f < b; f++) {
                var g = a.faceVertexUvs[f];
                for (void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []), e = 0, c = g.length; e < c; e++) {
                    var h = g[e], i = [], j = 0;
                    for (d = h.length; j < d; j++) i.push(h[j].clone());
                    this.faceVertexUvs[f].push(i);
                }
            }
            for (j = a.morphTargets, f = 0, b = j.length; f < b; f++) {
                if (d = {}, d.name = j[f].name, void 0 !== j[f].vertices) for (d.vertices = [], 
                e = 0, c = j[f].vertices.length; e < c; e++) d.vertices.push(j[f].vertices[e].clone());
                if (void 0 !== j[f].normals) for (d.normals = [], e = 0, c = j[f].normals.length; e < c; e++) d.normals.push(j[f].normals[e].clone());
                this.morphTargets.push(d);
            }
            for (j = a.morphNormals, f = 0, b = j.length; f < b; f++) {
                if (d = {}, void 0 !== j[f].vertexNormals) for (d.vertexNormals = [], e = 0, c = j[f].vertexNormals.length; e < c; e++) g = j[f].vertexNormals[e], 
                h = {}, h.a = g.a.clone(), h.b = g.b.clone(), h.c = g.c.clone(), d.vertexNormals.push(h);
                if (void 0 !== j[f].faceNormals) for (d.faceNormals = [], e = 0, c = j[f].faceNormals.length; e < c; e++) d.faceNormals.push(j[f].faceNormals[e].clone());
                this.morphNormals.push(d);
            }
            for (e = a.skinWeights, f = 0, b = e.length; f < b; f++) this.skinWeights.push(e[f].clone());
            for (e = a.skinIndices, f = 0, b = e.length; f < b; f++) this.skinIndices.push(e[f].clone());
            for (e = a.lineDistances, f = 0, b = e.length; f < b; f++) this.lineDistances.push(e[f]);
            return f = a.boundingBox, null !== f && (this.boundingBox = f.clone()), f = a.boundingSphere, 
            null !== f && (this.boundingSphere = f.clone()), this.elementsNeedUpdate = a.elementsNeedUpdate, 
            this.verticesNeedUpdate = a.verticesNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, 
            this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, 
            this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, 
            this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), Object.defineProperty(A.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++;
        }
    }), Object.assign(A.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(a) {
            if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== a ? a.length / this.itemSize : 0, this.array = a, 
            this;
        },
        setDynamic: function(a) {
            return this.dynamic = a, this;
        },
        copy: function(a) {
            return this.name = a.name, this.array = new a.array.constructor(a.array), this.itemSize = a.itemSize, 
            this.count = a.count, this.normalized = a.normalized, this.dynamic = a.dynamic, 
            this;
        },
        copyAt: function(a, b, c) {
            a *= this.itemSize, c *= b.itemSize;
            for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
            return this;
        },
        copyArray: function(a) {
            return this.array.set(a), this;
        },
        copyColorsArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), 
                f = new q()), b[c++] = f.r, b[c++] = f.g, b[c++] = f.b;
            }
            return this;
        },
        copyVector2sArray: function(a) {
            for (var b = this.array, d = 0, e = 0, f = a.length; e < f; e++) {
                var g = a[e];
                void 0 === g && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", e), 
                g = new c()), b[d++] = g.x, b[d++] = g.y;
            }
            return this;
        },
        copyVector3sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var g = a[d];
                void 0 === g && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), 
                g = new f()), b[c++] = g.x, b[c++] = g.y, b[c++] = g.z;
            }
            return this;
        },
        copyVector4sArray: function(a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), 
                f = new i()), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z, b[c++] = f.w;
            }
            return this;
        },
        set: function(a, b) {
            return void 0 === b && (b = 0), this.array.set(a, b), this;
        },
        getX: function(a) {
            return this.array[a * this.itemSize];
        },
        setX: function(a, b) {
            return this.array[a * this.itemSize] = b, this;
        },
        getY: function(a) {
            return this.array[a * this.itemSize + 1];
        },
        setY: function(a, b) {
            return this.array[a * this.itemSize + 1] = b, this;
        },
        getZ: function(a) {
            return this.array[a * this.itemSize + 2];
        },
        setZ: function(a, b) {
            return this.array[a * this.itemSize + 2] = b, this;
        },
        getW: function(a) {
            return this.array[a * this.itemSize + 3];
        },
        setW: function(a, b) {
            return this.array[a * this.itemSize + 3] = b, this;
        },
        setXY: function(a, b, c) {
            return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this;
        },
        setXYZ: function(a, b, c, d) {
            return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, 
            this;
        },
        setXYZW: function(a, b, c, d, e) {
            return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, 
            this.array[a + 3] = e, this;
        },
        onUpload: function(a) {
            return this.onUploadCallback = a, this;
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
    }), B.prototype = Object.create(A.prototype), B.prototype.constructor = B, C.prototype = Object.create(A.prototype), 
    C.prototype.constructor = C, D.prototype = Object.create(A.prototype), D.prototype.constructor = D, 
    E.prototype = Object.create(A.prototype), E.prototype.constructor = E, F.prototype = Object.create(A.prototype), 
    F.prototype.constructor = F, G.prototype = Object.create(A.prototype), G.prototype.constructor = G, 
    H.prototype = Object.create(A.prototype), H.prototype.constructor = H, I.prototype = Object.create(A.prototype), 
    I.prototype.constructor = I, J.prototype = Object.create(A.prototype), J.prototype.constructor = J, 
    Object.assign(K.prototype, {
        computeGroups: function(a) {
            var b = [], c = void 0;
            a = a.faces;
            for (var d = 0; d < a.length; d++) {
                var e = a[d];
                if (e.materialIndex !== c) {
                    c = e.materialIndex, void 0 !== f && (f.count = 3 * d - f.start, b.push(f));
                    var f = {
                        start: 3 * d,
                        materialIndex: c
                    };
                }
            }
            void 0 !== f && (f.count = 3 * d - f.start, b.push(f)), this.groups = b;
        },
        fromGeometry: function(a) {
            var b = a.faces, d = a.vertices, e = a.faceVertexUvs, f = e[0] && 0 < e[0].length, g = e[1] && 0 < e[1].length, h = a.morphTargets, i = h.length;
            if (0 < i) {
                for (var j = [], k = 0; k < i; k++) j[k] = {
                    name: h[k].name,
                    data: []
                };
                this.morphTargets.position = j;
            }
            var l = a.morphNormals, m = l.length;
            if (0 < m) {
                var n = [];
                for (k = 0; k < m; k++) n[k] = {
                    name: l[k].name,
                    data: []
                };
                this.morphTargets.normal = n;
            }
            var o = a.skinIndices, p = a.skinWeights, q = o.length === d.length, r = p.length === d.length;
            for (0 < d.length && 0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), 
            k = 0; k < b.length; k++) {
                var s = b[k];
                this.vertices.push(d[s.a], d[s.b], d[s.c]);
                var t = s.vertexNormals;
                for (3 === t.length ? this.normals.push(t[0], t[1], t[2]) : (t = s.normal, this.normals.push(t, t, t)), 
                t = s.vertexColors, 3 === t.length ? this.colors.push(t[0], t[1], t[2]) : (t = s.color, 
                this.colors.push(t, t, t)), !0 === f && (t = e[0][k], void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", k), 
                this.uvs.push(new c(), new c(), new c()))), !0 === g && (t = e[1][k], void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", k), 
                this.uvs2.push(new c(), new c(), new c()))), t = 0; t < i; t++) {
                    var u = h[t].vertices;
                    j[t].data.push(u[s.a], u[s.b], u[s.c]);
                }
                for (t = 0; t < m; t++) u = l[t].vertexNormals[k], n[t].data.push(u.a, u.b, u.c);
                q && this.skinIndices.push(o[s.a], o[s.b], o[s.c]), r && this.skinWeights.push(p[s.a], p[s.b], p[s.c]);
            }
            return this.computeGroups(a), this.verticesNeedUpdate = a.verticesNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, 
            this.colorsNeedUpdate = a.colorsNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, 
            this.groupsNeedUpdate = a.groupsNeedUpdate, this;
        }
    });
    var kf = 1;
    M.prototype = Object.assign(Object.create(b.prototype), {
        constructor: M,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index;
        },
        setIndex: function(a) {
            Array.isArray(a) ? this.index = new (65535 < L(a) ? H : F)(a, 1) : this.index = a;
        },
        addAttribute: function(a, b, c) {
            return b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? "index" === a ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), 
            this.setIndex(b), this) : (this.attributes[a] = b, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), 
            this.addAttribute(a, new A(b, c)));
        },
        getAttribute: function(a) {
            return this.attributes[a];
        },
        removeAttribute: function(a) {
            return delete this.attributes[a], this;
        },
        addGroup: function(a, b, c) {
            this.groups.push({
                start: a,
                count: b,
                materialIndex: void 0 !== c ? c : 0
            });
        },
        clearGroups: function() {
            this.groups = [];
        },
        setDrawRange: function(a, b) {
            this.drawRange.start = a, this.drawRange.count = b;
        },
        applyMatrix: function(a) {
            var b = this.attributes.position;
            return void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0), b = this.attributes.normal, 
            void 0 !== b && (new g().getNormalMatrix(a).applyToBufferAttribute(b), b.needsUpdate = !0), 
            null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
            this;
        },
        rotateX: function() {
            var a = new d();
            return function(b) {
                return a.makeRotationX(b), this.applyMatrix(a), this;
            };
        }(),
        rotateY: function() {
            var a = new d();
            return function(b) {
                return a.makeRotationY(b), this.applyMatrix(a), this;
            };
        }(),
        rotateZ: function() {
            var a = new d();
            return function(b) {
                return a.makeRotationZ(b), this.applyMatrix(a), this;
            };
        }(),
        translate: function() {
            var a = new d();
            return function(b, c, d) {
                return a.makeTranslation(b, c, d), this.applyMatrix(a), this;
            };
        }(),
        scale: function() {
            var a = new d();
            return function(b, c, d) {
                return a.makeScale(b, c, d), this.applyMatrix(a), this;
            };
        }(),
        lookAt: function() {
            var a = new v();
            return function(b) {
                a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix);
            };
        }(),
        center: function() {
            var a = new f();
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(a).negate(), this.translate(a.x, a.y, a.z), 
                this;
            };
        }(),
        setFromObject: function(a) {
            var b = a.geometry;
            if (a.isPoints || a.isLine) {
                a = new I(3 * b.vertices.length, 3);
                var c = new I(3 * b.colors.length, 3);
                this.addAttribute("position", a.copyVector3sArray(b.vertices)), this.addAttribute("color", c.copyColorsArray(b.colors)), 
                b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new I(b.lineDistances.length, 1), 
                this.addAttribute("lineDistance", a.copyArray(b.lineDistances))), null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()), 
                null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone());
            } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
            return this;
        },
        setFromPoints: function(a) {
            for (var b = [], c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                b.push(e.x, e.y, e.z || 0);
            }
            return this.addAttribute("position", new I(b, 3)), this;
        },
        updateFromObject: function(a) {
            var b = a.geometry;
            if (a.isMesh) {
                var c = b.__directGeometry;
                if (!0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1), void 0 === c) return this.fromGeometry(b);
                c.verticesNeedUpdate = b.verticesNeedUpdate, c.normalsNeedUpdate = b.normalsNeedUpdate, 
                c.colorsNeedUpdate = b.colorsNeedUpdate, c.uvsNeedUpdate = b.uvsNeedUpdate, c.groupsNeedUpdate = b.groupsNeedUpdate, 
                b.verticesNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.uvsNeedUpdate = !1, 
                b.groupsNeedUpdate = !1, b = c;
            }
            return !0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), 
            c.needsUpdate = !0), b.verticesNeedUpdate = !1), !0 === b.normalsNeedUpdate && (c = this.attributes.normal, 
            void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1), 
            !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), 
            c.needsUpdate = !0), b.colorsNeedUpdate = !1), b.uvsNeedUpdate && (c = this.attributes.uv, 
            void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1), 
            b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), 
            c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1), b.groupsNeedUpdate && (b.computeGroups(a.geometry), 
            this.groups = b.groups, b.groupsNeedUpdate = !1), this;
        },
        fromGeometry: function(a) {
            return a.__directGeometry = new K().fromGeometry(a), this.fromDirectGeometry(a.__directGeometry);
        },
        fromDirectGeometry: function(a) {
            var b = new Float32Array(3 * a.vertices.length);
            this.addAttribute("position", new A(b, 3).copyVector3sArray(a.vertices)), 0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), 
            this.addAttribute("normal", new A(b, 3).copyVector3sArray(a.normals))), 0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), 
            this.addAttribute("color", new A(b, 3).copyColorsArray(a.colors))), 0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), 
            this.addAttribute("uv", new A(b, 2).copyVector2sArray(a.uvs))), 0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), 
            this.addAttribute("uv2", new A(b, 2).copyVector2sArray(a.uvs2))), this.groups = a.groups;
            for (var c in a.morphTargets) {
                b = [];
                for (var d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
                    var g = d[e], h = new I(3 * g.data.length, 3);
                    h.name = g.name, b.push(h.copyVector3sArray(g.data));
                }
                this.morphAttributes[c] = b;
            }
            return 0 < a.skinIndices.length && (c = new I(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))), 
            0 < a.skinWeights.length && (c = new I(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))), 
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), 
            this;
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new m());
            var a = this.attributes.position;
            void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) : this.boundingBox.makeEmpty(), 
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        },
        computeBoundingSphere: function() {
            var a = new m(), b = new f();
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new n());
                var c = this.attributes.position;
                if (c) {
                    var d = this.boundingSphere.center;
                    a.setFromBufferAttribute(c), a.getCenter(d);
                    for (var e = 0, f = 0, g = c.count; f < g; f++) b.x = c.getX(f), b.y = c.getY(f), 
                    b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b));
                    this.boundingSphere.radius = Math.sqrt(e), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            };
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var a = this.index, b = this.attributes;
            if (b.position) {
                var c = b.position.array;
                if (void 0 === b.normal) this.addAttribute("normal", new A(new Float32Array(c.length), 3)); else for (var d = b.normal.array, e = 0, g = d.length; e < g; e++) d[e] = 0;
                d = b.normal.array;
                var h = new f(), i = new f(), j = new f(), k = new f(), l = new f();
                if (a) {
                    var m = a.array;
                    for (e = 0, g = a.count; e < g; e += 3) {
                        a = 3 * m[e + 0];
                        var n = 3 * m[e + 1], o = 3 * m[e + 2];
                        h.fromArray(c, a), i.fromArray(c, n), j.fromArray(c, o), k.subVectors(j, i), l.subVectors(h, i), 
                        k.cross(l), d[a] += k.x, d[a + 1] += k.y, d[a + 2] += k.z, d[n] += k.x, d[n + 1] += k.y, 
                        d[n + 2] += k.z, d[o] += k.x, d[o + 1] += k.y, d[o + 2] += k.z;
                    }
                } else for (e = 0, g = c.length; e < g; e += 9) h.fromArray(c, e), i.fromArray(c, e + 3), 
                j.fromArray(c, e + 6), k.subVectors(j, i), l.subVectors(h, i), k.cross(l), d[e] = k.x, 
                d[e + 1] = k.y, d[e + 2] = k.z, d[e + 3] = k.x, d[e + 4] = k.y, d[e + 5] = k.z, 
                d[e + 6] = k.x, d[e + 7] = k.y, d[e + 8] = k.z;
                this.normalizeNormals(), b.normal.needsUpdate = !0;
            }
        },
        merge: function(a, b) {
            if (a && a.isBufferGeometry) {
                void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var c, d = this.attributes;
                for (c in d) if (void 0 !== a.attributes[c]) {
                    var e = d[c].array, f = a.attributes[c], g = f.array, h = 0;
                    for (f = f.itemSize * b; h < g.length; h++, f++) e[f] = g[h];
                }
                return this;
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
        },
        normalizeNormals: function() {
            var a = new f();
            return function() {
                for (var b = this.attributes.normal, c = 0, d = b.count; c < d; c++) a.x = b.getX(c), 
                a.y = b.getY(c), a.z = b.getZ(c), a.normalize(), b.setXYZ(c, a.x, a.y, a.z);
            };
        }(),
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), 
            this;
            var a, b = new M(), c = this.index.array, d = this.attributes;
            for (a in d) {
                var e = d[a], f = e.array, g = e.itemSize, h = new f.constructor(c.length * g), i = 0;
                e = 0;
                for (var j = c.length; e < j; e++) for (var k = c[e] * g, l = 0; l < g; l++) h[i++] = f[k++];
                b.addAttribute(a, new A(h, g));
            }
            for (c = this.groups, e = 0, j = c.length; e < j; e++) d = c[e], b.addGroup(d.start, d.count, d.materialIndex);
            return b;
        },
        toJSON: function() {
            var a = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), 
            0 < Object.keys(this.userData).length && (a.userData = this.userData), void 0 !== this.parameters) {
                var b = this.parameters;
                for (e in b) void 0 !== b[e] && (a[e] = b[e]);
                return a;
            }
            a.data = {
                attributes: {}
            };
            var c = this.index;
            null !== c && (b = Array.prototype.slice.call(c.array), a.data.index = {
                type: c.array.constructor.name,
                array: b
            }), c = this.attributes;
            for (e in c) {
                var d = c[e];
                b = Array.prototype.slice.call(d.array), a.data.attributes[e] = {
                    itemSize: d.itemSize,
                    type: d.array.constructor.name,
                    array: b,
                    normalized: d.normalized
                };
            }
            var e = this.groups;
            return 0 < e.length && (a.data.groups = JSON.parse(JSON.stringify(e))), e = this.boundingSphere, 
            null !== e && (a.data.boundingSphere = {
                center: e.center.toArray(),
                radius: e.radius
            }), a;
        },
        clone: function() {
            return new M().copy(this);
        },
        copy: function(a) {
            var b;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], 
            this.boundingSphere = this.boundingBox = null, this.name = a.name;
            var c = a.index;
            null !== c && this.setIndex(c.clone()), c = a.attributes;
            for (g in c) this.addAttribute(g, c[g].clone());
            var d = a.morphAttributes;
            for (g in d) {
                var e = [], f = d[g];
                for (c = 0, b = f.length; c < b; c++) e.push(f[c].clone());
                this.morphAttributes[g] = e;
            }
            var g = a.groups;
            for (c = 0, b = g.length; c < b; c++) d = g[c], this.addGroup(d.start, d.count, d.materialIndex);
            return g = a.boundingBox, null !== g && (this.boundingBox = g.clone()), g = a.boundingSphere, 
            null !== g && (this.boundingSphere = g.clone()), this.drawRange.start = a.drawRange.start, 
            this.drawRange.count = a.drawRange.count, this.userData = a.userData, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), N.prototype = Object.create(z.prototype), N.prototype.constructor = N, O.prototype = Object.create(M.prototype), 
    O.prototype.constructor = O, P.prototype = Object.create(z.prototype), P.prototype.constructor = P, 
    Q.prototype = Object.create(M.prototype), Q.prototype.constructor = Q;
    var lf = 0;
    R.prototype = Object.assign(Object.create(b.prototype), {
        constructor: R,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(a) {
            if (void 0 !== a) for (var b in a) {
                var c = a[b];
                if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined."); else if ("shading" === b) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), 
                this.flatShading = 1 === c; else {
                    var d = this[b];
                    void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c;
                }
            }
        },
        toJSON: function(a) {
            function b(a) {
                var b, c = [];
                for (b in a) {
                    var d = a[b];
                    delete d.metadata, c.push(d);
                }
                return c;
            }
            var c = void 0 === a || "string" == typeof a;
            c && (a = {
                textures: {},
                images: {}
            });
            var d = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return d.uuid = this.uuid, d.type = this.type, "" !== this.name && (d.name = this.name), 
            this.color && this.color.isColor && (d.color = this.color.getHex()), void 0 !== this.roughness && (d.roughness = this.roughness), 
            void 0 !== this.metalness && (d.metalness = this.metalness), this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()), 
            1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity), 
            this.specular && this.specular.isColor && (d.specular = this.specular.getHex()), 
            void 0 !== this.shininess && (d.shininess = this.shininess), void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat), 
            void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness), 
            this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid), this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid), 
            this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid), 
            this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid, d.aoMapIntensity = this.aoMapIntensity), 
            this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, 
            d.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, 
            d.normalMapType = this.normalMapType, d.normalScale = this.normalScale.toArray()), 
            this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, 
            d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias), 
            this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid), 
            this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid), 
            this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid), 
            this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid), 
            this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, 
            d.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid), 
            void 0 !== this.size && (d.size = this.size), void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation), 
            1 !== this.blending && (d.blending = this.blending), !0 === this.flatShading && (d.flatShading = this.flatShading), 
            0 !== this.side && (d.side = this.side), 0 !== this.vertexColors && (d.vertexColors = this.vertexColors), 
            1 > this.opacity && (d.opacity = this.opacity), !0 === this.transparent && (d.transparent = this.transparent), 
            d.depthFunc = this.depthFunc, d.depthTest = this.depthTest, d.depthWrite = this.depthWrite, 
            0 !== this.rotation && (d.rotation = this.rotation), !0 === this.polygonOffset && (d.polygonOffset = !0), 
            0 !== this.polygonOffsetFactor && (d.polygonOffsetFactor = this.polygonOffsetFactor), 
            0 !== this.polygonOffsetUnits && (d.polygonOffsetUnits = this.polygonOffsetUnits), 
            1 !== this.linewidth && (d.linewidth = this.linewidth), void 0 !== this.dashSize && (d.dashSize = this.dashSize), 
            void 0 !== this.gapSize && (d.gapSize = this.gapSize), void 0 !== this.scale && (d.scale = this.scale), 
            !0 === this.dithering && (d.dithering = !0), 0 < this.alphaTest && (d.alphaTest = this.alphaTest), 
            !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha), 
            !0 === this.wireframe && (d.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth), 
            "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap), 
            "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin), 
            !0 === this.morphTargets && (d.morphTargets = !0), !0 === this.skinning && (d.skinning = !0), 
            !1 === this.visible && (d.visible = !1), "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData), 
            c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a)), 
            d;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            this.name = a.name, this.fog = a.fog, this.lights = a.lights, this.blending = a.blending, 
            this.side = a.side, this.flatShading = a.flatShading, this.vertexColors = a.vertexColors, 
            this.opacity = a.opacity, this.transparent = a.transparent, this.blendSrc = a.blendSrc, 
            this.blendDst = a.blendDst, this.blendEquation = a.blendEquation, this.blendSrcAlpha = a.blendSrcAlpha, 
            this.blendDstAlpha = a.blendDstAlpha, this.blendEquationAlpha = a.blendEquationAlpha, 
            this.depthFunc = a.depthFunc, this.depthTest = a.depthTest, this.depthWrite = a.depthWrite, 
            this.colorWrite = a.colorWrite, this.precision = a.precision, this.polygonOffset = a.polygonOffset, 
            this.polygonOffsetFactor = a.polygonOffsetFactor, this.polygonOffsetUnits = a.polygonOffsetUnits, 
            this.dithering = a.dithering, this.alphaTest = a.alphaTest, this.premultipliedAlpha = a.premultipliedAlpha, 
            this.overdraw = a.overdraw, this.visible = a.visible, this.userData = JSON.parse(JSON.stringify(a.userData)), 
            this.clipShadows = a.clipShadows, this.clipIntersection = a.clipIntersection;
            var b = a.clippingPlanes, c = null;
            if (null !== b) {
                var d = b.length;
                c = Array(d);
                for (var e = 0; e !== d; ++e) c[e] = b[e].clone();
            }
            return this.clippingPlanes = c, this.shadowSide = a.shadowSide, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), S.prototype = Object.create(R.prototype), S.prototype.constructor = S, S.prototype.isMeshBasicMaterial = !0, 
    S.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, 
        this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, 
        this.aoMapIntensity = a.aoMapIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, 
        this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, 
        this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, 
        this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, 
        this.skinning = a.skinning, this.morphTargets = a.morphTargets, this;
    }, T.prototype = Object.create(R.prototype), T.prototype.constructor = T, T.prototype.isShaderMaterial = !0, 
    T.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.fragmentShader = a.fragmentShader, this.vertexShader = a.vertexShader, 
        this.uniforms = df.clone(a.uniforms), this.defines = Object.assign({}, a.defines), 
        this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.lights = a.lights, 
        this.clipping = a.clipping, this.skinning = a.skinning, this.morphTargets = a.morphTargets, 
        this.morphNormals = a.morphNormals, this.extensions = a.extensions, this;
    }, T.prototype.toJSON = function(a) {
        var b = R.prototype.toJSON.call(this, a);
        b.uniforms = {};
        for (var c in this.uniforms) {
            var d = this.uniforms[c].value;
            b.uniforms[c] = d.isTexture ? {
                type: "t",
                value: d.toJSON(a).uuid
            } : d.isColor ? {
                type: "c",
                value: d.getHex()
            } : d.isVector2 ? {
                type: "v2",
                value: d.toArray()
            } : d.isVector3 ? {
                type: "v3",
                value: d.toArray()
            } : d.isVector4 ? {
                type: "v4",
                value: d.toArray()
            } : d.isMatrix4 ? {
                type: "m4",
                value: d.toArray()
            } : {
                value: d
            };
        }
        return 0 < Object.keys(this.defines).length && (b.defines = this.defines), b.vertexShader = this.vertexShader, 
        b.fragmentShader = this.fragmentShader, b;
    }, Object.assign(U.prototype, {
        set: function(a, b) {
            return this.origin.copy(a), this.direction.copy(b), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.origin.copy(a.origin), this.direction.copy(a.direction), this;
        },
        at: function(a, b) {
            return void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), 
            b = new f()), b.copy(this.direction).multiplyScalar(a).add(this.origin);
        },
        lookAt: function(a) {
            return this.direction.copy(a).sub(this.origin).normalize(), this;
        },
        recast: function() {
            var a = new f();
            return function(b) {
                return this.origin.copy(this.at(b, a)), this;
            };
        }(),
        closestPointToPoint: function(a, b) {
            return void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), 
            b = new f()), b.subVectors(a, this.origin), a = b.dot(this.direction), 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin);
        },
        distanceToPoint: function(a) {
            return Math.sqrt(this.distanceSqToPoint(a));
        },
        distanceSqToPoint: function() {
            var a = new f();
            return function(b) {
                var c = a.subVectors(b, this.origin).dot(this.direction);
                return 0 > c ? this.origin.distanceToSquared(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), 
                a.distanceToSquared(b));
            };
        }(),
        distanceSqToSegment: function() {
            var a = new f(), b = new f(), c = new f();
            return function(d, e, f, g) {
                a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);
                var h = .5 * d.distanceTo(e), i = -this.direction.dot(b), j = c.dot(this.direction), k = -c.dot(b), l = c.lengthSq(), m = Math.abs(1 - i * i);
                if (0 < m) {
                    d = i * k - j, e = i * j - k;
                    var n = h * m;
                    0 <= d ? e >= -n ? e <= n ? (h = 1 / m, d *= h, e *= h, i = d * (d + i * e + 2 * j) + e * (i * d + e + 2 * k) + l) : (e = h, 
                    d = Math.max(0, -(i * e + j)), i = -d * d + e * (e + 2 * k) + l) : (e = -h, d = Math.max(0, -(i * e + j)), 
                    i = -d * d + e * (e + 2 * k) + l) : e <= -n ? (d = Math.max(0, -(-i * h + j)), e = 0 < d ? -h : Math.min(Math.max(-h, -k), h), 
                    i = -d * d + e * (e + 2 * k) + l) : e <= n ? (d = 0, e = Math.min(Math.max(-h, -k), h), 
                    i = e * (e + 2 * k) + l) : (d = Math.max(0, -(i * h + j)), e = 0 < d ? h : Math.min(Math.max(-h, -k), h), 
                    i = -d * d + e * (e + 2 * k) + l);
                } else e = 0 < i ? -h : h, d = Math.max(0, -(i * e + j)), i = -d * d + e * (e + 2 * k) + l;
                return f && f.copy(this.direction).multiplyScalar(d).add(this.origin), g && g.copy(b).multiplyScalar(e).add(a), 
                i;
            };
        }(),
        intersectSphere: function() {
            var a = new f();
            return function(b, c) {
                a.subVectors(b.center, this.origin);
                var d = a.dot(this.direction), e = a.dot(a) - d * d;
                return b = b.radius * b.radius, e > b ? null : (b = Math.sqrt(b - e), e = d - b, 
                d += b, 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c));
            };
        }(),
        intersectsSphere: function(a) {
            return this.distanceSqToPoint(a.center) <= a.radius * a.radius;
        },
        distanceToPlane: function(a) {
            var b = a.normal.dot(this.direction);
            return 0 === b ? 0 === a.distanceToPoint(this.origin) ? 0 : null : (a = -(this.origin.dot(a.normal) + a.constant) / b, 
            0 <= a ? a : null);
        },
        intersectPlane: function(a, b) {
            return a = this.distanceToPlane(a), null === a ? null : this.at(a, b);
        },
        intersectsPlane: function(a) {
            var b = a.distanceToPoint(this.origin);
            return 0 === b || 0 > a.normal.dot(this.direction) * b;
        },
        intersectBox: function(a, b) {
            var c = 1 / this.direction.x, d = 1 / this.direction.y, e = 1 / this.direction.z, f = this.origin;
            if (0 <= c) {
                var g = (a.min.x - f.x) * c;
                c *= a.max.x - f.x;
            } else g = (a.max.x - f.x) * c, c *= a.min.x - f.x;
            if (0 <= d) {
                var h = (a.min.y - f.y) * d;
                d *= a.max.y - f.y;
            } else h = (a.max.y - f.y) * d, d *= a.min.y - f.y;
            return g > d || h > c ? null : ((h > g || g !== g) && (g = h), (d < c || c !== c) && (c = d), 
            0 <= e ? (h = (a.min.z - f.z) * e, a = (a.max.z - f.z) * e) : (h = (a.max.z - f.z) * e, 
            a = (a.min.z - f.z) * e), g > a || h > c ? null : ((h > g || g !== g) && (g = h), 
            (a < c || c !== c) && (c = a), 0 > c ? null : this.at(0 <= g ? g : c, b)));
        },
        intersectsBox: function() {
            var a = new f();
            return function(b) {
                return null !== this.intersectBox(b, a);
            };
        }(),
        intersectTriangle: function() {
            var a = new f(), b = new f(), c = new f(), d = new f();
            return function(e, f, g, h, i) {
                if (b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c), 0 < (f = this.direction.dot(d))) {
                    if (h) return null;
                    h = 1;
                } else {
                    if (!(0 > f)) return null;
                    h = -1, f = -f;
                }
                return a.subVectors(this.origin, e), 0 > (e = h * this.direction.dot(c.crossVectors(a, c))) ? null : 0 > (g = h * this.direction.dot(b.cross(a))) || e + g > f ? null : (e = -h * a.dot(d), 
                0 > e ? null : this.at(e / f, i));
            };
        }(),
        applyMatrix4: function(a) {
            return this.origin.applyMatrix4(a), this.direction.transformDirection(a), this;
        },
        equals: function(a) {
            return a.origin.equals(this.origin) && a.direction.equals(this.direction);
        }
    }), Object.assign(V, {
        getNormal: function() {
            var a = new f();
            return function(b, c, d, e) {
                return void 0 === e && (console.warn("THREE.Triangle: .getNormal() target is now required"), 
                e = new f()), e.subVectors(d, c), a.subVectors(b, c), e.cross(a), b = e.lengthSq(), 
                0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
            };
        }(),
        getBarycoord: function() {
            var a = new f(), b = new f(), c = new f();
            return function(d, e, g, h, i) {
                a.subVectors(h, e), b.subVectors(g, e), c.subVectors(d, e), d = a.dot(a), e = a.dot(b), 
                g = a.dot(c);
                var j = b.dot(b);
                h = b.dot(c);
                var k = d * j - e * e;
                return void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), 
                i = new f()), 0 === k ? i.set(-2, -1, -1) : (k = 1 / k, j = (j * g - e * h) * k, 
                d = (d * h - e * g) * k, i.set(1 - j - d, d, j));
            };
        }(),
        containsPoint: function() {
            var a = new f();
            return function(b, c, d, e) {
                return V.getBarycoord(b, c, d, e, a), 0 <= a.x && 0 <= a.y && 1 >= a.x + a.y;
            };
        }(),
        getUV: function() {
            var a = new f();
            return function(b, c, d, e, f, g, h, i) {
                return this.getBarycoord(b, c, d, e, a), i.set(0, 0), i.addScaledVector(f, a.x), 
                i.addScaledVector(g, a.y), i.addScaledVector(h, a.z), i;
            };
        }()
    }), Object.assign(V.prototype, {
        set: function(a, b, c) {
            return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
        },
        setFromPointsAndIndices: function(a, b, c, d) {
            return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this;
        },
        getArea: function() {
            var a = new f(), b = new f();
            return function() {
                return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length();
            };
        }(),
        getMidpoint: function(a) {
            return void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), 
            a = new f()), a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        },
        getNormal: function(a) {
            return V.getNormal(this.a, this.b, this.c, a);
        },
        getPlane: function(a) {
            return void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), 
            a = new f()), a.setFromCoplanarPoints(this.a, this.b, this.c);
        },
        getBarycoord: function(a, b) {
            return V.getBarycoord(a, this.a, this.b, this.c, b);
        },
        containsPoint: function(a) {
            return V.containsPoint(a, this.a, this.b, this.c);
        },
        getUV: function(a, b, c, d, e) {
            return V.getUV(a, this.a, this.b, this.c, b, c, d, e);
        },
        intersectsBox: function(a) {
            return a.intersectsTriangle(this);
        },
        closestPointToPoint: function() {
            var a = new f(), b = new f(), c = new f(), d = new f(), e = new f(), g = new f();
            return function(h, i) {
                void 0 === i && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), 
                i = new f());
                var j = this.a, k = this.b, l = this.c;
                a.subVectors(k, j), b.subVectors(l, j), d.subVectors(h, j);
                var m = a.dot(d), n = b.dot(d);
                if (0 >= m && 0 >= n) return i.copy(j);
                e.subVectors(h, k);
                var o = a.dot(e), p = b.dot(e);
                if (0 <= o && p <= o) return i.copy(k);
                var q = m * p - o * n;
                if (0 >= q && 0 <= m && 0 >= o) return k = m / (m - o), i.copy(j).addScaledVector(a, k);
                g.subVectors(h, l), h = a.dot(g);
                var r = b.dot(g);
                return 0 <= r && h <= r ? i.copy(l) : 0 >= (m = h * n - m * r) && 0 <= n && 0 >= r ? (q = n / (n - r), 
                i.copy(j).addScaledVector(b, q)) : 0 >= (n = o * r - h * p) && 0 <= p - o && 0 <= h - r ? (c.subVectors(l, k), 
                q = (p - o) / (p - o + (h - r)), i.copy(k).addScaledVector(c, q)) : (l = 1 / (n + m + q), 
                k = m * l, q *= l, i.copy(j).addScaledVector(a, k).addScaledVector(b, q));
            };
        }(),
        equals: function(a) {
            return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
        }
    }), W.prototype = Object.assign(Object.create(v.prototype), {
        constructor: W,
        isMesh: !0,
        setDrawMode: function(a) {
            this.drawMode = a;
        },
        copy: function(a) {
            return v.prototype.copy.call(this, a), this.drawMode = a.drawMode, void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice()), 
            void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary)), 
            this;
        },
        updateMorphTargets: function() {
            var a = this.geometry;
            if (a.isBufferGeometry) {
                a = a.morphAttributes;
                var b = Object.keys(a);
                if (0 < b.length) {
                    var c = a[b[0]];
                    if (void 0 !== c) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, 
                    a = 0, b = c.length; a < b; a++) {
                        var d = c[a].name || String(a);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = a;
                    }
                }
            } else if (void 0 !== (c = a.morphTargets) && 0 < c.length) for (this.morphTargetInfluences = [], 
            this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) d = c[a].name || String(a), 
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = a;
        },
        raycast: function() {
            function a(a, b, c, d, e, f, g, h) {
                return null === (1 === b.side ? d.intersectTriangle(g, f, e, !0, h) : d.intersectTriangle(e, f, g, 2 !== b.side, h)) ? null : (t.copy(h), 
                t.applyMatrix4(a.matrixWorld), b = c.ray.origin.distanceTo(t), b < c.near || b > c.far ? null : {
                    distance: b,
                    point: t.clone(),
                    object: a
                });
            }
            function b(b, d, e, f, g, h, l, m, n) {
                return i.fromBufferAttribute(g, l), j.fromBufferAttribute(g, m), k.fromBufferAttribute(g, n), 
                (b = a(b, d, e, f, i, j, k, s)) && (h && (p.fromBufferAttribute(h, l), q.fromBufferAttribute(h, m), 
                r.fromBufferAttribute(h, n), b.uv = V.getUV(s, i, j, k, p, q, r, new c())), h = new y(l, m, n), 
                V.getNormal(i, j, k, h.normal), b.face = h), b;
            }
            var e = new d(), g = new U(), h = new n(), i = new f(), j = new f(), k = new f(), l = new f(), m = new f(), o = new f(), p = new c(), q = new c(), r = new c(), s = new f(), t = new f();
            return function(d, f) {
                var n = this.geometry, t = this.material, u = this.matrixWorld;
                if (void 0 !== t && (null === n.boundingSphere && n.computeBoundingSphere(), h.copy(n.boundingSphere), 
                h.applyMatrix4(u), !1 !== d.ray.intersectsSphere(h) && (e.getInverse(u), g.copy(d.ray).applyMatrix4(e), 
                null === n.boundingBox || !1 !== g.intersectsBox(n.boundingBox)))) if (n.isBufferGeometry) {
                    var v = n.index, w = n.attributes.position, x = n.attributes.uv, y = n.groups;
                    n = n.drawRange;
                    var z;
                    if (null !== v) if (Array.isArray(t)) {
                        var A = 0;
                        for (z = y.length; A < z; A++) {
                            var B = y[A], C = t[B.materialIndex];
                            u = Math.max(B.start, n.start);
                            var D = Math.min(B.start + B.count, n.start + n.count);
                            for (B = u; B < D; B += 3) {
                                u = v.getX(B);
                                var E = v.getX(B + 1), F = v.getX(B + 2);
                                (u = b(this, C, d, g, w, x, u, E, F)) && (u.faceIndex = Math.floor(B / 3), f.push(u));
                            }
                        }
                    } else for (u = Math.max(0, n.start), D = Math.min(v.count, n.start + n.count), 
                    A = u, z = D; A < z; A += 3) u = v.getX(A), E = v.getX(A + 1), F = v.getX(A + 2), 
                    (u = b(this, t, d, g, w, x, u, E, F)) && (u.faceIndex = Math.floor(A / 3), f.push(u)); else if (void 0 !== w) if (Array.isArray(t)) for (A = 0, 
                    z = y.length; A < z; A++) for (B = y[A], C = t[B.materialIndex], u = Math.max(B.start, n.start), 
                    D = Math.min(B.start + B.count, n.start + n.count), B = u; B < D; B += 3) u = B, 
                    E = B + 1, F = B + 2, (u = b(this, C, d, g, w, x, u, E, F)) && (u.faceIndex = Math.floor(B / 3), 
                    f.push(u)); else for (u = Math.max(0, n.start), D = Math.min(w.count, n.start + n.count), 
                    A = u, z = D; A < z; A += 3) u = A, E = A + 1, F = A + 2, (u = b(this, t, d, g, w, x, u, E, F)) && (u.faceIndex = Math.floor(A / 3), 
                    f.push(u));
                } else if (n.isGeometry) for (w = Array.isArray(t), x = n.vertices, y = n.faces, 
                u = n.faceVertexUvs[0], 0 < u.length && (v = u), B = 0, D = y.length; B < D; B++) if (E = y[B], 
                void 0 !== (u = w ? t[E.materialIndex] : t)) {
                    if (A = x[E.a], z = x[E.b], C = x[E.c], !0 === u.morphTargets) {
                        F = n.morphTargets;
                        var G = this.morphTargetInfluences;
                        i.set(0, 0, 0), j.set(0, 0, 0), k.set(0, 0, 0);
                        for (var H = 0, I = F.length; H < I; H++) {
                            var J = G[H];
                            if (0 !== J) {
                                var K = F[H].vertices;
                                i.addScaledVector(l.subVectors(K[E.a], A), J), j.addScaledVector(m.subVectors(K[E.b], z), J), 
                                k.addScaledVector(o.subVectors(K[E.c], C), J);
                            }
                        }
                        i.add(A), j.add(z), k.add(C), A = i, z = j, C = k;
                    }
                    (u = a(this, u, d, g, A, z, C, s)) && (v && v[B] && (F = v[B], p.copy(F[0]), q.copy(F[1]), 
                    r.copy(F[2]), u.uv = V.getUV(s, A, z, C, p, q, r, new c())), u.face = E, u.faceIndex = B, 
                    f.push(u));
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), ga.prototype = Object.create(h.prototype), ga.prototype.constructor = ga, ga.prototype.isCubeTexture = !0, 
    Object.defineProperty(ga.prototype, "images", {
        get: function() {
            return this.image;
        },
        set: function(a) {
            this.image = a;
        }
    });
    var mf = new h(), nf = new ga(), of = [], pf = [], qf = new Float32Array(16), rf = new Float32Array(9), sf = new Float32Array(4);
    La.prototype.updateCache = function(a) {
        var b = this.cache;
        a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length)), 
        ja(b, a);
    }, Ma.prototype.setValue = function(a, b, c) {
        for (var d = this.seq, e = 0, f = d.length; e !== f; ++e) {
            var g = d[e];
            g.setValue(a, b[g.id], c);
        }
    };
    var tf = /([\w\d_]+)(\])?(\[|\.)?/g;
    Na.prototype.setValue = function(a, b, c) {
        void 0 !== (b = this.map[b]) && b.setValue(a, c, this.renderer);
    }, Na.prototype.setOptional = function(a, b, c) {
        void 0 !== (b = b[c]) && this.setValue(a, c, b);
    }, Na.upload = function(a, b, c, d) {
        for (var e = 0, f = b.length; e !== f; ++e) {
            var g = b[e], h = c[g.id];
            !1 !== h.needsUpdate && g.setValue(a, h.value, d);
        }
    }, Na.seqWithValue = function(a, b) {
        for (var c = [], d = 0, e = a.length; d !== e; ++d) {
            var f = a[d];
            f.id in b && c.push(f);
        }
        return c;
    };
    var uf = 0, vf = 0;
    kb.prototype = Object.create(R.prototype), kb.prototype.constructor = kb, kb.prototype.isMeshDepthMaterial = !0, 
    kb.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.depthPacking = a.depthPacking, this.skinning = a.skinning, 
        this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, 
        this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, 
        this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, 
        this;
    }, lb.prototype = Object.create(R.prototype), lb.prototype.constructor = lb, lb.prototype.isMeshDistanceMaterial = !0, 
    lb.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.referencePosition.copy(a.referencePosition), 
        this.nearDistance = a.nearDistance, this.farDistance = a.farDistance, this.skinning = a.skinning, 
        this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, 
        this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, 
        this.displacementBias = a.displacementBias, this;
    }, qb.prototype = Object.assign(Object.create(v.prototype), {
        constructor: qb,
        isGroup: !0
    }), rb.prototype = Object.assign(Object.create(w.prototype), {
        constructor: rb,
        isPerspectiveCamera: !0,
        copy: function(a, b) {
            return w.prototype.copy.call(this, a, b), this.fov = a.fov, this.zoom = a.zoom, 
            this.near = a.near, this.far = a.far, this.focus = a.focus, this.aspect = a.aspect, 
            this.view = null === a.view ? null : Object.assign({}, a.view), this.filmGauge = a.filmGauge, 
            this.filmOffset = a.filmOffset, this;
        },
        setFocalLength: function(a) {
            a = .5 * this.getFilmHeight() / a, this.fov = 2 * _e.RAD2DEG * Math.atan(a), this.updateProjectionMatrix();
        },
        getFocalLength: function() {
            var a = Math.tan(.5 * _e.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / a;
        },
        getEffectiveFOV: function() {
            return 2 * _e.RAD2DEG * Math.atan(Math.tan(.5 * _e.DEG2RAD * this.fov) / this.zoom);
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function(a, b, c, d, e, f) {
            this.aspect = a / b, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = a, this.view.fullHeight = b, this.view.offsetX = c, 
            this.view.offsetY = d, this.view.width = e, this.view.height = f, this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var a = this.near, b = a * Math.tan(.5 * _e.DEG2RAD * this.fov) / this.zoom, c = 2 * b, d = this.aspect * c, e = -.5 * d, f = this.view;
            if (null !== this.view && this.view.enabled) {
                var g = f.fullWidth, h = f.fullHeight;
                e += f.offsetX * d / g, b -= f.offsetY * c / h, d *= f.width / g, c *= f.height / h;
            }
            f = this.filmOffset, 0 !== f && (e += a * f / this.getFilmWidth()), this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far), 
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function(a) {
            return a = v.prototype.toJSON.call(this, a), a.object.fov = this.fov, a.object.zoom = this.zoom, 
            a.object.near = this.near, a.object.far = this.far, a.object.focus = this.focus, 
            a.object.aspect = this.aspect, null !== this.view && (a.object.view = Object.assign({}, this.view)), 
            a.object.filmGauge = this.filmGauge, a.object.filmOffset = this.filmOffset, a;
        }
    }), sb.prototype = Object.assign(Object.create(rb.prototype), {
        constructor: sb,
        isArrayCamera: !0
    }), wb.prototype.isFogExp2 = !0, wb.prototype.clone = function() {
        return new wb(this.color, this.density);
    }, wb.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        };
    }, xb.prototype.isFog = !0, xb.prototype.clone = function() {
        return new xb(this.color, this.near, this.far);
    }, xb.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }, yb.prototype = Object.assign(Object.create(v.prototype), {
        constructor: yb,
        copy: function(a, b) {
            return v.prototype.copy.call(this, a, b), null !== a.background && (this.background = a.background.clone()), 
            null !== a.fog && (this.fog = a.fog.clone()), null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()), 
            this.autoUpdate = a.autoUpdate, this.matrixAutoUpdate = a.matrixAutoUpdate, this;
        },
        toJSON: function(a) {
            var b = v.prototype.toJSON.call(this, a);
            return null !== this.background && (b.object.background = this.background.toJSON(a)), 
            null !== this.fog && (b.object.fog = this.fog.toJSON()), b;
        }
    }), Object.defineProperty(zb.prototype, "needsUpdate", {
        set: function(a) {
            !0 === a && this.version++;
        }
    }), Object.assign(zb.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(a) {
            if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== a ? a.length / this.stride : 0, this.array = a, this;
        },
        setDynamic: function(a) {
            return this.dynamic = a, this;
        },
        copy: function(a) {
            return this.array = new a.array.constructor(a.array), this.count = a.count, this.stride = a.stride, 
            this.dynamic = a.dynamic, this;
        },
        copyAt: function(a, b, c) {
            a *= this.stride, c *= b.stride;
            for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
            return this;
        },
        set: function(a, b) {
            return void 0 === b && (b = 0), this.array.set(a, b), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        onUpload: function(a) {
            return this.onUploadCallback = a, this;
        }
    }), Object.defineProperties(Ab.prototype, {
        count: {
            get: function() {
                return this.data.count;
            }
        },
        array: {
            get: function() {
                return this.data.array;
            }
        }
    }), Object.assign(Ab.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset] = b, this;
        },
        setY: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 1] = b, this;
        },
        setZ: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 2] = b, this;
        },
        setW: function(a, b) {
            return this.data.array[a * this.data.stride + this.offset + 3] = b, this;
        },
        getX: function(a) {
            return this.data.array[a * this.data.stride + this.offset];
        },
        getY: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 1];
        },
        getZ: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 2];
        },
        getW: function(a) {
            return this.data.array[a * this.data.stride + this.offset + 3];
        },
        setXY: function(a, b, c) {
            return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, 
            this;
        },
        setXYZ: function(a, b, c, d) {
            return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, 
            this.data.array[a + 2] = d, this;
        },
        setXYZW: function(a, b, c, d, e) {
            return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, 
            this.data.array[a + 2] = d, this.data.array[a + 3] = e, this;
        }
    }), Bb.prototype = Object.create(R.prototype), Bb.prototype.constructor = Bb, Bb.prototype.isSpriteMaterial = !0, 
    Bb.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, 
        this.rotation = a.rotation, this.sizeAttenuation = a.sizeAttenuation, this;
    };
    var wf;
    Cb.prototype = Object.assign(Object.create(v.prototype), {
        constructor: Cb,
        isSprite: !0,
        raycast: function() {
            function a(a, b, c, d, e, f) {
                h.subVectors(a, c).addScalar(.5).multiply(d), void 0 !== e ? (i.x = f * h.x - e * h.y, 
                i.y = e * h.x + f * h.y) : i.copy(h), a.copy(b), a.x += i.x, a.y += i.y, a.applyMatrix4(j);
            }
            var b = new f(), e = new f(), g = new f(), h = new c(), i = new c(), j = new d(), k = new f(), l = new f(), m = new f(), n = new c(), o = new c(), p = new c();
            return function(d, f) {
                e.setFromMatrixScale(this.matrixWorld), j.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), 
                g.setFromMatrixPosition(this.modelViewMatrix);
                var h = this.material.rotation;
                if (0 !== h) var i = Math.cos(h), q = Math.sin(h);
                h = this.center, a(k.set(-.5, -.5, 0), g, h, e, q, i), a(l.set(.5, -.5, 0), g, h, e, q, i), 
                a(m.set(.5, .5, 0), g, h, e, q, i), n.set(0, 0), o.set(1, 0), p.set(1, 1);
                var r = d.ray.intersectTriangle(k, l, m, !1, b);
                null === r && (a(l.set(-.5, .5, 0), g, h, e, q, i), o.set(0, 1), null === (r = d.ray.intersectTriangle(k, m, l, !1, b))) || (q = d.ray.origin.distanceTo(b)) < d.near || q > d.far || f.push({
                    distance: q,
                    point: b.clone(),
                    uv: V.getUV(b, k, l, m, n, o, p, new c()),
                    face: null,
                    object: this
                });
            };
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this);
        },
        copy: function(a) {
            return v.prototype.copy.call(this, a), void 0 !== a.center && this.center.copy(a.center), 
            this;
        }
    }), Db.prototype = Object.assign(Object.create(v.prototype), {
        constructor: Db,
        copy: function(a) {
            v.prototype.copy.call(this, a, !1), a = a.levels;
            for (var b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                this.addLevel(d.object.clone(), d.distance);
            }
            return this;
        },
        addLevel: function(a, b) {
            void 0 === b && (b = 0), b = Math.abs(b);
            for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++) ;
            c.splice(d, 0, {
                distance: b,
                object: a
            }), this.add(a);
        },
        getObjectForDistance: function(a) {
            for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++) ;
            return b[c - 1].object;
        },
        raycast: function() {
            var a = new f();
            return function(b, c) {
                a.setFromMatrixPosition(this.matrixWorld);
                var d = b.ray.origin.distanceTo(a);
                this.getObjectForDistance(d).raycast(b, c);
            };
        }(),
        update: function() {
            var a = new f(), b = new f();
            return function(c) {
                var d = this.levels;
                if (1 < d.length) {
                    a.setFromMatrixPosition(c.matrixWorld), b.setFromMatrixPosition(this.matrixWorld), 
                    c = a.distanceTo(b), d[0].object.visible = !0;
                    for (var e = 1, f = d.length; e < f && c >= d[e].distance; e++) d[e - 1].object.visible = !1, 
                    d[e].object.visible = !0;
                    for (;e < f; e++) d[e].object.visible = !1;
                }
            };
        }(),
        toJSON: function(a) {
            a = v.prototype.toJSON.call(this, a), a.object.levels = [];
            for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
                var e = b[c];
                a.object.levels.push({
                    object: e.object.uuid,
                    distance: e.distance
                });
            }
            return a;
        }
    }), Object.assign(Eb.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var a = 0, b = this.bones.length; a < b; a++) {
                var c = new d();
                this.bones[a] && c.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(c);
            }
        },
        pose: function() {
            var a, b, c = 0;
            for (b = this.bones.length; c < b; c++) (a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
            for (c = 0, b = this.bones.length; c < b; c++) (a = this.bones[c]) && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), 
            a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale));
        },
        update: function() {
            var a = new d(), b = new d();
            return function() {
                for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture, g = 0, h = c.length; g < h; g++) a.multiplyMatrices(c[g] ? c[g].matrixWorld : b, d[g]), 
                a.toArray(e, 16 * g);
                void 0 !== f && (f.needsUpdate = !0);
            };
        }(),
        clone: function() {
            return new Eb(this.bones, this.boneInverses);
        },
        getBoneByName: function(a) {
            for (var b = 0, c = this.bones.length; b < c; b++) {
                var d = this.bones[b];
                if (d.name === a) return d;
            }
        }
    }), Fb.prototype = Object.assign(Object.create(v.prototype), {
        constructor: Fb,
        isBone: !0
    }), Gb.prototype = Object.assign(Object.create(W.prototype), {
        constructor: Gb,
        isSkinnedMesh: !0,
        initBones: function() {
            var a, b = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                var c = 0;
                for (a = this.geometry.bones.length; c < a; c++) {
                    var d = this.geometry.bones[c], e = new Fb();
                    b.push(e), e.name = d.name, e.position.fromArray(d.pos), e.quaternion.fromArray(d.rotq), 
                    void 0 !== d.scl && e.scale.fromArray(d.scl);
                }
                for (c = 0, a = this.geometry.bones.length; c < a; c++) d = this.geometry.bones[c], 
                -1 !== d.parent && null !== d.parent && void 0 !== b[d.parent] ? b[d.parent].add(b[c]) : this.add(b[c]);
            }
            return this.updateMatrixWorld(!0), b;
        },
        bind: function(a, b) {
            this.skeleton = a, void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), 
            b = this.matrixWorld), this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b);
        },
        pose: function() {
            this.skeleton.pose();
        },
        normalizeSkinWeights: function() {
            var a;
            if (this.geometry && this.geometry.isGeometry) for (a = 0; a < this.geometry.skinWeights.length; a++) {
                var b = this.geometry.skinWeights[a], c = 1 / b.manhattanLength();
                1 / 0 !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0);
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                b = new i();
                var d = this.geometry.attributes.skinWeight;
                for (a = 0; a < d.count; a++) b.x = d.getX(a), b.y = d.getY(a), b.z = d.getZ(a), 
                b.w = d.getW(a), c = 1 / b.manhattanLength(), 1 / 0 !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0), 
                d.setXYZW(a, b.x, b.y, b.z, b.w);
            }
        },
        updateMatrixWorld: function(a) {
            W.prototype.updateMatrixWorld.call(this, a), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), Hb.prototype = Object.create(R.prototype), Hb.prototype.constructor = Hb, Hb.prototype.isLineBasicMaterial = !0, 
    Hb.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, 
        this.linecap = a.linecap, this.linejoin = a.linejoin, this;
    }, Ib.prototype = Object.assign(Object.create(v.prototype), {
        constructor: Ib,
        isLine: !0,
        computeLineDistances: function() {
            var a = new f(), b = new f();
            return function() {
                var c = this.geometry;
                if (c.isBufferGeometry) if (null === c.index) {
                    for (var d = c.attributes.position, e = [ 0 ], f = 1, g = d.count; f < g; f++) a.fromBufferAttribute(d, f - 1), 
                    b.fromBufferAttribute(d, f), e[f] = e[f - 1], e[f] += a.distanceTo(b);
                    c.addAttribute("lineDistance", new I(e, 1));
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (c.isGeometry) for (d = c.vertices, 
                e = c.lineDistances, e[0] = 0, f = 1, g = d.length; f < g; f++) e[f] = e[f - 1], 
                e[f] += d[f - 1].distanceTo(d[f]);
                return this;
            };
        }(),
        raycast: function() {
            var a = new d(), b = new U(), c = new n();
            return function(d, e) {
                var g = d.linePrecision, h = this.geometry, i = this.matrixWorld;
                if (null === h.boundingSphere && h.computeBoundingSphere(), c.copy(h.boundingSphere), 
                c.applyMatrix4(i), c.radius += g, !1 !== d.ray.intersectsSphere(c)) {
                    a.getInverse(i), b.copy(d.ray).applyMatrix4(a), g /= (this.scale.x + this.scale.y + this.scale.z) / 3, 
                    g *= g;
                    var j = new f(), k = new f();
                    i = new f();
                    var l = new f(), m = this && this.isLineSegments ? 2 : 1;
                    if (h.isBufferGeometry) {
                        var n = h.index, o = h.attributes.position.array;
                        if (null !== n) {
                            n = n.array, h = 0;
                            for (var p = n.length - 1; h < p; h += m) {
                                var q = n[h + 1];
                                j.fromArray(o, 3 * n[h]), k.fromArray(o, 3 * q), q = b.distanceSqToSegment(j, k, l, i), 
                                q > g || (l.applyMatrix4(this.matrixWorld), (q = d.ray.origin.distanceTo(l)) < d.near || q > d.far || e.push({
                                    distance: q,
                                    point: i.clone().applyMatrix4(this.matrixWorld),
                                    index: h,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }));
                            }
                        } else for (h = 0, p = o.length / 3 - 1; h < p; h += m) j.fromArray(o, 3 * h), k.fromArray(o, 3 * h + 3), 
                        (q = b.distanceSqToSegment(j, k, l, i)) > g || (l.applyMatrix4(this.matrixWorld), 
                        (q = d.ray.origin.distanceTo(l)) < d.near || q > d.far || e.push({
                            distance: q,
                            point: i.clone().applyMatrix4(this.matrixWorld),
                            index: h,
                            face: null,
                            faceIndex: null,
                            object: this
                        }));
                    } else if (h.isGeometry) for (j = h.vertices, k = j.length, h = 0; h < k - 1; h += m) (q = b.distanceSqToSegment(j[h], j[h + 1], l, i)) > g || (l.applyMatrix4(this.matrixWorld), 
                    (q = d.ray.origin.distanceTo(l)) < d.near || q > d.far || e.push({
                        distance: q,
                        point: i.clone().applyMatrix4(this.matrixWorld),
                        index: h,
                        face: null,
                        faceIndex: null,
                        object: this
                    }));
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), Jb.prototype = Object.assign(Object.create(Ib.prototype), {
        constructor: Jb,
        isLineSegments: !0,
        computeLineDistances: function() {
            var a = new f(), b = new f();
            return function() {
                var c = this.geometry;
                if (c.isBufferGeometry) if (null === c.index) {
                    for (var d = c.attributes.position, e = [], f = 0, g = d.count; f < g; f += 2) a.fromBufferAttribute(d, f), 
                    b.fromBufferAttribute(d, f + 1), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b);
                    c.addAttribute("lineDistance", new I(e, 1));
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (c.isGeometry) for (d = c.vertices, 
                e = c.lineDistances, f = 0, g = d.length; f < g; f += 2) a.copy(d[f]), b.copy(d[f + 1]), 
                e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b);
                return this;
            };
        }()
    }), Kb.prototype = Object.assign(Object.create(Ib.prototype), {
        constructor: Kb,
        isLineLoop: !0
    }), Lb.prototype = Object.create(R.prototype), Lb.prototype.constructor = Lb, Lb.prototype.isPointsMaterial = !0, 
    Lb.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, 
        this.size = a.size, this.sizeAttenuation = a.sizeAttenuation, this.morphTargets = a.morphTargets, 
        this;
    }, Mb.prototype = Object.assign(Object.create(v.prototype), {
        constructor: Mb,
        isPoints: !0,
        raycast: function() {
            var a = new d(), b = new U(), c = new n();
            return function(d, e) {
                function g(a, c) {
                    var f = b.distanceSqToPoint(a);
                    f < l && (b.closestPointToPoint(a, m), m.applyMatrix4(j), (a = d.ray.origin.distanceTo(m)) < d.near || a > d.far || e.push({
                        distance: a,
                        distanceToRay: Math.sqrt(f),
                        point: m.clone(),
                        index: c,
                        face: null,
                        object: h
                    }));
                }
                var h = this, i = this.geometry, j = this.matrixWorld, k = d.params.Points.threshold;
                if (null === i.boundingSphere && i.computeBoundingSphere(), c.copy(i.boundingSphere), 
                c.applyMatrix4(j), c.radius += k, !1 !== d.ray.intersectsSphere(c)) {
                    a.getInverse(j), b.copy(d.ray).applyMatrix4(a), k /= (this.scale.x + this.scale.y + this.scale.z) / 3;
                    var l = k * k;
                    k = new f();
                    var m = new f();
                    if (i.isBufferGeometry) {
                        var n = i.index;
                        if (i = i.attributes.position.array, null !== n) {
                            var o = n.array;
                            n = 0;
                            for (var p = o.length; n < p; n++) {
                                var q = o[n];
                                k.fromArray(i, 3 * q), g(k, q);
                            }
                        } else for (n = 0, o = i.length / 3; n < o; n++) k.fromArray(i, 3 * n), g(k, n);
                    } else for (k = i.vertices, n = 0, o = k.length; n < o; n++) g(k[n], n);
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), Nb.prototype = Object.assign(Object.create(h.prototype), {
        constructor: Nb,
        isVideoTexture: !0,
        update: function() {
            var a = this.image;
            a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
        }
    }), Ob.prototype = Object.create(h.prototype), Ob.prototype.constructor = Ob, Ob.prototype.isCompressedTexture = !0, 
    Pb.prototype = Object.create(h.prototype), Pb.prototype.constructor = Pb, Pb.prototype.isCanvasTexture = !0, 
    Qb.prototype = Object.create(h.prototype), Qb.prototype.constructor = Qb, Qb.prototype.isDepthTexture = !0, 
    Rb.prototype = Object.create(M.prototype), Rb.prototype.constructor = Rb, Sb.prototype = Object.create(z.prototype), 
    Sb.prototype.constructor = Sb, Tb.prototype = Object.create(M.prototype), Tb.prototype.constructor = Tb, 
    Ub.prototype = Object.create(z.prototype), Ub.prototype.constructor = Ub, Vb.prototype = Object.create(M.prototype), 
    Vb.prototype.constructor = Vb, Wb.prototype = Object.create(z.prototype), Wb.prototype.constructor = Wb, 
    Xb.prototype = Object.create(Vb.prototype), Xb.prototype.constructor = Xb, Yb.prototype = Object.create(z.prototype), 
    Yb.prototype.constructor = Yb, Zb.prototype = Object.create(Vb.prototype), Zb.prototype.constructor = Zb, 
    $b.prototype = Object.create(z.prototype), $b.prototype.constructor = $b, _b.prototype = Object.create(Vb.prototype), 
    _b.prototype.constructor = _b, ac.prototype = Object.create(z.prototype), ac.prototype.constructor = ac, 
    bc.prototype = Object.create(Vb.prototype), bc.prototype.constructor = bc, cc.prototype = Object.create(z.prototype), 
    cc.prototype.constructor = cc, dc.prototype = Object.create(M.prototype), dc.prototype.constructor = dc, 
    ec.prototype = Object.create(z.prototype), ec.prototype.constructor = ec, fc.prototype = Object.create(M.prototype), 
    fc.prototype.constructor = fc, gc.prototype = Object.create(z.prototype), gc.prototype.constructor = gc, 
    hc.prototype = Object.create(M.prototype), hc.prototype.constructor = hc;
    var xf = {
        triangulate: function(a, b, c) {
            c = c || 2;
            var d = b && b.length, e = d ? b[0] * c : a.length, f = ic(a, 0, e, c, !0), g = [];
            if (!f) return g;
            var h;
            if (d) {
                var i = c;
                d = [];
                var j, k = 0;
                for (j = b.length; k < j; k++) {
                    var l = b[k] * i;
                    l = ic(a, l, k < j - 1 ? b[k + 1] * i : a.length, i, !1), l === l.next && (l.steiner = !0), 
                    d.push(oc(l));
                }
                for (d.sort(lc), k = 0; k < d.length; k++) b = d[k], i = f, (i = mc(b, i)) && (b = uc(i, b), 
                jc(b, b.next)), f = jc(f, f.next);
            }
            if (a.length > 80 * c) {
                var m = h = a[0], n = d = a[1];
                for (i = c; i < e; i += c) k = a[i], b = a[i + 1], k < m && (m = k), b < n && (n = b), 
                k > h && (h = k), b > d && (d = b);
                h = Math.max(h - m, d - n), h = 0 !== h ? 1 / h : 0;
            }
            return kc(f, g, c, m, n, h), g;
        }
    }, yf = {
        area: function(a) {
            for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
            return .5 * c;
        },
        isClockWise: function(a) {
            return 0 > yf.area(a);
        },
        triangulateShape: function(a, b) {
            var c = [], d = [], e = [];
            yc(a), zc(c, a);
            var f = a.length;
            for (b.forEach(yc), a = 0; a < b.length; a++) d.push(f), f += b[a].length, zc(c, b[a]);
            for (b = xf.triangulate(c, d), a = 0; a < b.length; a += 3) e.push(b.slice(a, a + 3));
            return e;
        }
    };
    Ac.prototype = Object.create(z.prototype), Ac.prototype.constructor = Ac, Ac.prototype.toJSON = function() {
        var a = z.prototype.toJSON.call(this);
        return Cc(this.parameters.shapes, this.parameters.options, a);
    }, Bc.prototype = Object.create(M.prototype), Bc.prototype.constructor = Bc, Bc.prototype.toJSON = function() {
        var a = M.prototype.toJSON.call(this);
        return Cc(this.parameters.shapes, this.parameters.options, a);
    };
    var zf = {
        generateTopUV: function(a, b, d, e, f) {
            a = b[3 * e], e = b[3 * e + 1];
            var g = b[3 * f];
            return f = b[3 * f + 1], [ new c(b[3 * d], b[3 * d + 1]), new c(a, e), new c(g, f) ];
        },
        generateSideWallUV: function(a, b, d, e, f, g) {
            a = b[3 * d];
            var h = b[3 * d + 1];
            d = b[3 * d + 2];
            var i = b[3 * e], j = b[3 * e + 1];
            e = b[3 * e + 2];
            var k = b[3 * f], l = b[3 * f + 1];
            f = b[3 * f + 2];
            var m = b[3 * g], n = b[3 * g + 1];
            return b = b[3 * g + 2], .01 > Math.abs(h - j) ? [ new c(a, 1 - d), new c(i, 1 - e), new c(k, 1 - f), new c(m, 1 - b) ] : [ new c(h, 1 - d), new c(j, 1 - e), new c(l, 1 - f), new c(n, 1 - b) ];
        }
    };
    Dc.prototype = Object.create(z.prototype), Dc.prototype.constructor = Dc, Ec.prototype = Object.create(Bc.prototype), 
    Ec.prototype.constructor = Ec, Fc.prototype = Object.create(z.prototype), Fc.prototype.constructor = Fc, 
    Gc.prototype = Object.create(M.prototype), Gc.prototype.constructor = Gc, Hc.prototype = Object.create(z.prototype), 
    Hc.prototype.constructor = Hc, Ic.prototype = Object.create(M.prototype), Ic.prototype.constructor = Ic, 
    Jc.prototype = Object.create(z.prototype), Jc.prototype.constructor = Jc, Kc.prototype = Object.create(M.prototype), 
    Kc.prototype.constructor = Kc, Lc.prototype = Object.create(z.prototype), Lc.prototype.constructor = Lc, 
    Lc.prototype.toJSON = function() {
        var a = z.prototype.toJSON.call(this);
        return Nc(this.parameters.shapes, a);
    }, Mc.prototype = Object.create(M.prototype), Mc.prototype.constructor = Mc, Mc.prototype.toJSON = function() {
        var a = M.prototype.toJSON.call(this);
        return Nc(this.parameters.shapes, a);
    }, Oc.prototype = Object.create(M.prototype), Oc.prototype.constructor = Oc, Pc.prototype = Object.create(z.prototype), 
    Pc.prototype.constructor = Pc, Qc.prototype = Object.create(M.prototype), Qc.prototype.constructor = Qc, 
    Rc.prototype = Object.create(Pc.prototype), Rc.prototype.constructor = Rc, Sc.prototype = Object.create(Qc.prototype), 
    Sc.prototype.constructor = Sc, Tc.prototype = Object.create(z.prototype), Tc.prototype.constructor = Tc, 
    Uc.prototype = Object.create(M.prototype), Uc.prototype.constructor = Uc;
    var Af = Object.freeze({
        WireframeGeometry: Rb,
        ParametricGeometry: Sb,
        ParametricBufferGeometry: Tb,
        TetrahedronGeometry: Wb,
        TetrahedronBufferGeometry: Xb,
        OctahedronGeometry: Yb,
        OctahedronBufferGeometry: Zb,
        IcosahedronGeometry: $b,
        IcosahedronBufferGeometry: _b,
        DodecahedronGeometry: ac,
        DodecahedronBufferGeometry: bc,
        PolyhedronGeometry: Ub,
        PolyhedronBufferGeometry: Vb,
        TubeGeometry: cc,
        TubeBufferGeometry: dc,
        TorusKnotGeometry: ec,
        TorusKnotBufferGeometry: fc,
        TorusGeometry: gc,
        TorusBufferGeometry: hc,
        TextGeometry: Dc,
        TextBufferGeometry: Ec,
        SphereGeometry: Fc,
        SphereBufferGeometry: Gc,
        RingGeometry: Hc,
        RingBufferGeometry: Ic,
        PlaneGeometry: P,
        PlaneBufferGeometry: Q,
        LatheGeometry: Jc,
        LatheBufferGeometry: Kc,
        ShapeGeometry: Lc,
        ShapeBufferGeometry: Mc,
        ExtrudeGeometry: Ac,
        ExtrudeBufferGeometry: Bc,
        EdgesGeometry: Oc,
        ConeGeometry: Rc,
        ConeBufferGeometry: Sc,
        CylinderGeometry: Pc,
        CylinderBufferGeometry: Qc,
        CircleGeometry: Tc,
        CircleBufferGeometry: Uc,
        BoxGeometry: N,
        BoxBufferGeometry: O
    });
    Vc.prototype = Object.create(R.prototype), Vc.prototype.constructor = Vc, Vc.prototype.isShadowMaterial = !0, 
    Vc.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.color.copy(a.color), this;
    }, Wc.prototype = Object.create(T.prototype), Wc.prototype.constructor = Wc, Wc.prototype.isRawShaderMaterial = !0, 
    Xc.prototype = Object.create(R.prototype), Xc.prototype.constructor = Xc, Xc.prototype.isMeshStandardMaterial = !0, 
    Xc.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.defines = {
            STANDARD: ""
        }, this.color.copy(a.color), this.roughness = a.roughness, this.metalness = a.metalness, 
        this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, 
        this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), 
        this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, 
        this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, 
        this.normalMapType = a.normalMapType, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, 
        this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, 
        this.roughnessMap = a.roughnessMap, this.metalnessMap = a.metalnessMap, this.alphaMap = a.alphaMap, 
        this.envMap = a.envMap, this.envMapIntensity = a.envMapIntensity, this.refractionRatio = a.refractionRatio, 
        this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, 
        this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, 
        this.morphNormals = a.morphNormals, this;
    }, Yc.prototype = Object.create(Xc.prototype), Yc.prototype.constructor = Yc, Yc.prototype.isMeshPhysicalMaterial = !0, 
    Yc.prototype.copy = function(a) {
        return Xc.prototype.copy.call(this, a), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = a.reflectivity, this.clearCoat = a.clearCoat, this.clearCoatRoughness = a.clearCoatRoughness, 
        this;
    }, Zc.prototype = Object.create(R.prototype), Zc.prototype.constructor = Zc, Zc.prototype.isMeshPhongMaterial = !0, 
    Zc.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.color.copy(a.color), this.specular.copy(a.specular), 
        this.shininess = a.shininess, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, 
        this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), 
        this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, 
        this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, 
        this.normalMapType = a.normalMapType, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, 
        this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, 
        this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, 
        this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, 
        this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, 
        this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, 
        this.morphNormals = a.morphNormals, this;
    }, $c.prototype = Object.create(Zc.prototype), $c.prototype.constructor = $c, $c.prototype.isMeshToonMaterial = !0, 
    $c.prototype.copy = function(a) {
        return Zc.prototype.copy.call(this, a), this.gradientMap = a.gradientMap, this;
    }, _c.prototype = Object.create(R.prototype), _c.prototype.constructor = _c, _c.prototype.isMeshNormalMaterial = !0, 
    _c.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, 
        this.normalMap = a.normalMap, this.normalMapType = a.normalMapType, this.normalScale.copy(a.normalScale), 
        this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, 
        this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, 
        this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, 
        this;
    }, ad.prototype = Object.create(R.prototype), ad.prototype.constructor = ad, ad.prototype.isMeshLambertMaterial = !0, 
    ad.prototype.copy = function(a) {
        return R.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, 
        this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, 
        this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, 
        this.emissiveIntensity = a.emissiveIntensity, this.specularMap = a.specularMap, 
        this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, 
        this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, 
        this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, 
        this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, 
        this;
    }, bd.prototype = Object.create(Hb.prototype), bd.prototype.constructor = bd, bd.prototype.isLineDashedMaterial = !0, 
    bd.prototype.copy = function(a) {
        return Hb.prototype.copy.call(this, a), this.scale = a.scale, this.dashSize = a.dashSize, 
        this.gapSize = a.gapSize, this;
    };
    var Bf = Object.freeze({
        ShadowMaterial: Vc,
        SpriteMaterial: Bb,
        RawShaderMaterial: Wc,
        ShaderMaterial: T,
        PointsMaterial: Lb,
        MeshPhysicalMaterial: Yc,
        MeshStandardMaterial: Xc,
        MeshPhongMaterial: Zc,
        MeshToonMaterial: $c,
        MeshNormalMaterial: _c,
        MeshLambertMaterial: ad,
        MeshDepthMaterial: kb,
        MeshDistanceMaterial: lb,
        MeshBasicMaterial: S,
        LineDashedMaterial: bd,
        LineBasicMaterial: Hb,
        Material: R
    }), Cf = {
        enabled: !1,
        files: {},
        add: function(a, b) {
            !1 !== this.enabled && (this.files[a] = b);
        },
        get: function(a) {
            if (!1 !== this.enabled) return this.files[a];
        },
        remove: function(a) {
            delete this.files[a];
        },
        clear: function() {
            this.files = {};
        }
    }, Df = new cd(), Ef = {};
    Object.assign(dd.prototype, {
        load: function(a, b, c, d) {
            void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
            var e = this, f = Cf.get(a);
            if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
                b && b(f), e.manager.itemEnd(a);
            }, 0), f;
            if (void 0 === Ef[a]) {
                var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (g) {
                    c = g[1];
                    var h = !!g[2];
                    g = g[3], g = window.decodeURIComponent(g), h && (g = window.atob(g));
                    try {
                        var i = (this.responseType || "").toLowerCase();
                        switch (i) {
                          case "arraybuffer":
                          case "blob":
                            var j = new Uint8Array(g.length);
                            for (h = 0; h < g.length; h++) j[h] = g.charCodeAt(h);
                            var k = "blob" === i ? new Blob([ j.buffer ], {
                                type: c
                            }) : j.buffer;
                            break;

                          case "document":
                            k = new DOMParser().parseFromString(g, c);
                            break;

                          case "json":
                            k = JSON.parse(g);
                            break;

                          default:
                            k = g;
                        }
                        window.setTimeout(function() {
                            b && b(k), e.manager.itemEnd(a);
                        }, 0);
                    } catch (b) {
                        window.setTimeout(function() {
                            d && d(b), e.manager.itemEnd(a), e.manager.itemError(a);
                        }, 0);
                    }
                } else {
                    Ef[a] = [], Ef[a].push({
                        onLoad: b,
                        onProgress: c,
                        onError: d
                    });
                    var l = new XMLHttpRequest();
                    l.open("GET", a, !0), l.addEventListener("load", function(b) {
                        var c = this.response;
                        Cf.add(a, c);
                        var d = Ef[a];
                        if (delete Ef[a], 200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                            for (var f = 0, g = d.length; f < g; f++) {
                                var h = d[f];
                                h.onLoad && h.onLoad(c);
                            }
                            e.manager.itemEnd(a);
                        } else {
                            for (f = 0, g = d.length; f < g; f++) h = d[f], h.onError && h.onError(b);
                            e.manager.itemEnd(a), e.manager.itemError(a);
                        }
                    }, !1), l.addEventListener("progress", function(b) {
                        for (var c = Ef[a], d = 0, e = c.length; d < e; d++) {
                            var f = c[d];
                            f.onProgress && f.onProgress(b);
                        }
                    }, !1), l.addEventListener("error", function(b) {
                        var c = Ef[a];
                        delete Ef[a];
                        for (var d = 0, f = c.length; d < f; d++) {
                            var g = c[d];
                            g.onError && g.onError(b);
                        }
                        e.manager.itemEnd(a), e.manager.itemError(a);
                    }, !1), l.addEventListener("abort", function(b) {
                        var c = Ef[a];
                        delete Ef[a];
                        for (var d = 0, f = c.length; d < f; d++) {
                            var g = c[d];
                            g.onError && g.onError(b);
                        }
                        e.manager.itemEnd(a), e.manager.itemError(a);
                    }, !1), void 0 !== this.responseType && (l.responseType = this.responseType), void 0 !== this.withCredentials && (l.withCredentials = this.withCredentials), 
                    l.overrideMimeType && l.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (h in this.requestHeader) l.setRequestHeader(h, this.requestHeader[h]);
                    l.send(null);
                }
                return e.manager.itemStart(a), l;
            }
            Ef[a].push({
                onLoad: b,
                onProgress: c,
                onError: d
            });
        },
        setPath: function(a) {
            return this.path = a, this;
        },
        setResponseType: function(a) {
            return this.responseType = a, this;
        },
        setWithCredentials: function(a) {
            return this.withCredentials = a, this;
        },
        setMimeType: function(a) {
            return this.mimeType = a, this;
        },
        setRequestHeader: function(a) {
            return this.requestHeader = a, this;
        }
    }), Object.assign(ed.prototype, {
        load: function(a, b, c, d) {
            function e(e) {
                i.load(a[e], function(a) {
                    a = f._parser(a, !0), g[e] = {
                        width: a.width,
                        height: a.height,
                        format: a.format,
                        mipmaps: a.mipmaps
                    }, 6 === (j += 1) && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, 
                    h.needsUpdate = !0, b && b(h));
                }, c, d);
            }
            var f = this, g = [], h = new Ob();
            h.image = g;
            var i = new dd(this.manager);
            if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(a)) for (var j = 0, k = 0, l = a.length; k < l; ++k) e(k); else i.load(a, function(a) {
                if (a = f._parser(a, !0), a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
                    g[d] = {
                        mipmaps: []
                    };
                    for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), 
                    g[d].format = a.format, g[d].width = a.width, g[d].height = a.height;
                } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
                1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, 
                b && b(h);
            }, c, d);
            return h;
        },
        setPath: function(a) {
            return this.path = a, this;
        }
    }), Object.assign(fd.prototype, {
        load: function(a, b, c, d) {
            var e = this, f = new l(), g = new dd(this.manager);
            return g.setResponseType("arraybuffer"), g.load(a, function(a) {
                (a = e._parser(a)) && (void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, 
                f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, 
                f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, 
                f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, 
                void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), 
                void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), 
                f.needsUpdate = !0, b && b(f, a));
            }, c, d), f;
        }
    }), Object.assign(gd.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            function e() {
                i.removeEventListener("load", e, !1), i.removeEventListener("error", f, !1), Cf.add(a, this), 
                b && b(this), g.manager.itemEnd(a);
            }
            function f(b) {
                i.removeEventListener("load", e, !1), i.removeEventListener("error", f, !1), d && d(b), 
                g.manager.itemEnd(a), g.manager.itemError(a);
            }
            void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
            var g = this, h = Cf.get(a);
            if (void 0 !== h) return g.manager.itemStart(a), setTimeout(function() {
                b && b(h), g.manager.itemEnd(a);
            }, 0), h;
            var i = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return i.addEventListener("load", e, !1), i.addEventListener("error", f, !1), "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (i.crossOrigin = this.crossOrigin), 
            g.manager.itemStart(a), i.src = a, i;
        },
        setCrossOrigin: function(a) {
            return this.crossOrigin = a, this;
        },
        setPath: function(a) {
            return this.path = a, this;
        }
    }), Object.assign(hd.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            function e(c) {
                g.load(a[c], function(a) {
                    f.images[c] = a, 6 === ++h && (f.needsUpdate = !0, b && b(f));
                }, void 0, d);
            }
            var f = new ga(), g = new gd(this.manager);
            g.setCrossOrigin(this.crossOrigin), g.setPath(this.path);
            var h = 0;
            for (c = 0; c < a.length; ++c) e(c);
            return f;
        },
        setCrossOrigin: function(a) {
            return this.crossOrigin = a, this;
        },
        setPath: function(a) {
            return this.path = a, this;
        }
    }), Object.assign(id.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            var e = new h(), f = new gd(this.manager);
            return f.setCrossOrigin(this.crossOrigin), f.setPath(this.path), f.load(a, function(c) {
                e.image = c, c = 0 < a.search(/\.jpe?g$/i) || 0 === a.search(/^data:image\/jpeg/), 
                e.format = c ? 1022 : 1023, e.needsUpdate = !0, void 0 !== b && b(e);
            }, c, d), e;
        },
        setCrossOrigin: function(a) {
            return this.crossOrigin = a, this;
        },
        setPath: function(a) {
            return this.path = a, this;
        }
    }), Object.assign(jd.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null;
        },
        getPointAt: function(a, b) {
            return a = this.getUtoTmapping(a), this.getPoint(a, b);
        },
        getPoints: function(a) {
            void 0 === a && (a = 5);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
            return b;
        },
        getSpacedPoints: function(a) {
            void 0 === a && (a = 5);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
            return b;
        },
        getLength: function() {
            var a = this.getLengths();
            return a[a.length - 1];
        },
        getLengths: function(a) {
            if (void 0 === a && (a = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var b, c = [], d = this.getPoint(0), e = 0;
            for (c.push(0), b = 1; b <= a; b++) {
                var f = this.getPoint(b / a);
                e += f.distanceTo(d), c.push(e), d = f;
            }
            return this.cacheArcLengths = c;
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths();
        },
        getUtoTmapping: function(a, b) {
            var c = this.getLengths(), d = c.length;
            b = b || a * c[d - 1];
            for (var e, f = 0, g = d - 1; f <= g; ) if (a = Math.floor(f + (g - f) / 2), 0 > (e = c[a] - b)) f = a + 1; else {
                if (!(0 < e)) {
                    g = a;
                    break;
                }
                g = a - 1;
            }
            return a = g, c[a] === b ? a / (d - 1) : (f = c[a], (a + (b - f) / (c[a + 1] - f)) / (d - 1));
        },
        getTangent: function(a) {
            var b = a - 1e-4;
            return a += 1e-4, 0 > b && (b = 0), 1 < a && (a = 1), b = this.getPoint(b), this.getPoint(a).clone().sub(b).normalize();
        },
        getTangentAt: function(a) {
            return a = this.getUtoTmapping(a), this.getTangent(a);
        },
        computeFrenetFrames: function(a, b) {
            var c, e = new f(), g = [], h = [], i = [], j = new f(), k = new d();
            for (c = 0; c <= a; c++) {
                var l = c / a;
                g[c] = this.getTangentAt(l), g[c].normalize();
            }
            h[0] = new f(), i[0] = new f(), c = Number.MAX_VALUE, l = Math.abs(g[0].x);
            var m = Math.abs(g[0].y), n = Math.abs(g[0].z);
            for (l <= c && (c = l, e.set(1, 0, 0)), m <= c && (c = m, e.set(0, 1, 0)), n <= c && e.set(0, 0, 1), 
            j.crossVectors(g[0], e).normalize(), h[0].crossVectors(g[0], j), i[0].crossVectors(g[0], h[0]), 
            c = 1; c <= a; c++) h[c] = h[c - 1].clone(), i[c] = i[c - 1].clone(), j.crossVectors(g[c - 1], g[c]), 
            j.length() > Number.EPSILON && (j.normalize(), e = Math.acos(_e.clamp(g[c - 1].dot(g[c]), -1, 1)), 
            h[c].applyMatrix4(k.makeRotationAxis(j, e))), i[c].crossVectors(g[c], h[c]);
            if (!0 === b) for (e = Math.acos(_e.clamp(h[0].dot(h[a]), -1, 1)), e /= a, 0 < g[0].dot(j.crossVectors(h[0], h[a])) && (e = -e), 
            c = 1; c <= a; c++) h[c].applyMatrix4(k.makeRotationAxis(g[c], e * c)), i[c].crossVectors(g[c], h[c]);
            return {
                tangents: g,
                normals: h,
                binormals: i
            };
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.arcLengthDivisions = a.arcLengthDivisions, this;
        },
        toJSON: function() {
            var a = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return a.arcLengthDivisions = this.arcLengthDivisions, a.type = this.type, a;
        },
        fromJSON: function(a) {
            return this.arcLengthDivisions = a.arcLengthDivisions, this;
        }
    }), kd.prototype = Object.create(jd.prototype), kd.prototype.constructor = kd, kd.prototype.isEllipseCurve = !0, 
    kd.prototype.getPoint = function(a, b) {
        b = b || new c();
        for (var d = 2 * Math.PI, e = this.aEndAngle - this.aStartAngle, f = Math.abs(e) < Number.EPSILON; 0 > e; ) e += d;
        for (;e > d; ) e -= d;
        e < Number.EPSILON && (e = f ? 0 : d), !0 !== this.aClockwise || f || (e = e === d ? -d : e - d), 
        d = this.aStartAngle + a * e, a = this.aX + this.xRadius * Math.cos(d);
        var g = this.aY + this.yRadius * Math.sin(d);
        return 0 !== this.aRotation && (d = Math.cos(this.aRotation), e = Math.sin(this.aRotation), 
        f = a - this.aX, g -= this.aY, a = f * d - g * e + this.aX, g = f * e + g * d + this.aY), 
        b.set(a, g);
    }, kd.prototype.copy = function(a) {
        return jd.prototype.copy.call(this, a), this.aX = a.aX, this.aY = a.aY, this.xRadius = a.xRadius, 
        this.yRadius = a.yRadius, this.aStartAngle = a.aStartAngle, this.aEndAngle = a.aEndAngle, 
        this.aClockwise = a.aClockwise, this.aRotation = a.aRotation, this;
    }, kd.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        return a.aX = this.aX, a.aY = this.aY, a.xRadius = this.xRadius, a.yRadius = this.yRadius, 
        a.aStartAngle = this.aStartAngle, a.aEndAngle = this.aEndAngle, a.aClockwise = this.aClockwise, 
        a.aRotation = this.aRotation, a;
    }, kd.prototype.fromJSON = function(a) {
        return jd.prototype.fromJSON.call(this, a), this.aX = a.aX, this.aY = a.aY, this.xRadius = a.xRadius, 
        this.yRadius = a.yRadius, this.aStartAngle = a.aStartAngle, this.aEndAngle = a.aEndAngle, 
        this.aClockwise = a.aClockwise, this.aRotation = a.aRotation, this;
    }, ld.prototype = Object.create(kd.prototype), ld.prototype.constructor = ld, ld.prototype.isArcCurve = !0;
    var Ff = new f(), Gf = new md(), Hf = new md(), If = new md();
    nd.prototype = Object.create(jd.prototype), nd.prototype.constructor = nd, nd.prototype.isCatmullRomCurve3 = !0, 
    nd.prototype.getPoint = function(a, b) {
        b = b || new f();
        var c = this.points, d = c.length;
        a *= d - (this.closed ? 0 : 1);
        var e = Math.floor(a);
        if (a -= e, this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / d) + 1) * d : 0 === a && e === d - 1 && (e = d - 2, 
        a = 1), this.closed || 0 < e) var g = c[(e - 1) % d]; else Ff.subVectors(c[0], c[1]).add(c[0]), 
        g = Ff;
        var h = c[e % d], i = c[(e + 1) % d];
        if (this.closed || e + 2 < d ? c = c[(e + 2) % d] : (Ff.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), 
        c = Ff), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var j = "chordal" === this.curveType ? .5 : .25;
            d = Math.pow(g.distanceToSquared(h), j), e = Math.pow(h.distanceToSquared(i), j), 
            j = Math.pow(i.distanceToSquared(c), j), 1e-4 > e && (e = 1), 1e-4 > d && (d = e), 
            1e-4 > j && (j = e), Gf.initNonuniformCatmullRom(g.x, h.x, i.x, c.x, d, e, j), Hf.initNonuniformCatmullRom(g.y, h.y, i.y, c.y, d, e, j), 
            If.initNonuniformCatmullRom(g.z, h.z, i.z, c.z, d, e, j);
        } else "catmullrom" === this.curveType && (Gf.initCatmullRom(g.x, h.x, i.x, c.x, this.tension), 
        Hf.initCatmullRom(g.y, h.y, i.y, c.y, this.tension), If.initCatmullRom(g.z, h.z, i.z, c.z, this.tension));
        return b.set(Gf.calc(a), Hf.calc(a), If.calc(a)), b;
    }, nd.prototype.copy = function(a) {
        jd.prototype.copy.call(this, a), this.points = [];
        for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
        return this.closed = a.closed, this.curveType = a.curveType, this.tension = a.tension, 
        this;
    }, nd.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        a.points = [];
        for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
        return a.closed = this.closed, a.curveType = this.curveType, a.tension = this.tension, 
        a;
    }, nd.prototype.fromJSON = function(a) {
        jd.prototype.fromJSON.call(this, a), this.points = [];
        for (var b = 0, c = a.points.length; b < c; b++) {
            var d = a.points[b];
            this.points.push(new f().fromArray(d));
        }
        return this.closed = a.closed, this.curveType = a.curveType, this.tension = a.tension, 
        this;
    }, rd.prototype = Object.create(jd.prototype), rd.prototype.constructor = rd, rd.prototype.isCubicBezierCurve = !0, 
    rd.prototype.getPoint = function(a, b) {
        b = b || new c();
        var d = this.v0, e = this.v1, f = this.v2, g = this.v3;
        return b.set(qd(a, d.x, e.x, f.x, g.x), qd(a, d.y, e.y, f.y, g.y)), b;
    }, rd.prototype.copy = function(a) {
        return jd.prototype.copy.call(this, a), this.v0.copy(a.v0), this.v1.copy(a.v1), 
        this.v2.copy(a.v2), this.v3.copy(a.v3), this;
    }, rd.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        return a.v0 = this.v0.toArray(), a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), 
        a.v3 = this.v3.toArray(), a;
    }, rd.prototype.fromJSON = function(a) {
        return jd.prototype.fromJSON.call(this, a), this.v0.fromArray(a.v0), this.v1.fromArray(a.v1), 
        this.v2.fromArray(a.v2), this.v3.fromArray(a.v3), this;
    }, sd.prototype = Object.create(jd.prototype), sd.prototype.constructor = sd, sd.prototype.isCubicBezierCurve3 = !0, 
    sd.prototype.getPoint = function(a, b) {
        b = b || new f();
        var c = this.v0, d = this.v1, e = this.v2, g = this.v3;
        return b.set(qd(a, c.x, d.x, e.x, g.x), qd(a, c.y, d.y, e.y, g.y), qd(a, c.z, d.z, e.z, g.z)), 
        b;
    }, sd.prototype.copy = function(a) {
        return jd.prototype.copy.call(this, a), this.v0.copy(a.v0), this.v1.copy(a.v1), 
        this.v2.copy(a.v2), this.v3.copy(a.v3), this;
    }, sd.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        return a.v0 = this.v0.toArray(), a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), 
        a.v3 = this.v3.toArray(), a;
    }, sd.prototype.fromJSON = function(a) {
        return jd.prototype.fromJSON.call(this, a), this.v0.fromArray(a.v0), this.v1.fromArray(a.v1), 
        this.v2.fromArray(a.v2), this.v3.fromArray(a.v3), this;
    }, td.prototype = Object.create(jd.prototype), td.prototype.constructor = td, td.prototype.isLineCurve = !0, 
    td.prototype.getPoint = function(a, b) {
        return b = b || new c(), 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), 
        b.multiplyScalar(a).add(this.v1)), b;
    }, td.prototype.getPointAt = function(a, b) {
        return this.getPoint(a, b);
    }, td.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize();
    }, td.prototype.copy = function(a) {
        return jd.prototype.copy.call(this, a), this.v1.copy(a.v1), this.v2.copy(a.v2), 
        this;
    }, td.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        return a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), a;
    }, td.prototype.fromJSON = function(a) {
        return jd.prototype.fromJSON.call(this, a), this.v1.fromArray(a.v1), this.v2.fromArray(a.v2), 
        this;
    }, ud.prototype = Object.create(jd.prototype), ud.prototype.constructor = ud, ud.prototype.isLineCurve3 = !0, 
    ud.prototype.getPoint = function(a, b) {
        return b = b || new f(), 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), 
        b.multiplyScalar(a).add(this.v1)), b;
    }, ud.prototype.getPointAt = function(a, b) {
        return this.getPoint(a, b);
    }, ud.prototype.copy = function(a) {
        return jd.prototype.copy.call(this, a), this.v1.copy(a.v1), this.v2.copy(a.v2), 
        this;
    }, ud.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        return a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), a;
    }, ud.prototype.fromJSON = function(a) {
        return jd.prototype.fromJSON.call(this, a), this.v1.fromArray(a.v1), this.v2.fromArray(a.v2), 
        this;
    }, vd.prototype = Object.create(jd.prototype), vd.prototype.constructor = vd, vd.prototype.isQuadraticBezierCurve = !0, 
    vd.prototype.getPoint = function(a, b) {
        b = b || new c();
        var d = this.v0, e = this.v1, f = this.v2;
        return b.set(pd(a, d.x, e.x, f.x), pd(a, d.y, e.y, f.y)), b;
    }, vd.prototype.copy = function(a) {
        return jd.prototype.copy.call(this, a), this.v0.copy(a.v0), this.v1.copy(a.v1), 
        this.v2.copy(a.v2), this;
    }, vd.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        return a.v0 = this.v0.toArray(), a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), 
        a;
    }, vd.prototype.fromJSON = function(a) {
        return jd.prototype.fromJSON.call(this, a), this.v0.fromArray(a.v0), this.v1.fromArray(a.v1), 
        this.v2.fromArray(a.v2), this;
    }, wd.prototype = Object.create(jd.prototype), wd.prototype.constructor = wd, wd.prototype.isQuadraticBezierCurve3 = !0, 
    wd.prototype.getPoint = function(a, b) {
        b = b || new f();
        var c = this.v0, d = this.v1, e = this.v2;
        return b.set(pd(a, c.x, d.x, e.x), pd(a, c.y, d.y, e.y), pd(a, c.z, d.z, e.z)), 
        b;
    }, wd.prototype.copy = function(a) {
        return jd.prototype.copy.call(this, a), this.v0.copy(a.v0), this.v1.copy(a.v1), 
        this.v2.copy(a.v2), this;
    }, wd.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        return a.v0 = this.v0.toArray(), a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), 
        a;
    }, wd.prototype.fromJSON = function(a) {
        return jd.prototype.fromJSON.call(this, a), this.v0.fromArray(a.v0), this.v1.fromArray(a.v1), 
        this.v2.fromArray(a.v2), this;
    }, xd.prototype = Object.create(jd.prototype), xd.prototype.constructor = xd, xd.prototype.isSplineCurve = !0, 
    xd.prototype.getPoint = function(a, b) {
        b = b || new c();
        var d = this.points, e = (d.length - 1) * a;
        a = Math.floor(e), e -= a;
        var f = d[0 === a ? a : a - 1], g = d[a], h = d[a > d.length - 2 ? d.length - 1 : a + 1];
        return d = d[a > d.length - 3 ? d.length - 1 : a + 2], b.set(od(e, f.x, g.x, h.x, d.x), od(e, f.y, g.y, h.y, d.y)), 
        b;
    }, xd.prototype.copy = function(a) {
        jd.prototype.copy.call(this, a), this.points = [];
        for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
        return this;
    }, xd.prototype.toJSON = function() {
        var a = jd.prototype.toJSON.call(this);
        a.points = [];
        for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
        return a;
    }, xd.prototype.fromJSON = function(a) {
        jd.prototype.fromJSON.call(this, a), this.points = [];
        for (var b = 0, d = a.points.length; b < d; b++) {
            var e = a.points[b];
            this.points.push(new c().fromArray(e));
        }
        return this;
    };
    var Jf = Object.freeze({
        ArcCurve: ld,
        CatmullRomCurve3: nd,
        CubicBezierCurve: rd,
        CubicBezierCurve3: sd,
        EllipseCurve: kd,
        LineCurve: td,
        LineCurve3: ud,
        QuadraticBezierCurve: vd,
        QuadraticBezierCurve3: wd,
        SplineCurve: xd
    });
    yd.prototype = Object.assign(Object.create(jd.prototype), {
        constructor: yd,
        add: function(a) {
            this.curves.push(a);
        },
        closePath: function() {
            var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
            a.equals(b) || this.curves.push(new td(b, a));
        },
        getPoint: function(a) {
            var b = a * this.getLength(), c = this.getCurveLengths();
            for (a = 0; a < c.length; ) {
                if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
                a++;
            }
            return null;
        },
        getLength: function() {
            var a = this.getCurveLengths();
            return a[a.length - 1];
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), 
            a.push(b);
            return this.cacheLengths = a;
        },
        getSpacedPoints: function(a) {
            void 0 === a && (a = 40);
            for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
            return this.autoClose && b.push(b[0]), b;
        },
        getPoints: function(a) {
            a = a || 12;
            for (var b, c = [], d = 0, e = this.curves; d < e.length; d++) {
                var f = e[d];
                f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && (f.isLineCurve || f.isLineCurve3) ? 1 : f && f.isSplineCurve ? a * f.points.length : a);
                for (var g = 0; g < f.length; g++) {
                    var h = f[g];
                    b && b.equals(h) || (c.push(h), b = h);
                }
            }
            return this.autoClose && 1 < c.length && !c[c.length - 1].equals(c[0]) && c.push(c[0]), 
            c;
        },
        copy: function(a) {
            jd.prototype.copy.call(this, a), this.curves = [];
            for (var b = 0, c = a.curves.length; b < c; b++) this.curves.push(a.curves[b].clone());
            return this.autoClose = a.autoClose, this;
        },
        toJSON: function() {
            var a = jd.prototype.toJSON.call(this);
            a.autoClose = this.autoClose, a.curves = [];
            for (var b = 0, c = this.curves.length; b < c; b++) a.curves.push(this.curves[b].toJSON());
            return a;
        },
        fromJSON: function(a) {
            jd.prototype.fromJSON.call(this, a), this.autoClose = a.autoClose, this.curves = [];
            for (var b = 0, c = a.curves.length; b < c; b++) {
                var d = a.curves[b];
                this.curves.push(new Jf[d.type]().fromJSON(d));
            }
            return this;
        }
    }), zd.prototype = Object.assign(Object.create(yd.prototype), {
        constructor: zd,
        setFromPoints: function(a) {
            this.moveTo(a[0].x, a[0].y);
            for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y);
        },
        moveTo: function(a, b) {
            this.currentPoint.set(a, b);
        },
        lineTo: function(a, b) {
            var d = new td(this.currentPoint.clone(), new c(a, b));
            this.curves.push(d), this.currentPoint.set(a, b);
        },
        quadraticCurveTo: function(a, b, d, e) {
            a = new vd(this.currentPoint.clone(), new c(a, b), new c(d, e)), this.curves.push(a), 
            this.currentPoint.set(d, e);
        },
        bezierCurveTo: function(a, b, d, e, f, g) {
            a = new rd(this.currentPoint.clone(), new c(a, b), new c(d, e), new c(f, g)), this.curves.push(a), 
            this.currentPoint.set(f, g);
        },
        splineThru: function(a) {
            var b = [ this.currentPoint.clone() ].concat(a);
            b = new xd(b), this.curves.push(b), this.currentPoint.copy(a[a.length - 1]);
        },
        arc: function(a, b, c, d, e, f) {
            this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f);
        },
        absarc: function(a, b, c, d, e, f) {
            this.absellipse(a, b, c, c, d, e, f);
        },
        ellipse: function(a, b, c, d, e, f, g, h) {
            this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h);
        },
        absellipse: function(a, b, c, d, e, f, g, h) {
            a = new kd(a, b, c, d, e, f, g, h), 0 < this.curves.length && (b = a.getPoint(0), 
            b.equals(this.currentPoint) || this.lineTo(b.x, b.y)), this.curves.push(a), a = a.getPoint(1), 
            this.currentPoint.copy(a);
        },
        copy: function(a) {
            return yd.prototype.copy.call(this, a), this.currentPoint.copy(a.currentPoint), 
            this;
        },
        toJSON: function() {
            var a = yd.prototype.toJSON.call(this);
            return a.currentPoint = this.currentPoint.toArray(), a;
        },
        fromJSON: function(a) {
            return yd.prototype.fromJSON.call(this, a), this.currentPoint.fromArray(a.currentPoint), 
            this;
        }
    }), Ad.prototype = Object.assign(Object.create(zd.prototype), {
        constructor: Ad,
        getPointsHoles: function(a) {
            for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
            return b;
        },
        extractPoints: function(a) {
            return {
                shape: this.getPoints(a),
                holes: this.getPointsHoles(a)
            };
        },
        copy: function(a) {
            zd.prototype.copy.call(this, a), this.holes = [];
            for (var b = 0, c = a.holes.length; b < c; b++) this.holes.push(a.holes[b].clone());
            return this;
        },
        toJSON: function() {
            var a = zd.prototype.toJSON.call(this);
            a.uuid = this.uuid, a.holes = [];
            for (var b = 0, c = this.holes.length; b < c; b++) a.holes.push(this.holes[b].toJSON());
            return a;
        },
        fromJSON: function(a) {
            zd.prototype.fromJSON.call(this, a), this.uuid = a.uuid, this.holes = [];
            for (var b = 0, c = a.holes.length; b < c; b++) {
                var d = a.holes[b];
                this.holes.push(new zd().fromJSON(d));
            }
            return this;
        }
    }), Bd.prototype = Object.assign(Object.create(v.prototype), {
        constructor: Bd,
        isLight: !0,
        copy: function(a) {
            return v.prototype.copy.call(this, a), this.color.copy(a.color), this.intensity = a.intensity, 
            this;
        },
        toJSON: function(a) {
            return a = v.prototype.toJSON.call(this, a), a.object.color = this.color.getHex(), 
            a.object.intensity = this.intensity, void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()), 
            void 0 !== this.distance && (a.object.distance = this.distance), void 0 !== this.angle && (a.object.angle = this.angle), 
            void 0 !== this.decay && (a.object.decay = this.decay), void 0 !== this.penumbra && (a.object.penumbra = this.penumbra), 
            void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON()), a;
        }
    }), Cd.prototype = Object.assign(Object.create(Bd.prototype), {
        constructor: Cd,
        isHemisphereLight: !0,
        copy: function(a) {
            return Bd.prototype.copy.call(this, a), this.groundColor.copy(a.groundColor), this;
        }
    }), Object.assign(Dd.prototype, {
        copy: function(a) {
            return this.camera = a.camera.clone(), this.bias = a.bias, this.radius = a.radius, 
            this.mapSize.copy(a.mapSize), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        toJSON: function() {
            var a = {};
            return 0 !== this.bias && (a.bias = this.bias), 1 !== this.radius && (a.radius = this.radius), 
            512 === this.mapSize.x && 512 === this.mapSize.y || (a.mapSize = this.mapSize.toArray()), 
            a.camera = this.camera.toJSON(!1).object, delete a.camera.matrix, a;
        }
    }), Ed.prototype = Object.assign(Object.create(Dd.prototype), {
        constructor: Ed,
        isSpotLightShadow: !0,
        update: function(a) {
            var b = this.camera, c = 2 * _e.RAD2DEG * a.angle, d = this.mapSize.width / this.mapSize.height;
            a = a.distance || b.far, c === b.fov && d === b.aspect && a === b.far || (b.fov = c, 
            b.aspect = d, b.far = a, b.updateProjectionMatrix());
        }
    }), Fd.prototype = Object.assign(Object.create(Bd.prototype), {
        constructor: Fd,
        isSpotLight: !0,
        copy: function(a) {
            return Bd.prototype.copy.call(this, a), this.distance = a.distance, this.angle = a.angle, 
            this.penumbra = a.penumbra, this.decay = a.decay, this.target = a.target.clone(), 
            this.shadow = a.shadow.clone(), this;
        }
    }), Gd.prototype = Object.assign(Object.create(Bd.prototype), {
        constructor: Gd,
        isPointLight: !0,
        copy: function(a) {
            return Bd.prototype.copy.call(this, a), this.distance = a.distance, this.decay = a.decay, 
            this.shadow = a.shadow.clone(), this;
        }
    }), Hd.prototype = Object.assign(Object.create(Dd.prototype), {
        constructor: Hd
    }), Id.prototype = Object.assign(Object.create(Bd.prototype), {
        constructor: Id,
        isDirectionalLight: !0,
        copy: function(a) {
            return Bd.prototype.copy.call(this, a), this.target = a.target.clone(), this.shadow = a.shadow.clone(), 
            this;
        }
    }), Jd.prototype = Object.assign(Object.create(Bd.prototype), {
        constructor: Jd,
        isAmbientLight: !0
    }), Kd.prototype = Object.assign(Object.create(Bd.prototype), {
        constructor: Kd,
        isRectAreaLight: !0,
        copy: function(a) {
            return Bd.prototype.copy.call(this, a), this.width = a.width, this.height = a.height, 
            this;
        },
        toJSON: function(a) {
            return a = Bd.prototype.toJSON.call(this, a), a.object.width = this.width, a.object.height = this.height, 
            a;
        }
    });
    var Kf = {
        arraySlice: function(a, b, c) {
            return Kf.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c);
        },
        convertArray: function(a, b, c) {
            return !a || !c && a.constructor === b ? a : "number" == typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a);
        },
        isTypedArray: function(a) {
            return ArrayBuffer.isView(a) && !(a instanceof DataView);
        },
        getKeyframeOrder: function(a) {
            for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
            return c.sort(function(b, c) {
                return a[b] - a[c];
            }), c;
        },
        sortedArray: function(a, b, c) {
            for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f) for (var h = c[f] * b, i = 0; i !== b; ++i) e[g++] = a[h + i];
            return e;
        },
        flattenJSON: function(a, b, c, d) {
            for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d]; ) f = a[e++];
            if (void 0 !== f) {
                var g = f[d];
                if (void 0 !== g) if (Array.isArray(g)) do {
                    g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++];
                } while (void 0 !== f); else if (void 0 !== g.toArray) do {
                    g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++];
                } while (void 0 !== f); else do {
                    g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++];
                } while (void 0 !== f);
            }
        }
    };
    Object.assign(Ld.prototype, {
        evaluate: function(a) {
            var b = this.parameterPositions, c = this._cachedIndex, d = b[c], e = b[c - 1];
            a: {
                b: {
                    c: {
                        d: if (!(a < d)) {
                            for (var f = c + 2; ;) {
                                if (void 0 === d) {
                                    if (a < e) break d;
                                    return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, a, e);
                                }
                                if (c === f) break;
                                if (e = d, d = b[++c], a < d) break b;
                            }
                            d = b.length;
                            break c;
                        }
                        if (a >= e) break a;
                        for (f = b[1], a < f && (c = 2, e = f), f = c - 2; ;) {
                            if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                            if (c === f) break;
                            if (d = e, e = b[--c - 1], a >= e) break b;
                        }
                        d = c, c = 0;
                    }
                    for (;c < d; ) e = c + d >>> 1, a < b[e] ? d = e : c = e + 1;
                    if (d = b[c], void 0 === (e = b[c - 1])) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                    if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a);
                }
                this._cachedIndex = c, this.intervalChanged_(c, e, d);
            }
            return this.interpolate_(c, e, a, d);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function(a) {
            var b = this.resultBuffer, c = this.sampleValues, d = this.valueSize;
            a *= d;
            for (var e = 0; e !== d; ++e) b[e] = c[a + e];
            return b;
        },
        interpolate_: function() {
            throw Error("call to abstract method");
        },
        intervalChanged_: function() {}
    }), Object.assign(Ld.prototype, {
        beforeStart_: Ld.prototype.copySampleValue_,
        afterEnd_: Ld.prototype.copySampleValue_
    }), Md.prototype = Object.assign(Object.create(Ld.prototype), {
        constructor: Md,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(a, b, c) {
            var d = this.parameterPositions, e = a - 2, f = a + 1, g = d[e], h = d[f];
            if (void 0 === g) switch (this.getSettings_().endingStart) {
              case 2401:
                e = a, g = 2 * b - c;
                break;

              case 2402:
                e = d.length - 2, g = b + d[e] - d[e + 1];
                break;

              default:
                e = a, g = c;
            }
            if (void 0 === h) switch (this.getSettings_().endingEnd) {
              case 2401:
                f = a, h = 2 * c - b;
                break;

              case 2402:
                f = 1, h = c + d[1] - d[0];
                break;

              default:
                f = a - 1, h = b;
            }
            a = .5 * (c - b), d = this.valueSize, this._weightPrev = a / (b - g), this._weightNext = a / (h - c), 
            this._offsetPrev = e * d, this._offsetNext = f * d;
        },
        interpolate_: function(a, b, c, d) {
            var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
            a *= g;
            var h = a - g, i = this._offsetPrev, j = this._offsetNext, k = this._weightPrev, l = this._weightNext, m = (c - b) / (d - b);
            for (c = m * m, d = c * m, b = -k * d + 2 * k * c - k * m, k = (1 + k) * d + (-1.5 - 2 * k) * c + (-.5 + k) * m + 1, 
            m = (-1 - l) * d + (1.5 + l) * c + .5 * m, l = l * d - l * c, c = 0; c !== g; ++c) e[c] = b * f[i + c] + k * f[h + c] + m * f[a + c] + l * f[j + c];
            return e;
        }
    }), Nd.prototype = Object.assign(Object.create(Ld.prototype), {
        constructor: Nd,
        interpolate_: function(a, b, c, d) {
            var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
            a *= g;
            var h = a - g;
            for (b = (c - b) / (d - b), c = 1 - b, d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
            return e;
        }
    }), Od.prototype = Object.assign(Object.create(Ld.prototype), {
        constructor: Od,
        interpolate_: function(a) {
            return this.copySampleValue_(a - 1);
        }
    }), Object.assign(Pd, {
        toJSON: function(a) {
            var b = a.constructor;
            if (void 0 !== b.toJSON) b = b.toJSON(a); else {
                b = {
                    name: a.name,
                    times: Kf.convertArray(a.times, Array),
                    values: Kf.convertArray(a.values, Array)
                };
                var c = a.getInterpolation();
                c !== a.DefaultInterpolation && (b.interpolation = c);
            }
            return b.type = a.ValueTypeName, b;
        }
    }), Object.assign(Pd.prototype, {
        constructor: Pd,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(a) {
            return new Od(this.times, this.values, this.getValueSize(), a);
        },
        InterpolantFactoryMethodLinear: function(a) {
            return new Nd(this.times, this.values, this.getValueSize(), a);
        },
        InterpolantFactoryMethodSmooth: function(a) {
            return new Md(this.times, this.values, this.getValueSize(), a);
        },
        setInterpolation: function(a) {
            switch (a) {
              case 2300:
                var b = this.InterpolantFactoryMethodDiscrete;
                break;

              case 2301:
                b = this.InterpolantFactoryMethodLinear;
                break;

              case 2302:
                b = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === b) {
                if (b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, 
                void 0 === this.createInterpolant) {
                    if (a === this.DefaultInterpolation) throw Error(b);
                    this.setInterpolation(this.DefaultInterpolation);
                }
                return console.warn("THREE.KeyframeTrack:", b), this;
            }
            return this.createInterpolant = b, this;
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return 2300;

              case this.InterpolantFactoryMethodLinear:
                return 2301;

              case this.InterpolantFactoryMethodSmooth:
                return 2302;
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length;
        },
        shift: function(a) {
            if (0 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
            return this;
        },
        scale: function(a) {
            if (1 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
            return this;
        },
        trim: function(a, b) {
            for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a; ) ++e;
            for (;-1 !== f && c[f] > b; ) --f;
            return ++f, 0 === e && f === d || (e >= f && (f = Math.max(f, 1), e = f - 1), a = this.getValueSize(), 
            this.times = Kf.arraySlice(c, e, f), this.values = Kf.arraySlice(this.values, e * a, f * a)), 
            this;
        },
        validate: function() {
            var a = !0, b = this.getValueSize();
            0 != b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), 
            a = !1);
            var c = this.times;
            b = this.values;
            var d = c.length;
            0 === d && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = !1);
            for (var e = null, f = 0; f !== d; f++) {
                var g = c[f];
                if ("number" == typeof g && isNaN(g)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, g), a = !1;
                    break;
                }
                if (null !== e && e > g) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, f, g, e), a = !1;
                    break;
                }
                e = g;
            }
            if (void 0 !== b && Kf.isTypedArray(b)) for (f = 0, c = b.length; f !== c; ++f) if (d = b[f], 
            isNaN(d)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, d), 
                a = !1;
                break;
            }
            return a;
        },
        optimize: function() {
            for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; g < f; ++g) {
                var h = !1, i = a[g];
                if (i !== a[g + 1] && (1 !== g || i !== i[0])) if (d) h = !0; else {
                    var j = g * c, k = j - c, l = j + c;
                    for (i = 0; i !== c; ++i) {
                        var m = b[j + i];
                        if (m !== b[k + i] || m !== b[l + i]) {
                            h = !0;
                            break;
                        }
                    }
                }
                if (h) {
                    if (g !== e) for (a[e] = a[g], h = g * c, j = e * c, i = 0; i !== c; ++i) b[j + i] = b[h + i];
                    ++e;
                }
            }
            if (0 < f) {
                for (a[e] = a[f], h = f * c, j = e * c, i = 0; i !== c; ++i) b[j + i] = b[h + i];
                ++e;
            }
            return e !== a.length && (this.times = Kf.arraySlice(a, 0, e), this.values = Kf.arraySlice(b, 0, e * c)), 
            this;
        }
    }), Qd.prototype = Object.assign(Object.create(Pd.prototype), {
        constructor: Qd,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Rd.prototype = Object.assign(Object.create(Pd.prototype), {
        constructor: Rd,
        ValueTypeName: "color"
    }), Sd.prototype = Object.assign(Object.create(Pd.prototype), {
        constructor: Sd,
        ValueTypeName: "number"
    }), Td.prototype = Object.assign(Object.create(Ld.prototype), {
        constructor: Td,
        interpolate_: function(a, b, c, d) {
            var f = this.resultBuffer, g = this.sampleValues, h = this.valueSize;
            for (a *= h, b = (c - b) / (d - b), c = a + h; a !== c; a += 4) e.slerpFlat(f, 0, g, a - h, g, a, b);
            return f;
        }
    }), Ud.prototype = Object.assign(Object.create(Pd.prototype), {
        constructor: Ud,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(a) {
            return new Td(this.times, this.values, this.getValueSize(), a);
        },
        InterpolantFactoryMethodSmooth: void 0
    }), Vd.prototype = Object.assign(Object.create(Pd.prototype), {
        constructor: Vd,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Wd.prototype = Object.assign(Object.create(Pd.prototype), {
        constructor: Wd,
        ValueTypeName: "vector"
    }), Object.assign(Xd, {
        parse: function(a) {
            for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(Zd(c[e]).scale(d));
            return new Xd(a.name, a.duration, b);
        },
        toJSON: function(a) {
            var b = [], c = a.tracks;
            a = {
                name: a.name,
                duration: a.duration,
                tracks: b,
                uuid: a.uuid
            };
            for (var d = 0, e = c.length; d !== e; ++d) b.push(Pd.toJSON(c[d]));
            return a;
        },
        CreateFromMorphTargetSequence: function(a, b, c, d) {
            for (var e = b.length, f = [], g = 0; g < e; g++) {
                var h = [], i = [];
                h.push((g + e - 1) % e, g, (g + 1) % e), i.push(0, 1, 0);
                var j = Kf.getKeyframeOrder(h);
                h = Kf.sortedArray(h, 1, j), i = Kf.sortedArray(i, 1, j), d || 0 !== h[0] || (h.push(e), 
                i.push(i[0])), f.push(new Sd(".morphTargetInfluences[" + b[g].name + "]", h, i).scale(1 / c));
            }
            return new Xd(a, -1, f);
        },
        findByName: function(a, b) {
            var c = a;
            for (Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations), 
            a = 0; a < c.length; a++) if (c[a].name === b) return c[a];
            return null;
        },
        CreateClipsFromMorphTargetSequences: function(a, b, c) {
            for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
                var h = a[f], i = h.name.match(e);
                if (i && 1 < i.length) {
                    var j = i[1];
                    (i = d[j]) || (d[j] = i = []), i.push(h);
                }
            }
            a = [];
            for (j in d) a.push(Xd.CreateFromMorphTargetSequence(j, d[j], b, c));
            return a;
        },
        parseAnimation: function(a, b) {
            if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), 
            null;
            var c = function(a, b, c, d, e) {
                if (0 !== c.length) {
                    var f = [], g = [];
                    Kf.flattenJSON(c, f, g, d), 0 !== f.length && e.push(new a(b, f, g));
                }
            }, d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30;
            a = a.hierarchy || [];
            for (var h = 0; h < a.length; h++) {
                var i = a[h].keys;
                if (i && 0 !== i.length) if (i[0].morphTargets) {
                    f = {};
                    for (var j = 0; j < i.length; j++) if (i[j].morphTargets) for (var k = 0; k < i[j].morphTargets.length; k++) f[i[j].morphTargets[k]] = -1;
                    for (var l in f) {
                        var m = [], n = [];
                        for (k = 0; k !== i[j].morphTargets.length; ++k) {
                            var o = i[j];
                            m.push(o.time), n.push(o.morphTarget === l ? 1 : 0);
                        }
                        d.push(new Sd(".morphTargetInfluence[" + l + "]", m, n));
                    }
                    f = f.length * (g || 1);
                } else j = ".bones[" + b[h].name + "]", c(Wd, j + ".position", i, "pos", d), c(Ud, j + ".quaternion", i, "rot", d), 
                c(Wd, j + ".scale", i, "scl", d);
            }
            return 0 === d.length ? null : new Xd(e, f, d);
        }
    }), Object.assign(Xd.prototype, {
        resetDuration: function() {
            for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
                var d = this.tracks[b];
                a = Math.max(a, d.times[d.times.length - 1]);
            }
            return this.duration = a, this;
        },
        trim: function() {
            for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
            return this;
        },
        validate: function() {
            for (var a = !0, b = 0; b < this.tracks.length; b++) a = a && this.tracks[b].validate();
            return a;
        },
        optimize: function() {
            for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
            return this;
        }
    }), Object.assign($d.prototype, {
        load: function(a, b, c, d) {
            var e = this;
            new dd(e.manager).load(a, function(a) {
                b(e.parse(JSON.parse(a)));
            }, c, d);
        },
        setTextures: function(a) {
            this.textures = a;
        },
        parse: function(a) {
            function b(a) {
                return void 0 === e[a] && console.warn("THREE.MaterialLoader: Undefined texture", a), 
                e[a];
            }
            var e = this.textures, g = new Bf[a.type]();
            if (void 0 !== a.uuid && (g.uuid = a.uuid), void 0 !== a.name && (g.name = a.name), 
            void 0 !== a.color && g.color.setHex(a.color), void 0 !== a.roughness && (g.roughness = a.roughness), 
            void 0 !== a.metalness && (g.metalness = a.metalness), void 0 !== a.emissive && g.emissive.setHex(a.emissive), 
            void 0 !== a.specular && g.specular.setHex(a.specular), void 0 !== a.shininess && (g.shininess = a.shininess), 
            void 0 !== a.clearCoat && (g.clearCoat = a.clearCoat), void 0 !== a.clearCoatRoughness && (g.clearCoatRoughness = a.clearCoatRoughness), 
            void 0 !== a.vertexColors && (g.vertexColors = a.vertexColors), void 0 !== a.fog && (g.fog = a.fog), 
            void 0 !== a.flatShading && (g.flatShading = a.flatShading), void 0 !== a.blending && (g.blending = a.blending), 
            void 0 !== a.side && (g.side = a.side), void 0 !== a.opacity && (g.opacity = a.opacity), 
            void 0 !== a.transparent && (g.transparent = a.transparent), void 0 !== a.alphaTest && (g.alphaTest = a.alphaTest), 
            void 0 !== a.depthTest && (g.depthTest = a.depthTest), void 0 !== a.depthWrite && (g.depthWrite = a.depthWrite), 
            void 0 !== a.colorWrite && (g.colorWrite = a.colorWrite), void 0 !== a.wireframe && (g.wireframe = a.wireframe), 
            void 0 !== a.wireframeLinewidth && (g.wireframeLinewidth = a.wireframeLinewidth), 
            void 0 !== a.wireframeLinecap && (g.wireframeLinecap = a.wireframeLinecap), void 0 !== a.wireframeLinejoin && (g.wireframeLinejoin = a.wireframeLinejoin), 
            void 0 !== a.rotation && (g.rotation = a.rotation), 1 !== a.linewidth && (g.linewidth = a.linewidth), 
            void 0 !== a.dashSize && (g.dashSize = a.dashSize), void 0 !== a.gapSize && (g.gapSize = a.gapSize), 
            void 0 !== a.scale && (g.scale = a.scale), void 0 !== a.polygonOffset && (g.polygonOffset = a.polygonOffset), 
            void 0 !== a.polygonOffsetFactor && (g.polygonOffsetFactor = a.polygonOffsetFactor), 
            void 0 !== a.polygonOffsetUnits && (g.polygonOffsetUnits = a.polygonOffsetUnits), 
            void 0 !== a.skinning && (g.skinning = a.skinning), void 0 !== a.morphTargets && (g.morphTargets = a.morphTargets), 
            void 0 !== a.dithering && (g.dithering = a.dithering), void 0 !== a.visible && (g.visible = a.visible), 
            void 0 !== a.userData && (g.userData = a.userData), void 0 !== a.uniforms) for (var h in a.uniforms) {
                var j = a.uniforms[h];
                switch (g.uniforms[h] = {}, j.type) {
                  case "t":
                    g.uniforms[h].value = b(j.value);
                    break;

                  case "c":
                    g.uniforms[h].value = new q().setHex(j.value);
                    break;

                  case "v2":
                    g.uniforms[h].value = new c().fromArray(j.value);
                    break;

                  case "v3":
                    g.uniforms[h].value = new f().fromArray(j.value);
                    break;

                  case "v4":
                    g.uniforms[h].value = new i().fromArray(j.value);
                    break;

                  case "m4":
                    g.uniforms[h].value = new d().fromArray(j.value);
                    break;

                  default:
                    g.uniforms[h].value = j.value;
                }
            }
            return void 0 !== a.defines && (g.defines = a.defines), void 0 !== a.vertexShader && (g.vertexShader = a.vertexShader), 
            void 0 !== a.fragmentShader && (g.fragmentShader = a.fragmentShader), void 0 !== a.shading && (g.flatShading = 1 === a.shading), 
            void 0 !== a.size && (g.size = a.size), void 0 !== a.sizeAttenuation && (g.sizeAttenuation = a.sizeAttenuation), 
            void 0 !== a.map && (g.map = b(a.map)), void 0 !== a.alphaMap && (g.alphaMap = b(a.alphaMap), 
            g.transparent = !0), void 0 !== a.bumpMap && (g.bumpMap = b(a.bumpMap)), void 0 !== a.bumpScale && (g.bumpScale = a.bumpScale), 
            void 0 !== a.normalMap && (g.normalMap = b(a.normalMap)), void 0 !== a.normalMapType && (g.normalMapType = a.normalMapType), 
            void 0 !== a.normalScale && (h = a.normalScale, !1 === Array.isArray(h) && (h = [ h, h ]), 
            g.normalScale = new c().fromArray(h)), void 0 !== a.displacementMap && (g.displacementMap = b(a.displacementMap)), 
            void 0 !== a.displacementScale && (g.displacementScale = a.displacementScale), void 0 !== a.displacementBias && (g.displacementBias = a.displacementBias), 
            void 0 !== a.roughnessMap && (g.roughnessMap = b(a.roughnessMap)), void 0 !== a.metalnessMap && (g.metalnessMap = b(a.metalnessMap)), 
            void 0 !== a.emissiveMap && (g.emissiveMap = b(a.emissiveMap)), void 0 !== a.emissiveIntensity && (g.emissiveIntensity = a.emissiveIntensity), 
            void 0 !== a.specularMap && (g.specularMap = b(a.specularMap)), void 0 !== a.envMap && (g.envMap = b(a.envMap)), 
            void 0 !== a.reflectivity && (g.reflectivity = a.reflectivity), void 0 !== a.lightMap && (g.lightMap = b(a.lightMap)), 
            void 0 !== a.lightMapIntensity && (g.lightMapIntensity = a.lightMapIntensity), void 0 !== a.aoMap && (g.aoMap = b(a.aoMap)), 
            void 0 !== a.aoMapIntensity && (g.aoMapIntensity = a.aoMapIntensity), void 0 !== a.gradientMap && (g.gradientMap = b(a.gradientMap)), 
            g;
        }
    }), Object.assign(_d.prototype, {
        load: function(a, b, c, d) {
            var e = this;
            new dd(e.manager).load(a, function(a) {
                b(e.parse(JSON.parse(a)));
            }, c, d);
        },
        parse: function(a) {
            var b = new M(), c = a.data.index;
            void 0 !== c && (c = new Lf[c.type](c.array), b.setIndex(new A(c, 1)));
            var d = a.data.attributes;
            for (g in d) {
                var e = d[g];
                c = new Lf[e.type](e.array), b.addAttribute(g, new A(c, e.itemSize, e.normalized));
            }
            var g = a.data.groups || a.data.drawcalls || a.data.offsets;
            if (void 0 !== g) for (c = 0, d = g.length; c !== d; ++c) e = g[c], b.addGroup(e.start, e.count, e.materialIndex);
            return a = a.data.boundingSphere, void 0 !== a && (g = new f(), void 0 !== a.center && g.fromArray(a.center), 
            b.boundingSphere = new n(g, a.radius)), b;
        }
    });
    var Lf = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    ae.Handlers = {
        handlers: [],
        add: function(a, b) {
            this.handlers.push(a, b);
        },
        get: function(a) {
            for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
                var e = b[c + 1];
                if (b[c].test(a)) return e;
            }
            return null;
        }
    }, Object.assign(ae.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(a, b, c) {
            for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
            return d;
        },
        createMaterial: function() {
            var a = {
                NoBlending: 0,
                NormalBlending: 1,
                AdditiveBlending: 2,
                SubtractiveBlending: 3,
                MultiplyBlending: 4,
                CustomBlending: 5
            }, b = new q(), c = new id(), d = new $d();
            return function(e, f, g) {
                function h(a, b, d, e, h) {
                    a = f + a;
                    var i = ae.Handlers.get(a);
                    return null !== i ? a = i.load(a) : (c.setCrossOrigin(g), a = c.load(a)), void 0 !== b && (a.repeat.fromArray(b), 
                    1 !== b[0] && (a.wrapS = 1e3), 1 !== b[1] && (a.wrapT = 1e3)), void 0 !== d && a.offset.fromArray(d), 
                    void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1e3), "mirror" === e[0] && (a.wrapS = 1002), 
                    "repeat" === e[1] && (a.wrapT = 1e3), "mirror" === e[1] && (a.wrapT = 1002)), void 0 !== h && (a.anisotropy = h), 
                    b = _e.generateUUID(), j[b] = a, b;
                }
                var i, j = {}, k = {
                    uuid: _e.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (i in e) {
                    var l = e[i];
                    switch (i) {
                      case "DbgColor":
                      case "DbgIndex":
                      case "opticalDensity":
                      case "illumination":
                        break;

                      case "DbgName":
                        k.name = l;
                        break;

                      case "blending":
                        k.blending = a[l];
                        break;

                      case "colorAmbient":
                      case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", i, "is no longer supported.");
                        break;

                      case "colorDiffuse":
                        k.color = b.fromArray(l).getHex();
                        break;

                      case "colorSpecular":
                        k.specular = b.fromArray(l).getHex();
                        break;

                      case "colorEmissive":
                        k.emissive = b.fromArray(l).getHex();
                        break;

                      case "specularCoef":
                        k.shininess = l;
                        break;

                      case "shading":
                        "basic" === l.toLowerCase() && (k.type = "MeshBasicMaterial"), "phong" === l.toLowerCase() && (k.type = "MeshPhongMaterial"), 
                        "standard" === l.toLowerCase() && (k.type = "MeshStandardMaterial");
                        break;

                      case "mapDiffuse":
                        k.map = h(l, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                        break;

                      case "mapDiffuseRepeat":
                      case "mapDiffuseOffset":
                      case "mapDiffuseWrap":
                      case "mapDiffuseAnisotropy":
                        break;

                      case "mapEmissive":
                        k.emissiveMap = h(l, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                        break;

                      case "mapEmissiveRepeat":
                      case "mapEmissiveOffset":
                      case "mapEmissiveWrap":
                      case "mapEmissiveAnisotropy":
                        break;

                      case "mapLight":
                        k.lightMap = h(l, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                        break;

                      case "mapLightRepeat":
                      case "mapLightOffset":
                      case "mapLightWrap":
                      case "mapLightAnisotropy":
                        break;

                      case "mapAO":
                        k.aoMap = h(l, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                        break;

                      case "mapAORepeat":
                      case "mapAOOffset":
                      case "mapAOWrap":
                      case "mapAOAnisotropy":
                        break;

                      case "mapBump":
                        k.bumpMap = h(l, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                        break;

                      case "mapBumpScale":
                        k.bumpScale = l;
                        break;

                      case "mapBumpRepeat":
                      case "mapBumpOffset":
                      case "mapBumpWrap":
                      case "mapBumpAnisotropy":
                        break;

                      case "mapNormal":
                        k.normalMap = h(l, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                        break;

                      case "mapNormalFactor":
                        k.normalScale = l;
                        break;

                      case "mapNormalRepeat":
                      case "mapNormalOffset":
                      case "mapNormalWrap":
                      case "mapNormalAnisotropy":
                        break;

                      case "mapSpecular":
                        k.specularMap = h(l, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                        break;

                      case "mapSpecularRepeat":
                      case "mapSpecularOffset":
                      case "mapSpecularWrap":
                      case "mapSpecularAnisotropy":
                        break;

                      case "mapMetalness":
                        k.metalnessMap = h(l, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                        break;

                      case "mapMetalnessRepeat":
                      case "mapMetalnessOffset":
                      case "mapMetalnessWrap":
                      case "mapMetalnessAnisotropy":
                        break;

                      case "mapRoughness":
                        k.roughnessMap = h(l, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                        break;

                      case "mapRoughnessRepeat":
                      case "mapRoughnessOffset":
                      case "mapRoughnessWrap":
                      case "mapRoughnessAnisotropy":
                        break;

                      case "mapAlpha":
                        k.alphaMap = h(l, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                        break;

                      case "mapAlphaRepeat":
                      case "mapAlphaOffset":
                      case "mapAlphaWrap":
                      case "mapAlphaAnisotropy":
                        break;

                      case "flipSided":
                        k.side = 1;
                        break;

                      case "doubleSided":
                        k.side = 2;
                        break;

                      case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), 
                        k.opacity = l;
                        break;

                      case "depthTest":
                      case "depthWrite":
                      case "colorWrite":
                      case "opacity":
                      case "reflectivity":
                      case "transparent":
                      case "visible":
                      case "wireframe":
                        k[i] = l;
                        break;

                      case "vertexColors":
                        !0 === l && (k.vertexColors = 2), "face" === l && (k.vertexColors = 1);
                        break;

                      default:
                        console.error("THREE.Loader.createMaterial: Unsupported", i, l);
                    }
                }
                return "MeshBasicMaterial" === k.type && delete k.emissive, "MeshPhongMaterial" !== k.type && delete k.specular, 
                1 > k.opacity && (k.transparent = !0), d.setTextures(j), d.parse(k);
            };
        }()
    });
    var Mf = {
        decodeText: function(a) {
            if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(a);
            for (var b = "", c = 0, d = a.length; c < d; c++) b += String.fromCharCode(a[c]);
            return decodeURIComponent(escape(b));
        },
        extractUrlBase: function(a) {
            var b = a.lastIndexOf("/");
            return -1 === b ? "./" : a.substr(0, b + 1);
        }
    };
    Object.assign(be.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            var e = this, f = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Mf.extractUrlBase(a), g = new dd(this.manager);
            g.setWithCredentials(this.withCredentials), g.load(a, function(c) {
                c = JSON.parse(c);
                var d = c.metadata;
                if (void 0 !== d && void 0 !== (d = d.type) && "object" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
                c = e.parse(c, f), b(c.geometry, c.materials);
            }, c, d);
        },
        setCrossOrigin: function(a) {
            return this.crossOrigin = a, this;
        },
        setTexturePath: function(a) {
            return this.texturePath = a, this;
        },
        parse: function() {
            return function(a, b) {
                void 0 !== a.data && (a = a.data), a.scale = void 0 !== a.scale ? 1 / a.scale : 1;
                var d, e, g, h = new z(), j = a, k = j.faces, l = j.vertices, m = j.normals, n = j.colors, o = j.scale, p = 0;
                if (void 0 !== j.uvs) {
                    for (d = 0; d < j.uvs.length; d++) j.uvs[d].length && p++;
                    for (d = 0; d < p; d++) h.faceVertexUvs[d] = [];
                }
                var r = 0;
                for (g = l.length; r < g; ) d = new f(), d.x = l[r++] * o, d.y = l[r++] * o, d.z = l[r++] * o, 
                h.vertices.push(d);
                for (r = 0, g = k.length; r < g; ) {
                    l = k[r++];
                    var s = 1 & l, t = 2 & l;
                    d = 8 & l;
                    var u = 16 & l, v = 32 & l;
                    if (o = 64 & l, l &= 128, s) {
                        s = new y(), s.a = k[r], s.b = k[r + 1], s.c = k[r + 3];
                        var w = new y();
                        if (w.a = k[r + 1], w.b = k[r + 2], w.c = k[r + 3], r += 4, t && (t = k[r++], s.materialIndex = t, 
                        w.materialIndex = t), t = h.faces.length, d) for (d = 0; d < p; d++) {
                            var x = j.uvs[d];
                            for (h.faceVertexUvs[d][t] = [], h.faceVertexUvs[d][t + 1] = [], e = 0; 4 > e; e++) {
                                var A = k[r++], B = x[2 * A];
                                A = x[2 * A + 1], B = new c(B, A), 2 !== e && h.faceVertexUvs[d][t].push(B), 0 !== e && h.faceVertexUvs[d][t + 1].push(B);
                            }
                        }
                        if (u && (u = 3 * k[r++], s.normal.set(m[u++], m[u++], m[u]), w.normal.copy(s.normal)), 
                        v) for (d = 0; 4 > d; d++) u = 3 * k[r++], v = new f(m[u++], m[u++], m[u]), 2 !== d && s.vertexNormals.push(v), 
                        0 !== d && w.vertexNormals.push(v);
                        if (o && (o = k[r++], o = n[o], s.color.setHex(o), w.color.setHex(o)), l) for (d = 0; 4 > d; d++) o = k[r++], 
                        o = n[o], 2 !== d && s.vertexColors.push(new q(o)), 0 !== d && w.vertexColors.push(new q(o));
                        h.faces.push(s), h.faces.push(w);
                    } else {
                        if (s = new y(), s.a = k[r++], s.b = k[r++], s.c = k[r++], t && (t = k[r++], s.materialIndex = t), 
                        t = h.faces.length, d) for (d = 0; d < p; d++) for (x = j.uvs[d], h.faceVertexUvs[d][t] = [], 
                        e = 0; 3 > e; e++) A = k[r++], B = x[2 * A], A = x[2 * A + 1], B = new c(B, A), 
                        h.faceVertexUvs[d][t].push(B);
                        if (u && (u = 3 * k[r++], s.normal.set(m[u++], m[u++], m[u])), v) for (d = 0; 3 > d; d++) u = 3 * k[r++], 
                        v = new f(m[u++], m[u++], m[u]), s.vertexNormals.push(v);
                        if (o && (o = k[r++], s.color.setHex(n[o])), l) for (d = 0; 3 > d; d++) o = k[r++], 
                        s.vertexColors.push(new q(n[o]));
                        h.faces.push(s);
                    }
                }
                if (j = a, r = void 0 !== j.influencesPerVertex ? j.influencesPerVertex : 2, j.skinWeights) for (g = 0, 
                k = j.skinWeights.length; g < k; g += r) h.skinWeights.push(new i(j.skinWeights[g], 1 < r ? j.skinWeights[g + 1] : 0, 2 < r ? j.skinWeights[g + 2] : 0, 3 < r ? j.skinWeights[g + 3] : 0));
                if (j.skinIndices) for (g = 0, k = j.skinIndices.length; g < k; g += r) h.skinIndices.push(new i(j.skinIndices[g], 1 < r ? j.skinIndices[g + 1] : 0, 2 < r ? j.skinIndices[g + 2] : 0, 3 < r ? j.skinIndices[g + 3] : 0));
                if (h.bones = j.bones, h.bones && 0 < h.bones.length && (h.skinWeights.length !== h.skinIndices.length || h.skinIndices.length !== h.vertices.length) && console.warn("When skinning, number of vertices (" + h.vertices.length + "), skinIndices (" + h.skinIndices.length + "), and skinWeights (" + h.skinWeights.length + ") should match."), 
                g = a, k = g.scale, void 0 !== g.morphTargets) for (j = 0, r = g.morphTargets.length; j < r; j++) for (h.morphTargets[j] = {}, 
                h.morphTargets[j].name = g.morphTargets[j].name, h.morphTargets[j].vertices = [], 
                m = h.morphTargets[j].vertices, n = g.morphTargets[j].vertices, p = 0, l = n.length; p < l; p += 3) o = new f(), 
                o.x = n[p] * k, o.y = n[p + 1] * k, o.z = n[p + 2] * k, m.push(o);
                if (void 0 !== g.morphColors && 0 < g.morphColors.length) for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), 
                k = h.faces, g = g.morphColors[0].colors, j = 0, r = k.length; j < r; j++) k[j].color.fromArray(g, 3 * j);
                for (g = a, j = [], r = [], void 0 !== g.animation && r.push(g.animation), void 0 !== g.animations && (g.animations.length ? r = r.concat(g.animations) : r.push(g.animations)), 
                g = 0; g < r.length; g++) (k = Xd.parseAnimation(r[g], h.bones)) && j.push(k);
                return h.morphTargets && (r = Xd.CreateClipsFromMorphTargetSequences(h.morphTargets, 10), 
                j = j.concat(r)), 0 < j.length && (h.animations = j), h.computeFaceNormals(), h.computeBoundingSphere(), 
                void 0 === a.materials || 0 === a.materials.length ? {
                    geometry: h
                } : (a = ae.prototype.initMaterials(a.materials, b, this.crossOrigin), {
                    geometry: h,
                    materials: a
                });
            };
        }()
    }), Object.assign(ce.prototype, {
        crossOrigin: "anonymous",
        load: function(a, b, c, d) {
            "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
            var e = this;
            new dd(e.manager).load(a, function(c) {
                var f = null;
                try {
                    f = JSON.parse(c);
                } catch (b) {
                    return void 0 !== d && d(b), void console.error("THREE:ObjectLoader: Can't parse " + a + ".", b.message);
                }
                c = f.metadata, void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : e.parse(f, b);
            }, c, d);
        },
        setTexturePath: function(a) {
            return this.texturePath = a, this;
        },
        setCrossOrigin: function(a) {
            return this.crossOrigin = a, this;
        },
        parse: function(a, b) {
            var c = this.parseShape(a.shapes);
            c = this.parseGeometries(a.geometries, c);
            var d = this.parseImages(a.images, function() {
                void 0 !== b && b(e);
            });
            d = this.parseTextures(a.textures, d), d = this.parseMaterials(a.materials, d);
            var e = this.parseObject(a.object, c, d);
            return a.animations && (e.animations = this.parseAnimations(a.animations)), void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e), 
            e;
        },
        parseShape: function(a) {
            var b = {};
            if (void 0 !== a) for (var c = 0, d = a.length; c < d; c++) {
                var e = new Ad().fromJSON(a[c]);
                b[e.uuid] = e;
            }
            return b;
        },
        parseGeometries: function(a, b) {
            var c = {};
            if (void 0 !== a) for (var d = new be(), e = new _d(), f = 0, g = a.length; f < g; f++) {
                var h = a[f];
                switch (h.type) {
                  case "PlaneGeometry":
                  case "PlaneBufferGeometry":
                    var i = new Af[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                    break;

                  case "BoxGeometry":
                  case "BoxBufferGeometry":
                  case "CubeGeometry":
                    i = new Af[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                    break;

                  case "CircleGeometry":
                  case "CircleBufferGeometry":
                    i = new Af[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
                    break;

                  case "CylinderGeometry":
                  case "CylinderBufferGeometry":
                    i = new Af[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                    break;

                  case "ConeGeometry":
                  case "ConeBufferGeometry":
                    i = new Af[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                    break;

                  case "SphereGeometry":
                  case "SphereBufferGeometry":
                    i = new Af[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                    break;

                  case "DodecahedronGeometry":
                  case "DodecahedronBufferGeometry":
                  case "IcosahedronGeometry":
                  case "IcosahedronBufferGeometry":
                  case "OctahedronGeometry":
                  case "OctahedronBufferGeometry":
                  case "TetrahedronGeometry":
                  case "TetrahedronBufferGeometry":
                    i = new Af[h.type](h.radius, h.detail);
                    break;

                  case "RingGeometry":
                  case "RingBufferGeometry":
                    i = new Af[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
                    break;

                  case "TorusGeometry":
                  case "TorusBufferGeometry":
                    i = new Af[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                    break;

                  case "TorusKnotGeometry":
                  case "TorusKnotBufferGeometry":
                    i = new Af[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
                    break;

                  case "LatheGeometry":
                  case "LatheBufferGeometry":
                    i = new Af[h.type](h.points, h.segments, h.phiStart, h.phiLength);
                    break;

                  case "PolyhedronGeometry":
                  case "PolyhedronBufferGeometry":
                    i = new Af[h.type](h.vertices, h.indices, h.radius, h.details);
                    break;

                  case "ShapeGeometry":
                  case "ShapeBufferGeometry":
                    i = [];
                    for (var j = 0, k = h.shapes.length; j < k; j++) {
                        var l = b[h.shapes[j]];
                        i.push(l);
                    }
                    i = new Af[h.type](i, h.curveSegments);
                    break;

                  case "ExtrudeGeometry":
                  case "ExtrudeBufferGeometry":
                    for (i = [], j = 0, k = h.shapes.length; j < k; j++) l = b[h.shapes[j]], i.push(l);
                    j = h.options.extrudePath, void 0 !== j && (h.options.extrudePath = new Jf[j.type]().fromJSON(j)), 
                    i = new Af[h.type](i, h.options);
                    break;

                  case "BufferGeometry":
                    i = e.parse(h);
                    break;

                  case "Geometry":
                    i = d.parse(h, this.texturePath).geometry;
                    break;

                  default:
                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
                    continue;
                }
                i.uuid = h.uuid, void 0 !== h.name && (i.name = h.name), !0 === i.isBufferGeometry && void 0 !== h.userData && (i.userData = h.userData), 
                c[h.uuid] = i;
            }
            return c;
        },
        parseMaterials: function(a, b) {
            var c = {};
            if (void 0 !== a) {
                var d = new $d();
                d.setTextures(b), b = 0;
                for (var e = a.length; b < e; b++) {
                    var f = a[b];
                    if ("MultiMaterial" === f.type) {
                        for (var g = [], h = 0; h < f.materials.length; h++) g.push(d.parse(f.materials[h]));
                        c[f.uuid] = g;
                    } else c[f.uuid] = d.parse(f);
                }
            }
            return c;
        },
        parseAnimations: function(a) {
            for (var b = [], c = 0; c < a.length; c++) {
                var d = a[c], e = Xd.parse(d);
                void 0 !== d.uuid && (e.uuid = d.uuid), b.push(e);
            }
            return b;
        },
        parseImages: function(a, b) {
            function c(a) {
                return d.manager.itemStart(a), f.load(a, function() {
                    d.manager.itemEnd(a);
                }, void 0, function() {
                    d.manager.itemEnd(a), d.manager.itemError(a);
                });
            }
            var d = this, e = {};
            if (void 0 !== a && 0 < a.length) {
                b = new cd(b);
                var f = new gd(b);
                f.setCrossOrigin(this.crossOrigin), b = 0;
                for (var g = a.length; b < g; b++) {
                    var h = a[b], i = h.url;
                    if (Array.isArray(i)) {
                        e[h.uuid] = [];
                        for (var j = 0, k = i.length; j < k; j++) {
                            var l = i[j];
                            l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : d.texturePath + l, e[h.uuid].push(c(l));
                        }
                    } else l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : d.texturePath + h.url, 
                    e[h.uuid] = c(l);
                }
            }
            return e;
        },
        parseTextures: function(a, b) {
            function c(a, b) {
                return "number" == typeof a ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), 
                b[a]);
            }
            var d = {};
            if (void 0 !== a) for (var e = 0, f = a.length; e < f; e++) {
                var g = a[e];
                void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid), 
                void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
                var i = Array.isArray(b[g.image]) ? new ga(b[g.image]) : new h(b[g.image]);
                i.needsUpdate = !0, i.uuid = g.uuid, void 0 !== g.name && (i.name = g.name), void 0 !== g.mapping && (i.mapping = c(g.mapping, Nf)), 
                void 0 !== g.offset && i.offset.fromArray(g.offset), void 0 !== g.repeat && i.repeat.fromArray(g.repeat), 
                void 0 !== g.center && i.center.fromArray(g.center), void 0 !== g.rotation && (i.rotation = g.rotation), 
                void 0 !== g.wrap && (i.wrapS = c(g.wrap[0], Of), i.wrapT = c(g.wrap[1], Of)), void 0 !== g.format && (i.format = g.format), 
                void 0 !== g.minFilter && (i.minFilter = c(g.minFilter, Pf)), void 0 !== g.magFilter && (i.magFilter = c(g.magFilter, Pf)), 
                void 0 !== g.anisotropy && (i.anisotropy = g.anisotropy), void 0 !== g.flipY && (i.flipY = g.flipY), 
                d[g.uuid] = i;
            }
            return d;
        },
        parseObject: function(a, b, c) {
            function d(a) {
                return void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a), 
                b[a];
            }
            function e(a) {
                if (void 0 !== a) {
                    if (Array.isArray(a)) {
                        for (var b = [], d = 0, e = a.length; d < e; d++) {
                            var f = a[d];
                            void 0 === c[f] && console.warn("THREE.ObjectLoader: Undefined material", f), b.push(c[f]);
                        }
                        return b;
                    }
                    return void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a), 
                    c[a];
                }
            }
            switch (a.type) {
              case "Scene":
                var f = new yb();
                void 0 !== a.background && Number.isInteger(a.background) && (f.background = new q(a.background)), 
                void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new xb(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (f.fog = new wb(a.fog.color, a.fog.density)));
                break;

              case "PerspectiveCamera":
                f = new rb(a.fov, a.aspect, a.near, a.far), void 0 !== a.focus && (f.focus = a.focus), 
                void 0 !== a.zoom && (f.zoom = a.zoom), void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge), 
                void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset), void 0 !== a.view && (f.view = Object.assign({}, a.view));
                break;

              case "OrthographicCamera":
                f = new x(a.left, a.right, a.top, a.bottom, a.near, a.far), void 0 !== a.zoom && (f.zoom = a.zoom), 
                void 0 !== a.view && (f.view = Object.assign({}, a.view));
                break;

              case "AmbientLight":
                f = new Jd(a.color, a.intensity);
                break;

              case "DirectionalLight":
                f = new Id(a.color, a.intensity);
                break;

              case "PointLight":
                f = new Gd(a.color, a.intensity, a.distance, a.decay);
                break;

              case "RectAreaLight":
                f = new Kd(a.color, a.intensity, a.width, a.height);
                break;

              case "SpotLight":
                f = new Fd(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
                break;

              case "HemisphereLight":
                f = new Cd(a.color, a.groundColor, a.intensity);
                break;

              case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");

              case "Mesh":
                f = d(a.geometry);
                var g = e(a.material);
                f = f.bones && 0 < f.bones.length ? new Gb(f, g) : new W(f, g);
                break;

              case "LOD":
                f = new Db();
                break;

              case "Line":
                f = new Ib(d(a.geometry), e(a.material), a.mode);
                break;

              case "LineLoop":
                f = new Kb(d(a.geometry), e(a.material));
                break;

              case "LineSegments":
                f = new Jb(d(a.geometry), e(a.material));
                break;

              case "PointCloud":
              case "Points":
                f = new Mb(d(a.geometry), e(a.material));
                break;

              case "Sprite":
                f = new Cb(e(a.material));
                break;

              case "Group":
                f = new qb();
                break;

              default:
                f = new v();
            }
            if (f.uuid = a.uuid, void 0 !== a.name && (f.name = a.name), void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix), 
            void 0 !== a.matrixAutoUpdate && (f.matrixAutoUpdate = a.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== a.position && f.position.fromArray(a.position), 
            void 0 !== a.rotation && f.rotation.fromArray(a.rotation), void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion), 
            void 0 !== a.scale && f.scale.fromArray(a.scale)), void 0 !== a.castShadow && (f.castShadow = a.castShadow), 
            void 0 !== a.receiveShadow && (f.receiveShadow = a.receiveShadow), a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias), 
            void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize), 
            void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera))), 
            void 0 !== a.visible && (f.visible = a.visible), void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled), 
            void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder), void 0 !== a.userData && (f.userData = a.userData), 
            void 0 !== a.layers && (f.layers.mask = a.layers), void 0 !== a.children) {
                g = a.children;
                for (var h = 0; h < g.length; h++) f.add(this.parseObject(g[h], b, c));
            }
            if ("LOD" === a.type) for (a = a.levels, g = 0; g < a.length; g++) {
                h = a[g];
                var i = f.getObjectByProperty("uuid", h.object);
                void 0 !== i && f.addLevel(i, h.distance);
            }
            return f;
        }
    });
    var Nf = {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        SphericalReflectionMapping: 305,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307
    }, Of = {
        RepeatWrapping: 1e3,
        ClampToEdgeWrapping: 1001,
        MirroredRepeatWrapping: 1002
    }, Pf = {
        NearestFilter: 1003,
        NearestMipMapNearestFilter: 1004,
        NearestMipMapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipMapNearestFilter: 1007,
        LinearMipMapLinearFilter: 1008
    };
    de.prototype = {
        constructor: de,
        setOptions: function(a) {
            return this.options = a, this;
        },
        load: function(a, b, c, d) {
            void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
            var e = this, f = Cf.get(a);
            if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
                b && b(f), e.manager.itemEnd(a);
            }, 0), f;
            fetch(a).then(function(a) {
                return a.blob();
            }).then(function(a) {
                return createImageBitmap(a, e.options);
            }).then(function(c) {
                Cf.add(a, c), b && b(c), e.manager.itemEnd(a);
            }).catch(function(b) {
                d && d(b), e.manager.itemEnd(a), e.manager.itemError(a);
            });
        },
        setCrossOrigin: function() {
            return this;
        },
        setPath: function(a) {
            return this.path = a, this;
        }
    }, Object.assign(ee.prototype, {
        moveTo: function(a, b) {
            this.currentPath = new zd(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(a, b);
        },
        lineTo: function(a, b) {
            this.currentPath.lineTo(a, b);
        },
        quadraticCurveTo: function(a, b, c, d) {
            this.currentPath.quadraticCurveTo(a, b, c, d);
        },
        bezierCurveTo: function(a, b, c, d, e, f) {
            this.currentPath.bezierCurveTo(a, b, c, d, e, f);
        },
        splineThru: function(a) {
            this.currentPath.splineThru(a);
        },
        toShapes: function(a, b) {
            function c(a) {
                for (var b = [], c = 0, d = a.length; c < d; c++) {
                    var e = a[c], f = new Ad();
                    f.curves = e.curves, b.push(f);
                }
                return b;
            }
            function d(a, b) {
                for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
                    var g = b[e], h = b[f], i = h.x - g.x, j = h.y - g.y;
                    if (Math.abs(j) > Number.EPSILON) {
                        if (0 > j && (g = b[f], i = -i, h = b[e], j = -j), !(a.y < g.y || a.y > h.y)) if (a.y === g.y) {
                            if (a.x === g.x) return !0;
                        } else {
                            if (0 === (e = j * (a.x - g.x) - i * (a.y - g.y))) return !0;
                            0 > e || (d = !d);
                        }
                    } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0;
                }
                return d;
            }
            var e = yf.isClockWise, f = this.subPaths;
            if (0 === f.length) return [];
            if (!0 === b) return c(f);
            if (b = [], 1 === f.length) {
                var g = f[0], h = new Ad();
                return h.curves = g.curves, b.push(h), b;
            }
            var i = !e(f[0].getPoints());
            i = a ? !i : i, h = [];
            var j = [], k = [], l = 0;
            j[l] = void 0, k[l] = [];
            for (var m = 0, n = f.length; m < n; m++) {
                g = f[m];
                var o = g.getPoints(), p = e(o);
                (p = a ? !p : p) ? (!i && j[l] && l++, j[l] = {
                    s: new Ad(),
                    p: o
                }, j[l].s.curves = g.curves, i && l++, k[l] = []) : k[l].push({
                    h: g,
                    p: o[0]
                });
            }
            if (!j[0]) return c(f);
            if (1 < j.length) {
                for (m = !1, a = [], e = 0, f = j.length; e < f; e++) h[e] = [];
                for (e = 0, f = j.length; e < f; e++) for (g = k[e], p = 0; p < g.length; p++) {
                    for (i = g[p], l = !0, o = 0; o < j.length; o++) d(i.p, j[o].p) && (e !== o && a.push({
                        froms: e,
                        tos: o,
                        hole: p
                    }), l ? (l = !1, h[o].push(i)) : m = !0);
                    l && h[e].push(i);
                }
                0 < a.length && (m || (k = h));
            }
            for (m = 0, e = j.length; m < e; m++) for (h = j[m].s, b.push(h), a = k[m], f = 0, 
            g = a.length; f < g; f++) h.holes.push(a[f].h);
            return b;
        }
    }), Object.assign(fe.prototype, {
        isFont: !0,
        generateShapes: function(a, b) {
            void 0 === b && (b = 100);
            var c = [], d = b;
            b = this.data;
            var e = Array.from ? Array.from(a) : String(a).split("");
            d /= b.resolution;
            var f = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * d;
            a = [];
            for (var g = 0, h = 0, i = 0; i < e.length; i++) {
                var j = e[i];
                if ("\n" === j) g = 0, h -= f; else {
                    var k = d, l = g, m = h;
                    if (j = b.glyphs[j] || b.glyphs["?"]) {
                        var n = new ee();
                        if (j.o) for (var o = j._cachedOutline || (j._cachedOutline = j.o.split(" ")), p = 0, q = o.length; p < q; ) switch (o[p++]) {
                          case "m":
                            var r = o[p++] * k + l, s = o[p++] * k + m;
                            n.moveTo(r, s);
                            break;

                          case "l":
                            r = o[p++] * k + l, s = o[p++] * k + m, n.lineTo(r, s);
                            break;

                          case "q":
                            var t = o[p++] * k + l, u = o[p++] * k + m, v = o[p++] * k + l, w = o[p++] * k + m;
                            n.quadraticCurveTo(v, w, t, u);
                            break;

                          case "b":
                            t = o[p++] * k + l, u = o[p++] * k + m, v = o[p++] * k + l, w = o[p++] * k + m, 
                            r = o[p++] * k + l, s = o[p++] * k + m, n.bezierCurveTo(v, w, r, s, t, u);
                        }
                        k = {
                            offsetX: j.ha * k,
                            path: n
                        };
                    } else k = void 0;
                    g += k.offsetX, a.push(k.path);
                }
            }
            for (b = 0, e = a.length; b < e; b++) Array.prototype.push.apply(c, a[b].toShapes());
            return c;
        }
    }), Object.assign(ge.prototype, {
        load: function(a, b, c, d) {
            var e = this, f = new dd(this.manager);
            f.setPath(this.path), f.load(a, function(a) {
                try {
                    var c = JSON.parse(a);
                } catch (b) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), 
                    c = JSON.parse(a.substring(65, a.length - 2));
                }
                a = e.parse(c), b && b(a);
            }, c, d);
        },
        parse: function(a) {
            return new fe(a);
        },
        setPath: function(a) {
            return this.path = a, this;
        }
    });
    var Qf, Rf = {
        getContext: function() {
            return void 0 === Qf && (Qf = new (window.AudioContext || window.webkitAudioContext)()), 
            Qf;
        },
        setContext: function(a) {
            Qf = a;
        }
    };
    Object.assign(he.prototype, {
        load: function(a, b, c, d) {
            var e = new dd(this.manager);
            e.setResponseType("arraybuffer"), e.load(a, function(a) {
                a = a.slice(0), Rf.getContext().decodeAudioData(a, function(a) {
                    b(a);
                });
            }, c, d);
        }
    }), Object.assign(ie.prototype, {
        update: function() {
            var a, b, c, e, f, g, h, i, j = new d(), k = new d();
            return function(d) {
                if (a !== this || b !== d.focus || c !== d.fov || e !== d.aspect * this.aspect || f !== d.near || g !== d.far || h !== d.zoom || i !== this.eyeSep) {
                    a = this, b = d.focus, c = d.fov, e = d.aspect * this.aspect, f = d.near, g = d.far, 
                    h = d.zoom;
                    var l = d.projectionMatrix.clone();
                    i = this.eyeSep / 2;
                    var m = i * f / b, n = f * Math.tan(_e.DEG2RAD * c * .5) / h;
                    k.elements[12] = -i, j.elements[12] = i;
                    var o = -n * e + m, p = n * e + m;
                    l.elements[0] = 2 * f / (p - o), l.elements[8] = (p + o) / (p - o), this.cameraL.projectionMatrix.copy(l), 
                    o = -n * e - m, p = n * e - m, l.elements[0] = 2 * f / (p - o), l.elements[8] = (p + o) / (p - o), 
                    this.cameraR.projectionMatrix.copy(l);
                }
                this.cameraL.matrixWorld.copy(d.matrixWorld).multiply(k), this.cameraR.matrixWorld.copy(d.matrixWorld).multiply(j);
            };
        }()
    }), je.prototype = Object.create(v.prototype), je.prototype.constructor = je, ke.prototype = Object.assign(Object.create(v.prototype), {
        constructor: ke,
        getInput: function() {
            return this.gain;
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), 
            this.gain.connect(this.context.destination), this.filter = null), this;
        },
        getFilter: function() {
            return this.filter;
        },
        setFilter: function(a) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), 
            this.filter = a, this.gain.connect(this.filter), this.filter.connect(this.context.destination), 
            this;
        },
        getMasterVolume: function() {
            return this.gain.gain.value;
        },
        setMasterVolume: function(a) {
            return this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01), this;
        },
        updateMatrixWorld: function() {
            var a = new f(), b = new e(), c = new f(), d = new f();
            return function(e) {
                v.prototype.updateMatrixWorld.call(this, e), e = this.context.listener;
                var f = this.up;
                this.matrixWorld.decompose(a, b, c), d.set(0, 0, -1).applyQuaternion(b), e.positionX ? (e.positionX.setValueAtTime(a.x, this.context.currentTime), 
                e.positionY.setValueAtTime(a.y, this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), 
                e.forwardX.setValueAtTime(d.x, this.context.currentTime), e.forwardY.setValueAtTime(d.y, this.context.currentTime), 
                e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), 
                e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z, this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), 
                e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z));
            };
        }()
    }), le.prototype = Object.assign(Object.create(v.prototype), {
        constructor: le,
        getOutput: function() {
            return this.gain;
        },
        setNodeSource: function(a) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = a, 
            this.connect(), this;
        },
        setMediaElementSource: function(a) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(a), 
            this.connect(), this;
        },
        setBuffer: function(a) {
            return this.buffer = a, this.sourceType = "buffer", this.autoplay && this.play(), 
            this;
        },
        play: function() {
            if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else {
                if (!1 !== this.hasPlaybackControl) {
                    var a = this.context.createBufferSource();
                    return a.buffer = this.buffer, a.loop = this.loop, a.onended = this.onEnded.bind(this), 
                    a.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, 
                    a.start(this.startTime, this.offset), this.isPlaying = !0, this.source = a, this.connect();
                }
                console.warn("THREE.Audio: this Audio has no playback control.");
            }
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), 
            this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, 
            this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.");
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, 
            this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.");
        },
        connect: function() {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this;
        },
        disconnect: function() {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            return this;
        },
        getFilters: function() {
            return this.filters;
        },
        setFilters: function(a) {
            return a || (a = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = a, 
            this.connect()) : this.filters = a, this;
        },
        getFilter: function() {
            return this.getFilters()[0];
        },
        setFilter: function(a) {
            return this.setFilters(a ? [ a ] : []);
        },
        setPlaybackRate: function(a) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), 
            this;
            console.warn("THREE.Audio: this Audio has no playback control.");
        },
        getPlaybackRate: function() {
            return this.playbackRate;
        },
        onEnded: function() {
            this.isPlaying = !1;
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), 
            !1) : this.loop;
        },
        setLoop: function(a) {
            if (!1 !== this.hasPlaybackControl) return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), 
            this;
            console.warn("THREE.Audio: this Audio has no playback control.");
        },
        getVolume: function() {
            return this.gain.gain.value;
        },
        setVolume: function(a) {
            return this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01), this;
        }
    }), me.prototype = Object.assign(Object.create(le.prototype), {
        constructor: me,
        getOutput: function() {
            return this.panner;
        },
        getRefDistance: function() {
            return this.panner.refDistance;
        },
        setRefDistance: function(a) {
            return this.panner.refDistance = a, this;
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor;
        },
        setRolloffFactor: function(a) {
            return this.panner.rolloffFactor = a, this;
        },
        getDistanceModel: function() {
            return this.panner.distanceModel;
        },
        setDistanceModel: function(a) {
            return this.panner.distanceModel = a, this;
        },
        getMaxDistance: function() {
            return this.panner.maxDistance;
        },
        setMaxDistance: function(a) {
            return this.panner.maxDistance = a, this;
        },
        setDirectionalCone: function(a, b, c) {
            return this.panner.coneInnerAngle = a, this.panner.coneOuterAngle = b, this.panner.coneOuterGain = c, 
            this;
        },
        updateMatrixWorld: function() {
            var a = new f(), b = new e(), c = new f(), d = new f();
            return function(e) {
                v.prototype.updateMatrixWorld.call(this, e), e = this.panner, this.matrixWorld.decompose(a, b, c), 
                d.set(0, 0, 1).applyQuaternion(b), e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z);
            };
        }()
    }), Object.assign(ne.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
        },
        getAverageFrequency: function() {
            for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
            return a / b.length;
        }
    }), Object.assign(oe.prototype, {
        accumulate: function(a, b) {
            var c = this.buffer, d = this.valueSize;
            a = a * d + d;
            var e = this.cumulativeWeight;
            if (0 === e) {
                for (e = 0; e !== d; ++e) c[a + e] = c[e];
                e = b;
            } else e += b, this._mixBufferRegion(c, a, 0, b / e, d);
            this.cumulativeWeight = e;
        },
        apply: function(a) {
            var b = this.valueSize, c = this.buffer;
            a = a * b + b;
            var d = this.cumulativeWeight, e = this.binding;
            this.cumulativeWeight = 0, 1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b), 
            d = b;
            for (var f = b + b; d !== f; ++d) if (c[d] !== c[d + b]) {
                e.setValue(c, a);
                break;
            }
        },
        saveOriginalState: function() {
            var a = this.buffer, b = this.valueSize, c = 3 * b;
            this.binding.getValue(a, c);
            for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
            this.cumulativeWeight = 0;
        },
        restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize);
        },
        _select: function(a, b, c, d, e) {
            if (.5 <= d) for (d = 0; d !== e; ++d) a[b + d] = a[c + d];
        },
        _slerp: function(a, b, c, d) {
            e.slerpFlat(a, b, a, b, a, c, d);
        },
        _lerp: function(a, b, c, d, e) {
            for (var f = 1 - d, g = 0; g !== e; ++g) {
                var h = b + g;
                a[h] = a[h] * f + a[c + g] * d;
            }
        }
    }), Object.assign(pe.prototype, {
        getValue: function(a, b) {
            this.bind();
            var c = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== c && c.getValue(a, b);
        },
        setValue: function(a, b) {
            for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b);
        },
        bind: function() {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind();
        },
        unbind: function() {
            for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind();
        }
    }), Object.assign(qe, {
        Composite: pe,
        create: function(a, b, c) {
            return a && a.isAnimationObjectGroup ? new qe.Composite(a, b, c) : new qe(a, b, c);
        },
        sanitizeNodeName: function() {
            var a = /[\[\]\.:\/]/g;
            return function(b) {
                return b.replace(/\s/g, "_").replace(a, "");
            };
        }(),
        parseTrackName: function() {
            var a = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", b = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
            a = /(WCOD+)?/.source.replace("WCOD", a);
            var c = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), d = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), e = new RegExp("^" + b + a + c + d + "$"), f = [ "material", "materials", "bones" ];
            return function(a) {
                var b = e.exec(a);
                if (!b) throw Error("PropertyBinding: Cannot parse trackName: " + a);
                b = {
                    nodeName: b[2],
                    objectName: b[3],
                    objectIndex: b[4],
                    propertyName: b[5],
                    propertyIndex: b[6]
                };
                var c = b.nodeName && b.nodeName.lastIndexOf(".");
                if (void 0 !== c && -1 !== c) {
                    var d = b.nodeName.substring(c + 1);
                    -1 !== f.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c), b.objectName = d);
                }
                if (null === b.propertyName || 0 === b.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + a);
                return b;
            };
        }(),
        findNode: function(a, b) {
            if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
            if (a.skeleton) {
                var c = a.skeleton.getBoneByName(b);
                if (void 0 !== c) return c;
            }
            if (a.children) {
                var d = function(a) {
                    for (var c = 0; c < a.length; c++) {
                        var e = a[c];
                        if (e.name === b || e.uuid === b || (e = d(e.children))) return e;
                    }
                    return null;
                };
                if (a = d(a.children)) return a;
            }
            return null;
        }
    }), Object.assign(qe.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [ function(a, b) {
            a[b] = this.node[this.propertyName];
        }, function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d];
        }, function(a, b) {
            a[b] = this.resolvedProperty[this.propertyIndex];
        }, function(a, b) {
            this.resolvedProperty.toArray(a, b);
        } ],
        SetterByBindingTypeAndVersioning: [ [ function(a, b) {
            this.targetObject[this.propertyName] = a[b];
        }, function(a, b) {
            this.targetObject[this.propertyName] = a[b], this.targetObject.needsUpdate = !0;
        }, function(a, b) {
            this.targetObject[this.propertyName] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
        }, function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
            this.targetObject.needsUpdate = !0;
        }, function(a, b) {
            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b];
        }, function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.needsUpdate = !0;
        }, function(a, b) {
            this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(a, b) {
            this.resolvedProperty.fromArray(a, b);
        }, function(a, b) {
            this.resolvedProperty.fromArray(a, b), this.targetObject.needsUpdate = !0;
        }, function(a, b) {
            this.resolvedProperty.fromArray(a, b), this.targetObject.matrixWorldNeedsUpdate = !0;
        } ] ],
        getValue: function(a, b) {
            this.bind(), this.getValue(a, b);
        },
        setValue: function(a, b) {
            this.bind(), this.setValue(a, b);
        },
        bind: function() {
            var a = this.node, b = this.parsedPath, c = b.objectName, d = b.propertyName, e = b.propertyIndex;
            if (a || (this.node = a = qe.findNode(this.rootNode, b.nodeName) || this.rootNode), 
            this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, 
            a) {
                if (c) {
                    var f = b.objectIndex;
                    switch (c) {
                      case "materials":
                        if (!a.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!a.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        a = a.material.materials;
                        break;

                      case "bones":
                        if (!a.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        for (a = a.skeleton.bones, c = 0; c < a.length; c++) if (a[c].name === f) {
                            f = c;
                            break;
                        }
                        break;

                      default:
                        if (void 0 === a[c]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        a = a[c];
                    }
                    if (void 0 !== f) {
                        if (void 0 === a[f]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a);
                        a = a[f];
                    }
                }
                if (void 0 === (f = a[d])) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a); else {
                    if (b = this.Versioning.None, this.targetObject = a, void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate), 
                    c = this.BindingType.Direct, void 0 !== e) {
                        if ("morphTargetInfluences" === d) {
                            if (!a.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (a.geometry.isBufferGeometry) {
                                if (!a.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++) if (a.geometry.morphAttributes.position[c].name === e) {
                                    e = c;
                                    break;
                                }
                            } else {
                                if (!a.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (c = 0; c < this.node.geometry.morphTargets.length; c++) if (a.geometry.morphTargets[c].name === e) {
                                    e = c;
                                    break;
                                }
                            }
                        }
                        c = this.BindingType.ArrayElement, this.resolvedProperty = f, this.propertyIndex = e;
                    } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, 
                    this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, 
                    this.resolvedProperty = f) : this.propertyName = d;
                    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
    }), Object.assign(qe.prototype, {
        _getValue_unbound: qe.prototype.getValue,
        _setValue_unbound: qe.prototype.setValue
    }), Object.assign(re.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, f = this._parsedPaths, g = this._bindings, h = g.length, i = void 0, j = 0, k = arguments.length; j !== k; ++j) {
                var l = arguments[j], m = l.uuid, n = d[m];
                if (void 0 === n) {
                    n = b++, d[m] = n, a.push(l), m = 0;
                    for (var o = h; m !== o; ++m) g[m].push(new qe(l, e[m], f[m]));
                } else if (n < c) {
                    i = a[n];
                    var p = --c;
                    for (o = a[p], d[o.uuid] = n, a[n] = o, d[m] = p, a[p] = l, m = 0, o = h; m !== o; ++m) {
                        var q = g[m], r = q[n];
                        q[n] = q[p], void 0 === r && (r = new qe(l, e[m], f[m])), q[p] = r;
                    }
                } else a[n] !== i && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
            this.nCachedObjects_ = c;
        },
        remove: function() {
            for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, d = this._bindings, e = d.length, f = 0, g = arguments.length; f !== g; ++f) {
                var h = arguments[f], i = h.uuid, j = c[i];
                if (void 0 !== j && j >= b) {
                    var k = b++, l = a[k];
                    for (c[l.uuid] = j, a[j] = l, c[i] = k, a[k] = h, h = 0, i = e; h !== i; ++h) {
                        l = d[h];
                        var m = l[j];
                        l[j] = l[k], l[k] = m;
                    }
                }
            }
            this.nCachedObjects_ = b;
        },
        uncache: function() {
            for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
                var i = arguments[g].uuid, j = d[i];
                if (void 0 !== j) if (delete d[i], j < c) {
                    i = --c;
                    var k = a[i], l = --b, m = a[l];
                    for (d[k.uuid] = j, a[j] = k, d[m.uuid] = i, a[i] = m, a.pop(), k = 0, m = f; k !== m; ++k) {
                        var n = e[k], o = n[l];
                        n[j] = n[i], n[i] = o, n.pop();
                    }
                } else for (l = --b, m = a[l], d[m.uuid] = j, a[j] = m, a.pop(), k = 0, m = f; k !== m; ++k) n = e[k], 
                n[j] = n[l], n.pop();
            }
            this.nCachedObjects_ = c;
        },
        subscribe_: function(a, b) {
            var c = this._bindingsIndicesByPath, d = c[a], e = this._bindings;
            if (void 0 !== d) return e[d];
            var f = this._paths, g = this._parsedPaths, h = this._objects, i = this.nCachedObjects_, j = Array(h.length);
            for (d = e.length, c[a] = d, f.push(a), g.push(b), e.push(j), c = i, d = h.length; c !== d; ++c) j[c] = new qe(h[c], a, b);
            return j;
        },
        unsubscribe_: function(a) {
            var b = this._bindingsIndicesByPath, c = b[a];
            if (void 0 !== c) {
                var d = this._paths, e = this._parsedPaths, f = this._bindings, g = f.length - 1, h = f[g];
                b[a[g]] = c, f[c] = h, f.pop(), e[c] = e[g], e.pop(), d[c] = d[g], d.pop();
            }
        }
    }), Object.assign(se.prototype, {
        play: function() {
            return this._mixer._activateAction(this), this;
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset();
        },
        reset: function() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, 
            this._startTime = null, this.stopFading().stopWarping();
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this);
        },
        startAt: function(a) {
            return this._startTime = a, this;
        },
        setLoop: function(a, b) {
            return this.loop = a, this.repetitions = b, this;
        },
        setEffectiveWeight: function(a) {
            return this.weight = a, this._effectiveWeight = this.enabled ? a : 0, this.stopFading();
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight;
        },
        fadeIn: function(a) {
            return this._scheduleFading(a, 0, 1);
        },
        fadeOut: function(a) {
            return this._scheduleFading(a, 1, 0);
        },
        crossFadeFrom: function(a, b, c) {
            if (a.fadeOut(b), this.fadeIn(b), c) {
                c = this._clip.duration;
                var d = a._clip.duration, e = c / d;
                a.warp(1, d / c, b), this.warp(e, 1, b);
            }
            return this;
        },
        crossFadeTo: function(a, b, c) {
            return a.crossFadeFrom(this, b, c);
        },
        stopFading: function() {
            var a = this._weightInterpolant;
            return null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)), 
            this;
        },
        setEffectiveTimeScale: function(a) {
            return this.timeScale = a, this._effectiveTimeScale = this.paused ? 0 : a, this.stopWarping();
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale;
        },
        setDuration: function(a) {
            return this.timeScale = this._clip.duration / a, this.stopWarping();
        },
        syncWith: function(a) {
            return this.time = a.time, this.timeScale = a.timeScale, this.stopWarping();
        },
        halt: function(a) {
            return this.warp(this._effectiveTimeScale, 0, a);
        },
        warp: function(a, b, c) {
            var d = this._mixer, e = d.time, f = this._timeScaleInterpolant, g = this.timeScale;
            return null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()), 
            d = f.parameterPositions, f = f.sampleValues, d[0] = e, d[1] = e + c, f[0] = a / g, 
            f[1] = b / g, this;
        },
        stopWarping: function() {
            var a = this._timeScaleInterpolant;
            return null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)), 
            this;
        },
        getMixer: function() {
            return this._mixer;
        },
        getClip: function() {
            return this._clip;
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root;
        },
        _update: function(a, b, c, d) {
            if (this.enabled) {
                var e = this._startTime;
                if (null !== e) {
                    if (0 > (b = (a - e) * c) || 0 === c) return;
                    this._startTime = null, b *= c;
                }
                if (b *= this._updateTimeScale(a), c = this._updateTime(b), 0 < (a = this._updateWeight(a))) {
                    b = this._interpolants, e = this._propertyBindings;
                    for (var f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a);
                }
            } else this._updateWeight(a);
        },
        _updateWeight: function(a) {
            var b = 0;
            if (this.enabled) {
                b = this.weight;
                var c = this._weightInterpolant;
                if (null !== c) {
                    var d = c.evaluate(a)[0];
                    b *= d, a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1));
                }
            }
            return this._effectiveWeight = b;
        },
        _updateTimeScale: function(a) {
            var b = 0;
            if (!this.paused) {
                b = this.timeScale;
                var c = this._timeScaleInterpolant;
                if (null !== c) {
                    b *= c.evaluate(a)[0], a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b);
                }
            }
            return this._effectiveTimeScale = b;
        },
        _updateTime: function(a) {
            var b = this.time + a, c = this._clip.duration, d = this.loop, e = this._loopCount, f = 2202 === d;
            if (0 === a) return -1 === e ? b : f && 1 == (1 & e) ? c - b : b;
            if (2200 === d) a: {
                if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c; else {
                    if (!(0 > b)) break a;
                    b = 0;
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 > a ? -1 : 1
                });
            } else {
                if (-1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, f)) : this._setEndings(0 === this.repetitions, !0, f)), 
                b >= c || 0 > b) {
                    d = Math.floor(b / c), b -= c * d, e += Math.abs(d);
                    var g = this.repetitions - e;
                    0 >= g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, 
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 < a ? 1 : -1
                    })) : (1 === g ? (a = 0 > a, this._setEndings(a, !a, f)) : this._setEndings(!1, !1, f), 
                    this._loopCount = e, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: d
                    }));
                }
                if (f && 1 == (1 & e)) return this.time = b, c - b;
            }
            return this.time = b;
        },
        _setEndings: function(a, b, c) {
            var d = this._interpolantSettings;
            c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, 
            d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
        },
        _scheduleFading: function(a, b, c) {
            var d = this._mixer, e = d.time, f = this._weightInterpolant;
            return null === f && (this._weightInterpolant = f = d._lendControlInterpolant()), 
            d = f.parameterPositions, f = f.sampleValues, d[0] = e, f[0] = b, d[1] = e + a, 
            f[1] = c, this;
        }
    }), te.prototype = Object.assign(Object.create(b.prototype), {
        constructor: te,
        _bindAction: function(a, b) {
            var c = a._localRoot || this._root, d = a._clip.tracks, e = d.length, f = a._propertyBindings;
            a = a._interpolants;
            var g = c.uuid, h = this._bindingsByRootAndName, i = h[g];
            for (void 0 === i && (i = {}, h[g] = i), h = 0; h !== e; ++h) {
                var j = d[h], k = j.name, l = i[k];
                if (void 0 === l) {
                    if (void 0 !== (l = f[h])) {
                        null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, g, k));
                        continue;
                    }
                    l = new oe(qe.create(c, k, b && b._propertyBindings[h].binding.parsedPath), j.ValueTypeName, j.getValueSize()), 
                    ++l.referenceCount, this._addInactiveBinding(l, g, k);
                }
                f[h] = l, a[h].resultBuffer = l.buffer;
            }
        },
        _activateAction: function(a) {
            if (!this._isActiveAction(a)) {
                if (null === a._cacheIndex) {
                    var b = (a._localRoot || this._root).uuid, c = a._clip.uuid, d = this._actionsByClip[c];
                    this._bindAction(a, d && d.knownActions[0]), this._addInactiveAction(a, c, b);
                }
                for (b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 == e.useCount++ && (this._lendBinding(e), e.saveOriginalState());
                }
                this._lendAction(a);
            }
        },
        _deactivateAction: function(a) {
            if (this._isActiveAction(a)) {
                for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                    var e = b[c];
                    0 == --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e));
                }
                this._takeBackAction(a);
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], 
            this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], 
            this._nActiveControlInterpolants = 0;
            var a = this;
            this.stats = {
                actions: {
                    get total() {
                        return a._actions.length;
                    },
                    get inUse() {
                        return a._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return a._bindings.length;
                    },
                    get inUse() {
                        return a._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return a._controlInterpolants.length;
                    },
                    get inUse() {
                        return a._nActiveControlInterpolants;
                    }
                }
            };
        },
        _isActiveAction: function(a) {
            return null !== (a = a._cacheIndex) && a < this._nActiveActions;
        },
        _addInactiveAction: function(a, b, c) {
            var d = this._actions, e = this._actionsByClip, f = e[b];
            void 0 === f ? (f = {
                knownActions: [ a ],
                actionByRoot: {}
            }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, 
            b.push(a)), a._cacheIndex = d.length, d.push(a), f.actionByRoot[c] = a;
        },
        _removeInactiveAction: function(a) {
            var b = this._actions, c = b[b.length - 1], d = a._cacheIndex;
            c._cacheIndex = d, b[d] = c, b.pop(), a._cacheIndex = null, b = a._clip.uuid, c = this._actionsByClip, 
            d = c[b];
            var e = d.knownActions, f = e[e.length - 1], g = a._byClipCacheIndex;
            f._byClipCacheIndex = g, e[g] = f, e.pop(), a._byClipCacheIndex = null, delete d.actionByRoot[(a._localRoot || this._root).uuid], 
            0 === e.length && delete c[b], this._removeInactiveBindingsForAction(a);
        },
        _removeInactiveBindingsForAction: function(a) {
            a = a._propertyBindings;
            for (var b = 0, c = a.length; b !== c; ++b) {
                var d = a[b];
                0 == --d.referenceCount && this._removeInactiveBinding(d);
            }
        },
        _lendAction: function(a) {
            var b = this._actions, c = a._cacheIndex, d = this._nActiveActions++, e = b[d];
            a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e;
        },
        _takeBackAction: function(a) {
            var b = this._actions, c = a._cacheIndex, d = --this._nActiveActions, e = b[d];
            a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e;
        },
        _addInactiveBinding: function(a, b, c) {
            var d = this._bindingsByRootAndName, e = d[b], f = this._bindings;
            void 0 === e && (e = {}, d[b] = e), e[c] = a, a._cacheIndex = f.length, f.push(a);
        },
        _removeInactiveBinding: function(a) {
            var b = this._bindings, c = a.binding, d = c.rootNode.uuid;
            c = c.path;
            var e = this._bindingsByRootAndName, f = e[d], g = b[b.length - 1];
            a = a._cacheIndex, g._cacheIndex = a, b[a] = g, b.pop(), delete f[c];
            a: {
                for (var h in f) break a;
                delete e[d];
            }
        },
        _lendBinding: function(a) {
            var b = this._bindings, c = a._cacheIndex, d = this._nActiveBindings++, e = b[d];
            a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e;
        },
        _takeBackBinding: function(a) {
            var b = this._bindings, c = a._cacheIndex, d = --this._nActiveBindings, e = b[d];
            a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e;
        },
        _lendControlInterpolant: function() {
            var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b];
            return void 0 === c && (c = new Nd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), 
            c.__cacheIndex = b, a[b] = c), c;
        },
        _takeBackControlInterpolant: function(a) {
            var b = this._controlInterpolants, c = a.__cacheIndex, d = --this._nActiveControlInterpolants, e = b[d];
            a.__cacheIndex = d, b[d] = a, e.__cacheIndex = c, b[c] = e;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(a, b) {
            var c = b || this._root, d = c.uuid;
            c = "string" == typeof a ? Xd.findByName(c, a) : a, a = null !== c ? c.uuid : a;
            var e = this._actionsByClip[a], f = null;
            if (void 0 !== e) {
                if (void 0 !== (f = e.actionByRoot[d])) return f;
                f = e.knownActions[0], null === c && (c = f._clip);
            }
            return null === c ? null : (b = new se(this, c, b), this._bindAction(b, f), this._addInactiveAction(b, a, d), 
            b);
        },
        existingAction: function(a, b) {
            var c = b || this._root;
            return b = c.uuid, c = "string" == typeof a ? Xd.findByName(c, a) : a, a = this._actionsByClip[c ? c.uuid : a], 
            void 0 !== a ? a.actionByRoot[b] || null : null;
        },
        stopAllAction: function() {
            for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
            for (e = 0; e !== d; ++e) c[e].useCount = 0;
            return this;
        },
        update: function(a) {
            a *= this.timeScale;
            for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) b[g]._update(d, a, e, f);
            for (a = this._bindings, b = this._nActiveBindings, g = 0; g !== b; ++g) a[g].apply(f);
            return this;
        },
        getRoot: function() {
            return this._root;
        },
        uncacheClip: function(a) {
            var b = this._actions;
            a = a.uuid;
            var c = this._actionsByClip, d = c[a];
            if (void 0 !== d) {
                d = d.knownActions;
                for (var e = 0, f = d.length; e !== f; ++e) {
                    var g = d[e];
                    this._deactivateAction(g);
                    var h = g._cacheIndex, i = b[b.length - 1];
                    g._cacheIndex = null, g._byClipCacheIndex = null, i._cacheIndex = h, b[h] = i, b.pop(), 
                    this._removeInactiveBindingsForAction(g);
                }
                delete c[a];
            }
        },
        uncacheRoot: function(a) {
            a = a.uuid;
            var b = this._actionsByClip;
            for (d in b) {
                var c = b[d].actionByRoot[a];
                void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c));
            }
            var d = this._bindingsByRootAndName[a];
            if (void 0 !== d) for (var e in d) a = d[e], a.restoreOriginalState(), this._removeInactiveBinding(a);
        },
        uncacheAction: function(a, b) {
            null !== (a = this.existingAction(a, b)) && (this._deactivateAction(a), this._removeInactiveAction(a));
        }
    }), ue.prototype.clone = function() {
        return new ue(void 0 === this.value.clone ? this.value : this.value.clone());
    }, ve.prototype = Object.assign(Object.create(M.prototype), {
        constructor: ve,
        isInstancedBufferGeometry: !0,
        copy: function(a) {
            return M.prototype.copy.call(this, a), this.maxInstancedCount = a.maxInstancedCount, 
            this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    }), we.prototype = Object.assign(Object.create(zb.prototype), {
        constructor: we,
        isInstancedInterleavedBuffer: !0,
        copy: function(a) {
            return zb.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, 
            this;
        }
    }), xe.prototype = Object.assign(Object.create(A.prototype), {
        constructor: xe,
        isInstancedBufferAttribute: !0,
        copy: function(a) {
            return A.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, 
            this;
        }
    }), Object.assign(ye.prototype, {
        linePrecision: 1,
        set: function(a, b) {
            this.ray.set(a, b);
        },
        setFromCamera: function(a, b) {
            b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), 
            this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), 
            this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function(a, b, c) {
            return c = c || [], Ae(a, this, c, b), c.sort(ze), c;
        },
        intersectObjects: function(a, b, c) {
            if (c = c || [], !1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), 
            c;
            for (var d = 0, e = a.length; d < e; d++) Ae(a[d], this, c, b);
            return c.sort(ze), c;
        }
    }), Object.assign(Be.prototype, {
        start: function() {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), 
            this.elapsedTime = 0, this.running = !0;
        },
        stop: function() {
            this.getElapsedTime(), this.autoStart = this.running = !1;
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime;
        },
        getDelta: function() {
            var a = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var b = ("undefined" == typeof performance ? Date : performance).now();
                a = (b - this.oldTime) / 1e3, this.oldTime = b, this.elapsedTime += a;
            }
            return a;
        }
    }), Object.assign(Ce.prototype, {
        set: function(a, b, c) {
            return this.radius = a, this.phi = b, this.theta = c, this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.radius = a.radius, this.phi = a.phi, this.theta = a.theta, this;
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
        },
        setFromVector3: function(a) {
            return this.setFromCartesianCoords(a.x, a.y, a.z);
        },
        setFromCartesianCoords: function(a, b, c) {
            return this.radius = Math.sqrt(a * a + b * b + c * c), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, c), 
            this.phi = Math.acos(_e.clamp(b / this.radius, -1, 1))), this;
        }
    }), Object.assign(De.prototype, {
        set: function(a, b, c) {
            return this.radius = a, this.theta = b, this.y = c, this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.radius = a.radius, this.theta = a.theta, this.y = a.y, this;
        },
        setFromVector3: function(a) {
            return this.setFromCartesianCoords(a.x, a.y, a.z);
        },
        setFromCartesianCoords: function(a, b, c) {
            return this.radius = Math.sqrt(a * a + c * c), this.theta = Math.atan2(a, c), this.y = b, 
            this;
        }
    }), Object.assign(Ee.prototype, {
        set: function(a, b) {
            return this.min.copy(a), this.max.copy(b), this;
        },
        setFromPoints: function(a) {
            this.makeEmpty();
            for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
            return this;
        },
        setFromCenterAndSize: function() {
            var a = new c();
            return function(b, c) {
                return c = a.copy(c).multiplyScalar(.5), this.min.copy(b).sub(c), this.max.copy(b).add(c), 
                this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.min.copy(a.min), this.max.copy(a.max), this;
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        getCenter: function(a) {
            return void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), 
            a = new c()), this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(a) {
            return void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), 
            a = new c()), this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min);
        },
        expandByPoint: function(a) {
            return this.min.min(a), this.max.max(a), this;
        },
        expandByVector: function(a) {
            return this.min.sub(a), this.max.add(a), this;
        },
        expandByScalar: function(a) {
            return this.min.addScalar(-a), this.max.addScalar(a), this;
        },
        containsPoint: function(a) {
            return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y);
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y;
        },
        getParameter: function(a, b) {
            return void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), 
            b = new c()), b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
        },
        intersectsBox: function(a) {
            return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y);
        },
        clampPoint: function(a, b) {
            return void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), 
            b = new c()), b.copy(a).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var a = new c();
            return function(b) {
                return a.copy(b).clamp(this.min, this.max).sub(b).length();
            };
        }(),
        intersect: function(a) {
            return this.min.max(a.min), this.max.min(a.max), this;
        },
        union: function(a) {
            return this.min.min(a.min), this.max.max(a.max), this;
        },
        translate: function(a) {
            return this.min.add(a), this.max.add(a), this;
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max);
        }
    }), Object.assign(Fe.prototype, {
        set: function(a, b) {
            return this.start.copy(a), this.end.copy(b), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(a) {
            return this.start.copy(a.start), this.end.copy(a.end), this;
        },
        getCenter: function(a) {
            return void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), 
            a = new f()), a.addVectors(this.start, this.end).multiplyScalar(.5);
        },
        delta: function(a) {
            return void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"), 
            a = new f()), a.subVectors(this.end, this.start);
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end);
        },
        distance: function() {
            return this.start.distanceTo(this.end);
        },
        at: function(a, b) {
            return void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), 
            b = new f()), this.delta(b).multiplyScalar(a).add(this.start);
        },
        closestPointToPointParameter: function() {
            var a = new f(), b = new f();
            return function(c, d) {
                return a.subVectors(c, this.start), b.subVectors(this.end, this.start), c = b.dot(b), 
                c = b.dot(a) / c, d && (c = _e.clamp(c, 0, 1)), c;
            };
        }(),
        closestPointToPoint: function(a, b, c) {
            return a = this.closestPointToPointParameter(a, b), void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), 
            c = new f()), this.delta(c).multiplyScalar(a).add(this.start);
        },
        applyMatrix4: function(a) {
            return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this;
        },
        equals: function(a) {
            return a.start.equals(this.start) && a.end.equals(this.end);
        }
    }), Ge.prototype = Object.create(v.prototype), Ge.prototype.constructor = Ge, Ge.prototype.isImmediateRenderObject = !0, 
    He.prototype = Object.create(Jb.prototype), He.prototype.constructor = He, He.prototype.update = function() {
        var a = new f(), b = new f(), c = new g();
        return function() {
            var d = [ "a", "b", "c" ];
            this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
            var e = this.object.matrixWorld, f = this.geometry.attributes.position, g = this.object.geometry;
            if (g && g.isGeometry) for (var h = g.vertices, i = g.faces, j = g = 0, k = i.length; j < k; j++) for (var l = i[j], m = 0, n = l.vertexNormals.length; m < n; m++) {
                var o = l.vertexNormals[m];
                a.copy(h[l[d[m]]]).applyMatrix4(e), b.copy(o).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), 
                f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
            } else if (g && g.isBufferGeometry) for (d = g.attributes.position, h = g.attributes.normal, 
            m = g = 0, n = d.count; m < n; m++) a.set(d.getX(m), d.getY(m), d.getZ(m)).applyMatrix4(e), 
            b.set(h.getX(m), h.getY(m), h.getZ(m)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), 
            f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
            f.needsUpdate = !0;
        };
    }(), Ie.prototype = Object.create(v.prototype), Ie.prototype.constructor = Ie, Ie.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
    }, Ie.prototype.update = function() {
        var a = new f(), b = new f();
        return function() {
            this.light.updateMatrixWorld();
            var c = this.light.distance ? this.light.distance : 1e3, d = c * Math.tan(this.light.angle);
            this.cone.scale.set(d, d, c), a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), 
            this.cone.lookAt(b.sub(a)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        };
    }(), Ke.prototype = Object.create(Jb.prototype), Ke.prototype.constructor = Ke, 
    Ke.prototype.updateMatrixWorld = function() {
        var a = new f(), b = new d(), c = new d();
        return function(d) {
            var e = this.bones, f = this.geometry, g = f.getAttribute("position");
            c.getInverse(this.root.matrixWorld);
            for (var h = 0, i = 0; h < e.length; h++) {
                var j = e[h];
                j.parent && j.parent.isBone && (b.multiplyMatrices(c, j.matrixWorld), a.setFromMatrixPosition(b), 
                g.setXYZ(i, a.x, a.y, a.z), b.multiplyMatrices(c, j.parent.matrixWorld), a.setFromMatrixPosition(b), 
                g.setXYZ(i + 1, a.x, a.y, a.z), i += 2);
            }
            f.getAttribute("position").needsUpdate = !0, v.prototype.updateMatrixWorld.call(this, d);
        };
    }(), Le.prototype = Object.create(W.prototype), Le.prototype.constructor = Le, Le.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose();
    }, Le.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }, Me.prototype = Object.create(v.prototype), Me.prototype.constructor = Me, Me.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }, Me.prototype.update = function() {
        var a = .5 * this.light.width, b = .5 * this.light.height, c = this.line.geometry.attributes.position, d = c.array;
        d[0] = a, d[1] = -b, d[2] = 0, d[3] = a, d[4] = b, d[5] = 0, d[6] = -a, d[7] = b, 
        d[8] = 0, d[9] = -a, d[10] = -b, d[11] = 0, d[12] = a, d[13] = -b, d[14] = 0, c.needsUpdate = !0, 
        void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
    }, Ne.prototype = Object.create(v.prototype), Ne.prototype.constructor = Ne, Ne.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }, Ne.prototype.update = function() {
        var a = new f(), b = new q(), c = new q();
        return function() {
            var d = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color); else {
                var e = d.geometry.getAttribute("color");
                b.copy(this.light.color), c.copy(this.light.groundColor);
                for (var f = 0, g = e.count; f < g; f++) {
                    var h = f < g / 2 ? b : c;
                    e.setXYZ(f, h.r, h.g, h.b);
                }
                e.needsUpdate = !0;
            }
            d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
        };
    }(), Oe.prototype = Object.create(Jb.prototype), Oe.prototype.constructor = Oe, 
    Pe.prototype = Object.create(Jb.prototype), Pe.prototype.constructor = Pe, Qe.prototype = Object.create(Jb.prototype), 
    Qe.prototype.constructor = Qe, Qe.prototype.update = function() {
        var a = new f(), b = new f(), c = new g();
        return function() {
            this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
            var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices;
            f = f.faces;
            for (var h = 0, i = 0, j = f.length; i < j; i++) {
                var k = f[i], l = k.normal;
                a.copy(g[k.a]).add(g[k.b]).add(g[k.c]).divideScalar(3).applyMatrix4(d), b.copy(l).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), 
                e.setXYZ(h, a.x, a.y, a.z), h += 1, e.setXYZ(h, b.x, b.y, b.z), h += 1;
            }
            e.needsUpdate = !0;
        };
    }(), Re.prototype = Object.create(v.prototype), Re.prototype.constructor = Re, Re.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), 
        this.targetLine.material.dispose();
    }, Re.prototype.update = function() {
        var a = new f(), b = new f(), c = new f();
        return function() {
            a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), 
            c.subVectors(b, a), this.lightPlane.lookAt(c), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), 
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), 
            this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(c), 
            this.targetLine.scale.z = c.length();
        };
    }(), Se.prototype = Object.create(Jb.prototype), Se.prototype.constructor = Se, 
    Se.prototype.update = function() {
        function a(a, f, g, h) {
            if (d.set(f, g, h).unproject(e), void 0 !== (a = c[a])) for (f = b.getAttribute("position"), 
            g = 0, h = a.length; g < h; g++) f.setXYZ(a[g], d.x, d.y, d.z);
        }
        var b, c, d = new f(), e = new w();
        return function() {
            b = this.geometry, c = this.pointMap, e.projectionMatrix.copy(this.camera.projectionMatrix), 
            a("c", 0, 0, -1), a("t", 0, 0, 1), a("n1", -1, -1, -1), a("n2", 1, -1, -1), a("n3", -1, 1, -1), 
            a("n4", 1, 1, -1), a("f1", -1, -1, 1), a("f2", 1, -1, 1), a("f3", -1, 1, 1), a("f4", 1, 1, 1), 
            a("u1", .7, 1.1, -1), a("u2", -.7, 1.1, -1), a("u3", 0, 2, -1), a("cf1", -1, 0, 1), 
            a("cf2", 1, 0, 1), a("cf3", 0, -1, 1), a("cf4", 0, 1, 1), a("cn1", -1, 0, -1), a("cn2", 1, 0, -1), 
            a("cn3", 0, -1, -1), a("cn4", 0, 1, -1), b.getAttribute("position").needsUpdate = !0;
        };
    }(), Te.prototype = Object.create(Jb.prototype), Te.prototype.constructor = Te, 
    Te.prototype.update = function() {
        var a = new m();
        return function(b) {
            if (void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments."), 
            void 0 !== this.object && a.setFromObject(this.object), !a.isEmpty()) {
                b = a.min;
                var c = a.max, d = this.geometry.attributes.position, e = d.array;
                e[0] = c.x, e[1] = c.y, e[2] = c.z, e[3] = b.x, e[4] = c.y, e[5] = c.z, e[6] = b.x, 
                e[7] = b.y, e[8] = c.z, e[9] = c.x, e[10] = b.y, e[11] = c.z, e[12] = c.x, e[13] = c.y, 
                e[14] = b.z, e[15] = b.x, e[16] = c.y, e[17] = b.z, e[18] = b.x, e[19] = b.y, e[20] = b.z, 
                e[21] = c.x, e[22] = b.y, e[23] = b.z, d.needsUpdate = !0, this.geometry.computeBoundingSphere();
            }
        };
    }(), Te.prototype.setFromObject = function(a) {
        return this.object = a, this.update(), this;
    }, Ue.prototype = Object.create(Jb.prototype), Ue.prototype.constructor = Ue, Ue.prototype.updateMatrixWorld = function(a) {
        var b = this.box;
        b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), 
        v.prototype.updateMatrixWorld.call(this, a));
    }, Ve.prototype = Object.create(Ib.prototype), Ve.prototype.constructor = Ve, Ve.prototype.updateMatrixWorld = function(a) {
        var b = -this.plane.constant;
        1e-8 > Math.abs(b) && (b = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, b), 
        this.children[0].material.side = 0 > b ? 1 : 0, this.lookAt(this.plane.normal), 
        v.prototype.updateMatrixWorld.call(this, a);
    };
    var Sf, Tf;
    We.prototype = Object.create(v.prototype), We.prototype.constructor = We, We.prototype.setDirection = function() {
        var a, b = new f();
        return function(c) {
            .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (b.set(c.z, 0, -c.x).normalize(), 
            a = Math.acos(c.y), this.quaternion.setFromAxisAngle(b, a));
        };
    }(), We.prototype.setLength = function(a, b, c) {
        void 0 === b && (b = .2 * a), void 0 === c && (c = .2 * b), this.line.scale.set(1, Math.max(0, a - b), 1), 
        this.line.updateMatrix(), this.cone.scale.set(c, b, c), this.cone.position.y = a, 
        this.cone.updateMatrix();
    }, We.prototype.setColor = function(a) {
        this.line.material.color.copy(a), this.cone.material.color.copy(a);
    }, Xe.prototype = Object.create(Jb.prototype), Xe.prototype.constructor = Xe, jd.create = function(a, b) {
        return console.log("THREE.Curve.create() has been deprecated"), a.prototype = Object.create(jd.prototype), 
        a.prototype.constructor = a, a.prototype.getPoint = b, a;
    }, Object.assign(yd.prototype, {
        createPointsGeometry: function(a) {
            return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), 
            a = this.getPoints(a), this.createGeometry(a);
        },
        createSpacedPointsGeometry: function(a) {
            return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), 
            a = this.getSpacedPoints(a), this.createGeometry(a);
        },
        createGeometry: function(a) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var b = new z(), c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                b.vertices.push(new f(e.x, e.y, e.z || 0));
            }
            return b;
        }
    }), Object.assign(zd.prototype, {
        fromPoints: function(a) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), 
            this.setFromPoints(a);
        }
    }), Ye.prototype = Object.create(nd.prototype), Ze.prototype = Object.create(nd.prototype), 
    $e.prototype = Object.create(nd.prototype), Object.assign($e.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.");
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.");
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
        }
    }), Oe.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    }, Ke.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    }, Object.assign(ae.prototype, {
        extractUrlBase: function(a) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), 
            Mf.extractUrlBase(a);
        }
    }), Object.assign(Ee.prototype, {
        center: function(a) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), 
            this.getCenter(a);
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        },
        isIntersectionBox: function(a) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(a);
        },
        size: function(a) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(a);
        }
    }), Object.assign(m.prototype, {
        center: function(a) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), 
            this.getCenter(a);
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        },
        isIntersectionBox: function(a) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(a);
        },
        isIntersectionSphere: function(a) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
            this.intersectsSphere(a);
        },
        size: function(a) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(a);
        }
    }), Fe.prototype.center = function(a) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), 
        this.getCenter(a);
    }, Object.assign(_e, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), 
            Math.random();
        },
        nearestPowerOfTwo: function(a) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), 
            _e.floorPowerOfTwo(a);
        },
        nextPowerOfTwo: function(a) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), 
            _e.ceilPowerOfTwo(a);
        }
    }), Object.assign(g.prototype, {
        flattenToArrayOffset: function(a, b) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), 
            this.toArray(a, b);
        },
        multiplyVector3: function(a) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), 
            a.applyMatrix3(this);
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
        },
        applyToBuffer: function(a) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), 
            this.applyToBufferAttribute(a);
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
        }
    }), Object.assign(d.prototype, {
        extractPosition: function(a) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), 
            this.copyPosition(a);
        },
        flattenToArrayOffset: function(a, b) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), 
            this.toArray(a, b);
        },
        getPosition: function() {
            var a;
            return function() {
                return void 0 === a && (a = new f()), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), 
                a.setFromMatrixColumn(this, 3);
            };
        }(),
        setRotationFromQuaternion: function(a) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), 
            this.makeRotationFromQuaternion(a);
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        },
        multiplyVector3: function(a) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
            a.applyMatrix4(this);
        },
        multiplyVector4: function(a) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
            a.applyMatrix4(this);
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
        },
        rotateAxis: function(a) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), 
            a.transformDirection(this);
        },
        crossVector: function(a) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
            a.applyMatrix4(this);
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.");
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        },
        applyToBuffer: function(a) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), 
            this.applyToBufferAttribute(a);
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
        },
        makeFrustum: function(a, b, c, d, e, f) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), 
            this.makePerspective(a, b, d, c, e, f);
        }
    }), o.prototype.isIntersectionLine = function(a) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), 
        this.intersectsLine(a);
    }, e.prototype.multiplyVector3 = function(a) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), 
        a.applyQuaternion(this);
    }, Object.assign(U.prototype, {
        isIntersectionBox: function(a) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(a);
        },
        isIntersectionPlane: function(a) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), 
            this.intersectsPlane(a);
        },
        isIntersectionSphere: function(a) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
            this.intersectsSphere(a);
        }
    }), Object.assign(V.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), 
            this.getArea();
        },
        barycoordFromPoint: function(a, b) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), 
            this.getBarycoord(a, b);
        },
        midpoint: function(a) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), 
            this.getMidpoint(a);
        },
        normal: function(a) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), 
            this.getNormal(a);
        },
        plane: function(a) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), 
            this.getPlane(a);
        }
    }), Object.assign(V, {
        barycoordFromPoint: function(a, b, c, d, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), 
            V.getBarycoord(a, b, c, d, e);
        },
        normal: function(a, b, c, d) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), 
            V.getNormal(a, b, c, d);
        }
    }), Object.assign(Ad.prototype, {
        extractAllPoints: function(a) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), 
            this.extractPoints(a);
        },
        extrude: function(a) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), 
            new Ac(this, a);
        },
        makeGeometry: function(a) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), 
            new Lc(this, a);
        }
    }), Object.assign(c.prototype, {
        fromAttribute: function(a, b, c) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
            this.fromBufferAttribute(a, b, c);
        },
        distanceToManhattan: function(a) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), 
            this.manhattanDistanceTo(a);
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), 
            this.manhattanLength();
        }
    }), Object.assign(f.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
        },
        getPositionFromMatrix: function(a) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), 
            this.setFromMatrixPosition(a);
        },
        getScaleFromMatrix: function(a) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), 
            this.setFromMatrixScale(a);
        },
        getColumnFromMatrix: function(a, b) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), 
            this.setFromMatrixColumn(b, a);
        },
        applyProjection: function(a) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), 
            this.applyMatrix4(a);
        },
        fromAttribute: function(a, b, c) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
            this.fromBufferAttribute(a, b, c);
        },
        distanceToManhattan: function(a) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), 
            this.manhattanDistanceTo(a);
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), 
            this.manhattanLength();
        }
    }), Object.assign(i.prototype, {
        fromAttribute: function(a, b, c) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
            this.fromBufferAttribute(a, b, c);
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), 
            this.manhattanLength();
        }
    }), Object.assign(z.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.");
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
        }
    }), Object.assign(v.prototype, {
        getChildByName: function(a) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), 
            this.getObjectByName(a);
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
        },
        translate: function(a, b) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), 
            this.translateOnAxis(b, a);
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
        }
    }), Object.defineProperties(v.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
            },
            set: function(a) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = a;
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            }
        }
    }), Object.defineProperties(Db.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
            }
        }
    }), Object.defineProperty(Eb.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        }
    }), Object.defineProperty(jd.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), 
            this.arcLengthDivisions;
        },
        set: function(a) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), 
            this.arcLengthDivisions = a;
        }
    }), rb.prototype.setLens = function(a, b) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), 
        void 0 !== b && (this.filmGauge = b), this.setFocalLength(a);
    }, Object.defineProperties(Bd.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.");
            }
        },
        shadowCameraFov: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = a;
            }
        },
        shadowCameraLeft: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = a;
            }
        },
        shadowCameraRight: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = a;
            }
        },
        shadowCameraTop: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = a;
            }
        },
        shadowCameraBottom: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), 
                this.shadow.camera.bottom = a;
            }
        },
        shadowCameraNear: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = a;
            }
        },
        shadowCameraFar: {
            set: function(a) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = a;
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
            }
        },
        shadowBias: {
            set: function(a) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = a;
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.");
            }
        },
        shadowMapWidth: {
            set: function(a) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = a;
            }
        },
        shadowMapHeight: {
            set: function(a) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = a;
            }
        }
    }), Object.defineProperties(A.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), 
                this.array.length;
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
        }
    }), Object.assign(M.prototype, {
        addIndex: function(a) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), 
            this.setIndex(a);
        },
        addDrawCall: function(a, b, c) {
            void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), 
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(a, b);
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), 
            this.clearGroups();
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
        }
    }), Object.defineProperties(M.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), 
                this.groups;
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), 
                this.groups;
            }
        }
    }), Object.assign(Bc.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
        }
    }), Object.defineProperties(ue.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), 
                this;
            }
        }
    }), Object.defineProperties(R.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.");
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new q();
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            },
            set: function(a) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), 
                this.flatShading = 1 === a;
            }
        }
    }), Object.defineProperties(Zc.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), 
                !1;
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
            }
        }
    }), Object.defineProperties(T.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), 
                this.extensions.derivatives;
            },
            set: function(a) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), 
                this.extensions.derivatives = a;
            }
        }
    }), Object.assign(vb.prototype, {
        animate: function(a) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(a);
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), 
            this.getRenderTarget();
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), 
            this.capabilities.getMaxAnisotropy();
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), 
            this.capabilities.precision;
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), 
            this.state.reset();
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), 
            this.extensions.get("OES_texture_float");
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), 
            this.extensions.get("OES_texture_half_float");
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), 
            this.extensions.get("OES_standard_derivatives");
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), 
            this.extensions.get("WEBGL_compressed_texture_s3tc");
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), 
            this.extensions.get("WEBGL_compressed_texture_pvrtc");
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), 
            this.extensions.get("EXT_blend_minmax");
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), 
            this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), 
            this.extensions.get("ANGLE_instanced_arrays");
        },
        enableScissorTest: function(a) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), 
            this.setScissorTest(a);
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
        }
    }), Object.defineProperties(vb.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), 
                this.shadowMap.enabled = a;
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = a;
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            }
        }
    }), Object.defineProperties(mb.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            }
        }
    }), Object.defineProperties(j.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = a;
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = a;
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
                this.texture.magFilter;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
                this.texture.magFilter = a;
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
                this.texture.minFilter;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
                this.texture.minFilter = a;
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
                this.texture.anisotropy;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
                this.texture.anisotropy = a;
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), 
                this.texture.offset;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = a;
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), 
                this.texture.repeat;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = a;
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), 
                this.texture.format;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = a;
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = a;
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
                this.texture.generateMipmaps;
            },
            set: function(a) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
                this.texture.generateMipmaps = a;
            }
        }
    }), Object.defineProperties(tb.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.");
            }
        },
        userHeight: {
            set: function() {
                console.warn("THREE.WebVRManager: .userHeight has been removed.");
            }
        }
    }), le.prototype.load = function(a) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var b = this;
        return new he().load(a, function(a) {
            b.setBuffer(a);
        }), this;
    }, ne.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), 
        this.getFrequencyData();
    }, je.prototype.updateCubeMap = function(a, b) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(a, b);
    }, af.crossOrigin = void 0, af.loadTexture = function(a, b, c, d) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var e = new id();
        return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), 
        a;
    }, af.loadTextureCube = function(a, b, c, d) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var e = new hd();
        return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), 
        a;
    }, af.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    }, af.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    }, a.WebGLRenderTargetCube = k, a.WebGLRenderTarget = j, a.WebGLRenderer = vb, a.ShaderLib = gf, 
    a.UniformsLib = ff, a.UniformsUtils = df, a.ShaderChunk = cf, a.FogExp2 = wb, a.Fog = xb, 
    a.Scene = yb, a.Sprite = Cb, a.LOD = Db, a.SkinnedMesh = Gb, a.Skeleton = Eb, a.Bone = Fb, 
    a.Mesh = W, a.LineSegments = Jb, a.LineLoop = Kb, a.Line = Ib, a.Points = Mb, a.Group = qb, 
    a.VideoTexture = Nb, a.DataTexture = l, a.CompressedTexture = Ob, a.CubeTexture = ga, 
    a.CanvasTexture = Pb, a.DepthTexture = Qb, a.Texture = h, a.CompressedTextureLoader = ed, 
    a.DataTextureLoader = fd, a.CubeTextureLoader = hd, a.TextureLoader = id, a.ObjectLoader = ce, 
    a.MaterialLoader = $d, a.BufferGeometryLoader = _d, a.DefaultLoadingManager = Df, 
    a.LoadingManager = cd, a.JSONLoader = be, a.ImageLoader = gd, a.ImageBitmapLoader = de, 
    a.FontLoader = ge, a.FileLoader = dd, a.Loader = ae, a.LoaderUtils = Mf, a.Cache = Cf, 
    a.AudioLoader = he, a.SpotLightShadow = Ed, a.SpotLight = Fd, a.PointLight = Gd, 
    a.RectAreaLight = Kd, a.HemisphereLight = Cd, a.DirectionalLightShadow = Hd, a.DirectionalLight = Id, 
    a.AmbientLight = Jd, a.LightShadow = Dd, a.Light = Bd, a.StereoCamera = ie, a.PerspectiveCamera = rb, 
    a.OrthographicCamera = x, a.CubeCamera = je, a.ArrayCamera = sb, a.Camera = w, a.AudioListener = ke, 
    a.PositionalAudio = me, a.AudioContext = Rf, a.AudioAnalyser = ne, a.Audio = le, 
    a.VectorKeyframeTrack = Wd, a.StringKeyframeTrack = Vd, a.QuaternionKeyframeTrack = Ud, 
    a.NumberKeyframeTrack = Sd, a.ColorKeyframeTrack = Rd, a.BooleanKeyframeTrack = Qd, 
    a.PropertyMixer = oe, a.PropertyBinding = qe, a.KeyframeTrack = Pd, a.AnimationUtils = Kf, 
    a.AnimationObjectGroup = re, a.AnimationMixer = te, a.AnimationClip = Xd, a.Uniform = ue, 
    a.InstancedBufferGeometry = ve, a.BufferGeometry = M, a.Geometry = z, a.InterleavedBufferAttribute = Ab, 
    a.InstancedInterleavedBuffer = we, a.InterleavedBuffer = zb, a.InstancedBufferAttribute = xe, 
    a.Face3 = y, a.Object3D = v, a.Raycaster = ye, a.Layers = u, a.EventDispatcher = b, 
    a.Clock = Be, a.QuaternionLinearInterpolant = Td, a.LinearInterpolant = Nd, a.DiscreteInterpolant = Od, 
    a.CubicInterpolant = Md, a.Interpolant = Ld, a.Triangle = V, a.Math = _e, a.Spherical = Ce, 
    a.Cylindrical = De, a.Plane = o, a.Frustum = p, a.Sphere = n, a.Ray = U, a.Matrix4 = d, 
    a.Matrix3 = g, a.Box3 = m, a.Box2 = Ee, a.Line3 = Fe, a.Euler = t, a.Vector4 = i, 
    a.Vector3 = f, a.Vector2 = c, a.Quaternion = e, a.Color = q, a.ImmediateRenderObject = Ge, 
    a.VertexNormalsHelper = He, a.SpotLightHelper = Ie, a.SkeletonHelper = Ke, a.PointLightHelper = Le, 
    a.RectAreaLightHelper = Me, a.HemisphereLightHelper = Ne, a.GridHelper = Oe, a.PolarGridHelper = Pe, 
    a.FaceNormalsHelper = Qe, a.DirectionalLightHelper = Re, a.CameraHelper = Se, a.BoxHelper = Te, 
    a.Box3Helper = Ue, a.PlaneHelper = Ve, a.ArrowHelper = We, a.AxesHelper = Xe, a.Shape = Ad, 
    a.Path = zd, a.ShapePath = ee, a.Font = fe;
    a.CurvePath = yd, a.Curve = jd, a.ImageUtils = af, a.ShapeUtils = yf, a.WebGLUtils = pb, 
    a.WireframeGeometry = Rb, a.ParametricGeometry = Sb, a.ParametricBufferGeometry = Tb, 
    a.TetrahedronGeometry = Wb, a.TetrahedronBufferGeometry = Xb, a.OctahedronGeometry = Yb, 
    a.OctahedronBufferGeometry = Zb, a.IcosahedronGeometry = $b, a.IcosahedronBufferGeometry = _b, 
    a.DodecahedronGeometry = ac, a.DodecahedronBufferGeometry = bc, a.PolyhedronGeometry = Ub, 
    a.PolyhedronBufferGeometry = Vb, a.TubeGeometry = cc, a.TubeBufferGeometry = dc, 
    a.TorusKnotGeometry = ec, a.TorusKnotBufferGeometry = fc, a.TorusGeometry = gc, 
    a.TorusBufferGeometry = hc, a.TextGeometry = Dc, a.TextBufferGeometry = Ec, a.SphereGeometry = Fc, 
    a.SphereBufferGeometry = Gc, a.RingGeometry = Hc, a.RingBufferGeometry = Ic, a.PlaneGeometry = P, 
    a.PlaneBufferGeometry = Q, a.LatheGeometry = Jc, a.LatheBufferGeometry = Kc, a.ShapeGeometry = Lc, 
    a.ShapeBufferGeometry = Mc, a.ExtrudeGeometry = Ac, a.ExtrudeBufferGeometry = Bc, 
    a.EdgesGeometry = Oc, a.ConeGeometry = Rc, a.ConeBufferGeometry = Sc, a.CylinderGeometry = Pc, 
    a.CylinderBufferGeometry = Qc, a.CircleGeometry = Tc, a.CircleBufferGeometry = Uc, 
    a.BoxGeometry = N, a.BoxBufferGeometry = O, a.ShadowMaterial = Vc, a.SpriteMaterial = Bb, 
    a.RawShaderMaterial = Wc, a.ShaderMaterial = T, a.PointsMaterial = Lb, a.MeshPhysicalMaterial = Yc, 
    a.MeshStandardMaterial = Xc, a.MeshPhongMaterial = Zc, a.MeshToonMaterial = $c, 
    a.MeshNormalMaterial = _c, a.MeshLambertMaterial = ad, a.MeshDepthMaterial = kb, 
    a.MeshDistanceMaterial = lb, a.MeshBasicMaterial = S, a.LineDashedMaterial = bd, 
    a.LineBasicMaterial = Hb, a.Material = R, a.Float64BufferAttribute = J, a.Float32BufferAttribute = I, 
    a.Uint32BufferAttribute = H, a.Int32BufferAttribute = G, a.Uint16BufferAttribute = F, 
    a.Int16BufferAttribute = E, a.Uint8ClampedBufferAttribute = D, a.Uint8BufferAttribute = C, 
    a.Int8BufferAttribute = B, a.BufferAttribute = A, a.ArcCurve = ld, a.CatmullRomCurve3 = nd, 
    a.CubicBezierCurve = rd, a.CubicBezierCurve3 = sd, a.EllipseCurve = kd, a.LineCurve = td, 
    a.LineCurve3 = ud, a.QuadraticBezierCurve = vd, a.QuadraticBezierCurve3 = wd, a.SplineCurve = xd, 
    a.REVISION = "96", a.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, a.CullFaceNone = 0, a.CullFaceBack = 1, a.CullFaceFront = 2, a.CullFaceFrontBack = 3, 
    a.FrontFaceDirectionCW = 0, a.FrontFaceDirectionCCW = 1, a.BasicShadowMap = 0, a.PCFShadowMap = 1, 
    a.PCFSoftShadowMap = 2, a.FrontSide = 0, a.BackSide = 1, a.DoubleSide = 2, a.FlatShading = 1, 
    a.SmoothShading = 2, a.NoColors = 0, a.FaceColors = 1, a.VertexColors = 2, a.NoBlending = 0, 
    a.NormalBlending = 1, a.AdditiveBlending = 2, a.SubtractiveBlending = 3, a.MultiplyBlending = 4, 
    a.CustomBlending = 5, a.AddEquation = 100, a.SubtractEquation = 101, a.ReverseSubtractEquation = 102, 
    a.MinEquation = 103, a.MaxEquation = 104, a.ZeroFactor = 200, a.OneFactor = 201, 
    a.SrcColorFactor = 202, a.OneMinusSrcColorFactor = 203, a.SrcAlphaFactor = 204, 
    a.OneMinusSrcAlphaFactor = 205, a.DstAlphaFactor = 206, a.OneMinusDstAlphaFactor = 207, 
    a.DstColorFactor = 208, a.OneMinusDstColorFactor = 209, a.SrcAlphaSaturateFactor = 210, 
    a.NeverDepth = 0, a.AlwaysDepth = 1, a.LessDepth = 2, a.LessEqualDepth = 3, a.EqualDepth = 4, 
    a.GreaterEqualDepth = 5, a.GreaterDepth = 6, a.NotEqualDepth = 7, a.MultiplyOperation = 0, 
    a.MixOperation = 1, a.AddOperation = 2, a.NoToneMapping = 0, a.LinearToneMapping = 1, 
    a.ReinhardToneMapping = 2, a.Uncharted2ToneMapping = 3, a.CineonToneMapping = 4, 
    a.UVMapping = 300, a.CubeReflectionMapping = 301, a.CubeRefractionMapping = 302, 
    a.EquirectangularReflectionMapping = 303, a.EquirectangularRefractionMapping = 304, 
    a.SphericalReflectionMapping = 305, a.CubeUVReflectionMapping = 306, a.CubeUVRefractionMapping = 307, 
    a.RepeatWrapping = 1e3, a.ClampToEdgeWrapping = 1001, a.MirroredRepeatWrapping = 1002, 
    a.NearestFilter = 1003, a.NearestMipMapNearestFilter = 1004, a.NearestMipMapLinearFilter = 1005, 
    a.LinearFilter = 1006, a.LinearMipMapNearestFilter = 1007, a.LinearMipMapLinearFilter = 1008, 
    a.UnsignedByteType = 1009, a.ByteType = 1010, a.ShortType = 1011, a.UnsignedShortType = 1012, 
    a.IntType = 1013, a.UnsignedIntType = 1014, a.FloatType = 1015, a.HalfFloatType = 1016, 
    a.UnsignedShort4444Type = 1017, a.UnsignedShort5551Type = 1018, a.UnsignedShort565Type = 1019, 
    a.UnsignedInt248Type = 1020, a.AlphaFormat = 1021, a.RGBFormat = 1022, a.RGBAFormat = 1023, 
    a.LuminanceFormat = 1024, a.LuminanceAlphaFormat = 1025, a.RGBEFormat = 1023, a.DepthFormat = 1026, 
    a.DepthStencilFormat = 1027, a.RGB_S3TC_DXT1_Format = 33776, a.RGBA_S3TC_DXT1_Format = 33777, 
    a.RGBA_S3TC_DXT3_Format = 33778, a.RGBA_S3TC_DXT5_Format = 33779, a.RGB_PVRTC_4BPPV1_Format = 35840, 
    a.RGB_PVRTC_2BPPV1_Format = 35841, a.RGBA_PVRTC_4BPPV1_Format = 35842, a.RGBA_PVRTC_2BPPV1_Format = 35843, 
    a.RGB_ETC1_Format = 36196, a.RGBA_ASTC_4x4_Format = 37808, a.RGBA_ASTC_5x4_Format = 37809, 
    a.RGBA_ASTC_5x5_Format = 37810, a.RGBA_ASTC_6x5_Format = 37811, a.RGBA_ASTC_6x6_Format = 37812, 
    a.RGBA_ASTC_8x5_Format = 37813, a.RGBA_ASTC_8x6_Format = 37814, a.RGBA_ASTC_8x8_Format = 37815, 
    a.RGBA_ASTC_10x5_Format = 37816, a.RGBA_ASTC_10x6_Format = 37817, a.RGBA_ASTC_10x8_Format = 37818, 
    a.RGBA_ASTC_10x10_Format = 37819, a.RGBA_ASTC_12x10_Format = 37820;
    a.RGBA_ASTC_12x12_Format = 37821, a.LoopOnce = 2200, a.LoopRepeat = 2201, a.LoopPingPong = 2202, 
    a.InterpolateDiscrete = 2300, a.InterpolateLinear = 2301, a.InterpolateSmooth = 2302, 
    a.ZeroCurvatureEnding = 2400, a.ZeroSlopeEnding = 2401, a.WrapAroundEnding = 2402, 
    a.TrianglesDrawMode = 0, a.TriangleStripDrawMode = 1, a.TriangleFanDrawMode = 2, 
    a.LinearEncoding = 3e3, a.sRGBEncoding = 3001, a.GammaEncoding = 3007, a.RGBEEncoding = 3002, 
    a.LogLuvEncoding = 3003, a.RGBM7Encoding = 3004, a.RGBM16Encoding = 3005, a.RGBDEncoding = 3006, 
    a.BasicDepthPacking = 3200, a.RGBADepthPacking = 3201, a.TangentSpaceNormalMap = 0, 
    a.ObjectSpaceNormalMap = 1, a.CubeGeometry = N, a.Face4 = function(a, b, c, d, e, f, g) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), 
        new y(a, b, c, e, f, g);
    }, a.LineStrip = 0, a.LinePieces = 1, a.MeshFaceMaterial = function(a) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), 
        a;
    }, a.MultiMaterial = function(a) {
        return void 0 === a && (a = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), 
        a.isMultiMaterial = !0, a.materials = a, a.clone = function() {
            return a.slice();
        }, a;
    }, a.PointCloud = function(a, b) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Mb(a, b);
    }, a.Particle = function(a) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Cb(a);
    }, a.ParticleSystem = function(a, b) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Mb(a, b);
    }, a.PointCloudMaterial = function(a) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), 
        new Lb(a);
    }, a.ParticleBasicMaterial = function(a) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), 
        new Lb(a);
    }, a.ParticleSystemMaterial = function(a) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), 
        new Lb(a);
    }, a.Vertex = function(a, b, c) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), 
        new f(a, b, c);
    }, a.DynamicBufferAttribute = function(a, b) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), 
        new A(a, b).setDynamic(!0);
    }, a.Int8Attribute = function(a, b) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), 
        new B(a, b);
    }, a.Uint8Attribute = function(a, b) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), 
        new C(a, b);
    }, a.Uint8ClampedAttribute = function(a, b) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), 
        new D(a, b);
    }, a.Int16Attribute = function(a, b) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), 
        new E(a, b);
    }, a.Uint16Attribute = function(a, b) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), 
        new F(a, b);
    }, a.Int32Attribute = function(a, b) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), 
        new G(a, b);
    }, a.Uint32Attribute = function(a, b) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), 
        new H(a, b);
    }, a.Float32Attribute = function(a, b) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), 
        new I(a, b);
    }, a.Float64Attribute = function(a, b) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), 
        new J(a, b);
    }, a.ClosedSplineCurve3 = Ye, a.SplineCurve3 = Ze, a.Spline = $e, a.AxisHelper = function(a) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Xe(a);
    }, a.BoundingBoxHelper = function(a, b) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), 
        new Te(a, b);
    }, a.EdgesHelper = function(a, b) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), 
        new Jb(new Oc(a.geometry), new Hb({
            color: void 0 !== b ? b : 16777215
        }));
    }, a.WireframeHelper = function(a, b) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), 
        new Jb(new Rb(a.geometry), new Hb({
            color: void 0 !== b ? b : 16777215
        }));
    }, a.XHRLoader = function(a) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new dd(a);
    }, a.BinaryTextureLoader = function(a) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), 
        new fd(a);
    }, a.GeometryUtils = {
        merge: function(a, b, c) {
            if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), 
            b.isMesh) {
                b.matrixAutoUpdate && b.updateMatrix();
                var d = b.matrix;
                b = b.geometry;
            }
            a.merge(b, d, c);
        },
        center: function(a) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), 
            a.center();
        }
    }, a.Projector = function() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), 
        this.projectVector = function(a, b) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), a.project(b);
        }, this.unprojectVector = function(a, b) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), 
            a.unproject(b);
        }, this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
        };
    }, a.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), 
        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), 
        this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, 
        this.setSize = function() {};
    }, a.SceneUtils = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
        }
    }, a.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
    }, Object.defineProperty(a, "__esModule", {
        value: !0
    });
}), THREE.OBJLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.OBJLoader.prototype = {
    constructor: THREE.OBJLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.XHRLoader(e.manager);
        f.setCrossOrigin(this.crossOrigin), f.load(a, function(a) {
            b(e.parse(a));
        });
    },
    parse: function(a) {
        function b(a, b, c) {
            return new THREE.Vector3(a, b, c);
        }
        function c(a, b) {
            return new THREE.Vector2(a, b);
        }
        function d(a, b, c, d) {
            return new THREE.Face3(a, b, c, d);
        }
        function e(a, b, c, e) {
            void 0 === e ? h.faces.push(d(parseInt(a) - (l + 1), parseInt(b) - (l + 1), parseInt(c) - (l + 1))) : h.faces.push(d(parseInt(a) - (l + 1), parseInt(b) - (l + 1), parseInt(c) - (l + 1), [ m[parseInt(e[0]) - 1].clone(), m[parseInt(e[1]) - 1].clone(), m[parseInt(e[2]) - 1].clone() ]));
        }
        function f(a, b, c) {
            h.faceVertexUvs[0].push([ n[parseInt(a) - 1].clone(), n[parseInt(b) - 1].clone(), n[parseInt(c) - 1].clone() ]);
        }
        function g(a, b, c) {
            void 0 === a[3] ? (e(a[0], a[1], a[2], c), void 0 !== b && b.length > 0 && f(b[0], b[1], b[2])) : (void 0 !== c && c.length > 0 ? (e(a[0], a[1], a[3], [ c[0], c[1], c[3] ]), 
            e(a[1], a[2], a[3], [ c[1], c[2], c[3] ])) : (e(a[0], a[1], a[3]), e(a[1], a[2], a[3])), 
            void 0 !== b && b.length > 0 && (f(b[0], b[1], b[3]), f(b[1], b[2], b[3])));
        }
        var h, i, j, k = new THREE.Object3D(), l = 0;
        !1 === /^o /gm.test(a) && (h = new THREE.Geometry(), i = new THREE.MeshLambertMaterial(), 
        j = new THREE.Mesh(h, i), k.add(j));
        for (var m = [], n = [], o = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, p = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, q = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, r = /f( +\d+)( +\d+)( +\d+)( +\d+)?/, s = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/, t = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/, u = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/, v = a.split("\n"), w = 0; w < v.length; w++) {
            var x = v[w];
            x = x.trim();
            var y;
            0 !== x.length && "#" !== x.charAt(0) && (null !== (y = o.exec(x)) ? h.vertices.push(b(parseFloat(y[1]), parseFloat(y[2]), parseFloat(y[3]))) : null !== (y = p.exec(x)) ? m.push(b(parseFloat(y[1]), parseFloat(y[2]), parseFloat(y[3]))) : null !== (y = q.exec(x)) ? n.push(c(parseFloat(y[1]), parseFloat(y[2]))) : null !== (y = r.exec(x)) ? g([ y[1], y[2], y[3], y[4] ]) : null !== (y = s.exec(x)) ? g([ y[2], y[5], y[8], y[11] ], [ y[3], y[6], y[9], y[12] ]) : null !== (y = t.exec(x)) ? g([ y[2], y[6], y[10], y[14] ], [ y[3], y[7], y[11], y[15] ], [ y[4], y[8], y[12], y[16] ]) : null !== (y = u.exec(x)) ? g([ y[2], y[5], y[8], y[11] ], [], [ y[3], y[6], y[9], y[12] ]) : /^o /.test(x) ? (void 0 !== h && (l += h.vertices.length), 
            h = new THREE.Geometry(), i = new THREE.MeshLambertMaterial(), j = new THREE.Mesh(h, i), 
            j.name = x.substring(2).trim(), k.add(j), 0) : /^g /.test(x) || (/^usemtl /.test(x) ? i.name = x.substring(7).trim() : /^mtllib /.test(x) || /^s /.test(x)));
        }
        for (var w = 0, z = k.children.length; w < z; w++) {
            var h = k.children[w].geometry;
            h.computeCentroids(), h.computeFaceNormals(), h.computeBoundingSphere();
        }
        return k;
    }
}, window.Physijs = function() {
    "use strict";
    var a, b, c, d, e, f, g, h = !1, i = j, j = {}, k = new THREE.Vector3(), l = new THREE.Vector3(), m = new THREE.Matrix4(), n = new THREE.Quaternion(), o = {
        WORLDREPORT: 0,
        COLLISIONREPORT: 1,
        VEHICLEREPORT: 2,
        CONSTRAINTREPORT: 3
    }, p = 9, q = 6;
    return j.scripts = {}, b = function() {
        this._eventListeners = {};
    }, b.prototype.addEventListener = function(a, b) {
        this._eventListeners.hasOwnProperty(a) || (this._eventListeners[a] = []), this._eventListeners[a].push(b);
    }, b.prototype.removeEventListener = function(a, b) {
        var c;
        return !!this._eventListeners.hasOwnProperty(a) && (c = this._eventListeners[a].indexOf(b)) >= 0 && (this._eventListeners[a].splice(c, 1), 
        !0);
    }, b.prototype.dispatchEvent = function(a) {
        var b, c = Array.prototype.splice.call(arguments, 1);
        if (this._eventListeners.hasOwnProperty(a)) for (b = 0; b < this._eventListeners[a].length; b++) this._eventListeners[a][b].apply(this, c);
    }, b.make = function(a) {
        a.prototype.addEventListener = b.prototype.addEventListener, a.prototype.removeEventListener = b.prototype.removeEventListener, 
        a.prototype.dispatchEvent = b.prototype.dispatchEvent;
    }, c = function() {
        var a = 1;
        return function() {
            return a++;
        };
    }(), d = function(a, b) {
        return m.identity(), m.identity().makeRotationFromQuaternion(b.quaternion), m.getInverse(m), 
        k.copy(a), l.copy(b.position), k.sub(l).applyMatrix4(m);
    }, j.noConflict = function() {
        return window.Physijs = i, j;
    }, j.createMaterial = function(a, b, c) {
        var d = function() {};
        return d.prototype = a, d = new d(), d._physijs = {
            id: a.id,
            friction: void 0 === b ? .8 : b,
            restitution: void 0 === c ? .2 : c
        }, d;
    }, j.PointConstraint = function(a, b, e) {
        void 0 === e && (e = b, b = void 0), this.type = "point", this.appliedImpulse = 0, 
        this.id = c(), this.objecta = a._physijs.id, this.positiona = d(e, a).clone(), b && (this.objectb = b._physijs.id, 
        this.positionb = d(e, b).clone());
    }, j.PointConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb
        };
    }, j.HingeConstraint = function(a, b, e, f) {
        void 0 === f && (f = e, e = b, b = void 0), this.type = "hinge", this.appliedImpulse = 0, 
        this.id = c(), this.scene = a.parent, this.objecta = a._physijs.id, this.positiona = d(e, a).clone(), 
        this.position = e.clone(), this.axis = f, b && (this.objectb = b._physijs.id, this.positionb = d(e, b).clone());
    }, j.HingeConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb,
            axis: this.axis
        };
    }, j.HingeConstraint.prototype.setLimits = function(a, b, c, d) {
        this.scene.execute("hinge_setLimits", {
            constraint: this.id,
            low: a,
            high: b,
            bias_factor: c,
            relaxation_factor: d
        });
    }, j.HingeConstraint.prototype.enableAngularMotor = function(a, b) {
        this.scene.execute("hinge_enableAngularMotor", {
            constraint: this.id,
            velocity: a,
            acceleration: b
        });
    }, j.HingeConstraint.prototype.disableMotor = function(a, b) {
        this.scene.execute("hinge_disableMotor", {
            constraint: this.id
        });
    }, j.SliderConstraint = function(a, b, e, f) {
        void 0 === f && (f = e, e = b, b = void 0), this.type = "slider", this.appliedImpulse = 0, 
        this.id = c(), this.scene = a.parent, this.objecta = a._physijs.id, this.positiona = d(e, a).clone(), 
        this.axis = f, b && (this.objectb = b._physijs.id, this.positionb = d(e, b).clone());
    }, j.SliderConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb,
            axis: this.axis
        };
    }, j.SliderConstraint.prototype.setLimits = function(a, b, c, d) {
        this.scene.execute("slider_setLimits", {
            constraint: this.id,
            lin_lower: a,
            lin_upper: b,
            ang_lower: c,
            ang_upper: d
        });
    }, j.SliderConstraint.prototype.setRestitution = function(a, b) {
        this.scene.execute("slider_setRestitution", {
            constraint: this.id,
            linear: a,
            angular: b
        });
    }, j.SliderConstraint.prototype.enableLinearMotor = function(a, b) {
        this.scene.execute("slider_enableLinearMotor", {
            constraint: this.id,
            velocity: a,
            acceleration: b
        });
    }, j.SliderConstraint.prototype.disableLinearMotor = function() {
        this.scene.execute("slider_disableLinearMotor", {
            constraint: this.id
        });
    }, j.SliderConstraint.prototype.enableAngularMotor = function(a, b) {
        this.scene.execute("slider_enableAngularMotor", {
            constraint: this.id,
            velocity: a,
            acceleration: b
        });
    }, j.SliderConstraint.prototype.disableAngularMotor = function() {
        this.scene.execute("slider_disableAngularMotor", {
            constraint: this.id
        });
    }, j.ConeTwistConstraint = function(a, b, e) {
        if (void 0 === e) throw "Both objects must be defined in a ConeTwistConstraint.";
        this.type = "conetwist", this.appliedImpulse = 0, this.id = c(), this.scene = a.parent, 
        this.objecta = a._physijs.id, this.positiona = d(e, a).clone(), this.objectb = b._physijs.id, 
        this.positionb = d(e, b).clone(), this.axisa = {
            x: a.rotation.x,
            y: a.rotation.y,
            z: a.rotation.z
        }, this.axisb = {
            x: b.rotation.x,
            y: b.rotation.y,
            z: b.rotation.z
        };
    }, j.ConeTwistConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb,
            axisa: this.axisa,
            axisb: this.axisb
        };
    }, j.ConeTwistConstraint.prototype.setLimit = function(a, b, c) {
        this.scene.execute("conetwist_setLimit", {
            constraint: this.id,
            x: a,
            y: b,
            z: c
        });
    }, j.ConeTwistConstraint.prototype.enableMotor = function() {
        this.scene.execute("conetwist_enableMotor", {
            constraint: this.id
        });
    }, j.ConeTwistConstraint.prototype.setMaxMotorImpulse = function(a) {
        this.scene.execute("conetwist_setMaxMotorImpulse", {
            constraint: this.id,
            max_impulse: a
        });
    }, j.ConeTwistConstraint.prototype.setMotorTarget = function(a) {
        a instanceof THREE.Vector3 ? a = new THREE.Quaternion().setFromEuler(new THREE.Euler(a.x, a.y, a.z)) : a instanceof THREE.Euler ? a = new THREE.Quaternion().setFromEuler(a) : a instanceof THREE.Matrix4 && (a = new THREE.Quaternion().setFromRotationMatrix(a)), 
        this.scene.execute("conetwist_setMotorTarget", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z,
            w: a.w
        });
    }, j.ConeTwistConstraint.prototype.disableMotor = function() {
        this.scene.execute("conetwist_disableMotor", {
            constraint: this.id
        });
    }, j.DOFConstraint = function(a, b, e) {
        void 0 === e && (e = b, b = void 0), this.type = "dof", this.appliedImpulse = 0, 
        this.id = c(), this.scene = a.parent, this.objecta = a._physijs.id, this.positiona = d(e, a).clone(), 
        this.axisa = {
            x: a.rotation.x,
            y: a.rotation.y,
            z: a.rotation.z
        }, b && (this.objectb = b._physijs.id, this.positionb = d(e, b).clone(), this.axisb = {
            x: b.rotation.x,
            y: b.rotation.y,
            z: b.rotation.z
        });
    }, j.DOFConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb,
            axisa: this.axisa,
            axisb: this.axisb
        };
    }, j.DOFConstraint.prototype.setLinearLowerLimit = function(a) {
        this.scene.execute("dof_setLinearLowerLimit", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.DOFConstraint.prototype.setLinearUpperLimit = function(a) {
        this.scene.execute("dof_setLinearUpperLimit", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.DOFConstraint.prototype.setAngularLowerLimit = function(a) {
        this.scene.execute("dof_setAngularLowerLimit", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.DOFConstraint.prototype.setAngularUpperLimit = function(a) {
        this.scene.execute("dof_setAngularUpperLimit", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.DOFConstraint.prototype.enableAngularMotor = function(a) {
        this.scene.execute("dof_enableAngularMotor", {
            constraint: this.id,
            which: a
        });
    }, j.DOFConstraint.prototype.configureAngularMotor = function(a, b, c, d, e) {
        this.scene.execute("dof_configureAngularMotor", {
            constraint: this.id,
            which: a,
            low_angle: b,
            high_angle: c,
            velocity: d,
            max_force: e
        });
    }, j.DOFConstraint.prototype.disableAngularMotor = function(a) {
        this.scene.execute("dof_disableAngularMotor", {
            constraint: this.id,
            which: a
        });
    }, j.Scene = function(c) {
        var d = this;
        b.call(this), THREE.Scene.call(this), this._worker = new Worker(j.scripts.worker || "physijs_worker.js"), 
        this._worker.transferableMessage = this._worker.webkitPostMessage || this._worker.postMessage, 
        this._materials_ref_counts = {}, this._objects = {}, this._vehicles = {}, this._constraints = {};
        var e = new ArrayBuffer(1);
        this._worker.transferableMessage(e, [ e ]), a = 0 === e.byteLength, this._worker.onmessage = function(a) {
            var b, c = a.data;
            if (c instanceof ArrayBuffer && 1 !== c.byteLength && (c = new Float32Array(c)), 
            c instanceof Float32Array) switch (c[0]) {
              case o.WORLDREPORT:
                d._updateScene(c);
                break;

              case o.COLLISIONREPORT:
                d._updateCollisions(c);
                break;

              case o.VEHICLEREPORT:
                d._updateVehicles(c);
                break;

              case o.CONSTRAINTREPORT:
                d._updateConstraints(c);
            } else if (c.cmd) switch (c.cmd) {
              case "objectReady":
                b = c.params, d._objects[b] && d._objects[b].dispatchEvent("ready");
                break;

              case "worldReady":
                d.dispatchEvent("ready");
                break;

              case "vehicle":
                window.test = c;
                break;

              default:
                console.debug("Received: " + c.cmd), console.dir(c.params);
            } else switch (c[0]) {
              case o.WORLDREPORT:
                d._updateScene(c);
                break;

              case o.COLLISIONREPORT:
                d._updateCollisions(c);
                break;

              case o.VEHICLEREPORT:
                d._updateVehicles(c);
                break;

              case o.CONSTRAINTREPORT:
                d._updateConstraints(c);
            }
        }, c = c || {}, c.ammo = j.scripts.ammo || "ammo.js", c.fixedTimeStep = c.fixedTimeStep || 1 / 60, 
        c.rateLimit = c.rateLimit || !0, this.execute("init", c);
    }, j.Scene.prototype = new THREE.Scene(), j.Scene.prototype.constructor = j.Scene, 
    b.make(j.Scene), j.Scene.prototype._updateScene = function(b) {
        var c, d, e, f = b[1];
        for (d = 0; d < f; d++) e = 2 + 14 * d, void 0 !== (c = this._objects[b[e]]) && (!1 === c.__dirtyPosition && c.position.set(b[e + 1], b[e + 2], b[e + 3]), 
        !1 === c.__dirtyRotation && c.quaternion.set(b[e + 4], b[e + 5], b[e + 6], b[e + 7]), 
        c._physijs.linearVelocity.set(b[e + 8], b[e + 9], b[e + 10]), c._physijs.angularVelocity.set(b[e + 11], b[e + 12], b[e + 13]));
        a && this._worker.transferableMessage(b.buffer, [ b.buffer ]), h = !1, this.dispatchEvent("update");
    }, j.Scene.prototype._updateVehicles = function(b) {
        var c, d, e, f;
        for (e = 0; e < (b.length - 1) / p; e++) f = 1 + e * p, void 0 !== (c = this._vehicles[b[f]]) && (d = c.wheels[b[f + 1]], 
        d.position.set(b[f + 2], b[f + 3], b[f + 4]), d.quaternion.set(b[f + 5], b[f + 6], b[f + 7], b[f + 8]));
        a && this._worker.transferableMessage(b.buffer, [ b.buffer ]);
    }, j.Scene.prototype._updateConstraints = function(b) {
        var c, d, e, f;
        for (e = 0; e < (b.length - 1) / q; e++) f = 1 + e * q, c = this._constraints[b[f]], 
        d = this._objects[b[f + 1]], void 0 !== c && void 0 !== d && (k.set(b[f + 2], b[f + 3], b[f + 4]), 
        m.extractRotation(d.matrix), k.applyMatrix4(m), c.positiona.addVectors(d.position, k), 
        c.appliedImpulse = b[f + 5]);
        a && this._worker.transferableMessage(b.buffer, [ b.buffer ]);
    }, j.Scene.prototype._updateCollisions = function(b) {
        var c, d, e, h, i, j, l, m = {}, n = {};
        for (c = 0; c < b[1]; c++) e = 2 + 5 * c, h = b[e], i = b[e + 1], n[h + "-" + i] = e + 2, 
        n[i + "-" + h] = -1 * (e + 2), m[h] || (m[h] = []), m[h].push(i), m[i] || (m[i] = []), 
        m[i].push(h);
        for (j in this._objects) if (this._objects.hasOwnProperty(j)) if (h = this._objects[j], 
        m[j]) {
            for (d = 0; d < h._physijs.touches.length; d++) -1 === m[j].indexOf(h._physijs.touches[d]) && h._physijs.touches.splice(d--, 1);
            for (d = 0; d < m[j].length; d++) if (l = m[j][d], (i = this._objects[l]) && -1 === h._physijs.touches.indexOf(l)) {
                h._physijs.touches.push(l), k.subVectors(h.getLinearVelocity(), i.getLinearVelocity()), 
                f = k.clone(), k.subVectors(h.getAngularVelocity(), i.getAngularVelocity()), g = k.clone();
                var o = n[h._physijs.id + "-" + i._physijs.id];
                o > 0 ? k.set(-b[o], -b[o + 1], -b[o + 2]) : (o *= -1, k.set(b[o], b[o + 1], b[o + 2])), 
                h.dispatchEvent("collision", i, f, g, k);
            }
        } else h._physijs.touches.length = 0;
        this.collisions = m, a && this._worker.transferableMessage(b.buffer, [ b.buffer ]);
    }, j.Scene.prototype.addConstraint = function(a, b) {
        if (this._constraints[a.id] = a, this.execute("addConstraint", a.getDefinition()), 
        b) {
            var c;
            switch (a.type) {
              case "point":
              case "hinge":
                c = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshNormalMaterial()), 
                c.position.copy(a.positiona), this._objects[a.objecta].add(c);
                break;

              case "slider":
                c = new THREE.Mesh(new THREE.CubeGeometry(10, 1, 1), new THREE.MeshNormalMaterial()), 
                c.position.copy(a.positiona), c.rotation.set(a.axis.y, a.axis.x, a.axis.z), this._objects[a.objecta].add(c);
                break;

              case "conetwist":
              case "dof":
                c = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshNormalMaterial()), 
                c.position.copy(a.positiona), this._objects[a.objecta].add(c);
            }
        }
        return a;
    }, j.Scene.prototype.removeConstraint = function(a) {
        void 0 !== this._constraints[a.id] && (this.execute("removeConstraint", {
            id: a.id
        }), delete this._constraints[a.id]);
    }, j.Scene.prototype.execute = function(a, b) {
        this._worker.postMessage({
            cmd: a,
            params: b
        });
    }, e = function(a, b) {
        var c;
        for (c = 0; c < b.children.length; c++) b.children[c]._physijs && (b.children[c].updateMatrix(), 
        b.children[c].updateMatrixWorld(), k.getPositionFromMatrix(b.children[c].matrixWorld), 
        n.setFromRotationMatrix(b.children[c].matrixWorld), b.children[c]._physijs.position_offset = {
            x: k.x,
            y: k.y,
            z: k.z
        }, b.children[c]._physijs.rotation = {
            x: n.x,
            y: n.y,
            z: n.z,
            w: n.w
        }, a._physijs.children.push(b.children[c]._physijs)), e(a, b.children[c]);
    }, j.Scene.prototype.add = function(a) {
        THREE.Mesh.prototype.add.call(this, a), a._physijs && (a.world = this, a instanceof j.Vehicle ? (this.add(a.mesh), 
        this._vehicles[a._physijs.id] = a, this.execute("addVehicle", a._physijs)) : (a.__dirtyPosition = !1, 
        a.__dirtyRotation = !1, this._objects[a._physijs.id] = a, a.children.length && (a._physijs.children = [], 
        e(a, a)), a.material._physijs && (this._materials_ref_counts.hasOwnProperty(a.material._physijs.id) ? this._materials_ref_counts[a.material._physijs.id]++ : (this.execute("registerMaterial", a.material._physijs), 
        a._physijs.materialId = a.material._physijs.id, this._materials_ref_counts[a.material._physijs.id] = 1)), 
        a._physijs.position = {
            x: a.position.x,
            y: a.position.y,
            z: a.position.z
        }, a._physijs.rotation = {
            x: a.quaternion.x,
            y: a.quaternion.y,
            z: a.quaternion.z,
            w: a.quaternion.w
        }, new THREE.Vector3(1, 1, 1), a._physijs.width && (a._physijs.width *= a.scale.x), 
        a._physijs.height && (a._physijs.height *= a.scale.y), a._physijs.depth && (a._physijs.depth *= a.scale.z), 
        this.execute("addObject", a._physijs)));
    }, j.Scene.prototype.remove = function(a) {
        if (a instanceof j.Vehicle) {
            for (this.execute("removeVehicle", {
                id: a._physijs.id
            }); a.wheels.length; ) this.remove(a.wheels.pop());
            this.remove(a.mesh), delete this._vehicles[a._physijs.id];
        } else THREE.Mesh.prototype.remove.call(this, a), a._physijs && (delete this._objects[a._physijs.id], 
        this.execute("removeObject", {
            id: a._physijs.id
        }));
        a.material && a.material._physijs && this._materials_ref_counts.hasOwnProperty(a.material._physijs.id) && 0 == --this._materials_ref_counts[a.material._physijs.id] && (this.execute("unRegisterMaterial", a.material._physijs), 
        delete this._materials_ref_counts[a.material._physijs.id]);
    }, j.Scene.prototype.setFixedTimeStep = function(a) {
        a && this.execute("setFixedTimeStep", a);
    }, j.Scene.prototype.setGravity = function(a) {
        a && this.execute("setGravity", a);
    }, j.Scene.prototype.simulate = function(a, b) {
        var c, d, e;
        if (h) return !1;
        h = !0;
        for (c in this._objects) this._objects.hasOwnProperty(c) && (d = this._objects[c], 
        (d.__dirtyPosition || d.__dirtyRotation) && (e = {
            id: d._physijs.id
        }, d.__dirtyPosition && (e.pos = {
            x: d.position.x,
            y: d.position.y,
            z: d.position.z
        }, d.__dirtyPosition = !1), d.__dirtyRotation && (e.quat = {
            x: d.quaternion.x,
            y: d.quaternion.y,
            z: d.quaternion.z,
            w: d.quaternion.w
        }, d.__dirtyRotation = !1), this.execute("updateTransform", e)));
        return this.execute("simulate", {
            timeStep: a,
            maxSubSteps: b
        }), !0;
    }, j.Mesh = function(a, d, e) {
        a && (b.call(this), THREE.Mesh.call(this, a, d), a.boundingBox || a.computeBoundingBox(), 
        this._physijs = {
            type: null,
            id: c(),
            mass: e || 0,
            touches: [],
            linearVelocity: new THREE.Vector3(),
            angularVelocity: new THREE.Vector3()
        });
    }, j.Mesh.prototype = new THREE.Mesh(), j.Mesh.prototype.constructor = j.Mesh, b.make(j.Mesh), 
    j.Mesh.prototype.__defineGetter__("mass", function() {
        return this._physijs.mass;
    }), j.Mesh.prototype.__defineSetter__("mass", function(a) {
        this._physijs.mass = a, this.world && this.world.execute("updateMass", {
            id: this._physijs.id,
            mass: a
        });
    }), j.Mesh.prototype.applyCentralImpulse = function(a) {
        this.world && this.world.execute("applyCentralImpulse", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.Mesh.prototype.applyImpulse = function(a, b) {
        this.world && this.world.execute("applyImpulse", {
            id: this._physijs.id,
            impulse_x: a.x,
            impulse_y: a.y,
            impulse_z: a.z,
            x: b.x,
            y: b.y,
            z: b.z
        });
    }, j.Mesh.prototype.applyCentralForce = function(a) {
        this.world && this.world.execute("applyCentralForce", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.Mesh.prototype.applyForce = function(a, b) {
        this.world && this.world.execute("applyForce", {
            id: this._physijs.id,
            force_x: a.x,
            force_y: a.y,
            force_z: a.z,
            x: b.x,
            y: b.y,
            z: b.z
        });
    }, j.Mesh.prototype.getAngularVelocity = function() {
        return this._physijs.angularVelocity;
    }, j.Mesh.prototype.setAngularVelocity = function(a) {
        this.world && this.world.execute("setAngularVelocity", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.Mesh.prototype.getLinearVelocity = function() {
        return this._physijs.linearVelocity;
    }, j.Mesh.prototype.setLinearVelocity = function(a) {
        this.world && this.world.execute("setLinearVelocity", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.Mesh.prototype.setAngularFactor = function(a) {
        this.world && this.world.execute("setAngularFactor", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.Mesh.prototype.setLinearFactor = function(a) {
        this.world && this.world.execute("setLinearFactor", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, j.Mesh.prototype.setDamping = function(a, b) {
        this.world && this.world.execute("setDamping", {
            id: this._physijs.id,
            linear: a,
            angular: b
        });
    }, j.Mesh.prototype.setCcdMotionThreshold = function(a) {
        this.world && this.world.execute("setCcdMotionThreshold", {
            id: this._physijs.id,
            threshold: a
        });
    }, j.Mesh.prototype.setCcdSweptSphereRadius = function(a) {
        this.world && this.world.execute("setCcdSweptSphereRadius", {
            id: this._physijs.id,
            radius: a
        });
    }, j.PlaneMesh = function(a, b, c) {
        var d, e;
        j.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, this._physijs.type = "plane", this._physijs.normal = a.faces[0].normal.clone(), 
        this._physijs.mass = void 0 === c ? d * e : c;
    }, j.PlaneMesh.prototype = new j.Mesh(), j.PlaneMesh.prototype.constructor = j.PlaneMesh, 
    j.HeightfieldMesh = function(a, b, c, d, e) {
        j.Mesh.call(this, a, b, c), this._physijs.type = "heightfield", this._physijs.xsize = a.boundingBox.max.x - a.boundingBox.min.x, 
        this._physijs.ysize = a.boundingBox.max.y - a.boundingBox.min.y, this._physijs.xpts = void 0 === d ? Math.sqrt(a.vertices.length) : d + 1, 
        this._physijs.ypts = void 0 === e ? Math.sqrt(a.vertices.length) : e + 1, this._physijs.absMaxHeight = Math.max(a.boundingBox.max.z, Math.abs(a.boundingBox.min.z));
        for (var f, g, h = [], i = 0; i < a.vertices.length; i++) f = i % this._physijs.xpts, 
        g = Math.round(i / this._physijs.xpts - i % this._physijs.xpts / this._physijs.xpts), 
        h[i] = a.vertices[f + (this._physijs.ypts - g - 1) * this._physijs.ypts].z;
        this._physijs.points = h;
    }, j.HeightfieldMesh.prototype = new j.Mesh(), j.HeightfieldMesh.prototype.constructor = j.HeightfieldMesh, 
    j.BoxMesh = function(a, b, c) {
        var d, e, f;
        j.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, f = a.boundingBox.max.z - a.boundingBox.min.z, 
        this._physijs.type = "box", this._physijs.width = d, this._physijs.height = e, this._physijs.depth = f, 
        this._physijs.mass = void 0 === c ? d * e * f : c;
    }, j.BoxMesh.prototype = new j.Mesh(), j.BoxMesh.prototype.constructor = j.BoxMesh, 
    j.SphereMesh = function(a, b, c) {
        j.Mesh.call(this, a, b, c), a.boundingSphere || a.computeBoundingSphere(), this._physijs.type = "sphere", 
        this._physijs.radius = a.boundingSphere.radius, this._physijs.mass = void 0 === c ? 4 / 3 * Math.PI * Math.pow(this._physijs.radius, 3) : c;
    }, j.SphereMesh.prototype = new j.Mesh(), j.SphereMesh.prototype.constructor = j.SphereMesh, 
    j.CylinderMesh = function(a, b, c) {
        var d, e, f;
        j.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, f = a.boundingBox.max.z - a.boundingBox.min.z, 
        this._physijs.type = "cylinder", this._physijs.width = d, this._physijs.height = e, 
        this._physijs.depth = f, this._physijs.mass = void 0 === c ? d * e * f : c;
    }, j.CylinderMesh.prototype = new j.Mesh(), j.CylinderMesh.prototype.constructor = j.CylinderMesh, 
    j.CapsuleMesh = function(a, b, c) {
        var d, e, f;
        j.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, f = a.boundingBox.max.z - a.boundingBox.min.z, 
        this._physijs.type = "capsule", this._physijs.radius = Math.max(d / 2, f / 2), this._physijs.height = e, 
        this._physijs.mass = void 0 === c ? d * e * f : c;
    }, j.CapsuleMesh.prototype = new j.Mesh(), j.CapsuleMesh.prototype.constructor = j.CapsuleMesh, 
    j.ConeMesh = function(a, b, c) {
        var d, e;
        j.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, this._physijs.type = "cone", this._physijs.radius = d / 2, 
        this._physijs.height = e, this._physijs.mass = void 0 === c ? d * e : c;
    }, j.ConeMesh.prototype = new j.Mesh(), j.ConeMesh.prototype.constructor = j.ConeMesh, 
    j.ConcaveMesh = function(a, b, c) {
        var d, e, f, g, h, i, k = [];
        for (j.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), h = a.vertices, 
        d = 0; d < a.faces.length; d++) i = a.faces[d], i instanceof THREE.Face3 ? k.push([ {
            x: h[i.a].x,
            y: h[i.a].y,
            z: h[i.a].z
        }, {
            x: h[i.b].x,
            y: h[i.b].y,
            z: h[i.b].z
        }, {
            x: h[i.c].x,
            y: h[i.c].y,
            z: h[i.c].z
        } ]) : i instanceof THREE.Face4 && (k.push([ {
            x: h[i.a].x,
            y: h[i.a].y,
            z: h[i.a].z
        }, {
            x: h[i.b].x,
            y: h[i.b].y,
            z: h[i.b].z
        }, {
            x: h[i.d].x,
            y: h[i.d].y,
            z: h[i.d].z
        } ]), k.push([ {
            x: h[i.b].x,
            y: h[i.b].y,
            z: h[i.b].z
        }, {
            x: h[i.c].x,
            y: h[i.c].y,
            z: h[i.c].z
        }, {
            x: h[i.d].x,
            y: h[i.d].y,
            z: h[i.d].z
        } ]));
        e = a.boundingBox.max.x - a.boundingBox.min.x, f = a.boundingBox.max.y - a.boundingBox.min.y, 
        g = a.boundingBox.max.z - a.boundingBox.min.z, this._physijs.type = "concave", this._physijs.triangles = k, 
        this._physijs.mass = void 0 === c ? e * f * g : c;
    }, j.ConcaveMesh.prototype = new j.Mesh(), j.ConcaveMesh.prototype.constructor = j.ConcaveMesh, 
    j.ConvexMesh = function(a, b, c) {
        var d, e, f, g, h = [];
        for (j.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = 0; d < a.vertices.length; d++) h.push({
            x: a.vertices[d].x,
            y: a.vertices[d].y,
            z: a.vertices[d].z
        });
        e = a.boundingBox.max.x - a.boundingBox.min.x, f = a.boundingBox.max.y - a.boundingBox.min.y, 
        g = a.boundingBox.max.z - a.boundingBox.min.z, this._physijs.type = "convex", this._physijs.points = h, 
        this._physijs.mass = void 0 === c ? e * f * g : c;
    }, j.ConvexMesh.prototype = new j.Mesh(), j.ConvexMesh.prototype.constructor = j.ConvexMesh, 
    j.Vehicle = function(a, b) {
        b = b || new j.VehicleTuning(), this.mesh = a, this.wheels = [], this._physijs = {
            id: c(),
            rigidBody: a._physijs.id,
            suspension_stiffness: b.suspension_stiffness,
            suspension_compression: b.suspension_compression,
            suspension_damping: b.suspension_damping,
            max_suspension_travel: b.max_suspension_travel,
            friction_slip: b.friction_slip,
            max_suspension_force: b.max_suspension_force
        };
    }, j.Vehicle.prototype.addWheel = function(a, b, c, d, e, f, g, h, i) {
        var j = new THREE.Mesh(a, b);
        j.castShadow = j.receiveShadow = !0, j.position.copy(d).multiplyScalar(f / 100).add(c), 
        this.world.add(j), this.wheels.push(j), this.world.execute("addWheel", {
            id: this._physijs.id,
            connection_point: {
                x: c.x,
                y: c.y,
                z: c.z
            },
            wheel_direction: {
                x: d.x,
                y: d.y,
                z: d.z
            },
            wheel_axle: {
                x: e.x,
                y: e.y,
                z: e.z
            },
            suspension_rest_length: f,
            wheel_radius: g,
            is_front_wheel: h,
            tuning: i
        });
    }, j.Vehicle.prototype.setSteering = function(a, b) {
        if (void 0 !== b && void 0 !== this.wheels[b]) this.world.execute("setSteering", {
            id: this._physijs.id,
            wheel: b,
            steering: a
        }); else if (this.wheels.length > 0) for (var c = 0; c < this.wheels.length; c++) this.world.execute("setSteering", {
            id: this._physijs.id,
            wheel: c,
            steering: a
        });
    }, j.Vehicle.prototype.setBrake = function(a, b) {
        if (void 0 !== b && void 0 !== this.wheels[b]) this.world.execute("setBrake", {
            id: this._physijs.id,
            wheel: b,
            brake: a
        }); else if (this.wheels.length > 0) for (var c = 0; c < this.wheels.length; c++) this.world.execute("setBrake", {
            id: this._physijs.id,
            wheel: c,
            brake: a
        });
    }, j.Vehicle.prototype.applyEngineForce = function(a, b) {
        if (void 0 !== b && void 0 !== this.wheels[b]) this.world.execute("applyEngineForce", {
            id: this._physijs.id,
            wheel: b,
            force: a
        }); else if (this.wheels.length > 0) for (var c = 0; c < this.wheels.length; c++) this.world.execute("applyEngineForce", {
            id: this._physijs.id,
            wheel: c,
            force: a
        });
    }, j.VehicleTuning = function(a, b, c, d, e, f) {
        this.suspension_stiffness = void 0 !== a ? a : 5.88, this.suspension_compression = void 0 !== b ? b : .83, 
        this.suspension_damping = void 0 !== c ? c : .88, this.max_suspension_travel = void 0 !== d ? d : 500, 
        this.friction_slip = void 0 !== e ? e : 10.5, this.max_suspension_force = void 0 !== f ? f : 6e3;
    }, j;
}();

var TWEEN = TWEEN || function() {
    var a, b, c, d, e = [];
    return {
        start: function(a) {
            c = setInterval(this.update, 1e3 / (a || 60));
        },
        stop: function() {
            clearInterval(c);
        },
        add: function(a) {
            e.push(a);
        },
        getAll: function() {
            return e;
        },
        removeAll: function() {
            e = [];
        },
        remove: function(b) {
            -1 !== (a = e.indexOf(b)) && e.splice(a, 1);
        },
        update: function() {
            for (a = 0, b = e.length, d = new Date().getTime(); a < b; ) e[a].update(d) ? a++ : (e.splice(a, 1), 
            b--);
        }
    };
}();

TWEEN.Tween = function(a) {
    var b = {}, c = {}, d = {}, e = 1e3, f = 0, g = null, h = TWEEN.Easing.Linear.EaseNone, i = null, j = null, k = null;
    this.to = function(b, c) {
        null !== c && (e = c);
        for (var f in b) null !== a[f] && (d[f] = b[f]);
        return this;
    }, this.start = function() {
        TWEEN.add(this), g = new Date().getTime() + f;
        for (var e in d) null !== a[e] && (b[e] = a[e], c[e] = d[e] - a[e]);
        return this;
    }, this.stop = function() {
        return TWEEN.remove(this), this;
    }, this.delay = function(a) {
        return f = a, this;
    }, this.easing = function(a) {
        return h = a, this;
    }, this.chain = function(a) {
        i = a;
    }, this.onUpdate = function(a) {
        return j = a, this;
    }, this.onComplete = function(a) {
        return k = a, this;
    }, this.update = function(d) {
        var f, l;
        if (d < g) return !0;
        d = (d - g) / e, d = d > 1 ? 1 : d, l = h(d);
        for (f in c) a[f] = b[f] + c[f] * l;
        return null !== j && j.call(a, l), 1 != d || (null !== k && k.call(a), null !== i && i.start(), 
        !1);
    };
}, TWEEN.Easing = {
    Linear: {},
    Quadratic: {},
    Cubic: {},
    Quartic: {},
    Quintic: {},
    Sinusoidal: {},
    Exponential: {},
    Circular: {},
    Elastic: {},
    Back: {},
    Bounce: {}
}, TWEEN.Easing.Linear.EaseNone = function(a) {
    return a;
}, TWEEN.Easing.Quadratic.EaseIn = function(a) {
    return a * a;
}, TWEEN.Easing.Quadratic.EaseOut = function(a) {
    return -a * (a - 2);
}, TWEEN.Easing.Quadratic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1);
}, TWEEN.Easing.Cubic.EaseIn = function(a) {
    return a * a * a;
}, TWEEN.Easing.Cubic.EaseOut = function(a) {
    return --a * a * a + 1;
}, TWEEN.Easing.Cubic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2);
}, TWEEN.Easing.Quartic.EaseIn = function(a) {
    return a * a * a * a;
}, TWEEN.Easing.Quartic.EaseOut = function(a) {
    return -(--a * a * a * a - 1);
}, TWEEN.Easing.Quartic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2);
}, TWEEN.Easing.Quintic.EaseIn = function(a) {
    return a * a * a * a * a;
}, TWEEN.Easing.Quintic.EaseOut = function(a) {
    return (a -= 1) * a * a * a * a + 1;
}, TWEEN.Easing.Quintic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2);
}, TWEEN.Easing.Sinusoidal.EaseIn = function(a) {
    return 1 - Math.cos(a * Math.PI / 2);
}, TWEEN.Easing.Sinusoidal.EaseOut = function(a) {
    return Math.sin(a * Math.PI / 2);
}, TWEEN.Easing.Sinusoidal.EaseInOut = function(a) {
    return -.5 * (Math.cos(Math.PI * a) - 1);
}, TWEEN.Easing.Exponential.EaseIn = function(a) {
    return 0 == a ? 0 : Math.pow(2, 10 * (a - 1));
}, TWEEN.Easing.Exponential.EaseOut = function(a) {
    return 1 == a ? 1 : 1 - Math.pow(2, -10 * a);
}, TWEEN.Easing.Exponential.EaseInOut = function(a) {
    return 0 == a ? 0 : 1 == a ? 1 : (a *= 2) < 1 ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (2 - Math.pow(2, -10 * (a - 1)));
}, TWEEN.Easing.Circular.EaseIn = function(a) {
    return -(Math.sqrt(1 - a * a) - 1);
}, TWEEN.Easing.Circular.EaseOut = function(a) {
    return Math.sqrt(1 - --a * a);
}, TWEEN.Easing.Circular.EaseInOut = function(a) {
    return (a /= .5) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
}, TWEEN.Easing.Elastic.EaseIn = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3), !c || c < 1 ? (c = 1, b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c), 
    -c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d));
}, TWEEN.Easing.Elastic.EaseOut = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3), !c || c < 1 ? (c = 1, b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c), 
    c * Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / d) + 1);
}, TWEEN.Easing.Elastic.EaseInOut = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3), !c || c < 1 ? (c = 1, b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c), 
    (a *= 2) < 1 ? -.5 * c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d) : c * Math.pow(2, -10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d) * .5 + 1);
}, TWEEN.Easing.Back.EaseIn = function(a) {
    return a * a * (2.70158 * a - 1.70158);
}, TWEEN.Easing.Back.EaseOut = function(a) {
    return (a -= 1) * a * (2.70158 * a + 1.70158) + 1;
}, TWEEN.Easing.Back.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * (3.5949095 * a - 2.5949095) : .5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2);
}, TWEEN.Easing.Bounce.EaseIn = function(a) {
    return 1 - TWEEN.Easing.Bounce.EaseOut(1 - a);
}, TWEEN.Easing.Bounce.EaseOut = function(a) {
    return (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375;
}, TWEEN.Easing.Bounce.EaseInOut = function(a) {
    return a < .5 ? .5 * TWEEN.Easing.Bounce.EaseIn(2 * a) : .5 * TWEEN.Easing.Bounce.EaseOut(2 * a - 1) + .5;
}, function() {
    var a = this, b = a._, c = Array.prototype, d = Object.prototype, e = Function.prototype, f = c.push, g = c.slice, h = c.concat, i = d.toString, j = d.hasOwnProperty, k = Array.isArray, l = Object.keys, m = e.bind, n = function(a) {
        return a instanceof n ? a : this instanceof n ? void (this._wrapped = a) : new n(a);
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = n), 
    exports._ = n) : a._ = n, n.VERSION = "1.7.0";
    var o = function(a, b, c) {
        if (void 0 === b) return a;
        switch (null == c ? 3 : c) {
          case 1:
            return function(c) {
                return a.call(b, c);
            };

          case 2:
            return function(c, d) {
                return a.call(b, c, d);
            };

          case 3:
            return function(c, d, e) {
                return a.call(b, c, d, e);
            };

          case 4:
            return function(c, d, e, f) {
                return a.call(b, c, d, e, f);
            };
        }
        return function() {
            return a.apply(b, arguments);
        };
    };
    n.iteratee = function(a, b, c) {
        return null == a ? n.identity : n.isFunction(a) ? o(a, b, c) : n.isObject(a) ? n.matches(a) : n.property(a);
    }, n.each = n.forEach = function(a, b, c) {
        if (null == a) return a;
        b = o(b, c);
        var d, e = a.length;
        if (e === +e) for (d = 0; e > d; d++) b(a[d], d, a); else {
            var f = n.keys(a);
            for (d = 0, e = f.length; e > d; d++) b(a[f[d]], f[d], a);
        }
        return a;
    }, n.map = n.collect = function(a, b, c) {
        if (null == a) return [];
        b = n.iteratee(b, c);
        for (var d, e = a.length !== +a.length && n.keys(a), f = (e || a).length, g = Array(f), h = 0; f > h; h++) d = e ? e[h] : h, 
        g[h] = b(a[d], d, a);
        return g;
    };
    var p = "Reduce of empty array with no initial value";
    n.reduce = n.foldl = n.inject = function(a, b, c, d) {
        null == a && (a = []), b = o(b, d, 4);
        var e, f = a.length !== +a.length && n.keys(a), g = (f || a).length, h = 0;
        if (arguments.length < 3) {
            if (!g) throw new TypeError(p);
            c = a[f ? f[h++] : h++];
        }
        for (;g > h; h++) e = f ? f[h] : h, c = b(c, a[e], e, a);
        return c;
    }, n.reduceRight = n.foldr = function(a, b, c, d) {
        null == a && (a = []), b = o(b, d, 4);
        var e, f = a.length !== +a.length && n.keys(a), g = (f || a).length;
        if (arguments.length < 3) {
            if (!g) throw new TypeError(p);
            c = a[f ? f[--g] : --g];
        }
        for (;g--; ) e = f ? f[g] : g, c = b(c, a[e], e, a);
        return c;
    }, n.find = n.detect = function(a, b, c) {
        var d;
        return b = n.iteratee(b, c), n.some(a, function(a, c, e) {
            return b(a, c, e) ? (d = a, !0) : void 0;
        }), d;
    }, n.filter = n.select = function(a, b, c) {
        var d = [];
        return null == a ? d : (b = n.iteratee(b, c), n.each(a, function(a, c, e) {
            b(a, c, e) && d.push(a);
        }), d);
    }, n.reject = function(a, b, c) {
        return n.filter(a, n.negate(n.iteratee(b)), c);
    }, n.every = n.all = function(a, b, c) {
        if (null == a) return !0;
        b = n.iteratee(b, c);
        var d, e, f = a.length !== +a.length && n.keys(a), g = (f || a).length;
        for (d = 0; g > d; d++) if (e = f ? f[d] : d, !b(a[e], e, a)) return !1;
        return !0;
    }, n.some = n.any = function(a, b, c) {
        if (null == a) return !1;
        b = n.iteratee(b, c);
        var d, e, f = a.length !== +a.length && n.keys(a), g = (f || a).length;
        for (d = 0; g > d; d++) if (e = f ? f[d] : d, b(a[e], e, a)) return !0;
        return !1;
    }, n.contains = n.include = function(a, b) {
        return null != a && (a.length !== +a.length && (a = n.values(a)), n.indexOf(a, b) >= 0);
    }, n.invoke = function(a, b) {
        var c = g.call(arguments, 2), d = n.isFunction(b);
        return n.map(a, function(a) {
            return (d ? b : a[b]).apply(a, c);
        });
    }, n.pluck = function(a, b) {
        return n.map(a, n.property(b));
    }, n.where = function(a, b) {
        return n.filter(a, n.matches(b));
    }, n.findWhere = function(a, b) {
        return n.find(a, n.matches(b));
    }, n.max = function(a, b, c) {
        var d, e, f = -1 / 0, g = -1 / 0;
        if (null == b && null != a) {
            a = a.length === +a.length ? a : n.values(a);
            for (var h = 0, i = a.length; i > h; h++) (d = a[h]) > f && (f = d);
        } else b = n.iteratee(b, c), n.each(a, function(a, c, d) {
            ((e = b(a, c, d)) > g || e === -1 / 0 && f === -1 / 0) && (f = a, g = e);
        });
        return f;
    }, n.min = function(a, b, c) {
        var d, e, f = 1 / 0, g = 1 / 0;
        if (null == b && null != a) {
            a = a.length === +a.length ? a : n.values(a);
            for (var h = 0, i = a.length; i > h; h++) d = a[h], f > d && (f = d);
        } else b = n.iteratee(b, c), n.each(a, function(a, c, d) {
            e = b(a, c, d), (g > e || 1 / 0 === e && 1 / 0 === f) && (f = a, g = e);
        });
        return f;
    }, n.shuffle = function(a) {
        for (var b, c = a && a.length === +a.length ? a : n.values(a), d = c.length, e = Array(d), f = 0; d > f; f++) b = n.random(0, f), 
        b !== f && (e[f] = e[b]), e[b] = c[f];
        return e;
    }, n.sample = function(a, b, c) {
        return null == b || c ? (a.length !== +a.length && (a = n.values(a)), a[n.random(a.length - 1)]) : n.shuffle(a).slice(0, Math.max(0, b));
    }, n.sortBy = function(a, b, c) {
        return b = n.iteratee(b, c), n.pluck(n.map(a, function(a, c, d) {
            return {
                value: a,
                index: c,
                criteria: b(a, c, d)
            };
        }).sort(function(a, b) {
            var c = a.criteria, d = b.criteria;
            if (c !== d) {
                if (c > d || void 0 === c) return 1;
                if (d > c || void 0 === d) return -1;
            }
            return a.index - b.index;
        }), "value");
    };
    var q = function(a) {
        return function(b, c, d) {
            var e = {};
            return c = n.iteratee(c, d), n.each(b, function(d, f) {
                var g = c(d, f, b);
                a(e, d, g);
            }), e;
        };
    };
    n.groupBy = q(function(a, b, c) {
        n.has(a, c) ? a[c].push(b) : a[c] = [ b ];
    }), n.indexBy = q(function(a, b, c) {
        a[c] = b;
    }), n.countBy = q(function(a, b, c) {
        n.has(a, c) ? a[c]++ : a[c] = 1;
    }), n.sortedIndex = function(a, b, c, d) {
        c = n.iteratee(c, d, 1);
        for (var e = c(b), f = 0, g = a.length; g > f; ) {
            var h = f + g >>> 1;
            c(a[h]) < e ? f = h + 1 : g = h;
        }
        return f;
    }, n.toArray = function(a) {
        return a ? n.isArray(a) ? g.call(a) : a.length === +a.length ? n.map(a, n.identity) : n.values(a) : [];
    }, n.size = function(a) {
        return null == a ? 0 : a.length === +a.length ? a.length : n.keys(a).length;
    }, n.partition = function(a, b, c) {
        b = n.iteratee(b, c);
        var d = [], e = [];
        return n.each(a, function(a, c, f) {
            (b(a, c, f) ? d : e).push(a);
        }), [ d, e ];
    }, n.first = n.head = n.take = function(a, b, c) {
        return null == a ? void 0 : null == b || c ? a[0] : 0 > b ? [] : g.call(a, 0, b);
    }, n.initial = function(a, b, c) {
        return g.call(a, 0, Math.max(0, a.length - (null == b || c ? 1 : b)));
    }, n.last = function(a, b, c) {
        return null == a ? void 0 : null == b || c ? a[a.length - 1] : g.call(a, Math.max(a.length - b, 0));
    }, n.rest = n.tail = n.drop = function(a, b, c) {
        return g.call(a, null == b || c ? 1 : b);
    }, n.compact = function(a) {
        return n.filter(a, n.identity);
    };
    var r = function(a, b, c, d) {
        if (b && n.every(a, n.isArray)) return h.apply(d, a);
        for (var e = 0, g = a.length; g > e; e++) {
            var i = a[e];
            n.isArray(i) || n.isArguments(i) ? b ? f.apply(d, i) : r(i, b, c, d) : c || d.push(i);
        }
        return d;
    };
    n.flatten = function(a, b) {
        return r(a, b, !1, []);
    }, n.without = function(a) {
        return n.difference(a, g.call(arguments, 1));
    }, n.uniq = n.unique = function(a, b, c, d) {
        if (null == a) return [];
        n.isBoolean(b) || (d = c, c = b, b = !1), null != c && (c = n.iteratee(c, d));
        for (var e = [], f = [], g = 0, h = a.length; h > g; g++) {
            var i = a[g];
            if (b) g && f === i || e.push(i), f = i; else if (c) {
                var j = c(i, g, a);
                n.indexOf(f, j) < 0 && (f.push(j), e.push(i));
            } else n.indexOf(e, i) < 0 && e.push(i);
        }
        return e;
    }, n.union = function() {
        return n.uniq(r(arguments, !0, !0, []));
    }, n.intersection = function(a) {
        if (null == a) return [];
        for (var b = [], c = arguments.length, d = 0, e = a.length; e > d; d++) {
            var f = a[d];
            if (!n.contains(b, f)) {
                for (var g = 1; c > g && n.contains(arguments[g], f); g++) ;
                g === c && b.push(f);
            }
        }
        return b;
    }, n.difference = function(a) {
        var b = r(g.call(arguments, 1), !0, !0, []);
        return n.filter(a, function(a) {
            return !n.contains(b, a);
        });
    }, n.zip = function(a) {
        if (null == a) return [];
        for (var b = n.max(arguments, "length").length, c = Array(b), d = 0; b > d; d++) c[d] = n.pluck(arguments, d);
        return c;
    }, n.object = function(a, b) {
        if (null == a) return {};
        for (var c = {}, d = 0, e = a.length; e > d; d++) b ? c[a[d]] = b[d] : c[a[d][0]] = a[d][1];
        return c;
    }, n.indexOf = function(a, b, c) {
        if (null == a) return -1;
        var d = 0, e = a.length;
        if (c) {
            if ("number" != typeof c) return d = n.sortedIndex(a, b), a[d] === b ? d : -1;
            d = 0 > c ? Math.max(0, e + c) : c;
        }
        for (;e > d; d++) if (a[d] === b) return d;
        return -1;
    }, n.lastIndexOf = function(a, b, c) {
        if (null == a) return -1;
        var d = a.length;
        for ("number" == typeof c && (d = 0 > c ? d + c + 1 : Math.min(d, c + 1)); --d >= 0; ) if (a[d] === b) return d;
        return -1;
    }, n.range = function(a, b, c) {
        arguments.length <= 1 && (b = a || 0, a = 0), c = c || 1;
        for (var d = Math.max(Math.ceil((b - a) / c), 0), e = Array(d), f = 0; d > f; f++, 
        a += c) e[f] = a;
        return e;
    };
    var s = function() {};
    n.bind = function(a, b) {
        var c, d;
        if (m && a.bind === m) return m.apply(a, g.call(arguments, 1));
        if (!n.isFunction(a)) throw new TypeError("Bind must be called on a function");
        return c = g.call(arguments, 2), d = function() {
            if (!(this instanceof d)) return a.apply(b, c.concat(g.call(arguments)));
            s.prototype = a.prototype;
            var e = new s();
            s.prototype = null;
            var f = a.apply(e, c.concat(g.call(arguments)));
            return n.isObject(f) ? f : e;
        };
    }, n.partial = function(a) {
        var b = g.call(arguments, 1);
        return function() {
            for (var c = 0, d = b.slice(), e = 0, f = d.length; f > e; e++) d[e] === n && (d[e] = arguments[c++]);
            for (;c < arguments.length; ) d.push(arguments[c++]);
            return a.apply(this, d);
        };
    }, n.bindAll = function(a) {
        var b, c, d = arguments.length;
        if (1 >= d) throw new Error("bindAll must be passed function names");
        for (b = 1; d > b; b++) c = arguments[b], a[c] = n.bind(a[c], a);
        return a;
    }, n.memoize = function(a, b) {
        var c = function(d) {
            var e = c.cache, f = b ? b.apply(this, arguments) : d;
            return n.has(e, f) || (e[f] = a.apply(this, arguments)), e[f];
        };
        return c.cache = {}, c;
    }, n.delay = function(a, b) {
        var c = g.call(arguments, 2);
        return setTimeout(function() {
            return a.apply(null, c);
        }, b);
    }, n.defer = function(a) {
        return n.delay.apply(n, [ a, 1 ].concat(g.call(arguments, 1)));
    }, n.throttle = function(a, b, c) {
        var d, e, f, g = null, h = 0;
        c || (c = {});
        var i = function() {
            h = !1 === c.leading ? 0 : n.now(), g = null, f = a.apply(d, e), g || (d = e = null);
        };
        return function() {
            var j = n.now();
            h || !1 !== c.leading || (h = j);
            var k = b - (j - h);
            return d = this, e = arguments, 0 >= k || k > b ? (clearTimeout(g), g = null, h = j, 
            f = a.apply(d, e), g || (d = e = null)) : g || !1 === c.trailing || (g = setTimeout(i, k)), 
            f;
        };
    }, n.debounce = function(a, b, c) {
        var d, e, f, g, h, i = function() {
            var j = n.now() - g;
            b > j && j > 0 ? d = setTimeout(i, b - j) : (d = null, c || (h = a.apply(f, e), 
            d || (f = e = null)));
        };
        return function() {
            f = this, e = arguments, g = n.now();
            var j = c && !d;
            return d || (d = setTimeout(i, b)), j && (h = a.apply(f, e), f = e = null), h;
        };
    }, n.wrap = function(a, b) {
        return n.partial(b, a);
    }, n.negate = function(a) {
        return function() {
            return !a.apply(this, arguments);
        };
    }, n.compose = function() {
        var a = arguments, b = a.length - 1;
        return function() {
            for (var c = b, d = a[b].apply(this, arguments); c--; ) d = a[c].call(this, d);
            return d;
        };
    }, n.after = function(a, b) {
        return function() {
            return --a < 1 ? b.apply(this, arguments) : void 0;
        };
    }, n.before = function(a, b) {
        var c;
        return function() {
            return --a > 0 ? c = b.apply(this, arguments) : b = null, c;
        };
    }, n.once = n.partial(n.before, 2), n.keys = function(a) {
        if (!n.isObject(a)) return [];
        if (l) return l(a);
        var b = [];
        for (var c in a) n.has(a, c) && b.push(c);
        return b;
    }, n.values = function(a) {
        for (var b = n.keys(a), c = b.length, d = Array(c), e = 0; c > e; e++) d[e] = a[b[e]];
        return d;
    }, n.pairs = function(a) {
        for (var b = n.keys(a), c = b.length, d = Array(c), e = 0; c > e; e++) d[e] = [ b[e], a[b[e]] ];
        return d;
    }, n.invert = function(a) {
        for (var b = {}, c = n.keys(a), d = 0, e = c.length; e > d; d++) b[a[c[d]]] = c[d];
        return b;
    }, n.functions = n.methods = function(a) {
        var b = [];
        for (var c in a) n.isFunction(a[c]) && b.push(c);
        return b.sort();
    }, n.extend = function(a) {
        if (!n.isObject(a)) return a;
        for (var b, c, d = 1, e = arguments.length; e > d; d++) {
            b = arguments[d];
            for (c in b) j.call(b, c) && (a[c] = b[c]);
        }
        return a;
    }, n.pick = function(a, b, c) {
        var d, e = {};
        if (null == a) return e;
        if (n.isFunction(b)) {
            b = o(b, c);
            for (d in a) {
                var f = a[d];
                b(f, d, a) && (e[d] = f);
            }
        } else {
            var i = h.apply([], g.call(arguments, 1));
            a = new Object(a);
            for (var j = 0, k = i.length; k > j; j++) (d = i[j]) in a && (e[d] = a[d]);
        }
        return e;
    }, n.omit = function(a, b, c) {
        if (n.isFunction(b)) b = n.negate(b); else {
            var d = n.map(h.apply([], g.call(arguments, 1)), String);
            b = function(a, b) {
                return !n.contains(d, b);
            };
        }
        return n.pick(a, b, c);
    }, n.defaults = function(a) {
        if (!n.isObject(a)) return a;
        for (var b = 1, c = arguments.length; c > b; b++) {
            var d = arguments[b];
            for (var e in d) void 0 === a[e] && (a[e] = d[e]);
        }
        return a;
    }, n.clone = function(a) {
        return n.isObject(a) ? n.isArray(a) ? a.slice() : n.extend({}, a) : a;
    }, n.tap = function(a, b) {
        return b(a), a;
    };
    var t = function(a, b, c, d) {
        if (a === b) return 0 !== a || 1 / a == 1 / b;
        if (null == a || null == b) return a === b;
        a instanceof n && (a = a._wrapped), b instanceof n && (b = b._wrapped);
        var e = i.call(a);
        if (e !== i.call(b)) return !1;
        switch (e) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a == "" + b;

          case "[object Number]":
            return +a != +a ? +b != +b : 0 == +a ? 1 / +a == 1 / b : +a == +b;

          case "[object Date]":
          case "[object Boolean]":
            return +a == +b;
        }
        if ("object" != typeof a || "object" != typeof b) return !1;
        for (var f = c.length; f--; ) if (c[f] === a) return d[f] === b;
        var g = a.constructor, h = b.constructor;
        if (g !== h && "constructor" in a && "constructor" in b && !(n.isFunction(g) && g instanceof g && n.isFunction(h) && h instanceof h)) return !1;
        c.push(a), d.push(b);
        var j, k;
        if ("[object Array]" === e) {
            if (j = a.length, k = j === b.length) for (;j-- && (k = t(a[j], b[j], c, d)); ) ;
        } else {
            var l, m = n.keys(a);
            if (j = m.length, k = n.keys(b).length === j) for (;j-- && (l = m[j], k = n.has(b, l) && t(a[l], b[l], c, d)); ) ;
        }
        return c.pop(), d.pop(), k;
    };
    n.isEqual = function(a, b) {
        return t(a, b, [], []);
    }, n.isEmpty = function(a) {
        if (null == a) return !0;
        if (n.isArray(a) || n.isString(a) || n.isArguments(a)) return 0 === a.length;
        for (var b in a) if (n.has(a, b)) return !1;
        return !0;
    }, n.isElement = function(a) {
        return !(!a || 1 !== a.nodeType);
    }, n.isArray = k || function(a) {
        return "[object Array]" === i.call(a);
    }, n.isObject = function(a) {
        var b = typeof a;
        return "function" === b || "object" === b && !!a;
    }, n.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(a) {
        n["is" + a] = function(b) {
            return i.call(b) === "[object " + a + "]";
        };
    }), n.isArguments(arguments) || (n.isArguments = function(a) {
        return n.has(a, "callee");
    }), "function" != typeof /./ && (n.isFunction = function(a) {
        return "function" == typeof a || !1;
    }), n.isFinite = function(a) {
        return isFinite(a) && !isNaN(parseFloat(a));
    }, n.isNaN = function(a) {
        return n.isNumber(a) && a !== +a;
    }, n.isBoolean = function(a) {
        return !0 === a || !1 === a || "[object Boolean]" === i.call(a);
    }, n.isNull = function(a) {
        return null === a;
    }, n.isUndefined = function(a) {
        return void 0 === a;
    }, n.has = function(a, b) {
        return null != a && j.call(a, b);
    }, n.noConflict = function() {
        return a._ = b, this;
    }, n.identity = function(a) {
        return a;
    }, n.constant = function(a) {
        return function() {
            return a;
        };
    }, n.noop = function() {}, n.property = function(a) {
        return function(b) {
            return b[a];
        };
    }, n.matches = function(a) {
        var b = n.pairs(a), c = b.length;
        return function(a) {
            if (null == a) return !c;
            a = new Object(a);
            for (var d = 0; c > d; d++) {
                var e = b[d], f = e[0];
                if (e[1] !== a[f] || !(f in a)) return !1;
            }
            return !0;
        };
    }, n.times = function(a, b, c) {
        var d = Array(Math.max(0, a));
        b = o(b, c, 1);
        for (var e = 0; a > e; e++) d[e] = b(e);
        return d;
    }, n.random = function(a, b) {
        return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
    }, n.now = Date.now || function() {
        return new Date().getTime();
    };
    var u = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, v = n.invert(u), w = function(a) {
        var b = function(b) {
            return a[b];
        }, c = "(?:" + n.keys(a).join("|") + ")", d = RegExp(c), e = RegExp(c, "g");
        return function(a) {
            return a = null == a ? "" : "" + a, d.test(a) ? a.replace(e, b) : a;
        };
    };
    n.escape = w(u), n.unescape = w(v), n.result = function(a, b) {
        if (null != a) {
            var c = a[b];
            return n.isFunction(c) ? a[b]() : c;
        }
    };
    var x = 0;
    n.uniqueId = function(a) {
        var b = ++x + "";
        return a ? a + b : b;
    }, n.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var y = /(.)^/, z = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, A = /\\|'|\r|\n|\u2028|\u2029/g, B = function(a) {
        return "\\" + z[a];
    };
    n.template = function(a, b, c) {
        !b && c && (b = c), b = n.defaults({}, b, n.templateSettings);
        var d = RegExp([ (b.escape || y).source, (b.interpolate || y).source, (b.evaluate || y).source ].join("|") + "|$", "g"), e = 0, f = "__p+='";
        a.replace(d, function(b, c, d, g, h) {
            return f += a.slice(e, h).replace(A, B), e = h + b.length, c ? f += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'" : d ? f += "'+\n((__t=(" + d + "))==null?'':__t)+\n'" : g && (f += "';\n" + g + "\n__p+='"), 
            b;
        }), f += "';\n", b.variable || (f = "with(obj||{}){\n" + f + "}\n"), f = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + f + "return __p;\n";
        try {
            var g = new Function(b.variable || "obj", "_", f);
        } catch (a) {
            throw a.source = f, a;
        }
        var h = function(a) {
            return g.call(this, a, n);
        }, i = b.variable || "obj";
        return h.source = "function(" + i + "){\n" + f + "}", h;
    }, n.chain = function(a) {
        var b = n(a);
        return b._chain = !0, b;
    };
    var C = function(a) {
        return this._chain ? n(a).chain() : a;
    };
    n.mixin = function(a) {
        n.each(n.functions(a), function(b) {
            var c = n[b] = a[b];
            n.prototype[b] = function() {
                var a = [ this._wrapped ];
                return f.apply(a, arguments), C.call(this, c.apply(n, a));
            };
        });
    }, n.mixin(n), n.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(a) {
        var b = c[a];
        n.prototype[a] = function() {
            var c = this._wrapped;
            return b.apply(c, arguments), "shift" !== a && "splice" !== a || 0 !== c.length || delete c[0], 
            C.call(this, c);
        };
    }), n.each([ "concat", "join", "slice" ], function(a) {
        var b = c[a];
        n.prototype[a] = function() {
            return C.call(this, b.apply(this._wrapped, arguments));
        };
    }), n.prototype.value = function() {
        return this._wrapped;
    }, "function" == typeof define && define.amd && define("underscore", [], function() {
        return n;
    });
}.call(this);