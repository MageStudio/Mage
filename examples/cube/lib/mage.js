/*! mage version: 0.0.37, 04-12-2016 */
function ParticleTween(a, b) {
    this.times = a || [], this.values = b || [];
}

function Particle() {
    this.position = new THREE.Vector3(), this.velocity = new THREE.Vector3(), this.acceleration = new THREE.Vector3(), 
    this.angle = 0, this.angleVelocity = 0, this.angleAcceleration = 0, this.size = 16, 
    this.color = new THREE.Color(), this.opacity = 1, this.age = 0, this.alive = 0;
}

function ParticleEngine() {
    this.positionStyle = Type.CUBE, this.positionBase = new THREE.Vector3(), this.positionSpread = new THREE.Vector3(), 
    this.positionRadius = 0, this.velocityStyle = Type.CUBE, this.velocityBase = new THREE.Vector3(), 
    this.velocitySpread = new THREE.Vector3(), this.speedBase = 0, this.speedSpread = 0, 
    this.accelerationBase = new THREE.Vector3(), this.accelerationSpread = new THREE.Vector3(), 
    this.angleBase = 0, this.angleSpread = 0, this.angleVelocityBase = 0, this.angleVelocitySpread = 0, 
    this.angleAccelerationBase = 0, this.angleAccelerationSpread = 0, this.sizeBase = 0, 
    this.sizeSpread = 0, this.sizeTween = new ParticleTween(), this.colorBase = new THREE.Vector3(0, 1, .5), 
    this.colorSpread = new THREE.Vector3(0, 0, 0), this.colorTween = new ParticleTween(), 
    this.opacityBase = 1, this.opacitySpread = 0, this.opacityTween = new ParticleTween(), 
    this.blendStyle = THREE.NormalBlending, this.particleArray = [], this.particlesPerSecond = 100, 
    this.particleDeathAge = 1, this.emitterAge = 0, this.emitterAlive = !0, this.emitterDeathAge = 60, 
    this.particleCount = this.particlesPerSecond * Math.min(this.particleDeathAge, this.emitterDeathAge), 
    this.particleGeometry = new THREE.Geometry(), this.particleTexture = null, this.particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
            texture: {
                type: "t",
                value: this.particleTexture
            }
        },
        attributes: {
            customVisible: {
                type: "f",
                value: []
            },
            customAngle: {
                type: "f",
                value: []
            },
            customSize: {
                type: "f",
                value: []
            },
            customColor: {
                type: "c",
                value: []
            },
            customOpacity: {
                type: "f",
                value: []
            }
        },
        vertexShader: particleVertexShader,
        fragmentShader: particleFragmentShader,
        transparent: !0,
        blending: THREE.NormalBlending,
        depthTest: !0
    }), this.particleMesh = new THREE.Mesh();
}

function BEE() {
    this.options = void 0, this.nodes = [], this.size = 0, this.hasRoot = !1, this._idPool = [];
}

function _preEach(a, b, c) {
    if (c) {
        var d = b + 1;
        a(c, d), _preEach(a, b, c.leftBranch), _preEach(a, b, c.rightBranch);
    }
}

function _postEach(a, b, c) {
    if (c) {
        console.log("inside _postEach"), _postEach(a, b, c.leftBranch), _postEach(a, b, c.rightBranch);
        var d = b + 1;
        a(c, d);
    }
}

function _defEach(a, b, c) {
    if (c) {
        _defEach(a, b, c.leftBranch);
        var d = b + 1;
        a(c, d), _defEach(a, b, c.rightBranch);
    }
}

function _hasLTR(a, b, c) {
    return !!b && (!!c(a.data, b.data) || (_hasLTR(e, b.leftBranch) || _hasLTR(e, b.rightBranch)));
}

function _hasRTL(a, b, c) {
    return !!b && (!!c(a.data, b.data) || (_hasRTL(e, b.rightBranch) || _hasRTL(e, b.leftBranch)));
}

function _orderedHas(a, b, c) {
    return !!b && (0 == c(a.data, b.data) || (c(a.data, b.data) < 0 ? _orderedHas(a, b.leftBranch) : _orderedHas(a, b.rightBranch)));
}

function height(a) {
    return a ? 1 + Math.max(_height(a.leftBranch), _height(a.rightBranch)) : 0;
}

function _orderedIns(a, b, c) {
    return b ? (c(a.data, b.data) < 0 || 0 == c(a.data, b.data) ? b.leftBranch = _orderedIns(a, b.leftBranch) : b.rightBranch = _orderedIns(a, b.rightBranch), 
    b) : buildNode(data, void 0, void 0);
}

function buildNode(a, b, c) {
    var d = this.createNode(a);
    return d.addLeaf(b, {
        branch: "left"
    }), d.addLeaf(c, {
        branch: "right"
    }), d;
}

function Node(a) {
    if (!(a.tree && a.tree instanceof BEE)) throw BEE.VALID_BEE;
    this.tree = a.tree;
    for (var b = Math.random().toString(BEE.MAX_ID_SIZE).slice(2); this.tree._idPool.indexOf(b) > -1; ) b = Math.random().toString(BEE.MAX_ID_SIZE).slice(2);
    this.tree._idPool.push(b), this._id = b, Object.defineProperty(this, "_id", {
        set: function() {
            throw BEE.UNTOUCHABLE;
        },
        get: function() {
            return b;
        }
    }), this.data = a.data, this.tree.size += 1, this.tree.nodes.push(this), this.leftBranch = void 0, 
    this.rightBranch = void 0, this.rightWeight = void 0, this.leftWeight = void 0, 
    this._isRoot = !1, this._isLeaf = !1, this._isParent = !1, this.children = 0, this.parents = 0, 
    this.parent = void 0;
}

function Class(a, b) {
    var c = __upperCaseFirstLetter__(a);
    if (__pool__[c] = new __class__(c, b), !b[c]) throw "NO CONSTRUCTOR PROVIDED";
    window[c] = b[c];
    for (var d in b) d != a && (window[c].prototype[d] = b[d]);
    return window[c].prototype.__print__ = function() {
        console.table(this);
    }, __pool__[c];
}

function __upperCaseFirstLetter__(a) {
    return a.length > 2 ? a[0].toUpperCase() + a.substring(1, a.length) : a.toUpperCase();
}

function include(a, b) {
    for (var c, d, e, f = [], g = document.getElementsByTagName("script"), h = 0; h < g.length; h++) f.push(g[h].src);
    var i = function(a) {
        for (var b = 0; b < f.length; b++) if (f[b].indexOf(a) != -1) return !0;
        return !1;
    };
    if (a instanceof Array) {
        var j = 0;
        if (0 == a.length) return void console.log("Why are you triyng to include 0 scripts? This makes me sad.");
        for (var k = function() {
            j == a.length && b();
        }, l = 0; l < a.length; l++) i(a[l]) ? b && k() : (c = document.createElement("script"), 
        c.type = "text/javascript", c.src = a[l] + ".js", b && (c.onload = c.onreadystatechange = function() {
            this.readyState && "complete" != this.readyState || (j++, k());
        }), e = document.getElementsByTagName("script")[0], e.parentNode.insertBefore(c, e));
    } else "string" == typeof a && (i(a) ? b && b() : (d = !1, c = document.createElement("script"), 
    c.type = "text/javascript", c.src = a + ".js", b && (c.onload = c.onreadystatechange = function() {
        d || this.readyState && "complete" != this.readyState || (d = !0, b());
    }), e = document.getElementsByTagName("script")[0], e.parentNode.insertBefore(c, e)));
}

function randomColor() {
    for (var a = "0123456789ABCDEF".split(""), b = "#", c = 0; c < 6; c++) b += a[Math.floor(16 * Math.random())];
    return b;
}

function componentToHex(a) {
    var b = a.toString(16);
    return 1 == b.length ? "0" + b : b;
}

function rgbToHex(a, b, c) {
    return "0x" + componentToHex(a) + componentToHex(b) + componentToHex(c);
}

function getIntValueFromHex(a) {
    return parseInt(a, 16);
}

function HashMap() {
    0 == arguments.length ? (this.total = 0, this.keys = new Array(), this.maxDimension = void 0) : 1 == arguments.length && (isNaN(arguments[0]) ? (this.total = 0, 
    this.keys = new Array(), this.maxDimension = void 0) : (this.total = 0, this.maxDimension = arguments[0], 
    this.keys = new Array())), this.map = {};
}

var license = "Copyright (c) 2015 by Marco Stagni < http://marcostagni.com mrc.stagni@gmail.com > and contributors.\n\nSome rights reserved. Redistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the following\n  disclaimer in the documentation and/or other materials provided\n  with the distribution.\n\n* The names of the contributors may not be used to endorse or\n  promote products derived from this software without specific\n  prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nMage contains third party software in the 'app/vendor' directory: each\nfile/module in this directory is distributed under its original license.\n\n";

!function(a, b) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
        if (!a.document) throw new Error("jQuery requires a window with a document");
        return b(a);
    } : b(a);
}("undefined" != typeof window ? window : this, function(a, b) {
    function c(a) {
        var b = a.length, c = fa.type(a);
        return "function" !== c && !fa.isWindow(a) && (!(1 !== a.nodeType || !b) || ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a));
    }
    function d(a, b, c) {
        if (fa.isFunction(b)) return fa.grep(a, function(a, d) {
            return !!b.call(a, d, a) !== c;
        });
        if (b.nodeType) return fa.grep(a, function(a) {
            return a === b !== c;
        });
        if ("string" == typeof b) {
            if (na.test(b)) return fa.filter(b, a, c);
            b = fa.filter(b, a);
        }
        return fa.grep(a, function(a) {
            return fa.inArray(a, b) >= 0 !== c;
        });
    }
    function e(a, b) {
        do a = a[b]; while (a && 1 !== a.nodeType);
        return a;
    }
    function f(a) {
        var b = va[a] = {};
        return fa.each(a.match(ua) || [], function(a, c) {
            b[c] = !0;
        }), b;
    }
    function g() {
        pa.addEventListener ? (pa.removeEventListener("DOMContentLoaded", h, !1), a.removeEventListener("load", h, !1)) : (pa.detachEvent("onreadystatechange", h), 
        a.detachEvent("onload", h));
    }
    function h() {
        (pa.addEventListener || "load" === event.type || "complete" === pa.readyState) && (g(), 
        fa.ready());
    }
    function i(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(Aa, "-$1").toLowerCase();
            if (c = a.getAttribute(d), "string" == typeof c) {
                try {
                    c = "true" === c || "false" !== c && ("null" === c ? null : +c + "" === c ? +c : za.test(c) ? fa.parseJSON(c) : c);
                } catch (a) {}
                fa.data(a, b, c);
            } else c = void 0;
        }
        return c;
    }
    function j(a) {
        var b;
        for (b in a) if (("data" !== b || !fa.isEmptyObject(a[b])) && "toJSON" !== b) return !1;
        return !0;
    }
    function k(a, b, c, d) {
        if (fa.acceptData(a)) {
            var e, f, g = fa.expando, h = a.nodeType, i = h ? fa.cache : a, j = h ? a[g] : a[g] && g;
            if (j && i[j] && (d || i[j].data) || void 0 !== c || "string" != typeof b) return j || (j = h ? a[g] = W.pop() || fa.guid++ : g), 
            i[j] || (i[j] = h ? {} : {
                toJSON: fa.noop
            }), ("object" == typeof b || "function" == typeof b) && (d ? i[j] = fa.extend(i[j], b) : i[j].data = fa.extend(i[j].data, b)), 
            f = i[j], d || (f.data || (f.data = {}), f = f.data), void 0 !== c && (f[fa.camelCase(b)] = c), 
            "string" == typeof b ? (e = f[b], null == e && (e = f[fa.camelCase(b)])) : e = f, 
            e;
        }
    }
    function l(a, b, c) {
        if (fa.acceptData(a)) {
            var d, e, f = a.nodeType, g = f ? fa.cache : a, h = f ? a[fa.expando] : fa.expando;
            if (g[h]) {
                if (b && (d = c ? g[h] : g[h].data)) {
                    fa.isArray(b) ? b = b.concat(fa.map(b, fa.camelCase)) : b in d ? b = [ b ] : (b = fa.camelCase(b), 
                    b = b in d ? [ b ] : b.split(" ")), e = b.length;
                    for (;e--; ) delete d[b[e]];
                    if (c ? !j(d) : !fa.isEmptyObject(d)) return;
                }
                (c || (delete g[h].data, j(g[h]))) && (f ? fa.cleanData([ a ], !0) : da.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
            }
        }
    }
    function m() {
        return !0;
    }
    function n() {
        return !1;
    }
    function o() {
        try {
            return pa.activeElement;
        } catch (a) {}
    }
    function p(a) {
        var b = La.split("|"), c = a.createDocumentFragment();
        if (c.createElement) for (;b.length; ) c.createElement(b.pop());
        return c;
    }
    function q(a, b) {
        var c, d, e = 0, f = typeof a.getElementsByTagName !== ya ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== ya ? a.querySelectorAll(b || "*") : void 0;
        if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || fa.nodeName(d, b) ? f.push(d) : fa.merge(f, q(d, b));
        return void 0 === b || b && fa.nodeName(a, b) ? fa.merge([ a ], f) : f;
    }
    function r(a) {
        Fa.test(a.type) && (a.defaultChecked = a.checked);
    }
    function s(a, b) {
        return fa.nodeName(a, "table") && fa.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
    }
    function t(a) {
        return a.type = (null !== fa.find.attr(a, "type")) + "/" + a.type, a;
    }
    function u(a) {
        var b = Wa.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"), a;
    }
    function v(a, b) {
        for (var c, d = 0; null != (c = a[d]); d++) fa._data(c, "globalEval", !b || fa._data(b[d], "globalEval"));
    }
    function w(a, b) {
        if (1 === b.nodeType && fa.hasData(a)) {
            var c, d, e, f = fa._data(a), g = fa._data(b, f), h = f.events;
            if (h) {
                delete g.handle, g.events = {};
                for (c in h) for (d = 0, e = h[c].length; e > d; d++) fa.event.add(b, c, h[c][d]);
            }
            g.data && (g.data = fa.extend({}, g.data));
        }
    }
    function x(a, b) {
        var c, d, e;
        if (1 === b.nodeType) {
            if (c = b.nodeName.toLowerCase(), !da.noCloneEvent && b[fa.expando]) {
                e = fa._data(b);
                for (d in e.events) fa.removeEvent(b, d, e.handle);
                b.removeAttribute(fa.expando);
            }
            "script" === c && b.text !== a.text ? (t(b).text = a.text, u(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), 
            da.html5Clone && a.innerHTML && !fa.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && Fa.test(a.type) ? (b.defaultChecked = b.checked = a.checked, 
            b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
        }
    }
    function y(b, c) {
        var d = fa(c.createElement(b)).appendTo(c.body), e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : fa.css(d[0], "display");
        return d.detach(), e;
    }
    function z(a) {
        var b = pa, c = ab[a];
        return c || (c = y(a, b), "none" !== c && c || (_a = (_a || fa("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), 
        b = (_a[0].contentWindow || _a[0].contentDocument).document, b.write(), b.close(), 
        c = y(a, b), _a.detach()), ab[a] = c), c;
    }
    function A(a, b) {
        return {
            get: function() {
                var c = a();
                if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments);
            }
        };
    }
    function B(a, b) {
        if (b in a) return b;
        for (var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = nb.length; e--; ) if (b = nb[e] + c, 
        b in a) return b;
        return d;
    }
    function C(a, b) {
        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = fa._data(d, "olddisplay"), 
        c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && Da(d) && (f[g] = fa._data(d, "olddisplay", z(d.nodeName)))) : f[g] || (e = Da(d), 
        (c && "none" !== c || !e) && fa._data(d, "olddisplay", e ? c : fa.css(d, "display"))));
        for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
        return a;
    }
    function D(a, b, c) {
        var d = jb.exec(b);
        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
    }
    function E(a, b, c, d, e) {
        for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += fa.css(a, c + Ca[f], !0, e)), 
        d ? ("content" === c && (g -= fa.css(a, "padding" + Ca[f], !0, e)), "margin" !== c && (g -= fa.css(a, "border" + Ca[f] + "Width", !0, e))) : (g += fa.css(a, "padding" + Ca[f], !0, e), 
        "padding" !== c && (g += fa.css(a, "border" + Ca[f] + "Width", !0, e)));
        return g;
    }
    function F(a, b, c) {
        var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = bb(a), g = da.boxSizing() && "border-box" === fa.css(a, "boxSizing", !1, f);
        if (0 >= e || null == e) {
            if (e = cb(a, b, f), (0 > e || null == e) && (e = a.style[b]), eb.test(e)) return e;
            d = g && (da.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
        }
        return e + E(a, b, c || (g ? "border" : "content"), d, f) + "px";
    }
    function G(a, b, c, d, e) {
        return new G.prototype.init(a, b, c, d, e);
    }
    function H() {
        return setTimeout(function() {
            ob = void 0;
        }), ob = fa.now();
    }
    function I(a, b) {
        var c, d = {
            height: a
        }, e = 0;
        for (b = b ? 1 : 0; 4 > e; e += 2 - b) c = Ca[e], d["margin" + c] = d["padding" + c] = a;
        return b && (d.opacity = d.width = a), d;
    }
    function J(a, b, c) {
        for (var d, e = (ub[b] || []).concat(ub["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d;
    }
    function K(a, b, c) {
        var d, e, f, g, h, i, j, k, l = this, m = {}, n = a.style, o = a.nodeType && Da(a), p = fa._data(a, "fxshow");
        c.queue || (h = fa._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, 
        i = h.empty.fire, h.empty.fire = function() {
            h.unqueued || i();
        }), h.unqueued++, l.always(function() {
            l.always(function() {
                h.unqueued--, fa.queue(a, "fx").length || h.empty.fire();
            });
        })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [ n.overflow, n.overflowX, n.overflowY ], 
        j = fa.css(a, "display"), k = z(a.nodeName), "none" === j && (j = k), "inline" === j && "none" === fa.css(a, "float") && (da.inlineBlockNeedsLayout && "inline" !== k ? n.zoom = 1 : n.display = "inline-block")), 
        c.overflow && (n.overflow = "hidden", da.shrinkWrapBlocks() || l.always(function() {
            n.overflow = c.overflow[0], n.overflowX = c.overflow[1], n.overflowY = c.overflow[2];
        }));
        for (d in b) if (e = b[d], qb.exec(e)) {
            if (delete b[d], f = f || "toggle" === e, e === (o ? "hide" : "show")) {
                if ("show" !== e || !p || void 0 === p[d]) continue;
                o = !0;
            }
            m[d] = p && p[d] || fa.style(a, d);
        }
        if (!fa.isEmptyObject(m)) {
            p ? "hidden" in p && (o = p.hidden) : p = fa._data(a, "fxshow", {}), f && (p.hidden = !o), 
            o ? fa(a).show() : l.done(function() {
                fa(a).hide();
            }), l.done(function() {
                var b;
                fa._removeData(a, "fxshow");
                for (b in m) fa.style(a, b, m[b]);
            });
            for (d in m) g = J(o ? p[d] : 0, d, l), d in p || (p[d] = g.start, o && (g.end = g.start, 
            g.start = "width" === d || "height" === d ? 1 : 0));
        }
    }
    function L(a, b) {
        var c, d, e, f, g;
        for (c in a) if (d = fa.camelCase(c), e = b[d], f = a[c], fa.isArray(f) && (e = f[1], 
        f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = fa.cssHooks[d], g && "expand" in g) {
            f = g.expand(f), delete a[d];
            for (c in f) c in a || (a[c] = f[c], b[c] = e);
        } else b[d] = e;
    }
    function M(a, b, c) {
        var d, e, f = 0, g = tb.length, h = fa.Deferred().always(function() {
            delete i.elem;
        }), i = function() {
            if (e) return !1;
            for (var b = ob || H(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
            return h.notifyWith(a, [ j, f, c ]), 1 > f && i ? c : (h.resolveWith(a, [ j ]), 
            !1);
        }, j = h.promise({
            elem: a,
            props: fa.extend({}, b),
            opts: fa.extend(!0, {
                specialEasing: {}
            }, c),
            originalProperties: b,
            originalOptions: c,
            startTime: ob || H(),
            duration: c.duration,
            tweens: [],
            createTween: function(b, c) {
                var d = fa.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                return j.tweens.push(d), d;
            },
            stop: function(b) {
                var c = 0, d = b ? j.tweens.length : 0;
                if (e) return this;
                for (e = !0; d > c; c++) j.tweens[c].run(1);
                return b ? h.resolveWith(a, [ j, b ]) : h.rejectWith(a, [ j, b ]), this;
            }
        }), k = j.props;
        for (L(k, j.opts.specialEasing); g > f; f++) if (d = tb[f].call(j, a, k, j.opts)) return d;
        return fa.map(k, J, j), fa.isFunction(j.opts.start) && j.opts.start.call(a, j), 
        fa.fx.timer(fa.extend(i, {
            elem: a,
            anim: j,
            queue: j.opts.queue
        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
    }
    function N(a) {
        return function(b, c) {
            "string" != typeof b && (c = b, b = "*");
            var d, e = 0, f = b.toLowerCase().match(ua) || [];
            if (fa.isFunction(c)) for (;d = f[e++]; ) "+" === d.charAt(0) ? (d = d.slice(1) || "*", 
            (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
        };
    }
    function O(a, b, c, d) {
        function e(h) {
            var i;
            return f[h] = !0, fa.each(a[h] || [], function(a, h) {
                var j = h(b, c, d);
                return "string" != typeof j || g || f[j] ? g ? !(i = j) : void 0 : (b.dataTypes.unshift(j), 
                e(j), !1);
            }), i;
        }
        var f = {}, g = a === Sb;
        return e(b.dataTypes[0]) || !f["*"] && e("*");
    }
    function P(a, b) {
        var c, d, e = fa.ajaxSettings.flatOptions || {};
        for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
        return c && fa.extend(!0, a, c), a;
    }
    function Q(a, b, c) {
        for (var d, e, f, g, h = a.contents, i = a.dataTypes; "*" === i[0]; ) i.shift(), 
        void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
        if (e) for (g in h) if (h[g] && h[g].test(e)) {
            i.unshift(g);
            break;
        }
        if (i[0] in c) f = i[0]; else {
            for (g in c) {
                if (!i[0] || a.converters[g + " " + i[0]]) {
                    f = g;
                    break;
                }
                d || (d = g);
            }
            f = f || d;
        }
        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
    }
    function R(a, b, c, d) {
        var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
        if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
        for (f = k.shift(); f; ) if (a.responseFields[f] && (c[a.responseFields[f]] = b), 
        !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) {
            if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                break;
            }
            if (g !== !0) if (g && a.throws) b = g(b); else try {
                b = g(b);
            } catch (a) {
                return {
                    state: "parsererror",
                    error: g ? a : "No conversion from " + i + " to " + f
                };
            }
        }
        return {
            state: "success",
            data: b
        };
    }
    function S(a, b, c, d) {
        var e;
        if (fa.isArray(b)) fa.each(b, function(b, e) {
            c || Vb.test(a) ? d(a, e) : S(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
        }); else if (c || "object" !== fa.type(b)) d(a, b); else for (e in b) S(a + "[" + e + "]", b[e], c, d);
    }
    function T() {
        try {
            return new a.XMLHttpRequest();
        } catch (a) {}
    }
    function U() {
        try {
            return new a.ActiveXObject("Microsoft.XMLHTTP");
        } catch (a) {}
    }
    function V(a) {
        return fa.isWindow(a) ? a : 9 === a.nodeType && (a.defaultView || a.parentWindow);
    }
    var W = [], X = W.slice, Y = W.concat, Z = W.push, $ = W.indexOf, _ = {}, aa = _.toString, ba = _.hasOwnProperty, ca = "".trim, da = {}, ea = "1.11.0", fa = function(a, b) {
        return new fa.fn.init(a, b);
    }, ga = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ha = /^-ms-/, ia = /-([\da-z])/gi, ja = function(a, b) {
        return b.toUpperCase();
    };
    fa.fn = fa.prototype = {
        jquery: ea,
        constructor: fa,
        selector: "",
        length: 0,
        toArray: function() {
            return X.call(this);
        },
        get: function(a) {
            return null != a ? 0 > a ? this[a + this.length] : this[a] : X.call(this);
        },
        pushStack: function(a) {
            var b = fa.merge(this.constructor(), a);
            return b.prevObject = this, b.context = this.context, b;
        },
        each: function(a, b) {
            return fa.each(this, a, b);
        },
        map: function(a) {
            return this.pushStack(fa.map(this, function(b, c) {
                return a.call(b, c, b);
            }));
        },
        slice: function() {
            return this.pushStack(X.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(a) {
            var b = this.length, c = +a + (0 > a ? b : 0);
            return this.pushStack(c >= 0 && b > c ? [ this[c] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: Z,
        sort: W.sort,
        splice: W.splice
    }, fa.extend = fa.fn.extend = function() {
        var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
        for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || fa.isFunction(g) || (g = {}), 
        h === i && (g = this, h--); i > h; h++) if (null != (e = arguments[h])) for (d in e) a = g[d], 
        c = e[d], g !== c && (j && c && (fa.isPlainObject(c) || (b = fa.isArray(c))) ? (b ? (b = !1, 
        f = a && fa.isArray(a) ? a : []) : f = a && fa.isPlainObject(a) ? a : {}, g[d] = fa.extend(j, f, c)) : void 0 !== c && (g[d] = c));
        return g;
    }, fa.extend({
        expando: "jQuery" + (ea + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(a) {
            throw new Error(a);
        },
        noop: function() {},
        isFunction: function(a) {
            return "function" === fa.type(a);
        },
        isArray: Array.isArray || function(a) {
            return "array" === fa.type(a);
        },
        isWindow: function(a) {
            return null != a && a == a.window;
        },
        isNumeric: function(a) {
            return a - parseFloat(a) >= 0;
        },
        isEmptyObject: function(a) {
            var b;
            for (b in a) return !1;
            return !0;
        },
        isPlainObject: function(a) {
            var b;
            if (!a || "object" !== fa.type(a) || a.nodeType || fa.isWindow(a)) return !1;
            try {
                if (a.constructor && !ba.call(a, "constructor") && !ba.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (a) {
                return !1;
            }
            if (da.ownLast) for (b in a) return ba.call(a, b);
            for (b in a) ;
            return void 0 === b || ba.call(a, b);
        },
        type: function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? _[aa.call(a)] || "object" : typeof a;
        },
        globalEval: function(b) {
            b && fa.trim(b) && (a.execScript || function(b) {
                a.eval.call(a, b);
            })(b);
        },
        camelCase: function(a) {
            return a.replace(ha, "ms-").replace(ia, ja);
        },
        nodeName: function(a, b) {
            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
        },
        each: function(a, b, d) {
            var e, f = 0, g = a.length, h = c(a);
            if (d) {
                if (h) for (;g > f && (e = b.apply(a[f], d), e !== !1); f++) ; else for (f in a) if (e = b.apply(a[f], d), 
                e === !1) break;
            } else if (h) for (;g > f && (e = b.call(a[f], f, a[f]), e !== !1); f++) ; else for (f in a) if (e = b.call(a[f], f, a[f]), 
            e === !1) break;
            return a;
        },
        trim: ca && !ca.call("\ufeff ") ? function(a) {
            return null == a ? "" : ca.call(a);
        } : function(a) {
            return null == a ? "" : (a + "").replace(ga, "");
        },
        makeArray: function(a, b) {
            var d = b || [];
            return null != a && (c(Object(a)) ? fa.merge(d, "string" == typeof a ? [ a ] : a) : Z.call(d, a)), 
            d;
        },
        inArray: function(a, b, c) {
            var d;
            if (b) {
                if ($) return $.call(b, a, c);
                for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) if (c in b && b[c] === a) return c;
            }
            return -1;
        },
        merge: function(a, b) {
            for (var c = +b.length, d = 0, e = a.length; c > d; ) a[e++] = b[d++];
            if (c !== c) for (;void 0 !== b[d]; ) a[e++] = b[d++];
            return a.length = e, a;
        },
        grep: function(a, b, c) {
            for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
            return e;
        },
        map: function(a, b, d) {
            var e, f = 0, g = a.length, h = c(a), i = [];
            if (h) for (;g > f; f++) e = b(a[f], f, d), null != e && i.push(e); else for (f in a) e = b(a[f], f, d), 
            null != e && i.push(e);
            return Y.apply([], i);
        },
        guid: 1,
        proxy: function(a, b) {
            var c, d, e;
            return "string" == typeof b && (e = a[b], b = a, a = e), fa.isFunction(a) ? (c = X.call(arguments, 2), 
            d = function() {
                return a.apply(b || this, c.concat(X.call(arguments)));
            }, d.guid = a.guid = a.guid || fa.guid++, d) : void 0;
        },
        now: function() {
            return +new Date();
        },
        support: da
    }), fa.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
        _["[object " + b + "]"] = b.toLowerCase();
    });
    var ka = function(a) {
        function b(a, b, c, d) {
            var e, f, g, h, i, j, l, o, p, q;
            if ((b ? b.ownerDocument || b : O) !== G && F(b), b = b || G, c = c || [], !a || "string" != typeof a) return c;
            if (1 !== (h = b.nodeType) && 9 !== h) return [];
            if (I && !d) {
                if (e = sa.exec(a)) if (g = e[1]) {
                    if (9 === h) {
                        if (f = b.getElementById(g), !f || !f.parentNode) return c;
                        if (f.id === g) return c.push(f), c;
                    } else if (b.ownerDocument && (f = b.ownerDocument.getElementById(g)) && M(b, f) && f.id === g) return c.push(f), 
                    c;
                } else {
                    if (e[2]) return _.apply(c, b.getElementsByTagName(a)), c;
                    if ((g = e[3]) && x.getElementsByClassName && b.getElementsByClassName) return _.apply(c, b.getElementsByClassName(g)), 
                    c;
                }
                if (x.qsa && (!J || !J.test(a))) {
                    if (o = l = N, p = b, q = 9 === h && a, 1 === h && "object" !== b.nodeName.toLowerCase()) {
                        for (j = m(a), (l = b.getAttribute("id")) ? o = l.replace(ua, "\\$&") : b.setAttribute("id", o), 
                        o = "[id='" + o + "'] ", i = j.length; i--; ) j[i] = o + n(j[i]);
                        p = ta.test(a) && k(b.parentNode) || b, q = j.join(",");
                    }
                    if (q) try {
                        return _.apply(c, p.querySelectorAll(q)), c;
                    } catch (a) {} finally {
                        l || b.removeAttribute("id");
                    }
                }
            }
            return v(a.replace(ia, "$1"), b, c, d);
        }
        function c() {
            function a(c, d) {
                return b.push(c + " ") > y.cacheLength && delete a[b.shift()], a[c + " "] = d;
            }
            var b = [];
            return a;
        }
        function d(a) {
            return a[N] = !0, a;
        }
        function e(a) {
            var b = G.createElement("div");
            try {
                return !!a(b);
            } catch (a) {
                return !1;
            } finally {
                b.parentNode && b.parentNode.removeChild(b), b = null;
            }
        }
        function f(a, b) {
            for (var c = a.split("|"), d = a.length; d--; ) y.attrHandle[c[d]] = b;
        }
        function g(a, b) {
            var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || W) - (~a.sourceIndex || W);
            if (d) return d;
            if (c) for (;c = c.nextSibling; ) if (c === b) return -1;
            return a ? 1 : -1;
        }
        function h(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return "input" === c && b.type === a;
            };
        }
        function i(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a;
            };
        }
        function j(a) {
            return d(function(b) {
                return b = +b, d(function(c, d) {
                    for (var e, f = a([], c.length, b), g = f.length; g--; ) c[e = f[g]] && (c[e] = !(d[e] = c[e]));
                });
            });
        }
        function k(a) {
            return a && typeof a.getElementsByTagName !== V && a;
        }
        function l() {}
        function m(a, c) {
            var d, e, f, g, h, i, j, k = S[a + " "];
            if (k) return c ? 0 : k.slice(0);
            for (h = a, i = [], j = y.preFilter; h; ) {
                (!d || (e = ja.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), 
                d = !1, (e = ka.exec(h)) && (d = e.shift(), f.push({
                    value: d,
                    type: e[0].replace(ia, " ")
                }), h = h.slice(d.length));
                for (g in y.filter) !(e = oa[g].exec(h)) || j[g] && !(e = j[g](e)) || (d = e.shift(), 
                f.push({
                    value: d,
                    type: g,
                    matches: e
                }), h = h.slice(d.length));
                if (!d) break;
            }
            return c ? h.length : h ? b.error(a) : S(a, i).slice(0);
        }
        function n(a) {
            for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
            return d;
        }
        function o(a, b, c) {
            var d = b.dir, e = c && "parentNode" === d, f = Q++;
            return b.first ? function(b, c, f) {
                for (;b = b[d]; ) if (1 === b.nodeType || e) return a(b, c, f);
            } : function(b, c, g) {
                var h, i, j = [ P, f ];
                if (g) {
                    for (;b = b[d]; ) if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
                } else for (;b = b[d]; ) if (1 === b.nodeType || e) {
                    if (i = b[N] || (b[N] = {}), (h = i[d]) && h[0] === P && h[1] === f) return j[2] = h[2];
                    if (i[d] = j, j[2] = a(b, c, g)) return !0;
                }
            };
        }
        function p(a) {
            return a.length > 1 ? function(b, c, d) {
                for (var e = a.length; e--; ) if (!a[e](b, c, d)) return !1;
                return !0;
            } : a[0];
        }
        function q(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), 
            j && b.push(h));
            return g;
        }
        function r(a, b, c, e, f, g) {
            return e && !e[N] && (e = r(e)), f && !f[N] && (f = r(f, g)), d(function(d, g, h, i) {
                var j, k, l, m = [], n = [], o = g.length, p = d || u(b || "*", h.nodeType ? [ h ] : h, []), r = !a || !d && b ? p : q(p, m, a, h, i), s = c ? f || (d ? a : o || e) ? [] : g : r;
                if (c && c(r, s, h, i), e) for (j = q(s, n), e(j, [], h, i), k = j.length; k--; ) (l = j[k]) && (s[n[k]] = !(r[n[k]] = l));
                if (d) {
                    if (f || a) {
                        if (f) {
                            for (j = [], k = s.length; k--; ) (l = s[k]) && j.push(r[k] = l);
                            f(null, s = [], j, i);
                        }
                        for (k = s.length; k--; ) (l = s[k]) && (j = f ? ba.call(d, l) : m[k]) > -1 && (d[j] = !(g[j] = l));
                    }
                } else s = q(s === g ? s.splice(o, s.length) : s), f ? f(null, g, s, i) : _.apply(g, s);
            });
        }
        function s(a) {
            for (var b, c, d, e = a.length, f = y.relative[a[0].type], g = f || y.relative[" "], h = f ? 1 : 0, i = o(function(a) {
                return a === b;
            }, g, !0), j = o(function(a) {
                return ba.call(b, a) > -1;
            }, g, !0), k = [ function(a, c, d) {
                return !f && (d || c !== C) || ((b = c).nodeType ? i(a, c, d) : j(a, c, d));
            } ]; e > h; h++) if (c = y.relative[a[h].type]) k = [ o(p(k), c) ]; else {
                if (c = y.filter[a[h].type].apply(null, a[h].matches), c[N]) {
                    for (d = ++h; e > d && !y.relative[a[d].type]; d++) ;
                    return r(h > 1 && p(k), h > 1 && n(a.slice(0, h - 1).concat({
                        value: " " === a[h - 2].type ? "*" : ""
                    })).replace(ia, "$1"), c, d > h && s(a.slice(h, d)), e > d && s(a = a.slice(d)), e > d && n(a));
                }
                k.push(c);
            }
            return p(k);
        }
        function t(a, c) {
            var e = c.length > 0, f = a.length > 0, g = function(d, g, h, i, j) {
                var k, l, m, n = 0, o = "0", p = d && [], r = [], s = C, t = d || f && y.find.TAG("*", j), u = P += null == s ? 1 : Math.random() || .1, v = t.length;
                for (j && (C = g !== G && g); o !== v && null != (k = t[o]); o++) {
                    if (f && k) {
                        for (l = 0; m = a[l++]; ) if (m(k, g, h)) {
                            i.push(k);
                            break;
                        }
                        j && (P = u);
                    }
                    e && ((k = !m && k) && n--, d && p.push(k));
                }
                if (n += o, e && o !== n) {
                    for (l = 0; m = c[l++]; ) m(p, r, g, h);
                    if (d) {
                        if (n > 0) for (;o--; ) p[o] || r[o] || (r[o] = Z.call(i));
                        r = q(r);
                    }
                    _.apply(i, r), j && !d && r.length > 0 && n + c.length > 1 && b.uniqueSort(i);
                }
                return j && (P = u, C = s), p;
            };
            return e ? d(g) : g;
        }
        function u(a, c, d) {
            for (var e = 0, f = c.length; f > e; e++) b(a, c[e], d);
            return d;
        }
        function v(a, b, c, d) {
            var e, f, g, h, i, j = m(a);
            if (!d && 1 === j.length) {
                if (f = j[0] = j[0].slice(0), f.length > 2 && "ID" === (g = f[0]).type && x.getById && 9 === b.nodeType && I && y.relative[f[1].type]) {
                    if (b = (y.find.ID(g.matches[0].replace(va, wa), b) || [])[0], !b) return c;
                    a = a.slice(f.shift().value.length);
                }
                for (e = oa.needsContext.test(a) ? 0 : f.length; e-- && (g = f[e], !y.relative[h = g.type]); ) if ((i = y.find[h]) && (d = i(g.matches[0].replace(va, wa), ta.test(f[0].type) && k(b.parentNode) || b))) {
                    if (f.splice(e, 1), a = d.length && n(f), !a) return _.apply(c, d), c;
                    break;
                }
            }
            return B(a, j)(d, b, !I, c, ta.test(a) && k(b.parentNode) || b), c;
        }
        var w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N = "sizzle" + -new Date(), O = a.document, P = 0, Q = 0, R = c(), S = c(), T = c(), U = function(a, b) {
            return a === b && (E = !0), 0;
        }, V = "undefined", W = 1 << 31, X = {}.hasOwnProperty, Y = [], Z = Y.pop, $ = Y.push, _ = Y.push, aa = Y.slice, ba = Y.indexOf || function(a) {
            for (var b = 0, c = this.length; c > b; b++) if (this[b] === a) return b;
            return -1;
        }, ca = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", da = "[\\x20\\t\\r\\n\\f]", ea = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", fa = ea.replace("w", "w#"), ga = "\\[" + da + "*(" + ea + ")" + da + "*(?:([*^$|!~]?=)" + da + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + fa + ")|)|)" + da + "*\\]", ha = ":(" + ea + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + ga.replace(3, 8) + ")*)|.*)\\)|)", ia = new RegExp("^" + da + "+|((?:^|[^\\\\])(?:\\\\.)*)" + da + "+$", "g"), ja = new RegExp("^" + da + "*," + da + "*"), ka = new RegExp("^" + da + "*([>+~]|" + da + ")" + da + "*"), la = new RegExp("=" + da + "*([^\\]'\"]*?)" + da + "*\\]", "g"), ma = new RegExp(ha), na = new RegExp("^" + fa + "$"), oa = {
            ID: new RegExp("^#(" + ea + ")"),
            CLASS: new RegExp("^\\.(" + ea + ")"),
            TAG: new RegExp("^(" + ea.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + ga),
            PSEUDO: new RegExp("^" + ha),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + da + "*(even|odd|(([+-]|)(\\d*)n|)" + da + "*(?:([+-]|)" + da + "*(\\d+)|))" + da + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + ca + ")$", "i"),
            needsContext: new RegExp("^" + da + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + da + "*((?:-\\d)?\\d*)" + da + "*\\)|)(?=[^-]|$)", "i")
        }, pa = /^(?:input|select|textarea|button)$/i, qa = /^h\d$/i, ra = /^[^{]+\{\s*\[native \w/, sa = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ta = /[+~]/, ua = /'|\\/g, va = new RegExp("\\\\([\\da-f]{1,6}" + da + "?|(" + da + ")|.)", "ig"), wa = function(a, b, c) {
            var d = "0x" + b - 65536;
            return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
        };
        try {
            _.apply(Y = aa.call(O.childNodes), O.childNodes), Y[O.childNodes.length].nodeType;
        } catch (a) {
            _ = {
                apply: Y.length ? function(a, b) {
                    $.apply(a, aa.call(b));
                } : function(a, b) {
                    for (var c = a.length, d = 0; a[c++] = b[d++]; ) ;
                    a.length = c - 1;
                }
            };
        }
        x = b.support = {}, A = b.isXML = function(a) {
            var b = a && (a.ownerDocument || a).documentElement;
            return !!b && "HTML" !== b.nodeName;
        }, F = b.setDocument = function(a) {
            var b, c = a ? a.ownerDocument || a : O, d = c.defaultView;
            return c !== G && 9 === c.nodeType && c.documentElement ? (G = c, H = c.documentElement, 
            I = !A(c), d && d !== d.top && (d.addEventListener ? d.addEventListener("unload", function() {
                F();
            }, !1) : d.attachEvent && d.attachEvent("onunload", function() {
                F();
            })), x.attributes = e(function(a) {
                return a.className = "i", !a.getAttribute("className");
            }), x.getElementsByTagName = e(function(a) {
                return a.appendChild(c.createComment("")), !a.getElementsByTagName("*").length;
            }), x.getElementsByClassName = ra.test(c.getElementsByClassName) && e(function(a) {
                return a.innerHTML = "<div class='a'></div><div class='a i'></div>", a.firstChild.className = "i", 
                2 === a.getElementsByClassName("i").length;
            }), x.getById = e(function(a) {
                return H.appendChild(a).id = N, !c.getElementsByName || !c.getElementsByName(N).length;
            }), x.getById ? (y.find.ID = function(a, b) {
                if (typeof b.getElementById !== V && I) {
                    var c = b.getElementById(a);
                    return c && c.parentNode ? [ c ] : [];
                }
            }, y.filter.ID = function(a) {
                var b = a.replace(va, wa);
                return function(a) {
                    return a.getAttribute("id") === b;
                };
            }) : (delete y.find.ID, y.filter.ID = function(a) {
                var b = a.replace(va, wa);
                return function(a) {
                    var c = typeof a.getAttributeNode !== V && a.getAttributeNode("id");
                    return c && c.value === b;
                };
            }), y.find.TAG = x.getElementsByTagName ? function(a, b) {
                return typeof b.getElementsByTagName !== V ? b.getElementsByTagName(a) : void 0;
            } : function(a, b) {
                var c, d = [], e = 0, f = b.getElementsByTagName(a);
                if ("*" === a) {
                    for (;c = f[e++]; ) 1 === c.nodeType && d.push(c);
                    return d;
                }
                return f;
            }, y.find.CLASS = x.getElementsByClassName && function(a, b) {
                return typeof b.getElementsByClassName !== V && I ? b.getElementsByClassName(a) : void 0;
            }, K = [], J = [], (x.qsa = ra.test(c.querySelectorAll)) && (e(function(a) {
                a.innerHTML = "<select t=''><option selected=''></option></select>", a.querySelectorAll("[t^='']").length && J.push("[*^$]=" + da + "*(?:''|\"\")"), 
                a.querySelectorAll("[selected]").length || J.push("\\[" + da + "*(?:value|" + ca + ")"), 
                a.querySelectorAll(":checked").length || J.push(":checked");
            }), e(function(a) {
                var b = c.createElement("input");
                b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && J.push("name" + da + "*[*^$|!~]?="), 
                a.querySelectorAll(":enabled").length || J.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), 
                J.push(",.*:");
            })), (x.matchesSelector = ra.test(L = H.webkitMatchesSelector || H.mozMatchesSelector || H.oMatchesSelector || H.msMatchesSelector)) && e(function(a) {
                x.disconnectedMatch = L.call(a, "div"), L.call(a, "[s!='']:x"), K.push("!=", ha);
            }), J = J.length && new RegExp(J.join("|")), K = K.length && new RegExp(K.join("|")), 
            b = ra.test(H.compareDocumentPosition), M = b || ra.test(H.contains) ? function(a, b) {
                var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, U = b ? function(a, b) {
                if (a === b) return E = !0, 0;
                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & d || !x.sortDetached && b.compareDocumentPosition(a) === d ? a === c || a.ownerDocument === O && M(O, a) ? -1 : b === c || b.ownerDocument === O && M(O, b) ? 1 : D ? ba.call(D, a) - ba.call(D, b) : 0 : 4 & d ? -1 : 1);
            } : function(a, b) {
                if (a === b) return E = !0, 0;
                var d, e = 0, f = a.parentNode, h = b.parentNode, i = [ a ], j = [ b ];
                if (!f || !h) return a === c ? -1 : b === c ? 1 : f ? -1 : h ? 1 : D ? ba.call(D, a) - ba.call(D, b) : 0;
                if (f === h) return g(a, b);
                for (d = a; d = d.parentNode; ) i.unshift(d);
                for (d = b; d = d.parentNode; ) j.unshift(d);
                for (;i[e] === j[e]; ) e++;
                return e ? g(i[e], j[e]) : i[e] === O ? -1 : j[e] === O ? 1 : 0;
            }, c) : G;
        }, b.matches = function(a, c) {
            return b(a, null, null, c);
        }, b.matchesSelector = function(a, c) {
            if ((a.ownerDocument || a) !== G && F(a), c = c.replace(la, "='$1']"), !(!x.matchesSelector || !I || K && K.test(c) || J && J.test(c))) try {
                var d = L.call(a, c);
                if (d || x.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
            } catch (a) {}
            return b(c, G, null, [ a ]).length > 0;
        }, b.contains = function(a, b) {
            return (a.ownerDocument || a) !== G && F(a), M(a, b);
        }, b.attr = function(a, b) {
            (a.ownerDocument || a) !== G && F(a);
            var c = y.attrHandle[b.toLowerCase()], d = c && X.call(y.attrHandle, b.toLowerCase()) ? c(a, b, !I) : void 0;
            return void 0 !== d ? d : x.attributes || !I ? a.getAttribute(b) : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
        }, b.error = function(a) {
            throw new Error("Syntax error, unrecognized expression: " + a);
        }, b.uniqueSort = function(a) {
            var b, c = [], d = 0, e = 0;
            if (E = !x.detectDuplicates, D = !x.sortStable && a.slice(0), a.sort(U), E) {
                for (;b = a[e++]; ) b === a[e] && (d = c.push(e));
                for (;d--; ) a.splice(c[d], 1);
            }
            return D = null, a;
        }, z = b.getText = function(a) {
            var b, c = "", d = 0, e = a.nodeType;
            if (e) {
                if (1 === e || 9 === e || 11 === e) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += z(a);
                } else if (3 === e || 4 === e) return a.nodeValue;
            } else for (;b = a[d++]; ) c += z(b);
            return c;
        }, y = b.selectors = {
            cacheLength: 50,
            createPseudo: d,
            match: oa,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(a) {
                    return a[1] = a[1].replace(va, wa), a[3] = (a[4] || a[5] || "").replace(va, wa), 
                    "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
                },
                CHILD: function(a) {
                    return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || b.error(a[0]), 
                    a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && b.error(a[0]), 
                    a;
                },
                PSEUDO: function(a) {
                    var b, c = !a[5] && a[2];
                    return oa.CHILD.test(a[0]) ? null : (a[3] && void 0 !== a[4] ? a[2] = a[4] : c && ma.test(c) && (b = m(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), 
                    a[2] = c.slice(0, b)), a.slice(0, 3));
                }
            },
            filter: {
                TAG: function(a) {
                    var b = a.replace(va, wa).toLowerCase();
                    return "*" === a ? function() {
                        return !0;
                    } : function(a) {
                        return a.nodeName && a.nodeName.toLowerCase() === b;
                    };
                },
                CLASS: function(a) {
                    var b = R[a + " "];
                    return b || (b = new RegExp("(^|" + da + ")" + a + "(" + da + "|$)")) && R(a, function(a) {
                        return b.test("string" == typeof a.className && a.className || typeof a.getAttribute !== V && a.getAttribute("class") || "");
                    });
                },
                ATTR: function(a, c, d) {
                    return function(e) {
                        var f = b.attr(e, a);
                        return null == f ? "!=" === c : !c || (f += "", "=" === c ? f === d : "!=" === c ? f !== d : "^=" === c ? d && 0 === f.indexOf(d) : "*=" === c ? d && f.indexOf(d) > -1 : "$=" === c ? d && f.slice(-d.length) === d : "~=" === c ? (" " + f + " ").indexOf(d) > -1 : "|=" === c && (f === d || f.slice(0, d.length + 1) === d + "-"));
                    };
                },
                CHILD: function(a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                    return 1 === d && 0 === e ? function(a) {
                        return !!a.parentNode;
                    } : function(b, c, i) {
                        var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h;
                        if (q) {
                            if (f) {
                                for (;p; ) {
                                    for (l = b; l = l[p]; ) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                                    o = p = "only" === a && !o && "nextSibling";
                                }
                                return !0;
                            }
                            if (o = [ g ? q.firstChild : q.lastChild ], g && s) {
                                for (k = q[N] || (q[N] = {}), j = k[a] || [], n = j[0] === P && j[1], m = j[0] === P && j[2], 
                                l = n && q.childNodes[n]; l = ++n && l && l[p] || (m = n = 0) || o.pop(); ) if (1 === l.nodeType && ++m && l === b) {
                                    k[a] = [ P, n, m ];
                                    break;
                                }
                            } else if (s && (j = (b[N] || (b[N] = {}))[a]) && j[0] === P) m = j[1]; else for (;(l = ++n && l && l[p] || (m = n = 0) || o.pop()) && ((h ? l.nodeName.toLowerCase() !== r : 1 !== l.nodeType) || !++m || (s && ((l[N] || (l[N] = {}))[a] = [ P, m ]), 
                            l !== b)); ) ;
                            return m -= e, m === d || m % d === 0 && m / d >= 0;
                        }
                    };
                },
                PSEUDO: function(a, c) {
                    var e, f = y.pseudos[a] || y.setFilters[a.toLowerCase()] || b.error("unsupported pseudo: " + a);
                    return f[N] ? f(c) : f.length > 1 ? (e = [ a, a, "", c ], y.setFilters.hasOwnProperty(a.toLowerCase()) ? d(function(a, b) {
                        for (var d, e = f(a, c), g = e.length; g--; ) d = ba.call(a, e[g]), a[d] = !(b[d] = e[g]);
                    }) : function(a) {
                        return f(a, 0, e);
                    }) : f;
                }
            },
            pseudos: {
                not: d(function(a) {
                    var b = [], c = [], e = B(a.replace(ia, "$1"));
                    return e[N] ? d(function(a, b, c, d) {
                        for (var f, g = e(a, null, d, []), h = a.length; h--; ) (f = g[h]) && (a[h] = !(b[h] = f));
                    }) : function(a, d, f) {
                        return b[0] = a, e(b, null, f, c), !c.pop();
                    };
                }),
                has: d(function(a) {
                    return function(c) {
                        return b(a, c).length > 0;
                    };
                }),
                contains: d(function(a) {
                    return function(b) {
                        return (b.textContent || b.innerText || z(b)).indexOf(a) > -1;
                    };
                }),
                lang: d(function(a) {
                    return na.test(a || "") || b.error("unsupported lang: " + a), a = a.replace(va, wa).toLowerCase(), 
                    function(b) {
                        var c;
                        do if (c = I ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), 
                        c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                        return !1;
                    };
                }),
                target: function(b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id;
                },
                root: function(a) {
                    return a === H;
                },
                focus: function(a) {
                    return a === G.activeElement && (!G.hasFocus || G.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
                },
                enabled: function(a) {
                    return a.disabled === !1;
                },
                disabled: function(a) {
                    return a.disabled === !0;
                },
                checked: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && !!a.checked || "option" === b && !!a.selected;
                },
                selected: function(a) {
                    return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;
                },
                empty: function(a) {
                    for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(a) {
                    return !y.pseudos.empty(a);
                },
                header: function(a) {
                    return qa.test(a.nodeName);
                },
                input: function(a) {
                    return pa.test(a.nodeName);
                },
                button: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b;
                },
                text: function(a) {
                    var b;
                    return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());
                },
                first: j(function() {
                    return [ 0 ];
                }),
                last: j(function(a, b) {
                    return [ b - 1 ];
                }),
                eq: j(function(a, b, c) {
                    return [ 0 > c ? c + b : c ];
                }),
                even: j(function(a, b) {
                    for (var c = 0; b > c; c += 2) a.push(c);
                    return a;
                }),
                odd: j(function(a, b) {
                    for (var c = 1; b > c; c += 2) a.push(c);
                    return a;
                }),
                lt: j(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; --d >= 0; ) a.push(d);
                    return a;
                }),
                gt: j(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; ++d < b; ) a.push(d);
                    return a;
                })
            }
        }, y.pseudos.nth = y.pseudos.eq;
        for (w in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) y.pseudos[w] = h(w);
        for (w in {
            submit: !0,
            reset: !0
        }) y.pseudos[w] = i(w);
        return l.prototype = y.filters = y.pseudos, y.setFilters = new l(), B = b.compile = function(a, b) {
            var c, d = [], e = [], f = T[a + " "];
            if (!f) {
                for (b || (b = m(a)), c = b.length; c--; ) f = s(b[c]), f[N] ? d.push(f) : e.push(f);
                f = T(a, t(e, d));
            }
            return f;
        }, x.sortStable = N.split("").sort(U).join("") === N, x.detectDuplicates = !!E, 
        F(), x.sortDetached = e(function(a) {
            return 1 & a.compareDocumentPosition(G.createElement("div"));
        }), e(function(a) {
            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
        }) || f("type|href|height|width", function(a, b, c) {
            return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
        }), x.attributes && e(function(a) {
            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");
        }) || f("value", function(a, b, c) {
            return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
        }), e(function(a) {
            return null == a.getAttribute("disabled");
        }) || f(ca, function(a, b, c) {
            var d;
            return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
        }), b;
    }(a);
    fa.find = ka, fa.expr = ka.selectors, fa.expr[":"] = fa.expr.pseudos, fa.unique = ka.uniqueSort, 
    fa.text = ka.getText, fa.isXMLDoc = ka.isXML, fa.contains = ka.contains;
    var la = fa.expr.match.needsContext, ma = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, na = /^.[^:#\[\.,]*$/;
    fa.filter = function(a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? fa.find.matchesSelector(d, a) ? [ d ] : [] : fa.find.matches(a, fa.grep(b, function(a) {
            return 1 === a.nodeType;
        }));
    }, fa.fn.extend({
        find: function(a) {
            var b, c = [], d = this, e = d.length;
            if ("string" != typeof a) return this.pushStack(fa(a).filter(function() {
                for (b = 0; e > b; b++) if (fa.contains(d[b], this)) return !0;
            }));
            for (b = 0; e > b; b++) fa.find(a, d[b], c);
            return c = this.pushStack(e > 1 ? fa.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, 
            c;
        },
        filter: function(a) {
            return this.pushStack(d(this, a || [], !1));
        },
        not: function(a) {
            return this.pushStack(d(this, a || [], !0));
        },
        is: function(a) {
            return !!d(this, "string" == typeof a && la.test(a) ? fa(a) : a || [], !1).length;
        }
    });
    var oa, pa = a.document, qa = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, ra = fa.fn.init = function(a, b) {
        var c, d;
        if (!a) return this;
        if ("string" == typeof a) {
            if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [ null, a, null ] : qa.exec(a), 
            !c || !c[1] && b) return !b || b.jquery ? (b || oa).find(a) : this.constructor(b).find(a);
            if (c[1]) {
                if (b = b instanceof fa ? b[0] : b, fa.merge(this, fa.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : pa, !0)), 
                ma.test(c[1]) && fa.isPlainObject(b)) for (c in b) fa.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                return this;
            }
            if (d = pa.getElementById(c[2]), d && d.parentNode) {
                if (d.id !== c[2]) return oa.find(a);
                this.length = 1, this[0] = d;
            }
            return this.context = pa, this.selector = a, this;
        }
        return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : fa.isFunction(a) ? "undefined" != typeof oa.ready ? oa.ready(a) : a(fa) : (void 0 !== a.selector && (this.selector = a.selector, 
        this.context = a.context), fa.makeArray(a, this));
    };
    ra.prototype = fa.fn, oa = fa(pa);
    var sa = /^(?:parents|prev(?:Until|All))/, ta = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    fa.extend({
        dir: function(a, b, c) {
            for (var d = [], e = a[b]; e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !fa(e).is(c)); ) 1 === e.nodeType && d.push(e), 
            e = e[b];
            return d;
        },
        sibling: function(a, b) {
            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
            return c;
        }
    }), fa.fn.extend({
        has: function(a) {
            var b, c = fa(a, this), d = c.length;
            return this.filter(function() {
                for (b = 0; d > b; b++) if (fa.contains(this, c[b])) return !0;
            });
        },
        closest: function(a, b) {
            for (var c, d = 0, e = this.length, f = [], g = la.test(a) || "string" != typeof a ? fa(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && fa.find.matchesSelector(c, a))) {
                f.push(c);
                break;
            }
            return this.pushStack(f.length > 1 ? fa.unique(f) : f);
        },
        index: function(a) {
            return a ? "string" == typeof a ? fa.inArray(this[0], fa(a)) : fa.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(a, b) {
            return this.pushStack(fa.unique(fa.merge(this.get(), fa(a, b))));
        },
        addBack: function(a) {
            return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
        }
    }), fa.each({
        parent: function(a) {
            var b = a.parentNode;
            return b && 11 !== b.nodeType ? b : null;
        },
        parents: function(a) {
            return fa.dir(a, "parentNode");
        },
        parentsUntil: function(a, b, c) {
            return fa.dir(a, "parentNode", c);
        },
        next: function(a) {
            return e(a, "nextSibling");
        },
        prev: function(a) {
            return e(a, "previousSibling");
        },
        nextAll: function(a) {
            return fa.dir(a, "nextSibling");
        },
        prevAll: function(a) {
            return fa.dir(a, "previousSibling");
        },
        nextUntil: function(a, b, c) {
            return fa.dir(a, "nextSibling", c);
        },
        prevUntil: function(a, b, c) {
            return fa.dir(a, "previousSibling", c);
        },
        siblings: function(a) {
            return fa.sibling((a.parentNode || {}).firstChild, a);
        },
        children: function(a) {
            return fa.sibling(a.firstChild);
        },
        contents: function(a) {
            return fa.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : fa.merge([], a.childNodes);
        }
    }, function(a, b) {
        fa.fn[a] = function(c, d) {
            var e = fa.map(this, b, c);
            return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = fa.filter(d, e)), 
            this.length > 1 && (ta[a] || (e = fa.unique(e)), sa.test(a) && (e = e.reverse())), 
            this.pushStack(e);
        };
    });
    var ua = /\S+/g, va = {};
    fa.Callbacks = function(a) {
        a = "string" == typeof a ? va[a] || f(a) : fa.extend({}, a);
        var b, c, d, e, g, h, i = [], j = !a.once && [], k = function(f) {
            for (c = a.memory && f, d = !0, g = h || 0, h = 0, e = i.length, b = !0; i && e > g; g++) if (i[g].apply(f[0], f[1]) === !1 && a.stopOnFalse) {
                c = !1;
                break;
            }
            b = !1, i && (j ? j.length && k(j.shift()) : c ? i = [] : l.disable());
        }, l = {
            add: function() {
                if (i) {
                    var d = i.length;
                    !function b(c) {
                        fa.each(c, function(c, d) {
                            var e = fa.type(d);
                            "function" === e ? a.unique && l.has(d) || i.push(d) : d && d.length && "string" !== e && b(d);
                        });
                    }(arguments), b ? e = i.length : c && (h = d, k(c));
                }
                return this;
            },
            remove: function() {
                return i && fa.each(arguments, function(a, c) {
                    for (var d; (d = fa.inArray(c, i, d)) > -1; ) i.splice(d, 1), b && (e >= d && e--, 
                    g >= d && g--);
                }), this;
            },
            has: function(a) {
                return a ? fa.inArray(a, i) > -1 : !(!i || !i.length);
            },
            empty: function() {
                return i = [], e = 0, this;
            },
            disable: function() {
                return i = j = c = void 0, this;
            },
            disabled: function() {
                return !i;
            },
            lock: function() {
                return j = void 0, c || l.disable(), this;
            },
            locked: function() {
                return !j;
            },
            fireWith: function(a, c) {
                return !i || d && !j || (c = c || [], c = [ a, c.slice ? c.slice() : c ], b ? j.push(c) : k(c)), 
                this;
            },
            fire: function() {
                return l.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!d;
            }
        };
        return l;
    }, fa.extend({
        Deferred: function(a) {
            var b = [ [ "resolve", "done", fa.Callbacks("once memory"), "resolved" ], [ "reject", "fail", fa.Callbacks("once memory"), "rejected" ], [ "notify", "progress", fa.Callbacks("memory") ] ], c = "pending", d = {
                state: function() {
                    return c;
                },
                always: function() {
                    return e.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var a = arguments;
                    return fa.Deferred(function(c) {
                        fa.each(b, function(b, f) {
                            var g = fa.isFunction(a[b]) && a[b];
                            e[f[1]](function() {
                                var a = g && g.apply(this, arguments);
                                a && fa.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [ a ] : arguments);
                            });
                        }), a = null;
                    }).promise();
                },
                promise: function(a) {
                    return null != a ? fa.extend(a, d) : d;
                }
            }, e = {};
            return d.pipe = d.then, fa.each(b, function(a, f) {
                var g = f[2], h = f[3];
                d[f[1]] = g.add, h && g.add(function() {
                    c = h;
                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
                    return e[f[0] + "With"](this === e ? d : this, arguments), this;
                }, e[f[0] + "With"] = g.fireWith;
            }), d.promise(e), a && a.call(e, e), e;
        },
        when: function(a) {
            var b, c, d, e = 0, f = X.call(arguments), g = f.length, h = 1 !== g || a && fa.isFunction(a.promise) ? g : 0, i = 1 === h ? a : fa.Deferred(), j = function(a, c, d) {
                return function(e) {
                    c[a] = this, d[a] = arguments.length > 1 ? X.call(arguments) : e, d === b ? i.notifyWith(c, d) : --h || i.resolveWith(c, d);
                };
            };
            if (g > 1) for (b = new Array(g), c = new Array(g), d = new Array(g); g > e; e++) f[e] && fa.isFunction(f[e].promise) ? f[e].promise().done(j(e, d, f)).fail(i.reject).progress(j(e, c, b)) : --h;
            return h || i.resolveWith(d, f), i.promise();
        }
    });
    var wa;
    fa.fn.ready = function(a) {
        return fa.ready.promise().done(a), this;
    }, fa.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(a) {
            a ? fa.readyWait++ : fa.ready(!0);
        },
        ready: function(a) {
            if (a === !0 ? !--fa.readyWait : !fa.isReady) {
                if (!pa.body) return setTimeout(fa.ready);
                fa.isReady = !0, a !== !0 && --fa.readyWait > 0 || (wa.resolveWith(pa, [ fa ]), 
                fa.fn.trigger && fa(pa).trigger("ready").off("ready"));
            }
        }
    }), fa.ready.promise = function(b) {
        if (!wa) if (wa = fa.Deferred(), "complete" === pa.readyState) setTimeout(fa.ready); else if (pa.addEventListener) pa.addEventListener("DOMContentLoaded", h, !1), 
        a.addEventListener("load", h, !1); else {
            pa.attachEvent("onreadystatechange", h), a.attachEvent("onload", h);
            var c = !1;
            try {
                c = null == a.frameElement && pa.documentElement;
            } catch (a) {}
            c && c.doScroll && !function a() {
                if (!fa.isReady) {
                    try {
                        c.doScroll("left");
                    } catch (b) {
                        return setTimeout(a, 50);
                    }
                    g(), fa.ready();
                }
            }();
        }
        return wa.promise(b);
    };
    var xa, ya = "undefined";
    for (xa in fa(da)) break;
    da.ownLast = "0" !== xa, da.inlineBlockNeedsLayout = !1, fa(function() {
        var a, b, c = pa.getElementsByTagName("body")[0];
        c && (a = pa.createElement("div"), a.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", 
        b = pa.createElement("div"), c.appendChild(a).appendChild(b), typeof b.style.zoom !== ya && (b.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1", 
        (da.inlineBlockNeedsLayout = 3 === b.offsetWidth) && (c.style.zoom = 1)), c.removeChild(a), 
        a = b = null);
    }), function() {
        var a = pa.createElement("div");
        if (null == da.deleteExpando) {
            da.deleteExpando = !0;
            try {
                delete a.test;
            } catch (a) {
                da.deleteExpando = !1;
            }
        }
        a = null;
    }(), fa.acceptData = function(a) {
        var b = fa.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1;
        return (1 === c || 9 === c) && (!b || b !== !0 && a.getAttribute("classid") === b);
    };
    var za = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Aa = /([A-Z])/g;
    fa.extend({
        cache: {},
        noData: {
            "applet ": !0,
            "embed ": !0,
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(a) {
            return a = a.nodeType ? fa.cache[a[fa.expando]] : a[fa.expando], !!a && !j(a);
        },
        data: function(a, b, c) {
            return k(a, b, c);
        },
        removeData: function(a, b) {
            return l(a, b);
        },
        _data: function(a, b, c) {
            return k(a, b, c, !0);
        },
        _removeData: function(a, b) {
            return l(a, b, !0);
        }
    }), fa.fn.extend({
        data: function(a, b) {
            var c, d, e, f = this[0], g = f && f.attributes;
            if (void 0 === a) {
                if (this.length && (e = fa.data(f), 1 === f.nodeType && !fa._data(f, "parsedAttrs"))) {
                    for (c = g.length; c--; ) d = g[c].name, 0 === d.indexOf("data-") && (d = fa.camelCase(d.slice(5)), 
                    i(f, d, e[d]));
                    fa._data(f, "parsedAttrs", !0);
                }
                return e;
            }
            return "object" == typeof a ? this.each(function() {
                fa.data(this, a);
            }) : arguments.length > 1 ? this.each(function() {
                fa.data(this, a, b);
            }) : f ? i(f, a, fa.data(f, a)) : void 0;
        },
        removeData: function(a) {
            return this.each(function() {
                fa.removeData(this, a);
            });
        }
    }), fa.extend({
        queue: function(a, b, c) {
            var d;
            return a ? (b = (b || "fx") + "queue", d = fa._data(a, b), c && (!d || fa.isArray(c) ? d = fa._data(a, b, fa.makeArray(c)) : d.push(c)), 
            d || []) : void 0;
        },
        dequeue: function(a, b) {
            b = b || "fx";
            var c = fa.queue(a, b), d = c.length, e = c.shift(), f = fa._queueHooks(a, b), g = function() {
                fa.dequeue(a, b);
            };
            "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), 
            delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
        },
        _queueHooks: function(a, b) {
            var c = b + "queueHooks";
            return fa._data(a, c) || fa._data(a, c, {
                empty: fa.Callbacks("once memory").add(function() {
                    fa._removeData(a, b + "queue"), fa._removeData(a, c);
                })
            });
        }
    }), fa.fn.extend({
        queue: function(a, b) {
            var c = 2;
            return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? fa.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                var c = fa.queue(this, a, b);
                fa._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && fa.dequeue(this, a);
            });
        },
        dequeue: function(a) {
            return this.each(function() {
                fa.dequeue(this, a);
            });
        },
        clearQueue: function(a) {
            return this.queue(a || "fx", []);
        },
        promise: function(a, b) {
            var c, d = 1, e = fa.Deferred(), f = this, g = this.length, h = function() {
                --d || e.resolveWith(f, [ f ]);
            };
            for ("string" != typeof a && (b = a, a = void 0), a = a || "fx"; g--; ) c = fa._data(f[g], a + "queueHooks"), 
            c && c.empty && (d++, c.empty.add(h));
            return h(), e.promise(b);
        }
    });
    var Ba = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Ca = [ "Top", "Right", "Bottom", "Left" ], Da = function(a, b) {
        return a = b || a, "none" === fa.css(a, "display") || !fa.contains(a.ownerDocument, a);
    }, Ea = fa.access = function(a, b, c, d, e, f, g) {
        var h = 0, i = a.length, j = null == c;
        if ("object" === fa.type(c)) {
            e = !0;
            for (h in c) fa.access(a, b, h, c[h], !0, f, g);
        } else if (void 0 !== d && (e = !0, fa.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), 
        b = null) : (j = b, b = function(a, b, c) {
            return j.call(fa(a), c);
        })), b)) for (;i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
    }, Fa = /^(?:checkbox|radio)$/i;
    !function() {
        var a = pa.createDocumentFragment(), b = pa.createElement("div"), c = pa.createElement("input");
        if (b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a>", 
        da.leadingWhitespace = 3 === b.firstChild.nodeType, da.tbody = !b.getElementsByTagName("tbody").length, 
        da.htmlSerialize = !!b.getElementsByTagName("link").length, da.html5Clone = "<:nav></:nav>" !== pa.createElement("nav").cloneNode(!0).outerHTML, 
        c.type = "checkbox", c.checked = !0, a.appendChild(c), da.appendChecked = c.checked, 
        b.innerHTML = "<textarea>x</textarea>", da.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, 
        a.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", 
        da.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, da.noCloneEvent = !0, 
        b.attachEvent && (b.attachEvent("onclick", function() {
            da.noCloneEvent = !1;
        }), b.cloneNode(!0).click()), null == da.deleteExpando) {
            da.deleteExpando = !0;
            try {
                delete b.test;
            } catch (a) {
                da.deleteExpando = !1;
            }
        }
        a = b = c = null;
    }(), function() {
        var b, c, d = pa.createElement("div");
        for (b in {
            submit: !0,
            change: !0,
            focusin: !0
        }) c = "on" + b, (da[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), da[b + "Bubbles"] = d.attributes[c].expando === !1);
        d = null;
    }();
    var Ga = /^(?:input|select|textarea)$/i, Ha = /^key/, Ia = /^(?:mouse|contextmenu)|click/, Ja = /^(?:focusinfocus|focusoutblur)$/, Ka = /^([^.]*)(?:\.(.+)|)$/;
    fa.event = {
        global: {},
        add: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q = fa._data(a);
            if (q) {
                for (c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = fa.guid++), 
                (g = q.events) || (g = q.events = {}), (k = q.handle) || (k = q.handle = function(a) {
                    return typeof fa === ya || a && fa.event.triggered === a.type ? void 0 : fa.event.dispatch.apply(k.elem, arguments);
                }, k.elem = a), b = (b || "").match(ua) || [ "" ], h = b.length; h--; ) f = Ka.exec(b[h]) || [], 
                n = p = f[1], o = (f[2] || "").split(".").sort(), n && (j = fa.event.special[n] || {}, 
                n = (e ? j.delegateType : j.bindType) || n, j = fa.event.special[n] || {}, l = fa.extend({
                    type: n,
                    origType: p,
                    data: d,
                    handler: c,
                    guid: c.guid,
                    selector: e,
                    needsContext: e && fa.expr.match.needsContext.test(e),
                    namespace: o.join(".")
                }, i), (m = g[n]) || (m = g[n] = [], m.delegateCount = 0, j.setup && j.setup.call(a, d, o, k) !== !1 || (a.addEventListener ? a.addEventListener(n, k, !1) : a.attachEvent && a.attachEvent("on" + n, k))), 
                j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, l) : m.push(l), 
                fa.event.global[n] = !0);
                a = null;
            }
        },
        remove: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, n, o, p, q = fa.hasData(a) && fa._data(a);
            if (q && (k = q.events)) {
                for (b = (b || "").match(ua) || [ "" ], j = b.length; j--; ) if (h = Ka.exec(b[j]) || [], 
                n = p = h[1], o = (h[2] || "").split(".").sort(), n) {
                    for (l = fa.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, 
                    m = k[n] || [], h = h[2] && new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
                    i = f = m.length; f--; ) g = m[f], !e && p !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (m.splice(f, 1), 
                    g.selector && m.delegateCount--, l.remove && l.remove.call(a, g));
                    i && !m.length && (l.teardown && l.teardown.call(a, o, q.handle) !== !1 || fa.removeEvent(a, n, q.handle), 
                    delete k[n]);
                } else for (n in k) fa.event.remove(a, n + b[j], c, d, !0);
                fa.isEmptyObject(k) && (delete q.handle, fa._removeData(a, "events"));
            }
        },
        trigger: function(b, c, d, e) {
            var f, g, h, i, j, k, l, m = [ d || pa ], n = ba.call(b, "type") ? b.type : b, o = ba.call(b, "namespace") ? b.namespace.split(".") : [];
            if (h = k = d = d || pa, 3 !== d.nodeType && 8 !== d.nodeType && !Ja.test(n + fa.event.triggered) && (n.indexOf(".") >= 0 && (o = n.split("."), 
            n = o.shift(), o.sort()), g = n.indexOf(":") < 0 && "on" + n, b = b[fa.expando] ? b : new fa.Event(n, "object" == typeof b && b), 
            b.isTrigger = e ? 2 : 3, b.namespace = o.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            b.result = void 0, b.target || (b.target = d), c = null == c ? [ b ] : fa.makeArray(c, [ b ]), 
            j = fa.event.special[n] || {}, e || !j.trigger || j.trigger.apply(d, c) !== !1)) {
                if (!e && !j.noBubble && !fa.isWindow(d)) {
                    for (i = j.delegateType || n, Ja.test(i + n) || (h = h.parentNode); h; h = h.parentNode) m.push(h), 
                    k = h;
                    k === (d.ownerDocument || pa) && m.push(k.defaultView || k.parentWindow || a);
                }
                for (l = 0; (h = m[l++]) && !b.isPropagationStopped(); ) b.type = l > 1 ? i : j.bindType || n, 
                f = (fa._data(h, "events") || {})[b.type] && fa._data(h, "handle"), f && f.apply(h, c), 
                f = g && h[g], f && f.apply && fa.acceptData(h) && (b.result = f.apply(h, c), b.result === !1 && b.preventDefault());
                if (b.type = n, !e && !b.isDefaultPrevented() && (!j._default || j._default.apply(m.pop(), c) === !1) && fa.acceptData(d) && g && d[n] && !fa.isWindow(d)) {
                    k = d[g], k && (d[g] = null), fa.event.triggered = n;
                    try {
                        d[n]();
                    } catch (a) {}
                    fa.event.triggered = void 0, k && (d[g] = k);
                }
                return b.result;
            }
        },
        dispatch: function(a) {
            a = fa.event.fix(a);
            var b, c, d, e, f, g = [], h = X.call(arguments), i = (fa._data(this, "events") || {})[a.type] || [], j = fa.event.special[a.type] || {};
            if (h[0] = a, a.delegateTarget = this, !j.preDispatch || j.preDispatch.call(this, a) !== !1) {
                for (g = fa.event.handlers.call(this, a, i), b = 0; (e = g[b++]) && !a.isPropagationStopped(); ) for (a.currentTarget = e.elem, 
                f = 0; (d = e.handlers[f++]) && !a.isImmediatePropagationStopped(); ) (!a.namespace_re || a.namespace_re.test(d.namespace)) && (a.handleObj = d, 
                a.data = d.data, c = ((fa.event.special[d.origType] || {}).handle || d.handler).apply(e.elem, h), 
                void 0 !== c && (a.result = c) === !1 && (a.preventDefault(), a.stopPropagation()));
                return j.postDispatch && j.postDispatch.call(this, a), a.result;
            }
        },
        handlers: function(a, b) {
            var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type)) for (;i != this; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
                for (e = [], f = 0; h > f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? fa(c, this).index(i) >= 0 : fa.find(c, this, null, [ i ]).length), 
                e[c] && e.push(d);
                e.length && g.push({
                    elem: i,
                    handlers: e
                });
            }
            return h < b.length && g.push({
                elem: this,
                handlers: b.slice(h)
            }), g;
        },
        fix: function(a) {
            if (a[fa.expando]) return a;
            var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
            for (g || (this.fixHooks[e] = g = Ia.test(e) ? this.mouseHooks : Ha.test(e) ? this.keyHooks : {}), 
            d = g.props ? this.props.concat(g.props) : this.props, a = new fa.Event(f), b = d.length; b--; ) c = d[b], 
            a[c] = f[c];
            return a.target || (a.target = f.srcElement || pa), 3 === a.target.nodeType && (a.target = a.target.parentNode), 
            a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(a, b) {
                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), 
                a;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(a, b) {
                var c, d, e, f = b.button, g = b.fromElement;
                return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || pa, 
                e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), 
                a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), 
                !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), 
                a;
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== o() && this.focus) try {
                        return this.focus(), !1;
                    } catch (a) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === o() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return fa.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), 
                    !1) : void 0;
                },
                _default: function(a) {
                    return fa.nodeName(a.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(a) {
                    void 0 !== a.result && (a.originalEvent.returnValue = a.result);
                }
            }
        },
        simulate: function(a, b, c, d) {
            var e = fa.extend(new fa.Event(), c, {
                type: a,
                isSimulated: !0,
                originalEvent: {}
            });
            d ? fa.event.trigger(e, null, b) : fa.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
        }
    }, fa.removeEvent = pa.removeEventListener ? function(a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c, !1);
    } : function(a, b, c) {
        var d = "on" + b;
        a.detachEvent && (typeof a[d] === ya && (a[d] = null), a.detachEvent(d, c));
    }, fa.Event = function(a, b) {
        return this instanceof fa.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, 
        this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && (a.returnValue === !1 || a.getPreventDefault && a.getPreventDefault()) ? m : n) : this.type = a, 
        b && fa.extend(this, b), this.timeStamp = a && a.timeStamp || fa.now(), void (this[fa.expando] = !0)) : new fa.Event(a, b);
    }, fa.Event.prototype = {
        isDefaultPrevented: n,
        isPropagationStopped: n,
        isImmediatePropagationStopped: n,
        preventDefault: function() {
            var a = this.originalEvent;
            this.isDefaultPrevented = m, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
        },
        stopPropagation: function() {
            var a = this.originalEvent;
            this.isPropagationStopped = m, a && (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = m, this.stopPropagation();
        }
    }, fa.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function(a, b) {
        fa.event.special[a] = {
            delegateType: b,
            bindType: b,
            handle: function(a) {
                var c, d = this, e = a.relatedTarget, f = a.handleObj;
                return (!e || e !== d && !fa.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), 
                a.type = b), c;
            }
        };
    }), da.submitBubbles || (fa.event.special.submit = {
        setup: function() {
            return !fa.nodeName(this, "form") && void fa.event.add(this, "click._submit keypress._submit", function(a) {
                var b = a.target, c = fa.nodeName(b, "input") || fa.nodeName(b, "button") ? b.form : void 0;
                c && !fa._data(c, "submitBubbles") && (fa.event.add(c, "submit._submit", function(a) {
                    a._submit_bubble = !0;
                }), fa._data(c, "submitBubbles", !0));
            });
        },
        postDispatch: function(a) {
            a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && fa.event.simulate("submit", this.parentNode, a, !0));
        },
        teardown: function() {
            return !fa.nodeName(this, "form") && void fa.event.remove(this, "._submit");
        }
    }), da.changeBubbles || (fa.event.special.change = {
        setup: function() {
            return Ga.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (fa.event.add(this, "propertychange._change", function(a) {
                "checked" === a.originalEvent.propertyName && (this._just_changed = !0);
            }), fa.event.add(this, "click._change", function(a) {
                this._just_changed && !a.isTrigger && (this._just_changed = !1), fa.event.simulate("change", this, a, !0);
            })), !1) : void fa.event.add(this, "beforeactivate._change", function(a) {
                var b = a.target;
                Ga.test(b.nodeName) && !fa._data(b, "changeBubbles") && (fa.event.add(b, "change._change", function(a) {
                    !this.parentNode || a.isSimulated || a.isTrigger || fa.event.simulate("change", this.parentNode, a, !0);
                }), fa._data(b, "changeBubbles", !0));
            });
        },
        handle: function(a) {
            var b = a.target;
            return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0;
        },
        teardown: function() {
            return fa.event.remove(this, "._change"), !Ga.test(this.nodeName);
        }
    }), da.focusinBubbles || fa.each({
        focus: "focusin",
        blur: "focusout"
    }, function(a, b) {
        var c = function(a) {
            fa.event.simulate(b, a.target, fa.event.fix(a), !0);
        };
        fa.event.special[b] = {
            setup: function() {
                var d = this.ownerDocument || this, e = fa._data(d, b);
                e || d.addEventListener(a, c, !0), fa._data(d, b, (e || 0) + 1);
            },
            teardown: function() {
                var d = this.ownerDocument || this, e = fa._data(d, b) - 1;
                e ? fa._data(d, b, e) : (d.removeEventListener(a, c, !0), fa._removeData(d, b));
            }
        };
    }), fa.fn.extend({
        on: function(a, b, c, d, e) {
            var f, g;
            if ("object" == typeof a) {
                "string" != typeof b && (c = c || b, b = void 0);
                for (f in a) this.on(f, b, c, a[f], e);
                return this;
            }
            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, 
            c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = n; else if (!d) return this;
            return 1 === e && (g = d, d = function(a) {
                return fa().off(a), g.apply(this, arguments);
            }, d.guid = g.guid || (g.guid = fa.guid++)), this.each(function() {
                fa.event.add(this, a, d, c, b);
            });
        },
        one: function(a, b, c, d) {
            return this.on(a, b, c, d, 1);
        },
        off: function(a, b, c) {
            var d, e;
            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, fa(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), 
            this;
            if ("object" == typeof a) {
                for (e in a) this.off(e, b, a[e]);
                return this;
            }
            return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = n), 
            this.each(function() {
                fa.event.remove(this, a, c, b);
            });
        },
        trigger: function(a, b) {
            return this.each(function() {
                fa.event.trigger(a, b, this);
            });
        },
        triggerHandler: function(a, b) {
            var c = this[0];
            return c ? fa.event.trigger(a, b, c, !0) : void 0;
        }
    });
    var La = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", Ma = / jQuery\d+="(?:null|\d+)"/g, Na = new RegExp("<(?:" + La + ")[\\s/>]", "i"), Oa = /^\s+/, Pa = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, Qa = /<([\w:]+)/, Ra = /<tbody/i, Sa = /<|&#?\w+;/, Ta = /<(?:script|style|link)/i, Ua = /checked\s*(?:[^=]|=\s*.checked.)/i, Va = /^$|\/(?:java|ecma)script/i, Wa = /^true\/(.*)/, Xa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, Ya = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: da.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, Za = p(pa), $a = Za.appendChild(pa.createElement("div"));
    Ya.optgroup = Ya.option, Ya.tbody = Ya.tfoot = Ya.colgroup = Ya.caption = Ya.thead, 
    Ya.th = Ya.td, fa.extend({
        clone: function(a, b, c) {
            var d, e, f, g, h, i = fa.contains(a.ownerDocument, a);
            if (da.html5Clone || fa.isXMLDoc(a) || !Na.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : ($a.innerHTML = a.outerHTML, 
            $a.removeChild(f = $a.firstChild)), !(da.noCloneEvent && da.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || fa.isXMLDoc(a))) for (d = q(f), 
            h = q(a), g = 0; null != (e = h[g]); ++g) d[g] && x(e, d[g]);
            if (b) if (c) for (h = h || q(a), d = d || q(f), g = 0; null != (e = h[g]); g++) w(e, d[g]); else w(a, f);
            return d = q(f, "script"), d.length > 0 && v(d, !i && q(a, "script")), d = h = e = null, 
            f;
        },
        buildFragment: function(a, b, c, d) {
            for (var e, f, g, h, i, j, k, l = a.length, m = p(b), n = [], o = 0; l > o; o++) if (f = a[o], 
            f || 0 === f) if ("object" === fa.type(f)) fa.merge(n, f.nodeType ? [ f ] : f); else if (Sa.test(f)) {
                for (h = h || m.appendChild(b.createElement("div")), i = (Qa.exec(f) || [ "", "" ])[1].toLowerCase(), 
                k = Ya[i] || Ya._default, h.innerHTML = k[1] + f.replace(Pa, "<$1></$2>") + k[2], 
                e = k[0]; e--; ) h = h.lastChild;
                if (!da.leadingWhitespace && Oa.test(f) && n.push(b.createTextNode(Oa.exec(f)[0])), 
                !da.tbody) for (f = "table" !== i || Ra.test(f) ? "<table>" !== k[1] || Ra.test(f) ? 0 : h : h.firstChild, 
                e = f && f.childNodes.length; e--; ) fa.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
                for (fa.merge(n, h.childNodes), h.textContent = ""; h.firstChild; ) h.removeChild(h.firstChild);
                h = m.lastChild;
            } else n.push(b.createTextNode(f));
            for (h && m.removeChild(h), da.appendChecked || fa.grep(q(n, "input"), r), o = 0; f = n[o++]; ) if ((!d || -1 === fa.inArray(f, d)) && (g = fa.contains(f.ownerDocument, f), 
            h = q(m.appendChild(f), "script"), g && v(h), c)) for (e = 0; f = h[e++]; ) Va.test(f.type || "") && c.push(f);
            return h = null, m;
        },
        cleanData: function(a, b) {
            for (var c, d, e, f, g = 0, h = fa.expando, i = fa.cache, j = da.deleteExpando, k = fa.event.special; null != (c = a[g]); g++) if ((b || fa.acceptData(c)) && (e = c[h], 
            f = e && i[e])) {
                if (f.events) for (d in f.events) k[d] ? fa.event.remove(c, d) : fa.removeEvent(c, d, f.handle);
                i[e] && (delete i[e], j ? delete c[h] : typeof c.removeAttribute !== ya ? c.removeAttribute(h) : c[h] = null, 
                W.push(e));
            }
        }
    }), fa.fn.extend({
        text: function(a) {
            return Ea(this, function(a) {
                return void 0 === a ? fa.text(this) : this.empty().append((this[0] && this[0].ownerDocument || pa).createTextNode(a));
            }, null, a, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = s(this, a);
                    b.appendChild(a);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = s(this, a);
                    b.insertBefore(a, b.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
            });
        },
        remove: function(a, b) {
            for (var c, d = a ? fa.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || fa.cleanData(q(c)), 
            c.parentNode && (b && fa.contains(c.ownerDocument, c) && v(q(c, "script")), c.parentNode.removeChild(c));
            return this;
        },
        empty: function() {
            for (var a, b = 0; null != (a = this[b]); b++) {
                for (1 === a.nodeType && fa.cleanData(q(a, !1)); a.firstChild; ) a.removeChild(a.firstChild);
                a.options && fa.nodeName(a, "select") && (a.options.length = 0);
            }
            return this;
        },
        clone: function(a, b) {
            return a = null != a && a, b = null == b ? a : b, this.map(function() {
                return fa.clone(this, a, b);
            });
        },
        html: function(a) {
            return Ea(this, function(a) {
                var b = this[0] || {}, c = 0, d = this.length;
                if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(Ma, "") : void 0;
                if (!("string" != typeof a || Ta.test(a) || !da.htmlSerialize && Na.test(a) || !da.leadingWhitespace && Oa.test(a) || Ya[(Qa.exec(a) || [ "", "" ])[1].toLowerCase()])) {
                    a = a.replace(Pa, "<$1></$2>");
                    try {
                        for (;d > c; c++) b = this[c] || {}, 1 === b.nodeType && (fa.cleanData(q(b, !1)), 
                        b.innerHTML = a);
                        b = 0;
                    } catch (a) {}
                }
                b && this.empty().append(a);
            }, null, a, arguments.length);
        },
        replaceWith: function() {
            var a = arguments[0];
            return this.domManip(arguments, function(b) {
                a = this.parentNode, fa.cleanData(q(this)), a && a.replaceChild(b, this);
            }), a && (a.length || a.nodeType) ? this : this.remove();
        },
        detach: function(a) {
            return this.remove(a, !0);
        },
        domManip: function(a, b) {
            a = Y.apply([], a);
            var c, d, e, f, g, h, i = 0, j = this.length, k = this, l = j - 1, m = a[0], n = fa.isFunction(m);
            if (n || j > 1 && "string" == typeof m && !da.checkClone && Ua.test(m)) return this.each(function(c) {
                var d = k.eq(c);
                n && (a[0] = m.call(this, c, d.html())), d.domManip(a, b);
            });
            if (j && (h = fa.buildFragment(a, this[0].ownerDocument, !1, this), c = h.firstChild, 
            1 === h.childNodes.length && (h = c), c)) {
                for (f = fa.map(q(h, "script"), t), e = f.length; j > i; i++) d = h, i !== l && (d = fa.clone(d, !0, !0), 
                e && fa.merge(f, q(d, "script"))), b.call(this[i], d, i);
                if (e) for (g = f[f.length - 1].ownerDocument, fa.map(f, u), i = 0; e > i; i++) d = f[i], 
                Va.test(d.type || "") && !fa._data(d, "globalEval") && fa.contains(g, d) && (d.src ? fa._evalUrl && fa._evalUrl(d.src) : fa.globalEval((d.text || d.textContent || d.innerHTML || "").replace(Xa, "")));
                h = c = null;
            }
            return this;
        }
    }), fa.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(a, b) {
        fa.fn[a] = function(a) {
            for (var c, d = 0, e = [], f = fa(a), g = f.length - 1; g >= d; d++) c = d === g ? this : this.clone(!0), 
            fa(f[d])[b](c), Z.apply(e, c.get());
            return this.pushStack(e);
        };
    });
    var _a, ab = {};
    !function() {
        var a, b, c = pa.createElement("div"), d = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
        c.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        a = c.getElementsByTagName("a")[0], a.style.cssText = "float:left;opacity:.5", da.opacity = /^0.5/.test(a.style.opacity), 
        da.cssFloat = !!a.style.cssFloat, c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", 
        da.clearCloneStyle = "content-box" === c.style.backgroundClip, a = c = null, da.shrinkWrapBlocks = function() {
            var a, c, e, f;
            if (null == b) {
                if (a = pa.getElementsByTagName("body")[0], !a) return;
                f = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px", c = pa.createElement("div"), 
                e = pa.createElement("div"), a.appendChild(c).appendChild(e), b = !1, typeof e.style.zoom !== ya && (e.style.cssText = d + ";width:1px;padding:1px;zoom:1", 
                e.innerHTML = "<div></div>", e.firstChild.style.width = "5px", b = 3 !== e.offsetWidth), 
                a.removeChild(c), a = c = e = null;
            }
            return b;
        };
    }();
    var bb, cb, db = /^margin/, eb = new RegExp("^(" + Ba + ")(?!px)[a-z%]+$", "i"), fb = /^(top|right|bottom|left)$/;
    a.getComputedStyle ? (bb = function(a) {
        return a.ownerDocument.defaultView.getComputedStyle(a, null);
    }, cb = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || bb(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || fa.contains(a.ownerDocument, a) || (g = fa.style(a, b)), 
        eb.test(g) && db.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, 
        g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + "";
    }) : pa.documentElement.currentStyle && (bb = function(a) {
        return a.currentStyle;
    }, cb = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || bb(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), 
        eb.test(g) && !fb.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), 
        h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), 
        void 0 === g ? g : g + "" || "auto";
    }), !function() {
        function b() {
            var b, c, d = pa.getElementsByTagName("body")[0];
            d && (b = pa.createElement("div"), c = pa.createElement("div"), b.style.cssText = j, 
            d.appendChild(b).appendChild(c), c.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%", 
            fa.swap(d, null != d.style.zoom ? {
                zoom: 1
            } : {}, function() {
                e = 4 === c.offsetWidth;
            }), f = !0, g = !1, h = !0, a.getComputedStyle && (g = "1%" !== (a.getComputedStyle(c, null) || {}).top, 
            f = "4px" === (a.getComputedStyle(c, null) || {
                width: "4px"
            }).width), d.removeChild(b), c = d = null);
        }
        var c, d, e, f, g, h, i = pa.createElement("div"), j = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px", k = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
        i.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        c = i.getElementsByTagName("a")[0], c.style.cssText = "float:left;opacity:.5", da.opacity = /^0.5/.test(c.style.opacity), 
        da.cssFloat = !!c.style.cssFloat, i.style.backgroundClip = "content-box", i.cloneNode(!0).style.backgroundClip = "", 
        da.clearCloneStyle = "content-box" === i.style.backgroundClip, c = i = null, fa.extend(da, {
            reliableHiddenOffsets: function() {
                if (null != d) return d;
                var a, b, c, e = pa.createElement("div"), f = pa.getElementsByTagName("body")[0];
                return f ? (e.setAttribute("className", "t"), e.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
                a = pa.createElement("div"), a.style.cssText = j, f.appendChild(a).appendChild(e), 
                e.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", b = e.getElementsByTagName("td"), 
                b[0].style.cssText = "padding:0;margin:0;border:0;display:none", c = 0 === b[0].offsetHeight, 
                b[0].style.display = "", b[1].style.display = "none", d = c && 0 === b[0].offsetHeight, 
                f.removeChild(a), e = f = null, d) : void 0;
            },
            boxSizing: function() {
                return null == e && b(), e;
            },
            boxSizingReliable: function() {
                return null == f && b(), f;
            },
            pixelPosition: function() {
                return null == g && b(), g;
            },
            reliableMarginRight: function() {
                var b, c, d, e;
                if (null == h && a.getComputedStyle) {
                    if (b = pa.getElementsByTagName("body")[0], !b) return;
                    c = pa.createElement("div"), d = pa.createElement("div"), c.style.cssText = j, b.appendChild(c).appendChild(d), 
                    e = d.appendChild(pa.createElement("div")), e.style.cssText = d.style.cssText = k, 
                    e.style.marginRight = e.style.width = "0", d.style.width = "1px", h = !parseFloat((a.getComputedStyle(e, null) || {}).marginRight), 
                    b.removeChild(c);
                }
                return h;
            }
        });
    }(), fa.swap = function(a, b, c, d) {
        var e, f, g = {};
        for (f in b) g[f] = a.style[f], a.style[f] = b[f];
        e = c.apply(a, d || []);
        for (f in b) a.style[f] = g[f];
        return e;
    };
    var gb = /alpha\([^)]*\)/i, hb = /opacity\s*=\s*([^)]*)/, ib = /^(none|table(?!-c[ea]).+)/, jb = new RegExp("^(" + Ba + ")(.*)$", "i"), kb = new RegExp("^([+-])=(" + Ba + ")", "i"), lb = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, mb = {
        letterSpacing: 0,
        fontWeight: 400
    }, nb = [ "Webkit", "O", "Moz", "ms" ];
    fa.extend({
        cssHooks: {
            opacity: {
                get: function(a, b) {
                    if (b) {
                        var c = cb(a, "opacity");
                        return "" === c ? "1" : c;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: da.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = fa.camelCase(b), i = a.style;
                if (b = fa.cssProps[h] || (fa.cssProps[h] = B(i, h)), g = fa.cssHooks[b] || fa.cssHooks[h], 
                void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                if (f = typeof c, "string" === f && (e = kb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(fa.css(a, b)), 
                f = "number"), null != c && c === c && ("number" !== f || fa.cssNumber[h] || (c += "px"), 
                da.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), 
                !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
                    i[b] = "", i[b] = c;
                } catch (a) {}
            }
        },
        css: function(a, b, c, d) {
            var e, f, g, h = fa.camelCase(b);
            return b = fa.cssProps[h] || (fa.cssProps[h] = B(a.style, h)), g = fa.cssHooks[b] || fa.cssHooks[h], 
            g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = cb(a, b, d)), "normal" === f && b in mb && (f = mb[b]), 
            "" === c || c ? (e = parseFloat(f), c === !0 || fa.isNumeric(e) ? e || 0 : f) : f;
        }
    }), fa.each([ "height", "width" ], function(a, b) {
        fa.cssHooks[b] = {
            get: function(a, c, d) {
                return c ? 0 === a.offsetWidth && ib.test(fa.css(a, "display")) ? fa.swap(a, lb, function() {
                    return F(a, b, d);
                }) : F(a, b, d) : void 0;
            },
            set: function(a, c, d) {
                var e = d && bb(a);
                return D(a, c, d ? E(a, b, d, da.boxSizing() && "border-box" === fa.css(a, "boxSizing", !1, e), e) : 0);
            }
        };
    }), da.opacity || (fa.cssHooks.opacity = {
        get: function(a, b) {
            return hb.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "";
        },
        set: function(a, b) {
            var c = a.style, d = a.currentStyle, e = fa.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || "";
            c.zoom = 1, (b >= 1 || "" === b) && "" === fa.trim(f.replace(gb, "")) && c.removeAttribute && (c.removeAttribute("filter"), 
            "" === b || d && !d.filter) || (c.filter = gb.test(f) ? f.replace(gb, e) : f + " " + e);
        }
    }), fa.cssHooks.marginRight = A(da.reliableMarginRight, function(a, b) {
        return b ? fa.swap(a, {
            display: "inline-block"
        }, cb, [ a, "marginRight" ]) : void 0;
    }), fa.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(a, b) {
        fa.cssHooks[a + b] = {
            expand: function(c) {
                for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [ c ]; 4 > d; d++) e[a + Ca[d] + b] = f[d] || f[d - 2] || f[0];
                return e;
            }
        }, db.test(a) || (fa.cssHooks[a + b].set = D);
    }), fa.fn.extend({
        css: function(a, b) {
            return Ea(this, function(a, b, c) {
                var d, e, f = {}, g = 0;
                if (fa.isArray(b)) {
                    for (d = bb(a), e = b.length; e > g; g++) f[b[g]] = fa.css(a, b[g], !1, d);
                    return f;
                }
                return void 0 !== c ? fa.style(a, b, c) : fa.css(a, b);
            }, a, b, arguments.length > 1);
        },
        show: function() {
            return C(this, !0);
        },
        hide: function() {
            return C(this);
        },
        toggle: function(a) {
            return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                Da(this) ? fa(this).show() : fa(this).hide();
            });
        }
    }), fa.Tween = G, G.prototype = {
        constructor: G,
        init: function(a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), 
            this.end = d, this.unit = f || (fa.cssNumber[c] ? "" : "px");
        },
        cur: function() {
            var a = G.propHooks[this.prop];
            return a && a.get ? a.get(this) : G.propHooks._default.get(this);
        },
        run: function(a) {
            var b, c = G.propHooks[this.prop];
            return this.pos = b = this.options.duration ? fa.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, 
            this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            c && c.set ? c.set(this) : G.propHooks._default.set(this), this;
        }
    }, G.prototype.init.prototype = G.prototype, G.propHooks = {
        _default: {
            get: function(a) {
                var b;
                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = fa.css(a.elem, a.prop, ""), 
                b && "auto" !== b ? b : 0) : a.elem[a.prop];
            },
            set: function(a) {
                fa.fx.step[a.prop] ? fa.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[fa.cssProps[a.prop]] || fa.cssHooks[a.prop]) ? fa.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
            }
        }
    }, G.propHooks.scrollTop = G.propHooks.scrollLeft = {
        set: function(a) {
            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
        }
    }, fa.easing = {
        linear: function(a) {
            return a;
        },
        swing: function(a) {
            return .5 - Math.cos(a * Math.PI) / 2;
        }
    }, fa.fx = G.prototype.init, fa.fx.step = {};
    var ob, pb, qb = /^(?:toggle|show|hide)$/, rb = new RegExp("^(?:([+-])=|)(" + Ba + ")([a-z%]*)$", "i"), sb = /queueHooks$/, tb = [ K ], ub = {
        "*": [ function(a, b) {
            var c = this.createTween(a, b), d = c.cur(), e = rb.exec(b), f = e && e[3] || (fa.cssNumber[a] ? "" : "px"), g = (fa.cssNumber[a] || "px" !== f && +d) && rb.exec(fa.css(c.elem, a)), h = 1, i = 20;
            if (g && g[3] !== f) {
                f = f || g[3], e = e || [], g = +d || 1;
                do h = h || ".5", g /= h, fa.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i);
            }
            return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), 
            c;
        } ]
    };
    fa.Animation = fa.extend(M, {
        tweener: function(a, b) {
            fa.isFunction(a) ? (b = a, a = [ "*" ]) : a = a.split(" ");
            for (var c, d = 0, e = a.length; e > d; d++) c = a[d], ub[c] = ub[c] || [], ub[c].unshift(b);
        },
        prefilter: function(a, b) {
            b ? tb.unshift(a) : tb.push(a);
        }
    }), fa.speed = function(a, b, c) {
        var d = a && "object" == typeof a ? fa.extend({}, a) : {
            complete: c || !c && b || fa.isFunction(a) && a,
            duration: a,
            easing: c && b || b && !fa.isFunction(b) && b
        };
        return d.duration = fa.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in fa.fx.speeds ? fa.fx.speeds[d.duration] : fa.fx.speeds._default, 
        (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function() {
            fa.isFunction(d.old) && d.old.call(this), d.queue && fa.dequeue(this, d.queue);
        }, d;
    }, fa.fn.extend({
        fadeTo: function(a, b, c, d) {
            return this.filter(Da).css("opacity", 0).show().end().animate({
                opacity: b
            }, a, c, d);
        },
        animate: function(a, b, c, d) {
            var e = fa.isEmptyObject(a), f = fa.speed(b, c, d), g = function() {
                var b = M(this, fa.extend({}, a), f);
                (e || fa._data(this, "finish")) && b.stop(!0);
            };
            return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);
        },
        stop: function(a, b, c) {
            var d = function(a) {
                var b = a.stop;
                delete a.stop, b(c);
            };
            return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), 
            this.each(function() {
                var b = !0, e = null != a && a + "queueHooks", f = fa.timers, g = fa._data(this);
                if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && sb.test(e) && d(g[e]);
                for (e = f.length; e--; ) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), 
                b = !1, f.splice(e, 1));
                (b || !c) && fa.dequeue(this, a);
            });
        },
        finish: function(a) {
            return a !== !1 && (a = a || "fx"), this.each(function() {
                var b, c = fa._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = fa.timers, g = d ? d.length : 0;
                for (c.finish = !0, fa.queue(this, a, []), e && e.stop && e.stop.call(this, !0), 
                b = f.length; b--; ) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), 
                f.splice(b, 1));
                for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
                delete c.finish;
            });
        }
    }), fa.each([ "toggle", "show", "hide" ], function(a, b) {
        var c = fa.fn[b];
        fa.fn[b] = function(a, d, e) {
            return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(I(b, !0), a, d, e);
        };
    }), fa.each({
        slideDown: I("show"),
        slideUp: I("hide"),
        slideToggle: I("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(a, b) {
        fa.fn[a] = function(a, c, d) {
            return this.animate(b, a, c, d);
        };
    }), fa.timers = [], fa.fx.tick = function() {
        var a, b = fa.timers, c = 0;
        for (ob = fa.now(); c < b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1);
        b.length || fa.fx.stop(), ob = void 0;
    }, fa.fx.timer = function(a) {
        fa.timers.push(a), a() ? fa.fx.start() : fa.timers.pop();
    }, fa.fx.interval = 13, fa.fx.start = function() {
        pb || (pb = setInterval(fa.fx.tick, fa.fx.interval));
    }, fa.fx.stop = function() {
        clearInterval(pb), pb = null;
    }, fa.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, fa.fn.delay = function(a, b) {
        return a = fa.fx ? fa.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
            var d = setTimeout(b, a);
            c.stop = function() {
                clearTimeout(d);
            };
        });
    }, function() {
        var a, b, c, d, e = pa.createElement("div");
        e.setAttribute("className", "t"), e.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        a = e.getElementsByTagName("a")[0], c = pa.createElement("select"), d = c.appendChild(pa.createElement("option")), 
        b = e.getElementsByTagName("input")[0], a.style.cssText = "top:1px", da.getSetAttribute = "t" !== e.className, 
        da.style = /top/.test(a.getAttribute("style")), da.hrefNormalized = "/a" === a.getAttribute("href"), 
        da.checkOn = !!b.value, da.optSelected = d.selected, da.enctype = !!pa.createElement("form").enctype, 
        c.disabled = !0, da.optDisabled = !d.disabled, b = pa.createElement("input"), b.setAttribute("value", ""), 
        da.input = "" === b.getAttribute("value"), b.value = "t", b.setAttribute("type", "radio"), 
        da.radioValue = "t" === b.value, a = b = c = d = e = null;
    }();
    var vb = /\r/g;
    fa.fn.extend({
        val: function(a) {
            var b, c, d, e = this[0];
            return arguments.length ? (d = fa.isFunction(a), this.each(function(c) {
                var e;
                1 === this.nodeType && (e = d ? a.call(this, c, fa(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : fa.isArray(e) && (e = fa.map(e, function(a) {
                    return null == a ? "" : a + "";
                })), b = fa.valHooks[this.type] || fa.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
            })) : e ? (b = fa.valHooks[e.type] || fa.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, 
            "string" == typeof c ? c.replace(vb, "") : null == c ? "" : c)) : void 0;
        }
    }), fa.extend({
        valHooks: {
            option: {
                get: function(a) {
                    var b = fa.find.attr(a, "value");
                    return null != b ? b : fa.text(a);
                }
            },
            select: {
                get: function(a) {
                    for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i], 
                    !(!c.selected && i !== e || (da.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && fa.nodeName(c.parentNode, "optgroup"))) {
                        if (b = fa(c).val(), f) return b;
                        g.push(b);
                    }
                    return g;
                },
                set: function(a, b) {
                    for (var c, d, e = a.options, f = fa.makeArray(b), g = e.length; g--; ) if (d = e[g], 
                    fa.inArray(fa.valHooks.option.get(d), f) >= 0) try {
                        d.selected = c = !0;
                    } catch (a) {
                        d.scrollHeight;
                    } else d.selected = !1;
                    return c || (a.selectedIndex = -1), e;
                }
            }
        }
    }), fa.each([ "radio", "checkbox" ], function() {
        fa.valHooks[this] = {
            set: function(a, b) {
                return fa.isArray(b) ? a.checked = fa.inArray(fa(a).val(), b) >= 0 : void 0;
            }
        }, da.checkOn || (fa.valHooks[this].get = function(a) {
            return null === a.getAttribute("value") ? "on" : a.value;
        });
    });
    var wb, xb, yb = fa.expr.attrHandle, zb = /^(?:checked|selected)$/i, Ab = da.getSetAttribute, Bb = da.input;
    fa.fn.extend({
        attr: function(a, b) {
            return Ea(this, fa.attr, a, b, arguments.length > 1);
        },
        removeAttr: function(a) {
            return this.each(function() {
                fa.removeAttr(this, a);
            });
        }
    }), fa.extend({
        attr: function(a, b, c) {
            var d, e, f = a.nodeType;
            if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === ya ? fa.prop(a, b, c) : (1 === f && fa.isXMLDoc(a) || (b = b.toLowerCase(), 
            d = fa.attrHooks[b] || (fa.expr.match.bool.test(b) ? xb : wb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = fa.find.attr(a, b), 
            null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), 
            c) : void fa.removeAttr(a, b));
        },
        removeAttr: function(a, b) {
            var c, d, e = 0, f = b && b.match(ua);
            if (f && 1 === a.nodeType) for (;c = f[e++]; ) d = fa.propFix[c] || c, fa.expr.match.bool.test(c) ? Bb && Ab || !zb.test(c) ? a[d] = !1 : a[fa.camelCase("default-" + c)] = a[d] = !1 : fa.attr(a, c, ""), 
            a.removeAttribute(Ab ? c : d);
        },
        attrHooks: {
            type: {
                set: function(a, b) {
                    if (!da.radioValue && "radio" === b && fa.nodeName(a, "input")) {
                        var c = a.value;
                        return a.setAttribute("type", b), c && (a.value = c), b;
                    }
                }
            }
        }
    }), xb = {
        set: function(a, b, c) {
            return b === !1 ? fa.removeAttr(a, c) : Bb && Ab || !zb.test(c) ? a.setAttribute(!Ab && fa.propFix[c] || c, c) : a[fa.camelCase("default-" + c)] = a[c] = !0, 
            c;
        }
    }, fa.each(fa.expr.match.bool.source.match(/\w+/g), function(a, b) {
        var c = yb[b] || fa.find.attr;
        yb[b] = Bb && Ab || !zb.test(b) ? function(a, b, d) {
            var e, f;
            return d || (f = yb[b], yb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, 
            yb[b] = f), e;
        } : function(a, b, c) {
            return c ? void 0 : a[fa.camelCase("default-" + b)] ? b.toLowerCase() : null;
        };
    }), Bb && Ab || (fa.attrHooks.value = {
        set: function(a, b, c) {
            return fa.nodeName(a, "input") ? void (a.defaultValue = b) : wb && wb.set(a, b, c);
        }
    }), Ab || (wb = {
        set: function(a, b, c) {
            var d = a.getAttributeNode(c);
            return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", 
            "value" === c || b === a.getAttribute(c) ? b : void 0;
        }
    }, yb.id = yb.name = yb.coords = function(a, b, c) {
        var d;
        return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null;
    }, fa.valHooks.button = {
        get: function(a, b) {
            var c = a.getAttributeNode(b);
            return c && c.specified ? c.value : void 0;
        },
        set: wb.set
    }, fa.attrHooks.contenteditable = {
        set: function(a, b, c) {
            wb.set(a, "" !== b && b, c);
        }
    }, fa.each([ "width", "height" ], function(a, b) {
        fa.attrHooks[b] = {
            set: function(a, c) {
                return "" === c ? (a.setAttribute(b, "auto"), c) : void 0;
            }
        };
    })), da.style || (fa.attrHooks.style = {
        get: function(a) {
            return a.style.cssText || void 0;
        },
        set: function(a, b) {
            return a.style.cssText = b + "";
        }
    });
    var Cb = /^(?:input|select|textarea|button|object)$/i, Db = /^(?:a|area)$/i;
    fa.fn.extend({
        prop: function(a, b) {
            return Ea(this, fa.prop, a, b, arguments.length > 1);
        },
        removeProp: function(a) {
            return a = fa.propFix[a] || a, this.each(function() {
                try {
                    this[a] = void 0, delete this[a];
                } catch (a) {}
            });
        }
    }), fa.extend({
        propFix: {
            for: "htmlFor",
            class: "className"
        },
        prop: function(a, b, c) {
            var d, e, f, g = a.nodeType;
            if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !fa.isXMLDoc(a), f && (b = fa.propFix[b] || b, 
            e = fa.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];
        },
        propHooks: {
            tabIndex: {
                get: function(a) {
                    var b = fa.find.attr(a, "tabindex");
                    return b ? parseInt(b, 10) : Cb.test(a.nodeName) || Db.test(a.nodeName) && a.href ? 0 : -1;
                }
            }
        }
    }), da.hrefNormalized || fa.each([ "href", "src" ], function(a, b) {
        fa.propHooks[b] = {
            get: function(a) {
                return a.getAttribute(b, 4);
            }
        };
    }), da.optSelected || (fa.propHooks.selected = {
        get: function(a) {
            var b = a.parentNode;
            return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null;
        }
    }), fa.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        fa.propFix[this.toLowerCase()] = this;
    }), da.enctype || (fa.propFix.enctype = "encoding");
    var Eb = /[\t\r\n\f]/g;
    fa.fn.extend({
        addClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
            if (fa.isFunction(a)) return this.each(function(b) {
                fa(this).addClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(ua) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(Eb, " ") : " ")) {
                for (f = 0; e = b[f++]; ) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                g = fa.trim(d), c.className !== g && (c.className = g);
            }
            return this;
        },
        removeClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
            if (fa.isFunction(a)) return this.each(function(b) {
                fa(this).removeClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(ua) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(Eb, " ") : "")) {
                for (f = 0; e = b[f++]; ) for (;d.indexOf(" " + e + " ") >= 0; ) d = d.replace(" " + e + " ", " ");
                g = a ? fa.trim(d) : "", c.className !== g && (c.className = g);
            }
            return this;
        },
        toggleClass: function(a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(fa.isFunction(a) ? function(c) {
                fa(this).toggleClass(a.call(this, c, this.className, b), b);
            } : function() {
                if ("string" === c) for (var b, d = 0, e = fa(this), f = a.match(ua) || []; b = f[d++]; ) e.hasClass(b) ? e.removeClass(b) : e.addClass(b); else (c === ya || "boolean" === c) && (this.className && fa._data(this, "__className__", this.className), 
                this.className = this.className || a === !1 ? "" : fa._data(this, "__className__") || "");
            });
        },
        hasClass: function(a) {
            for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(Eb, " ").indexOf(b) >= 0) return !0;
            return !1;
        }
    }), fa.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
        fa.fn[b] = function(a, c) {
            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
        };
    }), fa.fn.extend({
        hover: function(a, b) {
            return this.mouseenter(a).mouseleave(b || a);
        },
        bind: function(a, b, c) {
            return this.on(a, null, b, c);
        },
        unbind: function(a, b) {
            return this.off(a, null, b);
        },
        delegate: function(a, b, c, d) {
            return this.on(b, a, c, d);
        },
        undelegate: function(a, b, c) {
            return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
        }
    });
    var Fb = fa.now(), Gb = /\?/, Hb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    fa.parseJSON = function(b) {
        if (a.JSON && a.JSON.parse) return a.JSON.parse(b + "");
        var c, d = null, e = fa.trim(b + "");
        return e && !fa.trim(e.replace(Hb, function(a, b, e, f) {
            return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "");
        })) ? Function("return " + e)() : fa.error("Invalid JSON: " + b);
    }, fa.parseXML = function(b) {
        var c, d;
        if (!b || "string" != typeof b) return null;
        try {
            a.DOMParser ? (d = new DOMParser(), c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), 
            c.async = "false", c.loadXML(b));
        } catch (a) {
            c = void 0;
        }
        return c && c.documentElement && !c.getElementsByTagName("parsererror").length || fa.error("Invalid XML: " + b), 
        c;
    };
    var Ib, Jb, Kb = /#.*$/, Lb = /([?&])_=[^&]*/, Mb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Nb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Ob = /^(?:GET|HEAD)$/, Pb = /^\/\//, Qb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Rb = {}, Sb = {}, Tb = "*/".concat("*");
    try {
        Jb = location.href;
    } catch (a) {
        Jb = pa.createElement("a"), Jb.href = "", Jb = Jb.href;
    }
    Ib = Qb.exec(Jb.toLowerCase()) || [], fa.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Jb,
            type: "GET",
            isLocal: Nb.test(Ib[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Tb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": fa.parseJSON,
                "text xml": fa.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(a, b) {
            return b ? P(P(a, fa.ajaxSettings), b) : P(fa.ajaxSettings, a);
        },
        ajaxPrefilter: N(Rb),
        ajaxTransport: N(Sb),
        ajax: function(a, b) {
            function c(a, b, c, d) {
                var e, k, r, s, u, w = b;
                2 !== t && (t = 2, h && clearTimeout(h), j = void 0, g = d || "", v.readyState = a > 0 ? 4 : 0, 
                e = a >= 200 && 300 > a || 304 === a, c && (s = Q(l, v, c)), s = R(l, s, v, e), 
                e ? (l.ifModified && (u = v.getResponseHeader("Last-Modified"), u && (fa.lastModified[f] = u), 
                u = v.getResponseHeader("etag"), u && (fa.etag[f] = u)), 204 === a || "HEAD" === l.type ? w = "nocontent" : 304 === a ? w = "notmodified" : (w = s.state, 
                k = s.data, r = s.error, e = !r)) : (r = w, (a || !w) && (w = "error", 0 > a && (a = 0))), 
                v.status = a, v.statusText = (b || w) + "", e ? o.resolveWith(m, [ k, w, v ]) : o.rejectWith(m, [ v, w, r ]), 
                v.statusCode(q), q = void 0, i && n.trigger(e ? "ajaxSuccess" : "ajaxError", [ v, l, e ? k : r ]), 
                p.fireWith(m, [ v, w ]), i && (n.trigger("ajaxComplete", [ v, l ]), --fa.active || fa.event.trigger("ajaxStop")));
            }
            "object" == typeof a && (b = a, a = void 0), b = b || {};
            var d, e, f, g, h, i, j, k, l = fa.ajaxSetup({}, b), m = l.context || l, n = l.context && (m.nodeType || m.jquery) ? fa(m) : fa.event, o = fa.Deferred(), p = fa.Callbacks("once memory"), q = l.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                readyState: 0,
                getResponseHeader: function(a) {
                    var b;
                    if (2 === t) {
                        if (!k) for (k = {}; b = Mb.exec(g); ) k[b[1].toLowerCase()] = b[2];
                        b = k[a.toLowerCase()];
                    }
                    return null == b ? null : b;
                },
                getAllResponseHeaders: function() {
                    return 2 === t ? g : null;
                },
                setRequestHeader: function(a, b) {
                    var c = a.toLowerCase();
                    return t || (a = s[c] = s[c] || a, r[a] = b), this;
                },
                overrideMimeType: function(a) {
                    return t || (l.mimeType = a), this;
                },
                statusCode: function(a) {
                    var b;
                    if (a) if (2 > t) for (b in a) q[b] = [ q[b], a[b] ]; else v.always(a[v.status]);
                    return this;
                },
                abort: function(a) {
                    var b = a || u;
                    return j && j.abort(b), c(0, b), this;
                }
            };
            if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, l.url = ((a || l.url || Jb) + "").replace(Kb, "").replace(Pb, Ib[1] + "//"), 
            l.type = b.method || b.type || l.method || l.type, l.dataTypes = fa.trim(l.dataType || "*").toLowerCase().match(ua) || [ "" ], 
            null == l.crossDomain && (d = Qb.exec(l.url.toLowerCase()), l.crossDomain = !(!d || d[1] === Ib[1] && d[2] === Ib[2] && (d[3] || ("http:" === d[1] ? "80" : "443")) === (Ib[3] || ("http:" === Ib[1] ? "80" : "443")))), 
            l.data && l.processData && "string" != typeof l.data && (l.data = fa.param(l.data, l.traditional)), 
            O(Rb, l, b, v), 2 === t) return v;
            i = l.global, i && 0 === fa.active++ && fa.event.trigger("ajaxStart"), l.type = l.type.toUpperCase(), 
            l.hasContent = !Ob.test(l.type), f = l.url, l.hasContent || (l.data && (f = l.url += (Gb.test(f) ? "&" : "?") + l.data, 
            delete l.data), l.cache === !1 && (l.url = Lb.test(f) ? f.replace(Lb, "$1_=" + Fb++) : f + (Gb.test(f) ? "&" : "?") + "_=" + Fb++)), 
            l.ifModified && (fa.lastModified[f] && v.setRequestHeader("If-Modified-Since", fa.lastModified[f]), 
            fa.etag[f] && v.setRequestHeader("If-None-Match", fa.etag[f])), (l.data && l.hasContent && l.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", l.contentType), 
            v.setRequestHeader("Accept", l.dataTypes[0] && l.accepts[l.dataTypes[0]] ? l.accepts[l.dataTypes[0]] + ("*" !== l.dataTypes[0] ? ", " + Tb + "; q=0.01" : "") : l.accepts["*"]);
            for (e in l.headers) v.setRequestHeader(e, l.headers[e]);
            if (l.beforeSend && (l.beforeSend.call(m, v, l) === !1 || 2 === t)) return v.abort();
            u = "abort";
            for (e in {
                success: 1,
                error: 1,
                complete: 1
            }) v[e](l[e]);
            if (j = O(Sb, l, b, v)) {
                v.readyState = 1, i && n.trigger("ajaxSend", [ v, l ]), l.async && l.timeout > 0 && (h = setTimeout(function() {
                    v.abort("timeout");
                }, l.timeout));
                try {
                    t = 1, j.send(r, c);
                } catch (a) {
                    if (!(2 > t)) throw a;
                    c(-1, a);
                }
            } else c(-1, "No Transport");
            return v;
        },
        getJSON: function(a, b, c) {
            return fa.get(a, b, c, "json");
        },
        getScript: function(a, b) {
            return fa.get(a, void 0, b, "script");
        }
    }), fa.each([ "get", "post" ], function(a, b) {
        fa[b] = function(a, c, d, e) {
            return fa.isFunction(c) && (e = e || d, d = c, c = void 0), fa.ajax({
                url: a,
                type: b,
                dataType: e,
                data: c,
                success: d
            });
        };
    }), fa.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(a, b) {
        fa.fn[b] = function(a) {
            return this.on(b, a);
        };
    }), fa._evalUrl = function(a) {
        return fa.ajax({
            url: a,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            throws: !0
        });
    }, fa.fn.extend({
        wrapAll: function(a) {
            if (fa.isFunction(a)) return this.each(function(b) {
                fa(this).wrapAll(a.call(this, b));
            });
            if (this[0]) {
                var b = fa(a, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                    for (var a = this; a.firstChild && 1 === a.firstChild.nodeType; ) a = a.firstChild;
                    return a;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(a) {
            return this.each(fa.isFunction(a) ? function(b) {
                fa(this).wrapInner(a.call(this, b));
            } : function() {
                var b = fa(this), c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a);
            });
        },
        wrap: function(a) {
            var b = fa.isFunction(a);
            return this.each(function(c) {
                fa(this).wrapAll(b ? a.call(this, c) : a);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                fa.nodeName(this, "body") || fa(this).replaceWith(this.childNodes);
            }).end();
        }
    }), fa.expr.filters.hidden = function(a) {
        return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !da.reliableHiddenOffsets() && "none" === (a.style && a.style.display || fa.css(a, "display"));
    }, fa.expr.filters.visible = function(a) {
        return !fa.expr.filters.hidden(a);
    };
    var Ub = /%20/g, Vb = /\[\]$/, Wb = /\r?\n/g, Xb = /^(?:submit|button|image|reset|file)$/i, Yb = /^(?:input|select|textarea|keygen)/i;
    fa.param = function(a, b) {
        var c, d = [], e = function(a, b) {
            b = fa.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
        };
        if (void 0 === b && (b = fa.ajaxSettings && fa.ajaxSettings.traditional), fa.isArray(a) || a.jquery && !fa.isPlainObject(a)) fa.each(a, function() {
            e(this.name, this.value);
        }); else for (c in a) S(c, a[c], b, e);
        return d.join("&").replace(Ub, "+");
    }, fa.fn.extend({
        serialize: function() {
            return fa.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var a = fa.prop(this, "elements");
                return a ? fa.makeArray(a) : this;
            }).filter(function() {
                var a = this.type;
                return this.name && !fa(this).is(":disabled") && Yb.test(this.nodeName) && !Xb.test(a) && (this.checked || !Fa.test(a));
            }).map(function(a, b) {
                var c = fa(this).val();
                return null == c ? null : fa.isArray(c) ? fa.map(c, function(a) {
                    return {
                        name: b.name,
                        value: a.replace(Wb, "\r\n")
                    };
                }) : {
                    name: b.name,
                    value: c.replace(Wb, "\r\n")
                };
            }).get();
        }
    }), fa.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && T() || U();
    } : T;
    var Zb = 0, $b = {}, _b = fa.ajaxSettings.xhr();
    a.ActiveXObject && fa(a).on("unload", function() {
        for (var a in $b) $b[a](void 0, !0);
    }), da.cors = !!_b && "withCredentials" in _b, _b = da.ajax = !!_b, _b && fa.ajaxTransport(function(a) {
        if (!a.crossDomain || da.cors) {
            var b;
            return {
                send: function(c, d) {
                    var e, f = a.xhr(), g = ++Zb;
                    if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
                    a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                    for (e in c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                    f.send(a.hasContent && a.data || null), b = function(c, e) {
                        var h, i, j;
                        if (b && (e || 4 === f.readyState)) if (delete $b[g], b = void 0, f.onreadystatechange = fa.noop, 
                        e) 4 !== f.readyState && f.abort(); else {
                            j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                            try {
                                i = f.statusText;
                            } catch (a) {
                                i = "";
                            }
                            h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
                        }
                        j && d(h, i, j, f.getAllResponseHeaders());
                    }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = $b[g] = b : b();
                },
                abort: function() {
                    b && b(void 0, !0);
                }
            };
        }
    }), fa.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(a) {
                return fa.globalEval(a), a;
            }
        }
    }), fa.ajaxPrefilter("script", function(a) {
        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1);
    }), fa.ajaxTransport("script", function(a) {
        if (a.crossDomain) {
            var b, c = pa.head || fa("head")[0] || pa.documentElement;
            return {
                send: function(d, e) {
                    b = pa.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), 
                    b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
                        (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, 
                        b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"));
                    }, c.insertBefore(b, c.firstChild);
                },
                abort: function() {
                    b && b.onload(void 0, !0);
                }
            };
        }
    });
    var ac = [], bc = /(=)\?(?=&|$)|\?\?/;
    fa.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var a = ac.pop() || fa.expando + "_" + Fb++;
            return this[a] = !0, a;
        }
    }), fa.ajaxPrefilter("json jsonp", function(b, c, d) {
        var e, f, g, h = b.jsonp !== !1 && (bc.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && bc.test(b.data) && "data");
        return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = fa.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, 
        h ? b[h] = b[h].replace(bc, "$1" + e) : b.jsonp !== !1 && (b.url += (Gb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), 
        b.converters["script json"] = function() {
            return g || fa.error(e + " was not called"), g[0];
        }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
            g = arguments;
        }, d.always(function() {
            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, ac.push(e)), g && fa.isFunction(f) && f(g[0]), 
            g = f = void 0;
        }), "script") : void 0;
    }), fa.parseHTML = function(a, b, c) {
        if (!a || "string" != typeof a) return null;
        "boolean" == typeof b && (c = b, b = !1), b = b || pa;
        var d = ma.exec(a), e = !c && [];
        return d ? [ b.createElement(d[1]) ] : (d = fa.buildFragment([ a ], b, e), e && e.length && fa(e).remove(), 
        fa.merge([], d.childNodes));
    };
    var cc = fa.fn.load;
    fa.fn.load = function(a, b, c) {
        if ("string" != typeof a && cc) return cc.apply(this, arguments);
        var d, e, f, g = this, h = a.indexOf(" ");
        return h >= 0 && (d = a.slice(h, a.length), a = a.slice(0, h)), fa.isFunction(b) ? (c = b, 
        b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && fa.ajax({
            url: a,
            type: f,
            dataType: "html",
            data: b
        }).done(function(a) {
            e = arguments, g.html(d ? fa("<div>").append(fa.parseHTML(a)).find(d) : a);
        }).complete(c && function(a, b) {
            g.each(c, e || [ a.responseText, b, a ]);
        }), this;
    }, fa.expr.filters.animated = function(a) {
        return fa.grep(fa.timers, function(b) {
            return a === b.elem;
        }).length;
    };
    var dc = a.document.documentElement;
    fa.offset = {
        setOffset: function(a, b, c) {
            var d, e, f, g, h, i, j, k = fa.css(a, "position"), l = fa(a), m = {};
            "static" === k && (a.style.position = "relative"), h = l.offset(), f = fa.css(a, "top"), 
            i = fa.css(a, "left"), j = ("absolute" === k || "fixed" === k) && fa.inArray("auto", [ f, i ]) > -1, 
            j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), 
            fa.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), 
            null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m);
        }
    }, fa.fn.extend({
        offset: function(a) {
            if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                fa.offset.setOffset(this, a, b);
            });
            var b, c, d = {
                top: 0,
                left: 0
            }, e = this[0], f = e && e.ownerDocument;
            return f ? (b = f.documentElement, fa.contains(b, e) ? (typeof e.getBoundingClientRect !== ya && (d = e.getBoundingClientRect()), 
            c = V(f), {
                top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
            }) : d) : void 0;
        },
        position: function() {
            if (this[0]) {
                var a, b, c = {
                    top: 0,
                    left: 0
                }, d = this[0];
                return "fixed" === fa.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), 
                b = this.offset(), fa.nodeName(a[0], "html") || (c = a.offset()), c.top += fa.css(a[0], "borderTopWidth", !0), 
                c.left += fa.css(a[0], "borderLeftWidth", !0)), {
                    top: b.top - c.top - fa.css(d, "marginTop", !0),
                    left: b.left - c.left - fa.css(d, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var a = this.offsetParent || dc; a && !fa.nodeName(a, "html") && "static" === fa.css(a, "position"); ) a = a.offsetParent;
                return a || dc;
            });
        }
    }), fa.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(a, b) {
        var c = /Y/.test(b);
        fa.fn[a] = function(d) {
            return Ea(this, function(a, d, e) {
                var f = V(a);
                return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? fa(f).scrollLeft() : e, c ? e : fa(f).scrollTop()) : a[d] = e);
            }, a, d, arguments.length, null);
        };
    }), fa.each([ "top", "left" ], function(a, b) {
        fa.cssHooks[b] = A(da.pixelPosition, function(a, c) {
            return c ? (c = cb(a, b), eb.test(c) ? fa(a).position()[b] + "px" : c) : void 0;
        });
    }), fa.each({
        Height: "height",
        Width: "width"
    }, function(a, b) {
        fa.each({
            padding: "inner" + a,
            content: b,
            "": "outer" + a
        }, function(c, d) {
            fa.fn[d] = function(d, e) {
                var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border");
                return Ea(this, function(b, c, d) {
                    var e;
                    return fa.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, 
                    Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? fa.css(b, c, g) : fa.style(b, c, d, g);
                }, b, f ? d : void 0, f, null);
            };
        });
    }), fa.fn.size = function() {
        return this.length;
    }, fa.fn.andSelf = fa.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return fa;
    });
    var ec = a.jQuery, fc = a.$;
    return fa.noConflict = function(b) {
        return a.$ === fa && (a.$ = fc), b && a.jQuery === fa && (a.jQuery = ec), fa;
    }, typeof b === ya && (a.jQuery = a.$ = fa), fa;
}), function() {
    var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t = {}.hasOwnProperty, u = [].indexOf || function(a) {
        for (var b = 0, c = this.length; b < c; b++) if (b in this && this[b] === a) return b;
        return -1;
    };
    f = {
        is_unordered: !1,
        is_counting: !1,
        is_exclusive: !1,
        is_solitary: !1,
        prevent_default: !1,
        prevent_repeat: !1
    }, r = "meta alt option ctrl shift cmd".split(" "), p = "ctrl", a = {
        debug: !1
    };
    var v = function(a) {
        var b, c;
        for (b in a) t.call(a, b) && (c = a[b], !1 !== c && (this[b] = c));
        this.keys = this.keys || [], this.count = this.count || 0;
    };
    v.prototype.allows_key_repeat = function() {
        return !this.prevent_repeat && "function" == typeof this.on_keydown;
    }, v.prototype.reset = function() {
        return this.count = 0, this.keyup_fired = null;
    };
    var w = function(a, b) {
        var c, d;
        "undefined" != typeof jQuery && null !== jQuery && a instanceof jQuery && (1 !== a.length && o("Warning: your jQuery selector should have exactly one object."), 
        a = a[0]), this.should_force_event_defaults = this.should_suppress_event_defaults = !1, 
        this.sequence_delay = 800, this._registered_combos = [], this._keys_down = [], this._active_combos = [], 
        this._sequence = [], this._sequence_timer = null, this._prevent_capture = !1, this._defaults = b || {};
        for (c in f) t.call(f, c) && (d = f[c], this._defaults[c] = this._defaults[c] || d);
        this.element = a || document.body, c = function(a, b, c) {
            return a.addEventListener ? a.addEventListener(b, c) : a.attachEvent && a.attachEvent("on" + b, c), 
            c;
        };
        var e = this;
        this.keydown_event = c(this.element, "keydown", function(a) {
            return a = a || window.event, e._receive_input(a, !0), e._bug_catcher(a);
        });
        var g = this;
        this.keyup_event = c(this.element, "keyup", function(a) {
            return a = a || window.event, g._receive_input(a, !1);
        });
        var h = this;
        this.blur_event = c(window, "blur", function() {
            var a, b, c, d;
            for (d = h._keys_down, b = 0, c = d.length; b < c; b++) a = d[b], h._key_up(a, {});
            return h._keys_down = [];
        });
    };
    w.prototype.destroy = function() {
        var a;
        return a = function(a, b, c) {
            return null != a.removeEventListener ? a.removeEventListener(b, c) : null != a.removeEvent ? a.removeEvent("on" + b, c) : void 0;
        }, a(this.element, "keydown", this.keydown_event), a(this.element, "keyup", this.keyup_event), 
        a(window, "blur", this.blur_event);
    }, w.prototype._bug_catcher = function(a) {
        var b, c;
        if ("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && "cmd" !== (b = d(null != (c = a.keyCode) ? c : a.key)) && "shift" !== b && "alt" !== b && "caps" !== b && "tab" !== b) return this._receive_input(a, !1);
    }, w.prototype._cmd_bug_check = function(a) {
        return !("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && 0 > u.call(a, "cmd"));
    }, w.prototype._prevent_default = function(a, b) {
        if ((b || this.should_suppress_event_defaults) && !this.should_force_event_defaults && (a.preventDefault ? a.preventDefault() : a.returnValue = !1, 
        a.stopPropagation)) return a.stopPropagation();
    }, w.prototype._get_active_combos = function(a) {
        var b, c;
        return b = [], c = g(this._keys_down, function(b) {
            return b !== a;
        }), c.push(a), this._match_combo_arrays(c, function(a) {
            return function(c) {
                if (a._cmd_bug_check(c.keys)) return b.push(c);
            };
        }(this)), this._fuzzy_match_combo_arrays(c, function(a) {
            return function(c) {
                if (!(0 <= u.call(b, c)) && !c.is_solitary && a._cmd_bug_check(c.keys)) return b.push(c);
            };
        }(this)), b;
    }, w.prototype._get_potential_combos = function(a) {
        var b, c, d, e, f;
        for (c = [], f = this._registered_combos, d = 0, e = f.length; d < e; d++) b = f[d], 
        b.is_sequence || 0 <= u.call(b.keys, a) && this._cmd_bug_check(b.keys) && c.push(b);
        return c;
    }, w.prototype._add_to_active_combos = function(a) {
        var b, c, d, e, f, g, h, i, j, k, l;
        if (g = !1, f = !0, d = !1, 0 <= u.call(this._active_combos, a)) return !0;
        if (this._active_combos.length) for (e = h = 0, k = this._active_combos.length; 0 <= k ? h < k : h > k; e = 0 <= k ? ++h : --h) if ((b = this._active_combos[e]) && b.is_exclusive && a.is_exclusive) {
            if (b = b.keys, !g) for (i = 0, j = b.length; i < j; i++) if (c = b[i], g = !0, 
            0 > u.call(a.keys, c)) {
                g = !1;
                break;
            }
            if (f && !g) for (l = a.keys, i = 0, j = l.length; i < j; i++) if (c = l[i], f = !1, 
            0 > u.call(b, c)) {
                f = !0;
                break;
            }
            g && (d ? (b = this._active_combos.splice(e, 1)[0], null != b && b.reset()) : (b = this._active_combos.splice(e, 1, a)[0], 
            null != b && b.reset(), d = !0), f = !1);
        }
        return f && this._active_combos.unshift(a), g || f;
    }, w.prototype._remove_from_active_combos = function(a) {
        var b, c, d, e;
        for (c = d = 0, e = this._active_combos.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d) if (b = this._active_combos[c], 
        b === a) {
            a = this._active_combos.splice(c, 1)[0], a.reset();
            break;
        }
    }, w.prototype._get_possible_sequences = function() {
        var a, b, c, d, e, f, h, i, j, k, l, m;
        for (d = [], k = this._registered_combos, f = 0, j = k.length; f < j; f++) for (a = k[f], 
        b = h = 1, l = this._sequence.length; 1 <= l ? h <= l : h >= l; b = 1 <= l ? ++h : --h) if (e = this._sequence.slice(-b), 
        a.is_sequence) {
            if (0 > u.call(a.keys, "shift") && (e = g(e, function(a) {
                return "shift" !== a;
            }), !e.length)) continue;
            for (b = i = 0, m = e.length; 0 <= m ? i < m : i > m; b = 0 <= m ? ++i : --i) {
                if (a.keys[b] !== e[b]) {
                    c = !1;
                    break;
                }
                c = !0;
            }
            c && d.push(a);
        }
        return d;
    }, w.prototype._add_key_to_sequence = function(a, b) {
        var c, d, e, f;
        if (this._sequence.push(a), d = this._get_possible_sequences(), d.length) {
            for (e = 0, f = d.length; e < f; e++) c = d[e], this._prevent_default(b, c.prevent_default);
            this._sequence_timer && clearTimeout(this._sequence_timer), -1 < this.sequence_delay && (this._sequence_timer = setTimeout(function() {
                return this._sequence = [];
            }, this.sequence_delay));
        } else this._sequence = [];
    }, w.prototype._get_sequence = function(a) {
        var b, c, d, e, f, h, i, j, k, l, m, n;
        for (l = this._registered_combos, h = 0, k = l.length; h < k; h++) if (b = l[h], 
        b.is_sequence) {
            for (c = i = 1, m = this._sequence.length; 1 <= m ? i <= m : i >= m; c = 1 <= m ? ++i : --i) if (f = g(this._sequence, function(a) {
                return 0 <= u.call(b.keys, "shift") || "shift" !== a;
            }).slice(-c), b.keys.length === f.length) for (c = j = 0, n = f.length; 0 <= n ? j < n : j > n; c = 0 <= n ? ++j : --j) if (e = f[c], 
            !(0 > u.call(b.keys, "shift") && "shift" === e || "shift" === a && 0 > u.call(b.keys, "shift"))) {
                if (b.keys[c] !== e) {
                    d = !1;
                    break;
                }
                d = !0;
            }
            if (d) return b.is_exclusive && (this._sequence = []), b;
        }
        return !1;
    }, w.prototype._receive_input = function(a, b) {
        var c, e;
        if (this._prevent_capture) this._keys_down.length && (this._keys_down = []); else if (c = d(null != (e = a.keyCode) ? e : a.key), 
        (b || this._keys_down.length || !("alt" === c || c === p)) && c) return b ? this._key_down(c, a) : this._key_up(c, a);
    }, w.prototype._fire = function(a, b, c, d) {
        if ("function" == typeof b["on_" + a] && this._prevent_default(c, !0 !== b["on_" + a].call(b.this, c, b.count, d)), 
        "release" === a && (b.count = 0), "keyup" === a) return b.keyup_fired = !0;
    }, w.prototype._match_combo_arrays = function(a, d) {
        var e, f, g, h;
        for (h = this._registered_combos, f = 0, g = h.length; f < g; f++) e = h[f], (!e.is_unordered && c(a, e.keys) || e.is_unordered && b(a, e.keys)) && d(e);
    }, w.prototype._fuzzy_match_combo_arrays = function(a, b) {
        var c, d, e, f;
        for (f = this._registered_combos, d = 0, e = f.length; d < e; d++) c = f[d], (!c.is_unordered && j(c.keys, a) || c.is_unordered && i(c.keys, a)) && b(c);
    }, w.prototype._keys_remain = function(a) {
        var b, c, d, e;
        for (e = a.keys, c = 0, d = e.length; c < d; c++) if (a = e[c], 0 <= u.call(this._keys_down, a)) {
            b = !0;
            break;
        }
        return b;
    }, w.prototype._key_down = function(a, b) {
        var c, d, f, g, h;
        (c = e(a, b)) && (a = c), this._add_key_to_sequence(a, b), (c = this._get_sequence(a)) && this._fire("keydown", c, b);
        for (f in q) c = q[f], b[c] && (f === a || 0 <= u.call(this._keys_down, f) || this._keys_down.push(f));
        for (f in q) if (c = q[f], f !== a && 0 <= u.call(this._keys_down, f) && !b[c] && !("cmd" === f && "cmd" !== p)) for (c = d = 0, 
        g = this._keys_down.length; 0 <= g ? d < g : d > g; c = 0 <= g ? ++d : --d) this._keys_down[c] === f && this._keys_down.splice(c, 1);
        for (d = this._get_active_combos(a), f = this._get_potential_combos(a), g = 0, h = d.length; g < h; g++) c = d[g], 
        this._handle_combo_down(c, f, a, b);
        if (f.length) for (d = 0, g = f.length; d < g; d++) c = f[d], this._prevent_default(b, c.prevent_default);
        0 > u.call(this._keys_down, a) && this._keys_down.push(a);
    }, w.prototype._handle_combo_down = function(a, b, c, d) {
        var e, f, g, h, i;
        if (0 > u.call(a.keys, c)) return !1;
        if (this._prevent_default(d, a && a.prevent_default), e = !1, 0 <= u.call(this._keys_down, c) && (e = !0, 
        !a.allows_key_repeat())) return !1;
        if (g = this._add_to_active_combos(a, c), c = a.keyup_fired = !1, a.is_exclusive) for (h = 0, 
        i = b.length; h < i; h++) if (f = b[h], f.is_exclusive && f.keys.length > a.keys.length) {
            c = !0;
            break;
        }
        return !c && (a.is_counting && "function" == typeof a.on_keydown && (a.count += 1), 
        g) ? this._fire("keydown", a, d, e) : void 0;
    }, w.prototype._key_up = function(a, b) {
        var c, d, f, g, h, i;
        if (c = a, (f = e(a, b)) && (a = f), f = n[c], b.shiftKey ? f && 0 <= u.call(this._keys_down, f) || (a = c) : c && 0 <= u.call(this._keys_down, c) || (a = f), 
        (g = this._get_sequence(a)) && this._fire("keyup", g, b), 0 > u.call(this._keys_down, a)) return !1;
        for (g = h = 0, i = this._keys_down.length; 0 <= i ? h < i : h > i; g = 0 <= i ? ++h : --h) if ((d = this._keys_down[g]) === a || d === f || d === c) {
            this._keys_down.splice(g, 1);
            break;
        }
        for (d = this._active_combos.length, f = [], i = this._active_combos, g = 0, h = i.length; g < h; g++) c = i[g], 
        0 <= u.call(c.keys, a) && f.push(c);
        for (g = 0, h = f.length; g < h; g++) c = f[g], this._handle_combo_up(c, b, a);
        if (1 < d) for (h = this._active_combos, d = 0, g = h.length; d < g; d++) c = h[d], 
        void 0 === c || 0 <= u.call(f, c) || this._keys_remain(c) || this._remove_from_active_combos(c);
    }, w.prototype._handle_combo_up = function(a, c, d) {
        var e, f;
        this._prevent_default(c, a && a.prevent_default), f = this._keys_remain(a), a.keyup_fired || (e = this._keys_down.slice(), 
        e.push(d), a.is_solitary && !b(e, a.keys)) || (this._fire("keyup", a, c), a.is_counting && "function" == typeof a.on_keyup && "function" != typeof a.on_keydown && (a.count += 1)), 
        f || (this._fire("release", a, c), this._remove_from_active_combos(a));
    }, w.prototype.simple_combo = function(a, b) {
        return this.register_combo({
            keys: a,
            on_keydown: b
        });
    }, w.prototype.counting_combo = function(a, b) {
        return this.register_combo({
            keys: a,
            is_counting: !0,
            is_unordered: !1,
            on_keydown: b
        });
    }, w.prototype.sequence_combo = function(a, b) {
        return this.register_combo({
            keys: a,
            on_keydown: b,
            is_sequence: !0,
            is_exclusive: !0
        });
    }, w.prototype.register_combo = function(a) {
        var b, c, d;
        "string" == typeof a.keys && (a.keys = a.keys.split(" ")), d = this._defaults;
        for (b in d) t.call(d, b) && (c = d[b], void 0 === a[b] && (a[b] = c));
        if (a = new v(a), s(a)) return this._registered_combos.push(a), a;
    }, w.prototype.register_many = function(a) {
        var b, c, d, e;
        for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.register_combo(b));
        return e;
    }, w.prototype.unregister_combo = function(a) {
        var d, e, f, g, h, i;
        if (!a) return !1;
        var j = this;
        if (e = function(a) {
            var b, c, d, e;
            for (e = [], b = c = 0, d = j._registered_combos.length; 0 <= d ? c < d : c > d; b = 0 <= d ? ++c : --c) {
                if (a === j._registered_combos[b]) {
                    j._registered_combos.splice(b, 1);
                    break;
                }
                e.push(void 0);
            }
            return e;
        }, a instanceof v) return e(a);
        for ("string" == typeof a && (a = a.split(" ")), h = this._registered_combos, i = [], 
        f = 0, g = h.length; f < g; f++) d = h[f], null != d && (d.is_unordered && b(a, d.keys) || !d.is_unordered && c(a, d.keys) ? i.push(e(d)) : i.push(void 0));
        return i;
    }, w.prototype.unregister_many = function(a) {
        var b, c, d, e;
        for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.unregister_combo(b));
        return e;
    }, w.prototype.get_registered_combos = function() {
        return this._registered_combos;
    }, w.prototype.reset = function() {
        return this._registered_combos = [];
    }, w.prototype.listen = function() {
        return this._prevent_capture = !1;
    }, w.prototype.stop_listening = function() {
        return this._prevent_capture = !0;
    }, w.prototype.get_meta_key = function() {
        return p;
    }, a.Listener = w, d = function(a) {
        return m[a];
    }, g = function(a, b) {
        var c;
        if (a.filter) return a.filter(b);
        var d, e, f;
        for (f = [], d = 0, e = a.length; d < e; d++) c = a[d], b(c) && f.push(c);
        return f;
    }, b = function(a, b) {
        var c, d, e;
        if (a.length !== b.length) return !1;
        for (d = 0, e = a.length; d < e; d++) if (c = a[d], !(0 <= u.call(b, c))) return !1;
        return !0;
    }, c = function(a, b) {
        var c, d, e;
        if (a.length !== b.length) return !1;
        for (c = d = 0, e = a.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d) if (a[c] !== b[c]) return !1;
        return !0;
    }, i = function(a, b) {
        var c, d, e;
        for (d = 0, e = a.length; d < e; d++) if (c = a[d], 0 > u.call(b, c)) return !1;
        return !0;
    }, h = Array.prototype.indexOf || function(a, b) {
        var c, d, e;
        for (c = d = 0, e = a.length; 0 <= e ? d <= e : d >= e; c = 0 <= e ? ++d : --d) if (a[c] === b) return c;
        return -1;
    }, j = function(a, b) {
        var c, d, e, f;
        for (e = d = 0, f = a.length; e < f; e++) {
            if (c = a[e], c = h.call(b, c), !(c >= d)) return !1;
            d = c;
        }
        return !0;
    }, o = function() {
        if (a.debug) return console.log.apply(console, arguments);
    }, k = function(a) {
        var b, c, d;
        b = !1;
        for (d in m) if (c = m[d], a === c) {
            b = !0;
            break;
        }
        if (!b) for (d in n) if (c = n[d], a === c) {
            b = !0;
            break;
        }
        return b;
    }, s = function(a) {
        var b, c, d, e, g, i, j;
        for (g = !0, a.keys.length || o("You're trying to bind a combo with no keys:", a), 
        c = i = 0, j = a.keys.length; 0 <= j ? i < j : i > j; c = 0 <= j ? ++i : --i) d = a.keys[c], 
        (b = l[d]) && (d = a.keys[c] = b), "meta" === d && a.keys.splice(c, 1, p), "cmd" === d && o('Warning: use the "meta" key rather than "cmd" for Windows compatibility');
        for (j = a.keys, b = 0, i = j.length; b < i; b++) d = j[b], k(d) || (o('Do not recognize the key "' + d + '"'), 
        g = !1);
        if (0 <= u.call(a.keys, "meta") || 0 <= u.call(a.keys, "cmd")) {
            for (b = a.keys.slice(), i = 0, j = r.length; i < j; i++) d = r[i], -1 < (c = h.call(b, d)) && b.splice(c, 1);
            1 < b.length && (o("META and CMD key combos cannot have more than 1 non-modifier keys", a, b), 
            g = !1);
        }
        for (e in a) "undefined" === f[e] && o("The property " + e + " is not a valid combo property. Your combo has still been registered.");
        return g;
    }, e = function(a, b) {
        var c;
        return !!b.shiftKey && (c = n[a], null != c && c);
    }, q = {
        cmd: "metaKey",
        ctrl: "ctrlKey",
        shift: "shiftKey",
        alt: "altKey"
    }, l = {
        escape: "esc",
        control: "ctrl",
        command: "cmd",
        break: "pause",
        windows: "cmd",
        option: "alt",
        caps_lock: "caps",
        apostrophe: "'",
        semicolon: ";",
        tilde: "~",
        accent: "`",
        scroll_lock: "scroll",
        num_lock: "num"
    }, n = {
        "/": "?",
        ".": ">",
        ",": "<",
        "'": '"',
        ";": ":",
        "[": "{",
        "]": "}",
        "\\": "|",
        "`": "~",
        "=": "+",
        "-": "_",
        1: "!",
        2: "@",
        3: "#",
        4: "$",
        5: "%",
        6: "^",
        7: "&",
        8: "*",
        9: "(",
        "0": ")"
    }, m = {
        "0": "\\",
        8: "backspace",
        9: "tab",
        12: "num",
        13: "enter",
        16: "shift",
        17: "ctrl",
        18: "alt",
        19: "pause",
        20: "caps",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        44: "print",
        45: "insert",
        46: "delete",
        48: "0",
        49: "1",
        50: "2",
        51: "3",
        52: "4",
        53: "5",
        54: "6",
        55: "7",
        56: "8",
        57: "9",
        65: "a",
        66: "b",
        67: "c",
        68: "d",
        69: "e",
        70: "f",
        71: "g",
        72: "h",
        73: "i",
        74: "j",
        75: "k",
        76: "l",
        77: "m",
        78: "n",
        79: "o",
        80: "p",
        81: "q",
        82: "r",
        83: "s",
        84: "t",
        85: "u",
        86: "v",
        87: "w",
        88: "x",
        89: "y",
        90: "z",
        91: "cmd",
        92: "cmd",
        93: "cmd",
        96: "num_0",
        97: "num_1",
        98: "num_2",
        99: "num_3",
        100: "num_4",
        101: "num_5",
        102: "num_6",
        103: "num_7",
        104: "num_8",
        105: "num_9",
        106: "num_multiply",
        107: "num_add",
        108: "num_enter",
        109: "num_subtract",
        110: "num_decimal",
        111: "num_divide",
        112: "f1",
        113: "f2",
        114: "f3",
        115: "f4",
        116: "f5",
        117: "f6",
        118: "f7",
        119: "f8",
        120: "f9",
        121: "f10",
        122: "f11",
        123: "f12",
        124: "print",
        144: "num",
        145: "scroll",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        223: "`",
        224: "cmd",
        225: "alt",
        57392: "ctrl",
        63289: "num",
        59: ";",
        61: "=",
        173: "-"
    }, a._keycode_dictionary = m, a._is_array_in_array_sorted = j, -1 !== navigator.userAgent.indexOf("Mac OS X") && (p = "cmd"), 
    -1 !== navigator.userAgent.indexOf("Opera") && (m[17] = "cmd"), "function" == typeof define && define.amd ? define([], function() {
        return a;
    }) : "undefined" != typeof exports && null !== exports ? exports.keypress = a : window.keypress = a;
}.call(this);

var THREE = {
    REVISION: "77"
};

"function" == typeof define && define.amd ? define("three", THREE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = THREE), 
void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function(a) {
    return 0 > a ? -1 : 0 < a ? 1 : +a;
}), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
    get: function() {
        return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
    }
}), void 0 === Object.assign && function() {
    Object.assign = function(a) {
        if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
        for (var b = Object(a), c = 1; c < arguments.length; c++) {
            var d = arguments[c];
            if (void 0 !== d && null !== d) for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]);
        }
        return b;
    };
}(), Object.assign(THREE, {
    MOUSE: {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    },
    CullFaceNone: 0,
    CullFaceBack: 1,
    CullFaceFront: 2,
    CullFaceFrontBack: 3,
    FrontFaceDirectionCW: 0,
    FrontFaceDirectionCCW: 1,
    BasicShadowMap: 0,
    PCFShadowMap: 1,
    PCFSoftShadowMap: 2,
    FrontSide: 0,
    BackSide: 1,
    DoubleSide: 2,
    FlatShading: 1,
    SmoothShading: 2,
    NoColors: 0,
    FaceColors: 1,
    VertexColors: 2,
    NoBlending: 0,
    NormalBlending: 1,
    AdditiveBlending: 2,
    SubtractiveBlending: 3,
    MultiplyBlending: 4,
    CustomBlending: 5,
    AddEquation: 100,
    SubtractEquation: 101,
    ReverseSubtractEquation: 102,
    MinEquation: 103,
    MaxEquation: 104,
    ZeroFactor: 200,
    OneFactor: 201,
    SrcColorFactor: 202,
    OneMinusSrcColorFactor: 203,
    SrcAlphaFactor: 204,
    OneMinusSrcAlphaFactor: 205,
    DstAlphaFactor: 206,
    OneMinusDstAlphaFactor: 207,
    DstColorFactor: 208,
    OneMinusDstColorFactor: 209,
    SrcAlphaSaturateFactor: 210,
    NeverDepth: 0,
    AlwaysDepth: 1,
    LessDepth: 2,
    LessEqualDepth: 3,
    EqualDepth: 4,
    GreaterEqualDepth: 5,
    GreaterDepth: 6,
    NotEqualDepth: 7,
    MultiplyOperation: 0,
    MixOperation: 1,
    AddOperation: 2,
    NoToneMapping: 0,
    LinearToneMapping: 1,
    ReinhardToneMapping: 2,
    Uncharted2ToneMapping: 3,
    CineonToneMapping: 4,
    UVMapping: 300,
    CubeReflectionMapping: 301,
    CubeRefractionMapping: 302,
    EquirectangularReflectionMapping: 303,
    EquirectangularRefractionMapping: 304,
    SphericalReflectionMapping: 305,
    CubeUVReflectionMapping: 306,
    CubeUVRefractionMapping: 307,
    RepeatWrapping: 1e3,
    ClampToEdgeWrapping: 1001,
    MirroredRepeatWrapping: 1002,
    NearestFilter: 1003,
    NearestMipMapNearestFilter: 1004,
    NearestMipMapLinearFilter: 1005,
    LinearFilter: 1006,
    LinearMipMapNearestFilter: 1007,
    LinearMipMapLinearFilter: 1008,
    UnsignedByteType: 1009,
    ByteType: 1010,
    ShortType: 1011,
    UnsignedShortType: 1012,
    IntType: 1013,
    UnsignedIntType: 1014,
    FloatType: 1015,
    HalfFloatType: 1025,
    UnsignedShort4444Type: 1016,
    UnsignedShort5551Type: 1017,
    UnsignedShort565Type: 1018,
    AlphaFormat: 1019,
    RGBFormat: 1020,
    RGBAFormat: 1021,
    LuminanceFormat: 1022,
    LuminanceAlphaFormat: 1023,
    RGBEFormat: THREE.RGBAFormat,
    DepthFormat: 1026,
    RGB_S3TC_DXT1_Format: 2001,
    RGBA_S3TC_DXT1_Format: 2002,
    RGBA_S3TC_DXT3_Format: 2003,
    RGBA_S3TC_DXT5_Format: 2004,
    RGB_PVRTC_4BPPV1_Format: 2100,
    RGB_PVRTC_2BPPV1_Format: 2101,
    RGBA_PVRTC_4BPPV1_Format: 2102,
    RGBA_PVRTC_2BPPV1_Format: 2103,
    RGB_ETC1_Format: 2151,
    LoopOnce: 2200,
    LoopRepeat: 2201,
    LoopPingPong: 2202,
    InterpolateDiscrete: 2300,
    InterpolateLinear: 2301,
    InterpolateSmooth: 2302,
    ZeroCurvatureEnding: 2400,
    ZeroSlopeEnding: 2401,
    WrapAroundEnding: 2402,
    TrianglesDrawMode: 0,
    TriangleStripDrawMode: 1,
    TriangleFanDrawMode: 2,
    LinearEncoding: 3e3,
    sRGBEncoding: 3001,
    GammaEncoding: 3007,
    RGBEEncoding: 3002,
    LogLuvEncoding: 3003,
    RGBM7Encoding: 3004,
    RGBM16Encoding: 3005,
    RGBDEncoding: 3006,
    BasicDepthPacking: 3200,
    RGBADepthPacking: 3201
}), THREE.Color = function(a, b, c) {
    return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c);
}, THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function(a) {
        return a instanceof THREE.Color ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), 
        this;
    },
    setScalar: function(a) {
        this.b = this.g = this.r = a;
    },
    setHex: function(a) {
        return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, 
        this.b = (255 & a) / 255, this;
    },
    setRGB: function(a, b, c) {
        return this.r = a, this.g = b, this.b = c, this;
    },
    setHSL: function() {
        function a(a, b, c) {
            return 0 > c && (c += 1), 1 < c && (c -= 1), c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;
        }
        return function(b, c, d) {
            return b = THREE.Math.euclideanModulo(b, 1), c = THREE.Math.clamp(c, 0, 1), d = THREE.Math.clamp(d, 0, 1), 
            0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, 
            d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3)), 
            this;
        };
    }(),
    setStyle: function(a) {
        function b(b) {
            void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.");
        }
        var c;
        if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
            var d = c[2];
            switch (c[1]) {
              case "rgb":
              case "rgba":
                if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, 
                this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, 
                b(c[5]), this;
                if (c = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, 
                this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, 
                b(c[5]), this;
                break;

              case "hsl":
              case "hsla":
                if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
                    var d = parseFloat(c[1]) / 360, e = parseInt(c[2], 10) / 100, f = parseInt(c[3], 10) / 100;
                    return b(c[5]), this.setHSL(d, e, f);
                }
            }
        } else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) {
            if (c = c[1], d = c.length, 3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, 
            this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, 
            this;
            if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, 
            this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this;
        }
        return a && 0 < a.length && (c = THREE.ColorKeywords[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a)), 
        this;
    },
    clone: function() {
        return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(a) {
        return this.r = a.r, this.g = a.g, this.b = a.b, this;
    },
    copyGammaToLinear: function(a, b) {
        return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), 
        this.b = Math.pow(a.b, b), this;
    },
    copyLinearToGamma: function(a, b) {
        void 0 === b && (b = 2);
        var c = 0 < b ? 1 / b : 1;
        return this.r = Math.pow(a.r, c), this.g = Math.pow(a.g, c), this.b = Math.pow(a.b, c), 
        this;
    },
    convertGammaToLinear: function() {
        var a = this.r, b = this.g, c = this.b;
        return this.r = a * a, this.g = b * b, this.b = c * c, this;
    },
    convertLinearToGamma: function() {
        return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), 
        this;
    },
    getHex: function() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(a) {
        a = a || {
            h: 0,
            s: 0,
            l: 0
        };
        var b, c = this.r, d = this.g, e = this.b, f = Math.max(c, d, e), g = Math.min(c, d, e), h = (g + f) / 2;
        if (g === f) g = b = 0; else {
            var i = f - g, g = .5 >= h ? i / (f + g) : i / (2 - f - g);
            switch (f) {
              case c:
                b = (d - e) / i + (d < e ? 6 : 0);
                break;

              case d:
                b = (e - c) / i + 2;
                break;

              case e:
                b = (c - d) / i + 4;
            }
            b /= 6;
        }
        return a.h = b, a.s = g, a.l = h, a;
    },
    getStyle: function() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    },
    offsetHSL: function(a, b, c) {
        var d = this.getHSL();
        return d.h += a, d.s += b, d.l += c, this.setHSL(d.h, d.s, d.l), this;
    },
    add: function(a) {
        return this.r += a.r, this.g += a.g, this.b += a.b, this;
    },
    addColors: function(a, b) {
        return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this;
    },
    addScalar: function(a) {
        return this.r += a, this.g += a, this.b += a, this;
    },
    multiply: function(a) {
        return this.r *= a.r, this.g *= a.g, this.b *= a.b, this;
    },
    multiplyScalar: function(a) {
        return this.r *= a, this.g *= a, this.b *= a, this;
    },
    lerp: function(a, b) {
        return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, 
        this;
    },
    equals: function(a) {
        return a.r === this.r && a.g === this.g && a.b === this.b;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.r = a[b], this.g = a[b + 1], this.b = a[b + 2], 
        this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, 
        a[b + 2] = this.b, a;
    }
}, THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}, THREE.Quaternion = function(a, b, c, d) {
    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1;
}, THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    get x() {
        return this._x;
    },
    set x(a) {
        this._x = a, this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(a) {
        this._y = a, this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(a) {
        this._z = a, this.onChangeCallback();
    },
    get w() {
        return this._w;
    },
    set w(a) {
        this._w = a, this.onChangeCallback();
    },
    set: function(a, b, c, d) {
        return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), 
        this;
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(a) {
        return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), 
        this;
    },
    setFromEuler: function(a, b) {
        if (!1 == a instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2), g = Math.sin(a._y / 2), h = Math.sin(a._z / 2), i = a.order;
        return "XYZ" === i ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, 
        this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === i ? (this._x = f * d * e + c * g * h, 
        this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === i ? (this._x = f * d * e - c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === i ? (this._x = f * d * e - c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === i ? (this._x = f * d * e + c * g * h, 
        this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === i && (this._x = f * d * e - c * g * h, 
        this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h), 
        !1 !== b && this.onChangeCallback(), this;
    },
    setFromAxisAngle: function(a, b) {
        var c = b / 2, d = Math.sin(c);
        return this._x = a.x * d, this._y = a.y * d, this._z = a.z * d, this._w = Math.cos(c), 
        this.onChangeCallback(), this;
    },
    setFromRotationMatrix: function(a) {
        var b = a.elements, c = b[0];
        a = b[4];
        var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], i = b[6], b = b[10], j = c + f + b;
        return 0 < j ? (c = .5 / Math.sqrt(j + 1), this._w = .25 / c, this._x = (i - g) * c, 
        this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), 
        this._w = (i - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), 
        this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), 
        this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + i) / c, this._z = .25 * c), 
        this.onChangeCallback(), this;
    },
    setFromUnitVectors: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector3()), b = c.dot(d) + 1, 1e-6 > b ? (b = 0, 
            Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d), 
            this._x = a.x, this._y = a.y, this._z = a.z, this._w = b, this.normalize();
        };
    }(),
    inverse: function() {
        return this.conjugate().normalize();
    },
    conjugate: function() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
    },
    dot: function(a) {
        return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function() {
        var a = this.length();
        return 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, 
        this._y *= a, this._z *= a, this._w *= a), this.onChangeCallback(), this;
    },
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), 
        this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
    },
    premultiply: function(a) {
        return this.multiplyQuaternions(a, this);
    },
    multiplyQuaternions: function(a, b) {
        var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, i = b._z, j = b._w;
        return this._x = c * j + f * g + d * i - e * h, this._y = d * j + f * h + e * g - c * i, 
        this._z = e * j + f * i + c * h - d * g, this._w = f * j - c * g - d * h - e * i, 
        this.onChangeCallback(), this;
    },
    slerp: function(a, b) {
        if (0 === b) return this;
        if (1 === b) return this.copy(a);
        var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
        if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, 
        g = -g) : this.copy(a), 1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, 
        this;
        var h = Math.sqrt(1 - g * g);
        if (.001 > Math.abs(h)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), 
        this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
        var i = Math.atan2(h, g), g = Math.sin((1 - b) * i) / h, h = Math.sin(b * i) / h;
        return this._w = f * g + this._w * h, this._x = c * g + this._x * h, this._y = d * g + this._y * h, 
        this._z = e * g + this._z * h, this.onChangeCallback(), this;
    },
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], 
        this._w = a[b + 3], this.onChangeCallback(), this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, 
        a[b + 2] = this._z, a[b + 3] = this._w, a;
    },
    onChange: function(a) {
        return this.onChangeCallback = a, this;
    },
    onChangeCallback: function() {}
}, Object.assign(THREE.Quaternion, {
    slerp: function(a, b, c, d) {
        return c.copy(a).slerp(b, d);
    },
    slerpFlat: function(a, b, c, d, e, f, g) {
        var h = c[d + 0], i = c[d + 1], j = c[d + 2];
        c = c[d + 3], d = e[f + 0];
        var k = e[f + 1], l = e[f + 2];
        if (e = e[f + 3], c !== e || h !== d || i !== k || j !== l) {
            f = 1 - g;
            var m = h * d + i * k + j * l + c * e, n = 0 <= m ? 1 : -1, o = 1 - m * m;
            o > Number.EPSILON && (o = Math.sqrt(o), m = Math.atan2(o, m * n), f = Math.sin(f * m) / o, 
            g = Math.sin(g * m) / o), n *= g, h = h * f + d * n, i = i * f + k * n, j = j * f + l * n, 
            c = c * f + e * n, f === 1 - g && (g = 1 / Math.sqrt(h * h + i * i + j * j + c * c), 
            h *= g, i *= g, j *= g, c *= g);
        }
        a[b] = h, a[b + 1] = i, a[b + 2] = j, a[b + 3] = c;
    }
}), THREE.Vector2 = function(a, b) {
    this.x = a || 0, this.y = b || 0;
}, THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    get width() {
        return this.x;
    },
    set width(a) {
        this.x = a;
    },
    get height() {
        return this.y;
    },
    set height(a) {
        this.y = a;
    },
    set: function(a, b) {
        return this.x = a, this.y = b, this;
    },
    setScalar: function(a) {
        return this.y = this.x = a, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y);
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this;
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this);
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this;
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this;
    },
    addScaledVector: function(a, b) {
        return this.x += a.x * b, this.y += a.y * b, this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this);
    },
    subScalar: function(a) {
        return this.x -= a, this.y -= a, this;
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this;
    },
    multiply: function(a) {
        return this.x *= a.x, this.y *= a.y, this;
    },
    multiplyScalar: function(a) {
        return isFinite(a) ? (this.x *= a, this.y *= a) : this.y = this.x = 0, this;
    },
    divide: function(a) {
        return this.x /= a.x, this.y /= a.y, this;
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 / a);
    },
    min: function(a) {
        return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this;
    },
    max: function(a) {
        return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this;
    },
    clamp: function(a, b) {
        return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), 
        this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector2(), b = new THREE.Vector2()), a.set(c, c), 
            b.set(d, d), this.clamp(a, b);
        };
    }(),
    clampLength: function(a, b) {
        var c = this.length();
        return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c);
    },
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    angle: function() {
        var a = Math.atan2(this.y, this.x);
        return 0 > a && (a += 2 * Math.PI), a;
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x;
        return a = this.y - a.y, b * b + a * a;
    },
    setLength: function(a) {
        return this.multiplyScalar(a / this.length());
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this;
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a);
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this;
    },
    rotateAround: function(a, b) {
        var c = Math.cos(b), d = Math.sin(b), e = this.x - a.x, f = this.y - a.y;
        return this.x = e * c - f * d + a.x, this.y = e * d + f * c + a.y, this;
    }
}, THREE.Vector3 = function(a, b, c) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0;
}, THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function(a, b, c) {
        return this.x = a, this.y = b, this.z = c, this;
    },
    setScalar: function(a) {
        return this.z = this.y = this.x = a, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setZ: function(a) {
        return this.z = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          case 2:
            this.z = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this.z = a.z, this;
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this);
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this.z += a, this;
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
    },
    addScaledVector: function(a, b) {
        return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this);
    },
    subScalar: function(a) {
        return this.x -= a, this.y -= a, this.z -= a, this;
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
    },
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), 
        this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this);
    },
    multiplyScalar: function(a) {
        return isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0, 
        this;
    },
    multiplyVectors: function(a, b) {
        return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
    },
    applyEuler: function() {
        var a;
        return function(b) {
            return !1 == b instanceof THREE.Euler && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), 
            void 0 === a && (a = new THREE.Quaternion()), this.applyQuaternion(a.setFromEuler(b));
        };
    }(),
    applyAxisAngle: function() {
        var a;
        return function(b, c) {
            return void 0 === a && (a = new THREE.Quaternion()), this.applyQuaternion(a.setFromAxisAngle(b, c));
        };
    }(),
    applyMatrix3: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[3] * c + a[6] * d, this.y = a[1] * b + a[4] * c + a[7] * d, 
        this.z = a[2] * b + a[5] * c + a[8] * d, this;
    },
    applyMatrix4: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12], this.y = a[1] * b + a[5] * c + a[9] * d + a[13], 
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14], this;
    },
    applyProjection: function(a) {
        var b = this.x, c = this.y, d = this.z;
        a = a.elements;
        var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
        return this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e, this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e, 
        this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e, this;
    },
    applyQuaternion: function(a) {
        var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
        a = a.w;
        var h = a * b + f * d - g * c, i = a * c + g * b - e * d, j = a * d + e * c - f * b, b = -e * b - f * c - g * d;
        return this.x = h * a + b * -e + i * -g - j * -f, this.y = i * a + b * -f + j * -e - h * -g, 
        this.z = j * a + b * -g + h * -f - i * -e, this;
    },
    project: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)), 
            this.applyProjection(a);
        };
    }(),
    unproject: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)), 
            this.applyProjection(a);
        };
    }(),
    transformDirection: function(a) {
        var b = this.x, c = this.y, d = this.z;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d, this.y = a[1] * b + a[5] * c + a[9] * d, 
        this.z = a[2] * b + a[6] * c + a[10] * d, this.normalize();
    },
    divide: function(a) {
        return this.x /= a.x, this.y /= a.y, this.z /= a.z, this;
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 / a);
    },
    min: function(a) {
        return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), 
        this;
    },
    max: function(a) {
        return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), 
        this;
    },
    clamp: function(a, b) {
        return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), 
        this.z = Math.max(a.z, Math.min(b.z, this.z)), this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector3(), b = new THREE.Vector3()), a.set(c, c, c), 
            b.set(d, d, d), this.clamp(a, b);
        };
    }(),
    clampLength: function(a, b) {
        var c = this.length();
        return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c);
    },
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
        this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
        this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
        this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    setLength: function(a) {
        return this.multiplyScalar(a / this.length());
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, 
        this;
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a);
    },
    cross: function(a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), 
        this.crossVectors(a, b);
        var c = this.x, d = this.y, e = this.z;
        return this.x = d * a.z - e * a.y, this.y = e * a.x - c * a.z, this.z = c * a.y - d * a.x, 
        this;
    },
    crossVectors: function(a, b) {
        var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
        return this.x = d * h - e * g, this.y = e * f - c * h, this.z = c * g - d * f, this;
    },
    projectOnVector: function() {
        var a, b;
        return function(c) {
            return void 0 === a && (a = new THREE.Vector3()), a.copy(c).normalize(), b = this.dot(a), 
            this.copy(a).multiplyScalar(b);
        };
    }(),
    projectOnPlane: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Vector3()), a.copy(this).projectOnVector(b), 
            this.sub(a);
        };
    }(),
    reflect: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Vector3()), this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
        };
    }(),
    angleTo: function(a) {
        return a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq()), Math.acos(THREE.Math.clamp(a, -1, 1));
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x, c = this.y - a.y;
        return a = this.z - a.z, b * b + c * c + a * a;
    },
    setFromSpherical: function(a) {
        var b = Math.sin(a.phi) * a.radius;
        return this.x = b * Math.sin(a.theta), this.y = Math.cos(a.phi) * a.radius, this.z = b * Math.cos(a.theta), 
        this;
    },
    setFromMatrixPosition: function(a) {
        return this.setFromMatrixColumn(a, 3);
    },
    setFromMatrixScale: function(a) {
        var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length();
        return a = this.setFromMatrixColumn(a, 2).length(), this.x = b, this.y = c, this.z = a, 
        this;
    },
    setFromMatrixColumn: function(a, b) {
        if ("number" == typeof a) {
            console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
            var c = a;
            a = b, b = c;
        }
        return this.fromArray(a.elements, 4 * b);
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], 
        this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a[b + 2] = this.z, a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this.z = a.array[b + 2], this;
    }
}, THREE.Vector4 = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1;
}, THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function(a, b, c, d) {
        return this.x = a, this.y = b, this.z = c, this.w = d, this;
    },
    setScalar: function(a) {
        return this.w = this.z = this.y = this.x = a, this;
    },
    setX: function(a) {
        return this.x = a, this;
    },
    setY: function(a) {
        return this.y = a, this;
    },
    setZ: function(a) {
        return this.z = a, this;
    },
    setW: function(a) {
        return this.w = a, this;
    },
    setComponent: function(a, b) {
        switch (a) {
          case 0:
            this.x = b;
            break;

          case 1:
            this.y = b;
            break;

          case 2:
            this.z = b;
            break;

          case 3:
            this.w = b;
            break;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
          case 0:
            return this.x;

          case 1:
            return this.y;

          case 2:
            return this.z;

          case 3:
            return this.w;

          default:
            throw Error("index is out of range: " + a);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(a) {
        return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, 
        this;
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
        this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, 
        this);
    },
    addScalar: function(a) {
        return this.x += a, this.y += a, this.z += a, this.w += a, this;
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, 
        this;
    },
    addScaledVector: function(a, b) {
        return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, 
        this;
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
        this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, 
        this);
    },
    subScalar: function(a) {
        return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this;
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, 
        this;
    },
    multiplyScalar: function(a) {
        return isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a, this.w *= a) : this.w = this.z = this.y = this.x = 0, 
        this;
    },
    applyMatrix4: function(a) {
        var b = this.x, c = this.y, d = this.z, e = this.w;
        return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e, this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e, 
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e, this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e, 
        this;
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 / a);
    },
    setAxisAngleFromQuaternion: function(a) {
        this.w = 2 * Math.acos(a.w);
        var b = Math.sqrt(1 - a.w * a.w);
        return 1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, 
        this.z = a.z / b), this;
    },
    setAxisAngleFromRotationMatrix: function(a) {
        var b, c, d;
        a = a.elements;
        var e = a[0];
        d = a[4];
        var f = a[8], g = a[1], h = a[5], i = a[9];
        c = a[2], b = a[6];
        var j = a[10];
        return .01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(i - b) ? .1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(i + b) && .1 > Math.abs(e + h + j - 3) ? (this.set(1, 0, 0, 0), 
        this) : (a = Math.PI, e = (e + 1) / 2, h = (h + 1) / 2, j = (j + 1) / 2, d = (d + g) / 4, 
        f = (f + c) / 4, i = (i + b) / 4, e > h && e > j ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), 
        c = d / b, d = f / b) : h > j ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), 
        b = d / c, d = i / c) : .01 > j ? (c = b = .707106781, d = 0) : (d = Math.sqrt(j), 
        b = f / d, c = i / d), this.set(b, c, d, a), this) : (a = Math.sqrt((b - i) * (b - i) + (f - c) * (f - c) + (g - d) * (g - d)), 
        .001 > Math.abs(a) && (a = 1), this.x = (b - i) / a, this.y = (f - c) / a, this.z = (g - d) / a, 
        this.w = Math.acos((e + h + j - 1) / 2), this);
    },
    min: function(a) {
        return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), 
        this.w = Math.min(this.w, a.w), this;
    },
    max: function(a) {
        return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), 
        this.w = Math.max(this.w, a.w), this;
    },
    clamp: function(a, b) {
        return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), 
        this.z = Math.max(a.z, Math.min(b.z, this.z)), this.w = Math.max(a.w, Math.min(b.w, this.w)), 
        this;
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new THREE.Vector4(), b = new THREE.Vector4()), a.set(c, c, c, c), 
            b.set(d, d, d, d), this.clamp(a, b);
        };
    }(),
    floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
        this.w = Math.floor(this.w), this;
    },
    ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
        this.w = Math.ceil(this.w), this;
    },
    round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
        this.w = Math.round(this.w), this;
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), 
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), 
        this;
    },
    negate: function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    setLength: function(a) {
        return this.multiplyScalar(a / this.length());
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, 
        this.w += (a.w - this.w) * b, this;
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a);
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], 
        this.w = a[b + 3], this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, 
        a[b + 2] = this.z, a[b + 3] = this.w, a;
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], 
        this.z = a.array[b + 2], this.w = a.array[b + 3], this;
    }
}, THREE.Euler = function(a, b, c, d) {
    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || THREE.Euler.DefaultOrder;
}, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", 
THREE.Euler.prototype = {
    constructor: THREE.Euler,
    get x() {
        return this._x;
    },
    set x(a) {
        this._x = a, this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(a) {
        this._y = a, this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(a) {
        this._z = a, this.onChangeCallback();
    },
    get order() {
        return this._order;
    },
    set order(a) {
        this._order = a, this.onChangeCallback();
    },
    set: function(a, b, c, d) {
        return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), 
        this;
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(a) {
        return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), 
        this;
    },
    setFromRotationMatrix: function(a, b, c) {
        var d = THREE.Math.clamp, e = a.elements;
        a = e[0];
        var f = e[4], g = e[8], h = e[1], i = e[5], j = e[9], k = e[2], l = e[6], e = e[10];
        return b = b || this._order, "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-j, e), 
        this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(l, i), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(j, -1, 1)), 
        .99999 > Math.abs(j) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, i)) : (this._y = Math.atan2(-k, a), 
        this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(-k, e), 
        this._z = Math.atan2(-f, i)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)), 
        .99999 > Math.abs(k) ? (this._x = Math.atan2(l, e), this._z = Math.atan2(h, a)) : (this._x = 0, 
        this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), 
        .99999 > Math.abs(h) ? (this._x = Math.atan2(-j, i), this._y = Math.atan2(-k, a)) : (this._x = 0, 
        this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), 
        .99999 > Math.abs(f) ? (this._x = Math.atan2(l, i), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-j, e), 
        this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b), 
        this._order = b, !1 !== c && this.onChangeCallback(), this;
    },
    setFromQuaternion: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationFromQuaternion(b), 
            this.setFromRotationMatrix(a, c, d);
        };
    }(),
    setFromVector3: function(a, b) {
        return this.set(a.x, a.y, a.z, b || this._order);
    },
    reorder: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            return a.setFromEuler(this), this.setFromQuaternion(a, b);
        };
    }(),
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
    },
    fromArray: function(a) {
        return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), 
        this.onChangeCallback(), this;
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, 
        a[b + 2] = this._z, a[b + 3] = this._order, a;
    },
    toVector3: function(a) {
        return a ? a.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z);
    },
    onChange: function(a) {
        return this.onChangeCallback = a, this;
    },
    onChangeCallback: function() {}
}, THREE.Line3 = function(a, b) {
    this.start = void 0 !== a ? a : new THREE.Vector3(), this.end = void 0 !== b ? b : new THREE.Vector3();
}, THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function(a, b) {
        return this.start.copy(a), this.end.copy(b), this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.start.copy(a.start), this.end.copy(a.end), this;
    },
    center: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.start, this.end).multiplyScalar(.5);
    },
    delta: function(a) {
        return (a || new THREE.Vector3()).subVectors(this.end, this.start);
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end);
    },
    distance: function() {
        return this.start.distanceTo(this.end);
    },
    at: function(a, b) {
        var c = b || new THREE.Vector3();
        return this.delta(c).multiplyScalar(a).add(this.start);
    },
    closestPointToPointParameter: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c, d) {
            a.subVectors(c, this.start), b.subVectors(this.end, this.start);
            var e = b.dot(b), e = b.dot(a) / e;
            return d && (e = THREE.Math.clamp(e, 0, 1)), e;
        };
    }(),
    closestPointToPoint: function(a, b, c) {
        return a = this.closestPointToPointParameter(a, b), c = c || new THREE.Vector3(), 
        this.delta(c).multiplyScalar(a).add(this.start);
    },
    applyMatrix4: function(a) {
        return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this;
    },
    equals: function(a) {
        return a.start.equals(this.start) && a.end.equals(this.end);
    }
}, THREE.Box2 = function(a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector2(1 / 0, 1 / 0), this.max = void 0 !== b ? b : new THREE.Vector2(-(1 / 0), -(1 / 0));
}, THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function(a, b) {
        return this.min.copy(a), this.max.copy(b), this;
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
        return this;
    },
    setFromCenterAndSize: function() {
        var a = new THREE.Vector2();
        return function(b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            return this.min.copy(b).sub(d), this.max.copy(b).add(d), this;
        };
    }(),
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.min.copy(a.min), this.max.copy(a.max), this;
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -(1 / 0), this;
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    center: function(a) {
        return (a || new THREE.Vector2()).addVectors(this.min, this.max).multiplyScalar(.5);
    },
    size: function(a) {
        return (a || new THREE.Vector2()).subVectors(this.max, this.min);
    },
    expandByPoint: function(a) {
        return this.min.min(a), this.max.max(a), this;
    },
    expandByVector: function(a) {
        return this.min.sub(a), this.max.add(a), this;
    },
    expandByScalar: function(a) {
        return this.min.addScalar(-a), this.max.addScalar(a), this;
    },
    containsPoint: function(a) {
        return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y);
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y;
    },
    getParameter: function(a, b) {
        return (b || new THREE.Vector2()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
    },
    intersectsBox: function(a) {
        return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y);
    },
    clampPoint: function(a, b) {
        return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var a = new THREE.Vector2();
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length();
        };
    }(),
    intersect: function(a) {
        return this.min.max(a.min), this.max.min(a.max), this;
    },
    union: function(a) {
        return this.min.min(a.min), this.max.max(a.max), this;
    },
    translate: function(a) {
        return this.min.add(a), this.max.add(a), this;
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max);
    }
}, THREE.Box3 = function(a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== b ? b : new THREE.Vector3(-(1 / 0), -(1 / 0), -(1 / 0));
}, THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function(a, b) {
        return this.min.copy(a), this.max.copy(b), this;
    },
    setFromArray: function(a) {
        for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -(1 / 0), f = -(1 / 0), g = -(1 / 0), h = 0, i = a.length; h < i; h += 3) {
            var j = a[h], k = a[h + 1], l = a[h + 2];
            j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), 
            l > g && (g = l);
        }
        this.min.set(b, c, d), this.max.set(e, f, g);
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
        return this;
    },
    setFromCenterAndSize: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            return this.min.copy(b).sub(d), this.max.copy(b).add(d), this;
        };
    }(),
    setFromObject: function() {
        var a = new THREE.Vector3();
        return function(b) {
            var c = this;
            return b.updateMatrixWorld(!0), this.makeEmpty(), b.traverse(function(b) {
                var d = b.geometry;
                if (void 0 !== d) if (d instanceof THREE.Geometry) for (var e = d.vertices, d = 0, f = e.length; d < f; d++) a.copy(e[d]), 
                a.applyMatrix4(b.matrixWorld), c.expandByPoint(a); else if (d instanceof THREE.BufferGeometry && void 0 !== d.attributes.position) for (e = d.attributes.position.array, 
                d = 0, f = e.length; d < f; d += 3) a.fromArray(e, d), a.applyMatrix4(b.matrixWorld), 
                c.expandByPoint(a);
            }), this;
        };
    }(),
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.min.copy(a.min), this.max.copy(a.max), this;
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -(1 / 0), 
        this;
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    center: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.min, this.max).multiplyScalar(.5);
    },
    size: function(a) {
        return (a || new THREE.Vector3()).subVectors(this.max, this.min);
    },
    expandByPoint: function(a) {
        return this.min.min(a), this.max.max(a), this;
    },
    expandByVector: function(a) {
        return this.min.sub(a), this.max.add(a), this;
    },
    expandByScalar: function(a) {
        return this.min.addScalar(-a), this.max.addScalar(a), this;
    },
    containsPoint: function(a) {
        return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z);
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z;
    },
    getParameter: function(a, b) {
        return (b || new THREE.Vector3()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
    },
    intersectsBox: function(a) {
        return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z);
    },
    intersectsSphere: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Vector3()), this.clampPoint(b.center, a), 
            a.distanceToSquared(b.center) <= b.radius * b.radius;
        };
    }(),
    intersectsPlane: function(a) {
        var b, c;
        return 0 < a.normal.x ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, 
        c = a.normal.x * this.min.x), 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, 
        c += a.normal.y * this.min.y), 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, 
        c += a.normal.z * this.min.z), b <= a.constant && c >= a.constant;
    },
    clampPoint: function(a, b) {
        return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length();
        };
    }(),
    getBoundingSphere: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return b = b || new THREE.Sphere(), b.center = this.center(), b.radius = .5 * this.size(a).length(), 
            b;
        };
    }(),
    intersect: function(a) {
        return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), 
        this;
    },
    union: function(a) {
        return this.min.min(a.min), this.max.max(a.max), this;
    },
    applyMatrix4: function() {
        var a = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
        return function(b) {
            return this.isEmpty() ? this : (a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), 
            a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), 
            a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), 
            a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), 
            a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), this.setFromPoints(a), 
            this);
        };
    }(),
    translate: function(a) {
        return this.min.add(a), this.max.add(a), this;
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max);
    }
}, THREE.Matrix3 = function() {
    this.elements = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}, THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function(a, b, c, d, e, f, g, h, i) {
        var j = this.elements;
        return j[0] = a, j[1] = d, j[2] = g, j[3] = b, j[4] = e, j[5] = h, j[6] = c, j[7] = f, 
        j[8] = i, this;
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    clone: function() {
        return new this.constructor().fromArray(this.elements);
    },
    copy: function(a) {
        return a = a.elements, this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]), 
        this;
    },
    setFromMatrix4: function(a) {
        return a = a.elements, this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]), 
        this;
    },
    applyToVector3Array: function() {
        var a;
        return function(b, c, d) {
            void 0 === a && (a = new THREE.Vector3()), void 0 === c && (c = 0), void 0 === d && (d = b.length);
            for (var e = 0; e < d; e += 3, c += 3) a.fromArray(b, c), a.applyMatrix3(this), 
            a.toArray(b, c);
            return b;
        };
    }(),
    applyToBuffer: function() {
        var a;
        return function(b, c, d) {
            void 0 === a && (a = new THREE.Vector3()), void 0 === c && (c = 0), void 0 === d && (d = b.length / b.itemSize);
            for (var e = 0; e < d; e++, c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), 
            a.applyMatrix3(this), b.setXYZ(a.x, a.y, a.z);
            return b;
        };
    }(),
    multiplyScalar: function(a) {
        var b = this.elements;
        return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, 
        b[5] *= a, b[8] *= a, this;
    },
    determinant: function() {
        var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], a = a[8];
        return b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h;
    },
    getInverse: function(a, b) {
        a instanceof THREE.Matrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
        var c = a.elements, d = this.elements, e = c[0], f = c[1], g = c[2], h = c[3], i = c[4], j = c[5], k = c[6], l = c[7], c = c[8], m = c * i - j * l, n = j * k - c * h, o = l * h - i * k, p = e * m + f * n + g * o;
        if (0 === p) {
            if (b) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
            return console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"), 
            this.identity();
        }
        return p = 1 / p, d[0] = m * p, d[1] = (g * l - c * f) * p, d[2] = (j * f - g * i) * p, 
        d[3] = n * p, d[4] = (c * e - g * k) * p, d[5] = (g * h - j * e) * p, d[6] = o * p, 
        d[7] = (f * k - l * e) * p, d[8] = (i * e - f * h) * p, this;
    },
    transpose: function() {
        var a, b = this.elements;
        return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], 
        b[5] = b[7], b[7] = a, this;
    },
    flattenToArrayOffset: function(a, b) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."), 
        this.toArray(a, b);
    },
    getNormalMatrix: function(a) {
        return this.setFromMatrix4(a).getInverse(this).transpose();
    },
    transposeIntoArray: function(a) {
        var b = this.elements;
        return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], 
        a[6] = b[2], a[7] = b[5], a[8] = b[8], this;
    },
    fromArray: function(a) {
        return this.elements.set(a), this;
    },
    toArray: function(a, b) {
        void 0 === a && (a = []), void 0 === b && (b = 0);
        var c = this.elements;
        return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], 
        a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a;
    }
}, THREE.Matrix4 = function() {
    this.elements = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]), 
    0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}, THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        var q = this.elements;
        return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, 
        q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, 
        this;
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    clone: function() {
        return new THREE.Matrix4().fromArray(this.elements);
    },
    copy: function(a) {
        return this.elements.set(a.elements), this;
    },
    copyPosition: function(a) {
        var b = this.elements;
        return a = a.elements, b[12] = a[12], b[13] = a[13], b[14] = a[14], this;
    },
    extractBasis: function(a, b, c) {
        return a.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), 
        this;
    },
    makeBasis: function(a, b, c) {
        return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), 
        this;
    },
    extractRotation: function() {
        var a;
        return function(b) {
            void 0 === a && (a = new THREE.Vector3());
            var c = this.elements, d = b.elements, e = 1 / a.setFromMatrixColumn(b, 0).length(), f = 1 / a.setFromMatrixColumn(b, 1).length();
            return b = 1 / a.setFromMatrixColumn(b, 2).length(), c[0] = d[0] * e, c[1] = d[1] * e, 
            c[2] = d[2] * e, c[4] = d[4] * f, c[5] = d[5] * f, c[6] = d[6] * f, c[8] = d[8] * b, 
            c[9] = d[9] * b, c[10] = d[10] * b, this;
        };
    }(),
    makeRotationFromEuler: function(a) {
        !1 == a instanceof THREE.Euler && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
        if ("XYZ" === a.order) {
            a = f * h;
            var i = f * e, j = c * h, k = c * e;
            b[0] = g * h, b[4] = -g * e, b[8] = d, b[1] = i + j * d, b[5] = a - k * d, b[9] = -c * g, 
            b[2] = k - a * d, b[6] = j + i * d, b[10] = f * g;
        } else "YXZ" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a + k * c, 
        b[4] = j * c - i, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = i * c - j, 
        b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, i = g * e, j = d * h, 
        k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = j + i * c, b[1] = i + j * c, 
        b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, 
        i = f * e, j = c * h, k = c * e, b[0] = g * h, b[4] = j * d - i, b[8] = a * d + k, 
        b[1] = g * e, b[5] = k * d + a, b[9] = i * d - j, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, 
        i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = j * e + i, 
        b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = i * e + j, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, 
        i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, 
        b[5] = f * h, b[9] = i * e - j, b[2] = j * e - i, b[6] = c * h, b[10] = k * e + a);
        return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, 
        this;
    },
    makeRotationFromQuaternion: function(a) {
        var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, i = e + e;
        a = c * g;
        var j = c * h, c = c * i, k = d * h, d = d * i, e = e * i, g = f * g, h = f * h, f = f * i;
        return b[0] = 1 - (k + e), b[4] = j - f, b[8] = c + h, b[1] = j + f, b[5] = 1 - (a + e), 
        b[9] = d - g, b[2] = c - h, b[6] = d + g, b[10] = 1 - (a + k), b[3] = 0, b[7] = 0, 
        b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;
    },
    lookAt: function() {
        var a, b, c;
        return function(d, e, f) {
            void 0 === a && (a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3());
            var g = this.elements;
            return c.subVectors(d, e).normalize(), 0 === c.lengthSq() && (c.z = 1), a.crossVectors(f, c).normalize(), 
            0 === a.lengthSq() && (c.z += 1e-4, a.crossVectors(f, c).normalize()), b.crossVectors(c, a), 
            g[0] = a.x, g[4] = b.x, g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, 
            g[6] = b.z, g[10] = c.z, this;
        };
    }(),
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), 
        this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
    },
    premultiply: function(a) {
        return this.multiplyMatrices(a, this);
    },
    multiplyMatrices: function(a, b) {
        var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8], i = c[12], j = c[1], k = c[5], l = c[9], m = c[13], n = c[2], o = c[6], p = c[10], q = c[14], r = c[3], s = c[7], t = c[11], c = c[15], u = d[0], v = d[4], w = d[8], x = d[12], y = d[1], z = d[5], A = d[9], B = d[13], C = d[2], D = d[6], E = d[10], F = d[14], G = d[3], H = d[7], I = d[11], d = d[15];
        return e[0] = f * u + g * y + h * C + i * G, e[4] = f * v + g * z + h * D + i * H, 
        e[8] = f * w + g * A + h * E + i * I, e[12] = f * x + g * B + h * F + i * d, e[1] = j * u + k * y + l * C + m * G, 
        e[5] = j * v + k * z + l * D + m * H, e[9] = j * w + k * A + l * E + m * I, e[13] = j * x + k * B + l * F + m * d, 
        e[2] = n * u + o * y + p * C + q * G, e[6] = n * v + o * z + p * D + q * H, e[10] = n * w + o * A + p * E + q * I, 
        e[14] = n * x + o * B + p * F + q * d, e[3] = r * u + s * y + t * C + c * G, e[7] = r * v + s * z + t * D + c * H, 
        e[11] = r * w + s * A + t * E + c * I, e[15] = r * x + s * B + t * F + c * d, this;
    },
    multiplyToArray: function(a, b, c) {
        var d = this.elements;
        return this.multiplyMatrices(a, b), c[0] = d[0], c[1] = d[1], c[2] = d[2], c[3] = d[3], 
        c[4] = d[4], c[5] = d[5], c[6] = d[6], c[7] = d[7], c[8] = d[8], c[9] = d[9], c[10] = d[10], 
        c[11] = d[11], c[12] = d[12], c[13] = d[13], c[14] = d[14], c[15] = d[15], this;
    },
    multiplyScalar: function(a) {
        var b = this.elements;
        return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, 
        b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, 
        b[11] *= a, b[15] *= a, this;
    },
    applyToVector3Array: function() {
        var a;
        return function(b, c, d) {
            void 0 === a && (a = new THREE.Vector3()), void 0 === c && (c = 0), void 0 === d && (d = b.length);
            for (var e = 0; e < d; e += 3, c += 3) a.fromArray(b, c), a.applyMatrix4(this), 
            a.toArray(b, c);
            return b;
        };
    }(),
    applyToBuffer: function() {
        var a;
        return function(b, c, d) {
            void 0 === a && (a = new THREE.Vector3()), void 0 === c && (c = 0), void 0 === d && (d = b.length / b.itemSize);
            for (var e = 0; e < d; e++, c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), 
            a.applyMatrix4(this), b.setXYZ(a.x, a.y, a.z);
            return b;
        };
    }(),
    determinant: function() {
        var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], i = a[13], j = a[2], k = a[6], l = a[10], m = a[14];
        return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j);
    },
    transpose: function() {
        var a, b = this.elements;
        return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], 
        b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], 
        b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this;
    },
    flattenToArrayOffset: function(a, b) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."), 
        this.toArray(a, b);
    },
    getPosition: function() {
        var a;
        return function() {
            return void 0 === a && (a = new THREE.Vector3()), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), 
            a.setFromMatrixColumn(this, 3);
        };
    }(),
    setPosition: function(a) {
        var b = this.elements;
        return b[12] = a.x, b[13] = a.y, b[14] = a.z, this;
    },
    getInverse: function(a, b) {
        var c = this.elements, d = a.elements, e = d[0], f = d[1], g = d[2], h = d[3], i = d[4], j = d[5], k = d[6], l = d[7], m = d[8], n = d[9], o = d[10], p = d[11], q = d[12], r = d[13], s = d[14], d = d[15], t = n * s * l - r * o * l + r * k * p - j * s * p - n * k * d + j * o * d, u = q * o * l - m * s * l - q * k * p + i * s * p + m * k * d - i * o * d, v = m * r * l - q * n * l + q * j * p - i * r * p - m * j * d + i * n * d, w = q * n * k - m * r * k - q * j * o + i * r * o + m * j * s - i * n * s, x = e * t + f * u + g * v + h * w;
        if (0 === x) {
            if (b) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
            return console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), 
            this.identity();
        }
        return x = 1 / x, c[0] = t * x, c[1] = (r * o * h - n * s * h - r * g * p + f * s * p + n * g * d - f * o * d) * x, 
        c[2] = (j * s * h - r * k * h + r * g * l - f * s * l - j * g * d + f * k * d) * x, 
        c[3] = (n * k * h - j * o * h - n * g * l + f * o * l + j * g * p - f * k * p) * x, 
        c[4] = u * x, c[5] = (m * s * h - q * o * h + q * g * p - e * s * p - m * g * d + e * o * d) * x, 
        c[6] = (q * k * h - i * s * h - q * g * l + e * s * l + i * g * d - e * k * d) * x, 
        c[7] = (i * o * h - m * k * h + m * g * l - e * o * l - i * g * p + e * k * p) * x, 
        c[8] = v * x, c[9] = (q * n * h - m * r * h - q * f * p + e * r * p + m * f * d - e * n * d) * x, 
        c[10] = (i * r * h - q * j * h + q * f * l - e * r * l - i * f * d + e * j * d) * x, 
        c[11] = (m * j * h - i * n * h - m * f * l + e * n * l + i * f * p - e * j * p) * x, 
        c[12] = w * x, c[13] = (m * r * g - q * n * g + q * f * o - e * r * o - m * f * s + e * n * s) * x, 
        c[14] = (q * j * g - i * r * g - q * f * k + e * r * k + i * f * s - e * j * s) * x, 
        c[15] = (i * n * g - m * j * g + m * f * k - e * n * k - i * f * o + e * j * o) * x, 
        this;
    },
    scale: function(a) {
        var b = this.elements, c = a.x, d = a.y;
        return a = a.z, b[0] *= c, b[4] *= d, b[8] *= a, b[1] *= c, b[5] *= d, b[9] *= a, 
        b[2] *= c, b[6] *= d, b[10] *= a, b[3] *= c, b[7] *= d, b[11] *= a, this;
    },
    getMaxScaleOnAxis: function() {
        var a = this.elements;
        return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]));
    },
    makeTranslation: function(a, b, c) {
        return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this;
    },
    makeRotationX: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationY: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationZ: function(a) {
        var b = Math.cos(a);
        return a = Math.sin(a), this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 
        this;
    },
    makeRotationAxis: function(a, b) {
        var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, i = e * f, j = e * g;
        return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1), 
        this;
    },
    makeScale: function(a, b, c) {
        return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this;
    },
    compose: function(a, b, c) {
        return this.makeRotationFromQuaternion(b), this.scale(c), this.setPosition(a), this;
    },
    decompose: function() {
        var a, b;
        return function(c, d, e) {
            void 0 === a && (a = new THREE.Vector3(), b = new THREE.Matrix4());
            var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), i = a.set(f[8], f[9], f[10]).length();
            0 > this.determinant() && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14], b.elements.set(this.elements), 
            c = 1 / g;
            var f = 1 / h, j = 1 / i;
            return b.elements[0] *= c, b.elements[1] *= c, b.elements[2] *= c, b.elements[4] *= f, 
            b.elements[5] *= f, b.elements[6] *= f, b.elements[8] *= j, b.elements[9] *= j, 
            b.elements[10] *= j, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = i, this;
        };
    }(),
    makeFrustum: function(a, b, c, d, e, f) {
        var g = this.elements;
        return g[0] = 2 * e / (b - a), g[4] = 0, g[8] = (b + a) / (b - a), g[12] = 0, g[1] = 0, 
        g[5] = 2 * e / (d - c), g[9] = (d + c) / (d - c), g[13] = 0, g[2] = 0, g[6] = 0, 
        g[10] = -(f + e) / (f - e), g[14] = -2 * f * e / (f - e), g[3] = 0, g[7] = 0, g[11] = -1, 
        g[15] = 0, this;
    },
    makePerspective: function(a, b, c, d) {
        a = c * Math.tan(THREE.Math.DEG2RAD * a * .5);
        var e = -a;
        return this.makeFrustum(e * b, a * b, e, a, c, d);
    },
    makeOrthographic: function(a, b, c, d, e, f) {
        var g = this.elements, h = 1 / (b - a), i = 1 / (c - d), j = 1 / (f - e);
        return g[0] = 2 * h, g[4] = 0, g[8] = 0, g[12] = -((b + a) * h), g[1] = 0, g[5] = 2 * i, 
        g[9] = 0, g[13] = -((c + d) * i), g[2] = 0, g[6] = 0, g[10] = -2 * j, g[14] = -((f + e) * j), 
        g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this;
    },
    equals: function(a) {
        var b = this.elements;
        a = a.elements;
        for (var c = 0; 16 > c; c++) if (b[c] !== a[c]) return !1;
        return !0;
    },
    fromArray: function(a) {
        return this.elements.set(a), this;
    },
    toArray: function(a, b) {
        void 0 === a && (a = []), void 0 === b && (b = 0);
        var c = this.elements;
        return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], 
        a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], 
        a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], 
        a[b + 15] = c[15], a;
    }
}, THREE.Ray = function(a, b) {
    this.origin = void 0 !== a ? a : new THREE.Vector3(), this.direction = void 0 !== b ? b : new THREE.Vector3();
}, THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function(a, b) {
        return this.origin.copy(a), this.direction.copy(b), this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.origin.copy(a.origin), this.direction.copy(a.direction), this;
    },
    at: function(a, b) {
        return (b || new THREE.Vector3()).copy(this.direction).multiplyScalar(a).add(this.origin);
    },
    lookAt: function(a) {
        return this.direction.copy(a).sub(this.origin).normalize(), this;
    },
    recast: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return this.origin.copy(this.at(b, a)), this;
        };
    }(),
    closestPointToPoint: function(a, b) {
        var c = b || new THREE.Vector3();
        c.subVectors(a, this.origin);
        var d = c.dot(this.direction);
        return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);
    },
    distanceToPoint: function(a) {
        return Math.sqrt(this.distanceSqToPoint(a));
    },
    distanceSqToPoint: function() {
        var a = new THREE.Vector3();
        return function(b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            return 0 > c ? this.origin.distanceToSquared(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), 
            a.distanceToSquared(b));
        };
    }(),
    distanceSqToSegment: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
        return function(d, e, f, g) {
            a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);
            var h, i = .5 * d.distanceTo(e), j = -this.direction.dot(b), k = c.dot(this.direction), l = -c.dot(b), m = c.lengthSq(), n = Math.abs(1 - j * j);
            return 0 < n ? (d = j * l - k, e = j * k - l, h = i * n, 0 <= d ? e >= -h ? e <= h ? (i = 1 / n, 
            d *= i, e *= i, j = d * (d + j * e + 2 * k) + e * (j * d + e + 2 * l) + m) : (e = i, 
            d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : (e = -i, d = Math.max(0, -(j * e + k)), 
            j = -d * d + e * (e + 2 * l) + m) : e <= -h ? (d = Math.max(0, -(-j * i + k)), e = 0 < d ? -i : Math.min(Math.max(-i, -l), i), 
            j = -d * d + e * (e + 2 * l) + m) : e <= h ? (d = 0, e = Math.min(Math.max(-i, -l), i), 
            j = e * (e + 2 * l) + m) : (d = Math.max(0, -(j * i + k)), e = 0 < d ? i : Math.min(Math.max(-i, -l), i), 
            j = -d * d + e * (e + 2 * l) + m)) : (e = 0 < j ? -i : i, d = Math.max(0, -(j * e + k)), 
            j = -d * d + e * (e + 2 * l) + m), f && f.copy(this.direction).multiplyScalar(d).add(this.origin), 
            g && g.copy(b).multiplyScalar(e).add(a), j;
        };
    }(),
    intersectSphere: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            a.subVectors(b.center, this.origin);
            var d = a.dot(this.direction), e = a.dot(a) - d * d, f = b.radius * b.radius;
            return e > f ? null : (f = Math.sqrt(f - e), e = d - f, d += f, 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c));
        };
    }(),
    intersectsSphere: function(a) {
        return this.distanceToPoint(a.center) <= a.radius;
    },
    distanceToPlane: function(a) {
        var b = a.normal.dot(this.direction);
        return 0 === b ? 0 === a.distanceToPoint(this.origin) ? 0 : null : (a = -(this.origin.dot(a.normal) + a.constant) / b, 
        0 <= a ? a : null);
    },
    intersectPlane: function(a, b) {
        var c = this.distanceToPlane(a);
        return null === c ? null : this.at(c, b);
    },
    intersectsPlane: function(a) {
        var b = a.distanceToPoint(this.origin);
        return 0 === b || 0 > a.normal.dot(this.direction) * b;
    },
    intersectBox: function(a, b) {
        var c, d, e, f, g;
        d = 1 / this.direction.x, f = 1 / this.direction.y, g = 1 / this.direction.z;
        var h = this.origin;
        return 0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, 
        d *= a.min.x - h.x), 0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, 
        f *= a.min.y - h.y), c > f || e > d ? null : ((e > c || c !== c) && (c = e), (f < d || d !== d) && (d = f), 
        0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, 
        g *= a.min.z - h.z), c > g || e > d ? null : ((e > c || c !== c) && (c = e), (g < d || d !== d) && (d = g), 
        0 > d ? null : this.at(0 <= c ? c : d, b)));
    },
    intersectsBox: function() {
        var a = new THREE.Vector3();
        return function(b) {
            return null !== this.intersectBox(b, a);
        };
    }(),
    intersectTriangle: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Vector3();
        return function(e, f, g, h, i) {
            if (b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c), f = this.direction.dot(d), 
            0 < f) {
                if (h) return null;
                h = 1;
            } else {
                if (!(0 > f)) return null;
                h = -1, f = -f;
            }
            return a.subVectors(this.origin, e), e = h * this.direction.dot(c.crossVectors(a, c)), 
            0 > e ? null : (g = h * this.direction.dot(b.cross(a)), 0 > g || e + g > f ? null : (e = -h * a.dot(d), 
            0 > e ? null : this.at(e / f, i)));
        };
    }(),
    applyMatrix4: function(a) {
        return this.direction.add(this.origin).applyMatrix4(a), this.origin.applyMatrix4(a), 
        this.direction.sub(this.origin), this.direction.normalize(), this;
    },
    equals: function(a) {
        return a.origin.equals(this.origin) && a.direction.equals(this.direction);
    }
}, THREE.Sphere = function(a, b) {
    this.center = void 0 !== a ? a : new THREE.Vector3(), this.radius = void 0 !== b ? b : 0;
}, THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function(a, b) {
        return this.center.copy(a), this.radius = b, this;
    },
    setFromPoints: function() {
        var a = new THREE.Box3();
        return function(b, c) {
            var d = this.center;
            void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
            for (var e = 0, f = 0, g = b.length; f < g; f++) e = Math.max(e, d.distanceToSquared(b[f]));
            return this.radius = Math.sqrt(e), this;
        };
    }(),
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.center.copy(a.center), this.radius = a.radius, this;
    },
    empty: function() {
        return 0 >= this.radius;
    },
    containsPoint: function(a) {
        return a.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(a) {
        return a.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(a) {
        var b = this.radius + a.radius;
        return a.center.distanceToSquared(this.center) <= b * b;
    },
    intersectsBox: function(a) {
        return a.intersectsSphere(this);
    },
    intersectsPlane: function(a) {
        return Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius;
    },
    clampPoint: function(a, b) {
        var c = this.center.distanceToSquared(a), d = b || new THREE.Vector3();
        return d.copy(a), c > this.radius * this.radius && (d.sub(this.center).normalize(), 
        d.multiplyScalar(this.radius).add(this.center)), d;
    },
    getBoundingBox: function(a) {
        return a = a || new THREE.Box3(), a.set(this.center, this.center), a.expandByScalar(this.radius), 
        a;
    },
    applyMatrix4: function(a) {
        return this.center.applyMatrix4(a), this.radius *= a.getMaxScaleOnAxis(), this;
    },
    translate: function(a) {
        return this.center.add(a), this;
    },
    equals: function(a) {
        return a.center.equals(this.center) && a.radius === this.radius;
    }
}, THREE.Frustum = function(a, b, c, d, e, f) {
    this.planes = [ void 0 !== a ? a : new THREE.Plane(), void 0 !== b ? b : new THREE.Plane(), void 0 !== c ? c : new THREE.Plane(), void 0 !== d ? d : new THREE.Plane(), void 0 !== e ? e : new THREE.Plane(), void 0 !== f ? f : new THREE.Plane() ];
}, THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function(a, b, c, d, e, f) {
        var g = this.planes;
        return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), 
        this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
        return this;
    },
    setFromMatrix: function(a) {
        var b = this.planes, c = a.elements;
        a = c[0];
        var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], i = c[6], j = c[7], k = c[8], l = c[9], m = c[10], n = c[11], o = c[12], p = c[13], q = c[14], c = c[15];
        return b[0].setComponents(f - a, j - g, n - k, c - o).normalize(), b[1].setComponents(f + a, j + g, n + k, c + o).normalize(), 
        b[2].setComponents(f + d, j + h, n + l, c + p).normalize(), b[3].setComponents(f - d, j - h, n - l, c - p).normalize(), 
        b[4].setComponents(f - e, j - i, n - m, c - q).normalize(), b[5].setComponents(f + e, j + i, n + m, c + q).normalize(), 
        this;
    },
    intersectsObject: function() {
        var a = new THREE.Sphere();
        return function(b) {
            var c = b.geometry;
            return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld), 
            this.intersectsSphere(a);
        };
    }(),
    intersectsSprite: function() {
        var a = new THREE.Sphere();
        return function(b) {
            return a.center.set(0, 0, 0), a.radius = .7071067811865476, a.applyMatrix4(b.matrixWorld), 
            this.intersectsSphere(a);
        };
    }(),
    intersectsSphere: function(a) {
        var b = this.planes, c = a.center;
        a = -a.radius;
        for (var d = 0; 6 > d; d++) if (b[d].distanceToPoint(c) < a) return !1;
        return !0;
    },
    intersectsBox: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c) {
            for (var d = this.planes, e = 0; 6 > e; e++) {
                var f = d[e];
                a.x = 0 < f.normal.x ? c.min.x : c.max.x, b.x = 0 < f.normal.x ? c.max.x : c.min.x, 
                a.y = 0 < f.normal.y ? c.min.y : c.max.y, b.y = 0 < f.normal.y ? c.max.y : c.min.y, 
                a.z = 0 < f.normal.z ? c.min.z : c.max.z, b.z = 0 < f.normal.z ? c.max.z : c.min.z;
                var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
                if (0 > g && 0 > f) return !1;
            }
            return !0;
        };
    }(),
    containsPoint: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++) if (0 > b[c].distanceToPoint(a)) return !1;
        return !0;
    }
}, THREE.Plane = function(a, b) {
    this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== b ? b : 0;
}, THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function(a, b) {
        return this.normal.copy(a), this.constant = b, this;
    },
    setComponents: function(a, b, c, d) {
        return this.normal.set(a, b, c), this.constant = d, this;
    },
    setFromNormalAndCoplanarPoint: function(a, b) {
        return this.normal.copy(a), this.constant = -b.dot(this.normal), this;
    },
    setFromCoplanarPoints: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c, d, e) {
            return d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(), this.setFromNormalAndCoplanarPoint(d, c), 
            this;
        };
    }(),
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.normal.copy(a.normal), this.constant = a.constant, this;
    },
    normalize: function() {
        var a = 1 / this.normal.length();
        return this.normal.multiplyScalar(a), this.constant *= a, this;
    },
    negate: function() {
        return this.constant *= -1, this.normal.negate(), this;
    },
    distanceToPoint: function(a) {
        return this.normal.dot(a) + this.constant;
    },
    distanceToSphere: function(a) {
        return this.distanceToPoint(a.center) - a.radius;
    },
    projectPoint: function(a, b) {
        return this.orthoPoint(a, b).sub(a).negate();
    },
    orthoPoint: function(a, b) {
        var c = this.distanceToPoint(a);
        return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);
    },
    intersectLine: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            var d = c || new THREE.Vector3(), e = b.delta(a), f = this.normal.dot(e);
            return 0 !== f ? (f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)) : 0 === this.distanceToPoint(b.start) ? d.copy(b.start) : void 0;
        };
    }(),
    intersectsLine: function(a) {
        var b = this.distanceToPoint(a.start);
        return a = this.distanceToPoint(a.end), 0 > b && 0 < a || 0 > a && 0 < b;
    },
    intersectsBox: function(a) {
        return a.intersectsPlane(this);
    },
    intersectsSphere: function(a) {
        return a.intersectsPlane(this);
    },
    coplanarPoint: function(a) {
        return (a || new THREE.Vector3()).copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
        var a = new THREE.Vector3(), b = new THREE.Matrix3();
        return function(c, d) {
            var e = this.coplanarPoint(a).applyMatrix4(c), f = d || b.getNormalMatrix(c), f = this.normal.applyMatrix3(f).normalize();
            return this.constant = -e.dot(f), this;
        };
    }(),
    translate: function(a) {
        return this.constant -= a.dot(this.normal), this;
    },
    equals: function(a) {
        return a.normal.equals(this.normal) && a.constant === this.constant;
    }
}, THREE.Spherical = function(a, b, c) {
    return this.radius = void 0 !== a ? a : 1, this.phi = void 0 !== b ? b : 0, this.theta = void 0 !== c ? c : 0, 
    this;
}, THREE.Spherical.prototype = {
    constructor: THREE.Spherical,
    set: function(a, b, c) {
        return this.radius = a, this.phi = b, this.theta = c, this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.radius.copy(a.radius), this.phi.copy(a.phi), this.theta.copy(a.theta), 
        this;
    },
    makeSafe: function() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    },
    setFromVector3: function(a) {
        return this.radius = a.length(), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), 
        this.phi = Math.acos(THREE.Math.clamp(a.y / this.radius, -1, 1))), this;
    }
}, THREE.Math = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), c = Array(36), d = 0;
        return function() {
            for (var e = 0; 36 > e; e++) 8 === e || 13 === e || 18 === e || 23 === e ? c[e] = "-" : 14 === e ? c[e] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), 
            a = 15 & d, d >>= 4, c[e] = b[19 === e ? 3 & a | 8 : a]);
            return c.join("");
        };
    }(),
    clamp: function(a, b, c) {
        return Math.max(b, Math.min(c, a));
    },
    euclideanModulo: function(a, b) {
        return (a % b + b) % b;
    },
    mapLinear: function(a, b, c, d, e) {
        return d + (a - b) * (e - d) / (c - b);
    },
    smoothstep: function(a, b, c) {
        return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * (3 - 2 * a));
    },
    smootherstep: function(a, b, c) {
        return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * a * (a * (6 * a - 15) + 10));
    },
    random16: function() {
        return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), 
        Math.random();
    },
    randInt: function(a, b) {
        return a + Math.floor(Math.random() * (b - a + 1));
    },
    randFloat: function(a, b) {
        return a + Math.random() * (b - a);
    },
    randFloatSpread: function(a) {
        return a * (.5 - Math.random());
    },
    degToRad: function(a) {
        return a * THREE.Math.DEG2RAD;
    },
    radToDeg: function(a) {
        return a * THREE.Math.RAD2DEG;
    },
    isPowerOfTwo: function(a) {
        return 0 === (a & a - 1) && 0 !== a;
    },
    nearestPowerOfTwo: function(a) {
        return Math.pow(2, Math.round(Math.log(a) / Math.LN2));
    },
    nextPowerOfTwo: function(a) {
        return a--, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, a |= a >> 16, a++, 
        a;
    }
}, THREE.Spline = function(a) {
    function b(a, b, c, d, e, f, g) {
        return a = .5 * (c - a), d = .5 * (d - b), (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
    }
    this.points = a;
    var c, d, e, f, g, h, i, j, k, l = [], m = {
        x: 0,
        y: 0,
        z: 0
    };
    this.initFromArray = function(a) {
        this.points = [];
        for (var b = 0; b < a.length; b++) this.points[b] = {
            x: a[b][0],
            y: a[b][1],
            z: a[b][2]
        };
    }, this.getPoint = function(a) {
        return c = (this.points.length - 1) * a, d = Math.floor(c), e = c - d, l[0] = 0 === d ? d : d - 1, 
        l[1] = d, l[2] = d > this.points.length - 2 ? this.points.length - 1 : d + 1, l[3] = d > this.points.length - 3 ? this.points.length - 1 : d + 2, 
        h = this.points[l[0]], i = this.points[l[1]], j = this.points[l[2]], k = this.points[l[3]], 
        f = e * e, g = e * f, m.x = b(h.x, i.x, j.x, k.x, e, f, g), m.y = b(h.y, i.y, j.y, k.y, e, f, g), 
        m.z = b(h.z, i.z, j.z, k.z, e, f, g), m;
    }, this.getControlPointsArray = function() {
        var a, b, c = this.points.length, d = [];
        for (a = 0; a < c; a++) b = this.points[a], d[a] = [ b.x, b.y, b.z ];
        return d;
    }, this.getLength = function(a) {
        var b, c, d, e = b = b = 0, f = new THREE.Vector3(), g = new THREE.Vector3(), h = [], i = 0;
        for (h[0] = 0, a || (a = 100), c = this.points.length * a, f.copy(this.points[0]), 
        a = 1; a < c; a++) b = a / c, d = this.getPoint(b), g.copy(d), i += g.distanceTo(f), 
        f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b !== e && (h[b] = i, 
        e = b);
        return h[h.length] = i, {
            chunks: h,
            total: i
        };
    }, this.reparametrizeByArcLength = function(a) {
        var b, c, d, e, f, g, h = [], i = new THREE.Vector3(), j = this.getLength();
        for (h.push(i.copy(this.points[0]).clone()), b = 1; b < this.points.length; b++) {
            for (c = j.chunks[b] - j.chunks[b - 1], g = Math.ceil(a * c / j.total), e = (b - 1) / (this.points.length - 1), 
            f = b / (this.points.length - 1), c = 1; c < g - 1; c++) d = e + 1 / g * c * (f - e), 
            d = this.getPoint(d), h.push(i.copy(d).clone());
            h.push(i.copy(this.points[b]).clone());
        }
        this.points = h;
    };
}, THREE.Triangle = function(a, b, c) {
    this.a = void 0 !== a ? a : new THREE.Vector3(), this.b = void 0 !== b ? b : new THREE.Vector3(), 
    this.c = void 0 !== c ? c : new THREE.Vector3();
}, THREE.Triangle.normal = function() {
    var a = new THREE.Vector3();
    return function(b, c, d, e) {
        return e = e || new THREE.Vector3(), e.subVectors(d, c), a.subVectors(b, c), e.cross(a), 
        b = e.lengthSq(), 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
    };
}(), THREE.Triangle.barycoordFromPoint = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function(d, e, f, g, h) {
        a.subVectors(g, e), b.subVectors(f, e), c.subVectors(d, e), d = a.dot(a), e = a.dot(b), 
        f = a.dot(c);
        var i = b.dot(b);
        g = b.dot(c);
        var j = d * i - e * e;
        return h = h || new THREE.Vector3(), 0 === j ? h.set(-2, -1, -1) : (j = 1 / j, i = (i * f - e * g) * j, 
        d = (d * g - e * f) * j, h.set(1 - i - d, d, i));
    };
}(), THREE.Triangle.containsPoint = function() {
    var a = new THREE.Vector3();
    return function(b, c, d, e) {
        return b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a), 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;
    };
}(), THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function(a, b, c) {
        return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
    },
    setFromPointsAndIndices: function(a, b, c, d) {
        return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this;
    },
    area: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function() {
            return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length();
        };
    }(),
    midpoint: function(a) {
        return (a || new THREE.Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    normal: function(a) {
        return THREE.Triangle.normal(this.a, this.b, this.c, a);
    },
    plane: function(a) {
        return (a || new THREE.Plane()).setFromCoplanarPoints(this.a, this.b, this.c);
    },
    barycoordFromPoint: function(a, b) {
        return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);
    },
    containsPoint: function(a) {
        return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);
    },
    closestPointToPoint: function() {
        var a, b, c, d;
        return function(e, f) {
            void 0 === a && (a = new THREE.Plane(), b = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ], 
            c = new THREE.Vector3(), d = new THREE.Vector3());
            var g = f || new THREE.Vector3(), h = 1 / 0;
            if (a.setFromCoplanarPoints(this.a, this.b, this.c), a.projectPoint(e, c), !0 === this.containsPoint(c)) g.copy(c); else {
                b[0].set(this.a, this.b), b[1].set(this.b, this.c), b[2].set(this.c, this.a);
                for (var i = 0; i < b.length; i++) {
                    b[i].closestPointToPoint(c, !0, d);
                    var j = c.distanceToSquared(d);
                    j < h && (h = j, g.copy(d));
                }
            }
            return g;
        };
    }(),
    equals: function(a) {
        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
    }
}, THREE.Interpolant = function(a, b, c, d) {
    this.parameterPositions = a, this._cachedIndex = 0, this.resultBuffer = void 0 !== d ? d : new b.constructor(c), 
    this.sampleValues = b, this.valueSize = c;
}, THREE.Interpolant.prototype = {
    constructor: THREE.Interpolant,
    evaluate: function(a) {
        var b = this.parameterPositions, c = this._cachedIndex, d = b[c], e = b[c - 1];
        a: {
            b: {
                c: {
                    d: if (!(a < d)) {
                        for (var f = c + 2; ;) {
                            if (void 0 === d) {
                                if (a < e) break d;
                                return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, a, e);
                            }
                            if (c === f) break;
                            if (e = d, d = b[++c], a < d) break b;
                        }
                        d = b.length;
                        break c;
                    }
                    if (a >= e) break a;
                    for (f = b[1], a < f && (c = 2, e = f), f = c - 2; ;) {
                        if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                        if (c === f) break;
                        if (d = e, e = b[--c - 1], a >= e) break b;
                    }
                    d = c, c = 0;
                }
                for (;c < d; ) e = c + d >>> 1, a < b[e] ? d = e : c = e + 1;
                if (d = b[c], e = b[c - 1], void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a);
            }
            this._cachedIndex = c, this.intervalChanged_(c, e, d);
        }
        return this.interpolate_(c, e, a, d);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
        return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(a) {
        var b = this.resultBuffer, c = this.sampleValues, d = this.valueSize;
        a *= d;
        for (var e = 0; e !== d; ++e) b[e] = c[a + e];
        return b;
    },
    interpolate_: function(a, b, c, d) {
        throw Error("call to abstract method");
    },
    intervalChanged_: function(a, b, c) {}
}, Object.assign(THREE.Interpolant.prototype, {
    beforeStart_: THREE.Interpolant.prototype.copySampleValue_,
    afterEnd_: THREE.Interpolant.prototype.copySampleValue_
}), THREE.CubicInterpolant = function(a, b, c, d) {
    THREE.Interpolant.call(this, a, b, c, d), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
}, THREE.CubicInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.CubicInterpolant,
    DefaultSettings_: {
        endingStart: THREE.ZeroCurvatureEnding,
        endingEnd: THREE.ZeroCurvatureEnding
    },
    intervalChanged_: function(a, b, c) {
        var d = this.parameterPositions, e = a - 2, f = a + 1, g = d[e], h = d[f];
        if (void 0 === g) switch (this.getSettings_().endingStart) {
          case THREE.ZeroSlopeEnding:
            e = a, g = 2 * b - c;
            break;

          case THREE.WrapAroundEnding:
            e = d.length - 2, g = b + d[e] - d[e + 1];
            break;

          default:
            e = a, g = c;
        }
        if (void 0 === h) switch (this.getSettings_().endingEnd) {
          case THREE.ZeroSlopeEnding:
            f = a, h = 2 * c - b;
            break;

          case THREE.WrapAroundEnding:
            f = 1, h = c + d[1] - d[0];
            break;

          default:
            f = a - 1, h = b;
        }
        a = .5 * (c - b), d = this.valueSize, this._weightPrev = a / (b - g), this._weightNext = a / (h - c), 
        this._offsetPrev = e * d, this._offsetNext = f * d;
    },
    interpolate_: function(a, b, c, d) {
        var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
        a *= g;
        var h = a - g, i = this._offsetPrev, j = this._offsetNext, k = this._weightPrev, l = this._weightNext, m = (c - b) / (d - b);
        for (c = m * m, d = c * m, b = -k * d + 2 * k * c - k * m, k = (1 + k) * d + (-1.5 - 2 * k) * c + (-.5 + k) * m + 1, 
        m = (-1 - l) * d + (1.5 + l) * c + .5 * m, l = l * d - l * c, c = 0; c !== g; ++c) e[c] = b * f[i + c] + k * f[h + c] + m * f[a + c] + l * f[j + c];
        return e;
    }
}), THREE.DiscreteInterpolant = function(a, b, c, d) {
    THREE.Interpolant.call(this, a, b, c, d);
}, THREE.DiscreteInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.DiscreteInterpolant,
    interpolate_: function(a, b, c, d) {
        return this.copySampleValue_(a - 1);
    }
}), THREE.LinearInterpolant = function(a, b, c, d) {
    THREE.Interpolant.call(this, a, b, c, d);
}, THREE.LinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.LinearInterpolant,
    interpolate_: function(a, b, c, d) {
        var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
        a *= g;
        var h = a - g;
        for (b = (c - b) / (d - b), c = 1 - b, d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
        return e;
    }
}), THREE.QuaternionLinearInterpolant = function(a, b, c, d) {
    THREE.Interpolant.call(this, a, b, c, d);
}, THREE.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.QuaternionLinearInterpolant,
    interpolate_: function(a, b, c, d) {
        var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
        for (a *= g, b = (c - b) / (d - b), c = a + g; a !== c; a += 4) THREE.Quaternion.slerpFlat(e, 0, f, a - g, f, a, b);
        return e;
    }
}), THREE.Clock = function(a) {
    this.autoStart = void 0 === a || a, this.elapsedTime = this.oldTime = this.startTime = 0, 
    this.running = !1;
}, THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function() {
        this.oldTime = this.startTime = (performance || Date).now(), this.running = !0;
    },
    stop: function() {
        this.getElapsedTime(), this.running = !1;
    },
    getElapsedTime: function() {
        return this.getDelta(), this.elapsedTime;
    },
    getDelta: function() {
        var a = 0;
        if (this.autoStart && !this.running && this.start(), this.running) {
            var b = (performance || Date).now(), a = (b - this.oldTime) / 1e3;
            this.oldTime = b, this.elapsedTime += a;
        }
        return a;
    }
}, THREE.EventDispatcher = function() {}, Object.assign(THREE.EventDispatcher.prototype, {
    addEventListener: function(a, b) {
        void 0 === this._listeners && (this._listeners = {});
        var c = this._listeners;
        void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b);
    },
    hasEventListener: function(a, b) {
        if (void 0 === this._listeners) return !1;
        var c = this._listeners;
        return void 0 !== c[a] && -1 !== c[a].indexOf(b);
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners[a];
            if (void 0 !== c) {
                var d = c.indexOf(b);
                -1 !== d && c.splice(d, 1);
            }
        }
    },
    dispatchEvent: function(a) {
        if (void 0 !== this._listeners) {
            var b = this._listeners[a.type];
            if (void 0 !== b) {
                a.target = this;
                for (var c = [], d = 0, e = b.length, d = 0; d < e; d++) c[d] = b[d];
                for (d = 0; d < e; d++) c[d].call(this, a);
            }
        }
    }
}), THREE.Layers = function() {
    this.mask = 1;
}, THREE.Layers.prototype = {
    constructor: THREE.Layers,
    set: function(a) {
        this.mask = 1 << a;
    },
    enable: function(a) {
        this.mask |= 1 << a;
    },
    toggle: function(a) {
        this.mask ^= 1 << a;
    },
    disable: function(a) {
        this.mask &= ~(1 << a);
    },
    test: function(a) {
        return 0 !== (this.mask & a.mask);
    }
}, function(a) {
    function b(a, b) {
        return a.distance - b.distance;
    }
    function c(a, b, d, e) {
        if (!1 !== a.visible && (a.raycast(b, d), !0 === e)) {
            a = a.children, e = 0;
            for (var f = a.length; e < f; e++) c(a[e], b, d, !0);
        }
    }
    a.Raycaster = function(b, c, d, e) {
        this.ray = new a.Ray(b, c), this.near = d || 0, this.far = e || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), 
                    this.Points;
                }
            }
        });
    }, a.Raycaster.prototype = {
        constructor: a.Raycaster,
        linePrecision: 1,
        set: function(a, b) {
            this.ray.set(a, b);
        },
        setFromCamera: function(b, c) {
            c instanceof a.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(c.matrixWorld), 
            this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(this.ray.origin).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c), 
            this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function(a, d) {
            var e = [];
            return c(a, this, e, d), e.sort(b), e;
        },
        intersectObjects: function(a, d) {
            var e = [];
            if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), 
            e;
            for (var f = 0, g = a.length; f < g; f++) c(a[f], this, e, d);
            return e.sort(b), e;
        }
    };
}(THREE), THREE.Object3D = function() {
    Object.defineProperty(this, "id", {
        value: THREE.Object3DIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Object3D", 
    this.parent = null, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
    var a = new THREE.Vector3(), b = new THREE.Euler(), c = new THREE.Quaternion(), d = new THREE.Vector3(1, 1, 1);
    b.onChange(function() {
        c.setFromEuler(b, !1);
    }), c.onChange(function() {
        b.setFromQuaternion(c, void 0, !1);
    }), Object.defineProperties(this, {
        position: {
            enumerable: !0,
            value: a
        },
        rotation: {
            enumerable: !0,
            value: b
        },
        quaternion: {
            enumerable: !0,
            value: c
        },
        scale: {
            enumerable: !0,
            value: d
        },
        modelViewMatrix: {
            value: new THREE.Matrix4()
        },
        normalMatrix: {
            value: new THREE.Matrix3()
        }
    }), this.matrix = new THREE.Matrix4(), this.matrixWorld = new THREE.Matrix4(), this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate, 
    this.matrixWorldNeedsUpdate = !1, this.layers = new THREE.Layers(), this.visible = !0, 
    this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, 
    this.userData = {};
}, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.DefaultMatrixAutoUpdate = !0, 
Object.assign(THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {
    applyMatrix: function(a) {
        this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    setRotationFromAxisAngle: function(a, b) {
        this.quaternion.setFromAxisAngle(a, b);
    },
    setRotationFromEuler: function(a) {
        this.quaternion.setFromEuler(a, !0);
    },
    setRotationFromMatrix: function(a) {
        this.quaternion.setFromRotationMatrix(a);
    },
    setRotationFromQuaternion: function(a) {
        this.quaternion.copy(a);
    },
    rotateOnAxis: function() {
        var a = new THREE.Quaternion();
        return function(b, c) {
            return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this;
        };
    }(),
    rotateX: function() {
        var a = new THREE.Vector3(1, 0, 0);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    rotateY: function() {
        var a = new THREE.Vector3(0, 1, 0);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    rotateZ: function() {
        var a = new THREE.Vector3(0, 0, 1);
        return function(b) {
            return this.rotateOnAxis(a, b);
        };
    }(),
    translateOnAxis: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), 
            this;
        };
    }(),
    translateX: function() {
        var a = new THREE.Vector3(1, 0, 0);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    translateY: function() {
        var a = new THREE.Vector3(0, 1, 0);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    translateZ: function() {
        var a = new THREE.Vector3(0, 0, 1);
        return function(b) {
            return this.translateOnAxis(a, b);
        };
    }(),
    localToWorld: function(a) {
        return a.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
        var a = new THREE.Matrix4();
        return function(b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld));
        };
    }(),
    lookAt: function() {
        var a = new THREE.Matrix4();
        return function(b) {
            a.lookAt(b, this.position, this.up), this.quaternion.setFromRotationMatrix(a);
        };
    }(),
    add: function(a) {
        if (1 < arguments.length) {
            for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
            return this;
        }
        return a === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), 
        this) : (a instanceof THREE.Object3D ? (null !== a.parent && a.parent.remove(a), 
        a.parent = this, a.dispatchEvent({
            type: "added"
        }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a), 
        this);
    },
    remove: function(a) {
        if (1 < arguments.length) for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
        b = this.children.indexOf(a), -1 !== b && (a.parent = null, a.dispatchEvent({
            type: "removed"
        }), this.children.splice(b, 1));
    },
    getObjectById: function(a) {
        return this.getObjectByProperty("id", a);
    },
    getObjectByName: function(a) {
        return this.getObjectByProperty("name", a);
    },
    getObjectByProperty: function(a, b) {
        if (this[a] === b) return this;
        for (var c = 0, d = this.children.length; c < d; c++) {
            var e = this.children[c].getObjectByProperty(a, b);
            if (void 0 !== e) return e;
        }
    },
    getWorldPosition: function(a) {
        return a = a || new THREE.Vector3(), this.updateMatrixWorld(!0), a.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c) {
            return c = c || new THREE.Quaternion(), this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, c, b), 
            c;
        };
    }(),
    getWorldRotation: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            return b = b || new THREE.Euler(), this.getWorldQuaternion(a), b.setFromQuaternion(a, this.rotation.order, !1);
        };
    }(),
    getWorldScale: function() {
        var a = new THREE.Vector3(), b = new THREE.Quaternion();
        return function(c) {
            return c = c || new THREE.Vector3(), this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, b, c), 
            c;
        };
    }(),
    getWorldDirection: function() {
        var a = new THREE.Quaternion();
        return function(b) {
            return b = b || new THREE.Vector3(), this.getWorldQuaternion(a), b.set(0, 0, 1).applyQuaternion(a);
        };
    }(),
    raycast: function() {},
    traverse: function(a) {
        a(this);
        for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a);
    },
    traverseVisible: function(a) {
        if (!1 !== this.visible) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a);
        }
    },
    traverseAncestors: function(a) {
        var b = this.parent;
        null !== b && (a(b), b.traverseAncestors(a));
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    },
    updateMatrixWorld: function(a) {
        !0 === this.matrixAutoUpdate && this.updateMatrix(), !0 !== this.matrixWorldNeedsUpdate && !0 !== a || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
        this.matrixWorldNeedsUpdate = !1, a = !0);
        for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a);
    },
    toJSON: function(a) {
        function b(a) {
            var b, c = [];
            for (b in a) {
                var d = a[b];
                delete d.metadata, c.push(d);
            }
            return c;
        }
        var c = void 0 === a || "" === a, d = {};
        c && (a = {
            geometries: {},
            materials: {},
            textures: {},
            images: {}
        }, d.metadata = {
            version: 4.4,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        var e = {};
        if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 
        "{}" !== JSON.stringify(this.userData) && (e.userData = this.userData), !0 === this.castShadow && (e.castShadow = !0), 
        !0 === this.receiveShadow && (e.receiveShadow = !0), !1 === this.visible && (e.visible = !1), 
        e.matrix = this.matrix.toArray(), void 0 !== this.geometry && (void 0 === a.geometries[this.geometry.uuid] && (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)), 
        e.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === a.materials[this.material.uuid] && (a.materials[this.material.uuid] = this.material.toJSON(a)), 
        e.material = this.material.uuid), 0 < this.children.length) {
            e.children = [];
            for (var f = 0; f < this.children.length; f++) e.children.push(this.children[f].toJSON(a).object);
        }
        if (c) {
            var c = b(a.geometries), f = b(a.materials), g = b(a.textures);
            a = b(a.images), 0 < c.length && (d.geometries = c), 0 < f.length && (d.materials = f), 
            0 < g.length && (d.textures = g), 0 < a.length && (d.images = a);
        }
        return d.object = e, d;
    },
    clone: function(a) {
        return new this.constructor().copy(this, a);
    },
    copy: function(a, b) {
        if (void 0 === b && (b = !0), this.name = a.name, this.up.copy(a.up), this.position.copy(a.position), 
        this.quaternion.copy(a.quaternion), this.scale.copy(a.scale), this.matrix.copy(a.matrix), 
        this.matrixWorld.copy(a.matrixWorld), this.matrixAutoUpdate = a.matrixAutoUpdate, 
        this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate, this.visible = a.visible, 
        this.castShadow = a.castShadow, this.receiveShadow = a.receiveShadow, this.frustumCulled = a.frustumCulled, 
        this.renderOrder = a.renderOrder, this.userData = JSON.parse(JSON.stringify(a.userData)), 
        !0 === b) for (var c = 0; c < a.children.length; c++) this.add(a.children[c].clone());
        return this;
    }
}), THREE.Object3DIdCount = 0, THREE.Face3 = function(a, b, c, d, e, f) {
    this.a = a, this.b = b, this.c = c, this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3(), 
    this.vertexNormals = Array.isArray(d) ? d : [], this.color = e instanceof THREE.Color ? e : new THREE.Color(), 
    this.vertexColors = Array.isArray(e) ? e : [], this.materialIndex = void 0 !== f ? f : 0;
}, THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        this.a = a.a, this.b = a.b, this.c = a.c, this.normal.copy(a.normal), this.color.copy(a.color), 
        this.materialIndex = a.materialIndex;
        for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
        for (b = 0, c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
        return this;
    }
}, THREE.BufferAttribute = function(a, b, c) {
    this.uuid = THREE.Math.generateUUID(), this.array = a, this.itemSize = b, this.dynamic = !1, 
    this.updateRange = {
        offset: 0,
        count: -1
    }, this.version = 0, this.normalized = !0 === c;
}, THREE.BufferAttribute.prototype = {
    constructor: THREE.BufferAttribute,
    get count() {
        return this.array.length / this.itemSize;
    },
    set needsUpdate(a) {
        !0 === a && this.version++;
    },
    setDynamic: function(a) {
        return this.dynamic = a, this;
    },
    copy: function(a) {
        return this.array = new a.array.constructor(a.array), this.itemSize = a.itemSize, 
        this.dynamic = a.dynamic, this;
    },
    copyAt: function(a, b, c) {
        a *= this.itemSize, c *= b.itemSize;
        for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
        return this;
    },
    copyArray: function(a) {
        return this.array.set(a), this;
    },
    copyColorsArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), 
            f = new THREE.Color()), b[c++] = f.r, b[c++] = f.g, b[c++] = f.b;
        }
        return this;
    },
    copyIndicesArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            b[c++] = f.a, b[c++] = f.b, b[c++] = f.c;
        }
        return this;
    },
    copyVector2sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), 
            f = new THREE.Vector2()), b[c++] = f.x, b[c++] = f.y;
        }
        return this;
    },
    copyVector3sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), 
            f = new THREE.Vector3()), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z;
        }
        return this;
    },
    copyVector4sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), 
            f = new THREE.Vector4()), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z, b[c++] = f.w;
        }
        return this;
    },
    set: function(a, b) {
        return void 0 === b && (b = 0), this.array.set(a, b), this;
    },
    getX: function(a) {
        return this.array[a * this.itemSize];
    },
    setX: function(a, b) {
        return this.array[a * this.itemSize] = b, this;
    },
    getY: function(a) {
        return this.array[a * this.itemSize + 1];
    },
    setY: function(a, b) {
        return this.array[a * this.itemSize + 1] = b, this;
    },
    getZ: function(a) {
        return this.array[a * this.itemSize + 2];
    },
    setZ: function(a, b) {
        return this.array[a * this.itemSize + 2] = b, this;
    },
    getW: function(a) {
        return this.array[a * this.itemSize + 3];
    },
    setW: function(a, b) {
        return this.array[a * this.itemSize + 3] = b, this;
    },
    setXY: function(a, b, c) {
        return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this;
    },
    setXYZ: function(a, b, c, d) {
        return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, 
        this;
    },
    setXYZW: function(a, b, c, d, e) {
        return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, 
        this.array[a + 3] = e, this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
}, THREE.Int8Attribute = function(a, b) {
    return new THREE.BufferAttribute(new Int8Array(a), b);
}, THREE.Uint8Attribute = function(a, b) {
    return new THREE.BufferAttribute(new Uint8Array(a), b);
}, THREE.Uint8ClampedAttribute = function(a, b) {
    return new THREE.BufferAttribute(new Uint8ClampedArray(a), b);
}, THREE.Int16Attribute = function(a, b) {
    return new THREE.BufferAttribute(new Int16Array(a), b);
}, THREE.Uint16Attribute = function(a, b) {
    return new THREE.BufferAttribute(new Uint16Array(a), b);
}, THREE.Int32Attribute = function(a, b) {
    return new THREE.BufferAttribute(new Int32Array(a), b);
}, THREE.Uint32Attribute = function(a, b) {
    return new THREE.BufferAttribute(new Uint32Array(a), b);
}, THREE.Float32Attribute = function(a, b) {
    return new THREE.BufferAttribute(new Float32Array(a), b);
}, THREE.Float64Attribute = function(a, b) {
    return new THREE.BufferAttribute(new Float64Array(a), b);
}, THREE.DynamicBufferAttribute = function(a, b) {
    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), 
    new THREE.BufferAttribute(a, b).setDynamic(!0);
}, THREE.InstancedBufferAttribute = function(a, b, c) {
    THREE.BufferAttribute.call(this, a, b), this.meshPerAttribute = c || 1;
}, THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype), 
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute, 
THREE.InstancedBufferAttribute.prototype.copy = function(a) {
    return THREE.BufferAttribute.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, 
    this;
}, THREE.InterleavedBuffer = function(a, b) {
    this.uuid = THREE.Math.generateUUID(), this.array = a, this.stride = b, this.dynamic = !1, 
    this.updateRange = {
        offset: 0,
        count: -1
    }, this.version = 0;
}, THREE.InterleavedBuffer.prototype = {
    constructor: THREE.InterleavedBuffer,
    get length() {
        return this.array.length;
    },
    get count() {
        return this.array.length / this.stride;
    },
    set needsUpdate(a) {
        !0 === a && this.version++;
    },
    setDynamic: function(a) {
        return this.dynamic = a, this;
    },
    copy: function(a) {
        return this.array = new a.array.constructor(a.array), this.stride = a.stride, this.dynamic = a.dynamic, 
        this;
    },
    copyAt: function(a, b, c) {
        a *= this.stride, c *= b.stride;
        for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
        return this;
    },
    set: function(a, b) {
        return void 0 === b && (b = 0), this.array.set(a, b), this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
}, THREE.InstancedInterleavedBuffer = function(a, b, c) {
    THREE.InterleavedBuffer.call(this, a, b), this.meshPerAttribute = c || 1;
}, THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype), 
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer, 
THREE.InstancedInterleavedBuffer.prototype.copy = function(a) {
    return THREE.InterleavedBuffer.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, 
    this;
}, THREE.InterleavedBufferAttribute = function(a, b, c) {
    this.uuid = THREE.Math.generateUUID(), this.data = a, this.itemSize = b, this.offset = c;
}, THREE.InterleavedBufferAttribute.prototype = {
    constructor: THREE.InterleavedBufferAttribute,
    get length() {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), 
        this.array.length;
    },
    get count() {
        return this.data.count;
    },
    setX: function(a, b) {
        return this.data.array[a * this.data.stride + this.offset] = b, this;
    },
    setY: function(a, b) {
        return this.data.array[a * this.data.stride + this.offset + 1] = b, this;
    },
    setZ: function(a, b) {
        return this.data.array[a * this.data.stride + this.offset + 2] = b, this;
    },
    setW: function(a, b) {
        return this.data.array[a * this.data.stride + this.offset + 3] = b, this;
    },
    getX: function(a) {
        return this.data.array[a * this.data.stride + this.offset];
    },
    getY: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 1];
    },
    getZ: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 2];
    },
    getW: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 3];
    },
    setXY: function(a, b, c) {
        return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, 
        this;
    },
    setXYZ: function(a, b, c, d) {
        return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, 
        this.data.array[a + 2] = d, this;
    },
    setXYZW: function(a, b, c, d, e) {
        return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, 
        this.data.array[a + 2] = d, this.data.array[a + 3] = e, this;
    }
}, THREE.Geometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Geometry", 
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], 
    this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], 
    this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;
}, Object.assign(THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {
    applyMatrix: function(a) {
        for (var b = new THREE.Matrix3().getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
        for (c = 0, d = this.faces.length; c < d; c++) {
            a = this.faces[c], a.normal.applyMatrix3(b).normalize();
            for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize();
        }
        return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
        this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this;
    },
    rotateX: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationX(b), this.applyMatrix(a), 
            this;
        };
    }(),
    rotateY: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationY(b), this.applyMatrix(a), 
            this;
        };
    }(),
    rotateZ: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationZ(b), this.applyMatrix(a), 
            this;
        };
    }(),
    translate: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeTranslation(b, c, d), this.applyMatrix(a), 
            this;
        };
    }(),
    scale: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeScale(b, c, d), this.applyMatrix(a), 
            this;
        };
    }(),
    lookAt: function() {
        var a;
        return function(b) {
            void 0 === a && (a = new THREE.Object3D()), a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix);
        };
    }(),
    fromBufferGeometry: function(a) {
        function b(a, b, d, e) {
            var f = void 0 !== g ? [ k[a].clone(), k[b].clone(), k[d].clone() ] : [], n = void 0 !== h ? [ c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone() ] : [];
            e = new THREE.Face3(a, b, d, f, n, e), c.faces.push(e), void 0 !== i && c.faceVertexUvs[0].push([ l[a].clone(), l[b].clone(), l[d].clone() ]), 
            void 0 !== j && c.faceVertexUvs[1].push([ m[a].clone(), m[b].clone(), m[d].clone() ]);
        }
        var c = this, d = null !== a.index ? a.index.array : void 0, e = a.attributes, f = e.position.array, g = void 0 !== e.normal ? e.normal.array : void 0, h = void 0 !== e.color ? e.color.array : void 0, i = void 0 !== e.uv ? e.uv.array : void 0, j = void 0 !== e.uv2 ? e.uv2.array : void 0;
        void 0 !== j && (this.faceVertexUvs[1] = []);
        for (var k = [], l = [], m = [], n = e = 0; e < f.length; e += 3, n += 2) c.vertices.push(new THREE.Vector3(f[e], f[e + 1], f[e + 2])), 
        void 0 !== g && k.push(new THREE.Vector3(g[e], g[e + 1], g[e + 2])), void 0 !== h && c.colors.push(new THREE.Color(h[e], h[e + 1], h[e + 2])), 
        void 0 !== i && l.push(new THREE.Vector2(i[n], i[n + 1])), void 0 !== j && m.push(new THREE.Vector2(j[n], j[n + 1]));
        if (void 0 !== d) if (f = a.groups, 0 < f.length) for (e = 0; e < f.length; e++) for (var o = f[e], p = o.start, q = o.count, n = p, p = p + q; n < p; n += 3) b(d[n], d[n + 1], d[n + 2], o.materialIndex); else for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]); else for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
        return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), 
        null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this;
    },
    center: function() {
        this.computeBoundingBox();
        var a = this.boundingBox.center().negate();
        return this.translate(a.x, a.y, a.z), a;
    },
    normalize: function() {
        this.computeBoundingSphere();
        var a = this.boundingSphere.center, b = this.boundingSphere.radius, b = 0 === b ? 1 : 1 / b, c = new THREE.Matrix4();
        return c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1), 
        this.applyMatrix(c), this;
    },
    computeFaceNormals: function() {
        for (var a = new THREE.Vector3(), b = new THREE.Vector3(), c = 0, d = this.faces.length; c < d; c++) {
            var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
            a.subVectors(this.vertices[e.c], g), b.subVectors(f, g), a.cross(b), a.normalize(), 
            e.normal.copy(a);
        }
    },
    computeVertexNormals: function(a) {
        void 0 === a && (a = !0);
        var b, c, d;
        for (d = Array(this.vertices.length), b = 0, c = this.vertices.length; b < c; b++) d[b] = new THREE.Vector3();
        if (a) {
            var e, f, g, h = new THREE.Vector3(), i = new THREE.Vector3();
            for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], e = this.vertices[c.a], 
            f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), i.subVectors(e, f), 
            h.cross(i), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h);
        } else for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], d[c.a].add(c.normal), 
        d[c.b].add(c.normal), d[c.c].add(c.normal);
        for (b = 0, c = this.vertices.length; b < c; b++) d[b].normalize();
        for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], e = c.vertexNormals, 
        3 === e.length ? (e[0].copy(d[c.a]), e[1].copy(d[c.b]), e[2].copy(d[c.c])) : (e[0] = d[c.a].clone(), 
        e[1] = d[c.b].clone(), e[2] = d[c.c].clone());
        0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function() {
        var a, b, c, d, e;
        for (c = 0, d = this.faces.length; c < d; c++) for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), 
        e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
        var f = new THREE.Geometry();
        for (f.faces = this.faces, a = 0, b = this.morphTargets.length; a < b; a++) {
            if (!this.morphNormals[a]) {
                this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [], 
                e = this.morphNormals[a].faceNormals;
                var g, h, i = this.morphNormals[a].vertexNormals;
                for (c = 0, d = this.faces.length; c < d; c++) g = new THREE.Vector3(), h = {
                    a: new THREE.Vector3(),
                    b: new THREE.Vector3(),
                    c: new THREE.Vector3()
                }, e.push(g), i.push(h);
            }
            for (i = this.morphNormals[a], f.vertices = this.morphTargets[a].vertices, f.computeFaceNormals(), 
            f.computeVertexNormals(), c = 0, d = this.faces.length; c < d; c++) e = this.faces[c], 
            g = i.faceNormals[c], h = i.vertexNormals[c], g.copy(e.normal), h.a.copy(e.vertexNormals[0]), 
            h.b.copy(e.vertexNormals[1]), h.c.copy(e.vertexNormals[2]);
        }
        for (c = 0, d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, 
        e.vertexNormals = e.__originalVertexNormals;
    },
    computeTangents: function() {
        console.warn("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
        for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), 
        this.lineDistances[c] = a;
    },
    computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3()), this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere()), this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(a, b, c) {
        if (!1 == a instanceof THREE.Geometry) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a); else {
            var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, i = a.faces, j = this.faceVertexUvs[0];
            a = a.faceVertexUvs[0], void 0 === c && (c = 0), void 0 !== b && (d = new THREE.Matrix3().getNormalMatrix(b));
            for (var k = 0, l = g.length; k < l; k++) {
                var m = g[k].clone();
                void 0 !== b && m.applyMatrix4(b), f.push(m);
            }
            for (k = 0, l = i.length; k < l; k++) {
                var n, g = i[k], o = g.vertexNormals, p = g.vertexColors, m = new THREE.Face3(g.a + e, g.b + e, g.c + e);
                for (m.normal.copy(g.normal), void 0 !== d && m.normal.applyMatrix3(d).normalize(), 
                b = 0, f = o.length; b < f; b++) n = o[b].clone(), void 0 !== d && n.applyMatrix3(d).normalize(), 
                m.vertexNormals.push(n);
                for (m.color.copy(g.color), b = 0, f = p.length; b < f; b++) n = p[b], m.vertexColors.push(n.clone());
                m.materialIndex = g.materialIndex + c, h.push(m);
            }
            for (k = 0, l = a.length; k < l; k++) if (c = a[k], d = [], void 0 !== c) {
                for (b = 0, f = c.length; b < f; b++) d.push(c[b].clone());
                j.push(d);
            }
        }
    },
    mergeMesh: function(a) {
        !1 == a instanceof THREE.Mesh ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), 
        this.merge(a.geometry, a.matrix));
    },
    mergeVertices: function() {
        var a, b, c, d = {}, e = [], f = [], g = Math.pow(10, 4);
        for (b = 0, c = this.vertices.length; b < c; b++) a = this.vertices[b], a = Math.round(a.x * g) + "_" + Math.round(a.y * g) + "_" + Math.round(a.z * g), 
        void 0 === d[a] ? (d[a] = b, e.push(this.vertices[b]), f[b] = e.length - 1) : f[b] = f[d[a]];
        for (d = [], b = 0, c = this.faces.length; b < c; b++) for (g = this.faces[b], g.a = f[g.a], 
        g.b = f[g.b], g.c = f[g.c], g = [ g.a, g.b, g.c ], a = 0; 3 > a; a++) if (g[a] === g[(a + 1) % 3]) {
            d.push(b);
            break;
        }
        for (b = d.length - 1; 0 <= b; b--) for (g = d[b], this.faces.splice(g, 1), f = 0, 
        c = this.faceVertexUvs.length; f < c; f++) this.faceVertexUvs[f].splice(g, 1);
        return b = this.vertices.length - e.length, this.vertices = e, b;
    },
    sortFacesByMaterialIndex: function() {
        for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
        a.sort(function(a, b) {
            return a.materialIndex - b.materialIndex;
        });
        var d, e, f = this.faceVertexUvs[0], g = this.faceVertexUvs[1];
        for (f && f.length === b && (d = []), g && g.length === b && (e = []), c = 0; c < b; c++) {
            var h = a[c]._id;
            d && d.push(f[h]), e && e.push(g[h]);
        }
        d && (this.faceVertexUvs[0] = d), e && (this.faceVertexUvs[1] = e);
    },
    toJSON: function() {
        function a(a, b, c) {
            return c ? a | 1 << b : a & ~(1 << b);
        }
        function b(a) {
            var b = a.x.toString() + a.y.toString() + a.z.toString();
            return void 0 !== j[b] ? j[b] : (j[b] = i.length / 3, i.push(a.x, a.y, a.z), j[b]);
        }
        function c(a) {
            var b = a.r.toString() + a.g.toString() + a.b.toString();
            return void 0 !== l[b] ? l[b] : (l[b] = k.length, k.push(a.getHex()), l[b]);
        }
        function d(a) {
            var b = a.x.toString() + a.y.toString();
            return void 0 !== n[b] ? n[b] : (n[b] = m.length / 2, m.push(a.x, a.y), n[b]);
        }
        var e = {
            metadata: {
                version: 4.4,
                type: "Geometry",
                generator: "Geometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 
        void 0 !== this.parameters) {
            var f, g = this.parameters;
            for (f in g) void 0 !== g[f] && (e[f] = g[f]);
            return e;
        }
        for (g = [], f = 0; f < this.vertices.length; f++) {
            var h = this.vertices[f];
            g.push(h.x, h.y, h.z);
        }
        var h = [], i = [], j = {}, k = [], l = {}, m = [], n = {};
        for (f = 0; f < this.faces.length; f++) {
            var o = this.faces[f], p = void 0 !== this.faceVertexUvs[0][f], q = 0 < o.normal.length(), r = 0 < o.vertexNormals.length, s = 1 !== o.color.r || 1 !== o.color.g || 1 !== o.color.b, t = 0 < o.vertexColors.length, u = 0, u = a(u, 0, 0), u = a(u, 1, !0), u = a(u, 2, !1), u = a(u, 3, p), u = a(u, 4, q), u = a(u, 5, r), u = a(u, 6, s), u = a(u, 7, t);
            h.push(u), h.push(o.a, o.b, o.c), h.push(o.materialIndex), p && (p = this.faceVertexUvs[0][f], 
            h.push(d(p[0]), d(p[1]), d(p[2]))), q && h.push(b(o.normal)), r && (q = o.vertexNormals, 
            h.push(b(q[0]), b(q[1]), b(q[2]))), s && h.push(c(o.color)), t && (o = o.vertexColors, 
            h.push(c(o[0]), c(o[1]), c(o[2])));
        }
        return e.data = {}, e.data.vertices = g, e.data.normals = i, 0 < k.length && (e.data.colors = k), 
        0 < m.length && (e.data.uvs = [ m ]), e.data.faces = h, e;
    },
    clone: function() {
        return new THREE.Geometry().copy(this);
    },
    copy: function(a) {
        this.vertices = [], this.faces = [], this.faceVertexUvs = [ [] ];
        for (var b = a.vertices, c = 0, d = b.length; c < d; c++) this.vertices.push(b[c].clone());
        for (b = a.faces, c = 0, d = b.length; c < d; c++) this.faces.push(b[c].clone());
        for (c = 0, d = a.faceVertexUvs.length; c < d; c++) {
            b = a.faceVertexUvs[c], void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []);
            for (var e = 0, f = b.length; e < f; e++) {
                for (var g = b[e], h = [], i = 0, j = g.length; i < j; i++) h.push(g[i].clone());
                this.faceVertexUvs[c].push(h);
            }
        }
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}), THREE.GeometryIdCount = 0, THREE.DirectGeometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "DirectGeometry", 
    this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], 
    this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], 
    this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
}, Object.assign(THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {
    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
    computeFaceNormals: function() {
        console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.");
    },
    computeVertexNormals: function() {
        console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.");
    },
    computeGroups: function(a) {
        var b, c, d = [];
        a = a.faces;
        for (var e = 0; e < a.length; e++) {
            var f = a[e];
            f.materialIndex !== c && (c = f.materialIndex, void 0 !== b && (b.count = 3 * e - b.start, 
            d.push(b)), b = {
                start: 3 * e,
                materialIndex: c
            });
        }
        void 0 !== b && (b.count = 3 * e - b.start, d.push(b)), this.groups = d;
    },
    fromGeometry: function(a) {
        var b, c = a.faces, d = a.vertices, e = a.faceVertexUvs, f = e[0] && 0 < e[0].length, g = e[1] && 0 < e[1].length, h = a.morphTargets, i = h.length;
        if (0 < i) {
            b = [];
            for (var j = 0; j < i; j++) b[j] = [];
            this.morphTargets.position = b;
        }
        var k, l = a.morphNormals, m = l.length;
        if (0 < m) {
            for (k = [], j = 0; j < m; j++) k[j] = [];
            this.morphTargets.normal = k;
        }
        for (var n = a.skinIndices, o = a.skinWeights, p = n.length === d.length, q = o.length === d.length, j = 0; j < c.length; j++) {
            var r = c[j];
            this.vertices.push(d[r.a], d[r.b], d[r.c]);
            var s = r.vertexNormals;
            for (3 === s.length ? this.normals.push(s[0], s[1], s[2]) : (s = r.normal, this.normals.push(s, s, s)), 
            s = r.vertexColors, 3 === s.length ? this.colors.push(s[0], s[1], s[2]) : (s = r.color, 
            this.colors.push(s, s, s)), !0 === f && (s = e[0][j], void 0 !== s ? this.uvs.push(s[0], s[1], s[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", j), 
            this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()))), 
            !0 === g && (s = e[1][j], void 0 !== s ? this.uvs2.push(s[0], s[1], s[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", j), 
            this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()))), 
            s = 0; s < i; s++) {
                var t = h[s].vertices;
                b[s].push(t[r.a], t[r.b], t[r.c]);
            }
            for (s = 0; s < m; s++) t = l[s].vertexNormals[j], k[s].push(t.a, t.b, t.c);
            p && this.skinIndices.push(n[r.a], n[r.b], n[r.c]), q && this.skinWeights.push(o[r.a], o[r.b], o[r.c]);
        }
        return this.computeGroups(a), this.verticesNeedUpdate = a.verticesNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, 
        this.colorsNeedUpdate = a.colorsNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, 
        this.groupsNeedUpdate = a.groupsNeedUpdate, this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}), THREE.BufferGeometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", 
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], 
    this.boundingSphere = this.boundingBox = null, this.drawRange = {
        start: 0,
        count: 1 / 0
    };
}, Object.assign(THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {
    getIndex: function() {
        return this.index;
    },
    setIndex: function(a) {
        this.index = a;
    },
    addAttribute: function(a, b, c) {
        if (!1 == b instanceof THREE.BufferAttribute && !1 == b instanceof THREE.InterleavedBufferAttribute) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), 
        this.addAttribute(a, new THREE.BufferAttribute(b, c)); else {
            if ("index" !== a) return this.attributes[a] = b, this;
            console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), 
            this.setIndex(b);
        }
    },
    getAttribute: function(a) {
        return this.attributes[a];
    },
    removeAttribute: function(a) {
        return delete this.attributes[a], this;
    },
    addGroup: function(a, b, c) {
        this.groups.push({
            start: a,
            count: b,
            materialIndex: void 0 !== c ? c : 0
        });
    },
    clearGroups: function() {
        this.groups = [];
    },
    setDrawRange: function(a, b) {
        this.drawRange.start = a, this.drawRange.count = b;
    },
    applyMatrix: function(a) {
        var b = this.attributes.position;
        return void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0), b = this.attributes.normal, 
        void 0 !== b && (new THREE.Matrix3().getNormalMatrix(a).applyToVector3Array(b.array), 
        b.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
        this;
    },
    rotateX: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationX(b), this.applyMatrix(a), 
            this;
        };
    }(),
    rotateY: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationY(b), this.applyMatrix(a), 
            this;
        };
    }(),
    rotateZ: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeRotationZ(b), this.applyMatrix(a), 
            this;
        };
    }(),
    translate: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeTranslation(b, c, d), this.applyMatrix(a), 
            this;
        };
    }(),
    scale: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new THREE.Matrix4()), a.makeScale(b, c, d), this.applyMatrix(a), 
            this;
        };
    }(),
    lookAt: function() {
        var a;
        return function(b) {
            void 0 === a && (a = new THREE.Object3D()), a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix);
        };
    }(),
    center: function() {
        this.computeBoundingBox();
        var a = this.boundingBox.center().negate();
        return this.translate(a.x, a.y, a.z), a;
    },
    setFromObject: function(a) {
        var b = a.geometry;
        if (a instanceof THREE.Points || a instanceof THREE.Line) {
            a = new THREE.Float32Attribute(3 * b.vertices.length, 3);
            var c = new THREE.Float32Attribute(3 * b.colors.length, 3);
            this.addAttribute("position", a.copyVector3sArray(b.vertices)), this.addAttribute("color", c.copyColorsArray(b.colors)), 
            b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new THREE.Float32Attribute(b.lineDistances.length, 1), 
            this.addAttribute("lineDistance", a.copyArray(b.lineDistances))), null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()), 
            null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone());
        } else a instanceof THREE.Mesh && b instanceof THREE.Geometry && this.fromGeometry(b);
        return this;
    },
    updateFromObject: function(a) {
        var b = a.geometry;
        if (a instanceof THREE.Mesh) {
            var c = b.__directGeometry;
            if (void 0 === c) return this.fromGeometry(b);
            c.verticesNeedUpdate = b.verticesNeedUpdate, c.normalsNeedUpdate = b.normalsNeedUpdate, 
            c.colorsNeedUpdate = b.colorsNeedUpdate, c.uvsNeedUpdate = b.uvsNeedUpdate, c.groupsNeedUpdate = b.groupsNeedUpdate, 
            b.verticesNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.uvsNeedUpdate = !1, 
            b.groupsNeedUpdate = !1, b = c;
        }
        return !0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), 
        c.needsUpdate = !0), b.verticesNeedUpdate = !1), !0 === b.normalsNeedUpdate && (c = this.attributes.normal, 
        void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1), 
        !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), 
        c.needsUpdate = !0), b.colorsNeedUpdate = !1), b.uvsNeedUpdate && (c = this.attributes.uv, 
        void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1), 
        b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), 
        c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1), b.groupsNeedUpdate && (b.computeGroups(a.geometry), 
        this.groups = b.groups, b.groupsNeedUpdate = !1), this;
    },
    fromGeometry: function(a) {
        return a.__directGeometry = new THREE.DirectGeometry().fromGeometry(a), this.fromDirectGeometry(a.__directGeometry);
    },
    fromDirectGeometry: function(a) {
        var b = new Float32Array(3 * a.vertices.length);
        this.addAttribute("position", new THREE.BufferAttribute(b, 3).copyVector3sArray(a.vertices)), 
        0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", new THREE.BufferAttribute(b, 3).copyVector3sArray(a.normals))), 
        0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", new THREE.BufferAttribute(b, 3).copyColorsArray(a.colors))), 
        0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", new THREE.BufferAttribute(b, 2).copyVector2sArray(a.uvs))), 
        0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", new THREE.BufferAttribute(b, 2).copyVector2sArray(a.uvs2))), 
        0 < a.indices.length && (b = new (65535 < a.vertices.length ? Uint32Array : Uint16Array)(3 * a.indices.length), 
        this.setIndex(new THREE.BufferAttribute(b, 1).copyIndicesArray(a.indices))), this.groups = a.groups;
        for (var c in a.morphTargets) {
            for (var b = [], d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
                var g = d[e], h = new THREE.Float32Attribute(3 * g.length, 3);
                b.push(h.copyVector3sArray(g));
            }
            this.morphAttributes[c] = b;
        }
        return 0 < a.skinIndices.length && (c = new THREE.Float32Attribute(4 * a.skinIndices.length, 4), 
        this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))), 0 < a.skinWeights.length && (c = new THREE.Float32Attribute(4 * a.skinWeights.length, 4), 
        this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), 
        null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), this;
    },
    computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3());
        var a = this.attributes.position.array;
        void 0 !== a ? this.boundingBox.setFromArray(a) : this.boundingBox.makeEmpty(), 
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    },
    computeBoundingSphere: function() {
        var a = new THREE.Box3(), b = new THREE.Vector3();
        return function() {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
            var c = this.attributes.position.array;
            if (c) {
                var d = this.boundingSphere.center;
                a.setFromArray(c), a.center(d);
                for (var e = 0, f = 0, g = c.length; f < g; f += 3) b.fromArray(c, f), e = Math.max(e, d.distanceToSquared(b));
                this.boundingSphere.radius = Math.sqrt(e), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        };
    }(),
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
        var a = this.index, b = this.attributes, c = this.groups;
        if (b.position) {
            var d = b.position.array;
            if (void 0 === b.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(d.length), 3)); else for (var e = b.normal.array, f = 0, g = e.length; f < g; f++) e[f] = 0;
            var h, i, j, e = b.normal.array, k = new THREE.Vector3(), l = new THREE.Vector3(), m = new THREE.Vector3(), n = new THREE.Vector3(), o = new THREE.Vector3();
            if (a) {
                a = a.array, 0 === c.length && this.addGroup(0, a.length);
                for (var p = 0, q = c.length; p < q; ++p) for (f = c[p], g = f.start, h = f.count, 
                f = g, g += h; f < g; f += 3) h = 3 * a[f + 0], i = 3 * a[f + 1], j = 3 * a[f + 2], 
                k.fromArray(d, h), l.fromArray(d, i), m.fromArray(d, j), n.subVectors(m, l), o.subVectors(k, l), 
                n.cross(o), e[h] += n.x, e[h + 1] += n.y, e[h + 2] += n.z, e[i] += n.x, e[i + 1] += n.y, 
                e[i + 2] += n.z, e[j] += n.x, e[j + 1] += n.y, e[j + 2] += n.z;
            } else for (f = 0, g = d.length; f < g; f += 9) k.fromArray(d, f), l.fromArray(d, f + 3), 
            m.fromArray(d, f + 6), n.subVectors(m, l), o.subVectors(k, l), n.cross(o), e[f] = n.x, 
            e[f + 1] = n.y, e[f + 2] = n.z, e[f + 3] = n.x, e[f + 4] = n.y, e[f + 5] = n.z, 
            e[f + 6] = n.x, e[f + 7] = n.y, e[f + 8] = n.z;
            this.normalizeNormals(), b.normal.needsUpdate = !0;
        }
    },
    merge: function(a, b) {
        if (!1 != a instanceof THREE.BufferGeometry) {
            void 0 === b && (b = 0);
            var c, d = this.attributes;
            for (c in d) if (void 0 !== a.attributes[c]) for (var e = d[c].array, f = a.attributes[c], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, 
            f++) e[f] = g[h];
            return this;
        }
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
    },
    normalizeNormals: function() {
        for (var a, b, c, d = this.attributes.normal.array, e = 0, f = d.length; e < f; e += 3) a = d[e], 
        b = d[e + 1], c = d[e + 2], a = 1 / Math.sqrt(a * a + b * b + c * c), d[e] *= a, 
        d[e + 1] *= a, d[e + 2] *= a;
    },
    toNonIndexed: function() {
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), 
        this;
        var a, b = new THREE.BufferGeometry(), c = this.index.array, d = this.attributes;
        for (a in d) {
            for (var e = d[a], f = e.array, e = e.itemSize, g = new f.constructor(c.length * e), h = 0, i = 0, j = 0, k = c.length; j < k; j++) for (var h = c[j] * e, l = 0; l < e; l++) g[i++] = f[h++];
            b.addAttribute(a, new THREE.BufferAttribute(g, e));
        }
        return b;
    },
    toJSON: function() {
        var a = {
            metadata: {
                version: 4.4,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), 
        void 0 !== this.parameters) {
            var b, c = this.parameters;
            for (b in c) void 0 !== c[b] && (a[b] = c[b]);
            return a;
        }
        a.data = {
            attributes: {}
        };
        var d = this.index;
        null !== d && (c = Array.prototype.slice.call(d.array), a.data.index = {
            type: d.array.constructor.name,
            array: c
        }), d = this.attributes;
        for (b in d) {
            var e = d[b], c = Array.prototype.slice.call(e.array);
            a.data.attributes[b] = {
                itemSize: e.itemSize,
                type: e.array.constructor.name,
                array: c,
                normalized: e.normalized
            };
        }
        return b = this.groups, 0 < b.length && (a.data.groups = JSON.parse(JSON.stringify(b))), 
        b = this.boundingSphere, null !== b && (a.data.boundingSphere = {
            center: b.center.toArray(),
            radius: b.radius
        }), a;
    },
    clone: function() {
        return new THREE.BufferGeometry().copy(this);
    },
    copy: function(a) {
        var b = a.index;
        null !== b && this.setIndex(b.clone());
        var c, b = a.attributes;
        for (c in b) this.addAttribute(c, b[c].clone());
        for (a = a.groups, c = 0, b = a.length; c < b; c++) {
            var d = a[c];
            this.addGroup(d.start, d.count, d.materialIndex);
        }
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}), THREE.BufferGeometry.MaxIndex = 65535, THREE.InstancedBufferGeometry = function() {
    THREE.BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
}, THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry, 
THREE.InstancedBufferGeometry.prototype.addGroup = function(a, b, c) {
    this.groups.push({
        start: a,
        count: b,
        instances: c
    });
}, THREE.InstancedBufferGeometry.prototype.copy = function(a) {
    var b = a.index;
    null !== b && this.setIndex(b.clone());
    var c, b = a.attributes;
    for (c in b) this.addAttribute(c, b[c].clone());
    for (a = a.groups, c = 0, b = a.length; c < b; c++) {
        var d = a[c];
        this.addGroup(d.start, d.count, d.instances);
    }
    return this;
}, THREE.Uniform = function(a, b) {
    "string" == typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), 
    a = b), this.value = a, this.dynamic = !1;
}, THREE.Uniform.prototype = {
    constructor: THREE.Uniform,
    onUpdate: function(a) {
        return this.dynamic = !0, this.onUpdateCallback = a, this;
    }
}, THREE.AnimationAction = function() {
    throw Error("THREE.AnimationAction: Use mixer.clipAction for construction.");
}, THREE.AnimationAction._new = function(a, b, c) {
    this._mixer = a, this._clip = b, this._localRoot = c || null, a = b.tracks, b = a.length, 
    c = Array(b);
    for (var d = {
        endingStart: THREE.ZeroCurvatureEnding,
        endingEnd: THREE.ZeroCurvatureEnding
    }, e = 0; e !== b; ++e) {
        var f = a[e].createInterpolant(null);
        c[e] = f, f.settings = d;
    }
    this._interpolantSettings = d, this._interpolants = c, this._propertyBindings = Array(b), 
    this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, 
    this.loop = THREE.LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, 
    this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, 
    this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, 
    this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
}, THREE.AnimationAction._new.prototype = {
    constructor: THREE.AnimationAction._new,
    play: function() {
        return this._mixer._activateAction(this), this;
    },
    stop: function() {
        return this._mixer._deactivateAction(this), this.reset();
    },
    reset: function() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, 
        this._startTime = null, this.stopFading().stopWarping();
    },
    isRunning: function() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
    },
    isScheduled: function() {
        return this._mixer._isActiveAction(this);
    },
    startAt: function(a) {
        return this._startTime = a, this;
    },
    setLoop: function(a, b) {
        return this.loop = a, this.repetitions = b, this;
    },
    setEffectiveWeight: function(a) {
        return this.weight = a, this._effectiveWeight = this.enabled ? a : 0, this.stopFading();
    },
    getEffectiveWeight: function() {
        return this._effectiveWeight;
    },
    fadeIn: function(a) {
        return this._scheduleFading(a, 0, 1);
    },
    fadeOut: function(a) {
        return this._scheduleFading(a, 1, 0);
    },
    crossFadeFrom: function(a, b, c) {
        if (a.fadeOut(b), this.fadeIn(b), c) {
            c = this._clip.duration;
            var d = a._clip.duration, e = c / d;
            a.warp(1, d / c, b), this.warp(e, 1, b);
        }
        return this;
    },
    crossFadeTo: function(a, b, c) {
        return a.crossFadeFrom(this, b, c);
    },
    stopFading: function() {
        var a = this._weightInterpolant;
        return null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)), 
        this;
    },
    setEffectiveTimeScale: function(a) {
        return this.timeScale = a, this._effectiveTimeScale = this.paused ? 0 : a, this.stopWarping();
    },
    getEffectiveTimeScale: function() {
        return this._effectiveTimeScale;
    },
    setDuration: function(a) {
        return this.timeScale = this._clip.duration / a, this.stopWarping();
    },
    syncWith: function(a) {
        return this.time = a.time, this.timeScale = a.timeScale, this.stopWarping();
    },
    halt: function(a) {
        return this.warp(this._effectiveTimeScale, 0, a);
    },
    warp: function(a, b, c) {
        var d = this._mixer, e = d.time, f = this._timeScaleInterpolant, g = this.timeScale;
        return null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()), 
        d = f.parameterPositions, f = f.sampleValues, d[0] = e, d[1] = e + c, f[0] = a / g, 
        f[1] = b / g, this;
    },
    stopWarping: function() {
        var a = this._timeScaleInterpolant;
        return null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)), 
        this;
    },
    getMixer: function() {
        return this._mixer;
    },
    getClip: function() {
        return this._clip;
    },
    getRoot: function() {
        return this._localRoot || this._mixer._root;
    },
    _update: function(a, b, c, d) {
        var e = this._startTime;
        if (null !== e) {
            if (b = (a - e) * c, 0 > b || 0 === c) return;
            this._startTime = null, b *= c;
        }
        if (b *= this._updateTimeScale(a), c = this._updateTime(b), a = this._updateWeight(a), 
        0 < a) {
            b = this._interpolants;
            for (var e = this._propertyBindings, f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), 
            e[f].accumulate(d, a);
        }
    },
    _updateWeight: function(a) {
        var b = 0;
        if (this.enabled) {
            var b = this.weight, c = this._weightInterpolant;
            if (null !== c) {
                var d = c.evaluate(a)[0], b = b * d;
                a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1));
            }
        }
        return this._effectiveWeight = b;
    },
    _updateTimeScale: function(a) {
        var b = 0;
        if (!this.paused) {
            var b = this.timeScale, c = this._timeScaleInterpolant;
            if (null !== c) {
                var d = c.evaluate(a)[0], b = b * d;
                a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b);
            }
        }
        return this._effectiveTimeScale = b;
    },
    _updateTime: function(a) {
        var b = this.time + a;
        if (0 === a) return b;
        var c = this._clip.duration, d = this.loop, e = this._loopCount;
        if (d === THREE.LoopOnce) a: {
            if (-1 === e && (this.loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c; else {
                if (!(0 > b)) break a;
                b = 0;
            }
            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: 0 > a ? -1 : 1
            });
        } else {
            if (d = d === THREE.LoopPingPong, -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, !0, d)), 
            b >= c || 0 > b) {
                var f = Math.floor(b / c), b = b - c * f, e = e + Math.abs(f), g = this.repetitions - e;
                0 > g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, 
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 < a ? 1 : -1
                })) : (0 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(!1, !1, d), 
                this._loopCount = e, this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: f
                }));
            }
            if (d && 1 === (1 & e)) return this.time = b, c - b;
        }
        return this.time = b;
    },
    _setEndings: function(a, b, c) {
        var d = this._interpolantSettings;
        c ? (d.endingStart = THREE.ZeroSlopeEnding, d.endingEnd = THREE.ZeroSlopeEnding) : (d.endingStart = a ? this.zeroSlopeAtStart ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding : THREE.WrapAroundEnding, 
        d.endingEnd = b ? this.zeroSlopeAtEnd ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding : THREE.WrapAroundEnding);
    },
    _scheduleFading: function(a, b, c) {
        var d = this._mixer, e = d.time, f = this._weightInterpolant;
        return null === f && (this._weightInterpolant = f = d._lendControlInterpolant()), 
        d = f.parameterPositions, f = f.sampleValues, d[0] = e, f[0] = b, d[1] = e + a, 
        f[1] = c, this;
    }
}, THREE.AnimationClip = function(a, b, c) {
    this.name = a, this.tracks = c, this.duration = void 0 !== b ? b : -1, this.uuid = THREE.Math.generateUUID(), 
    0 > this.duration && this.resetDuration(), this.trim(), this.optimize();
}, THREE.AnimationClip.prototype = {
    constructor: THREE.AnimationClip,
    resetDuration: function() {
        for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) var d = this.tracks[b], a = Math.max(a, d.times[d.times.length - 1]);
        this.duration = a;
    },
    trim: function() {
        for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
        return this;
    },
    optimize: function() {
        for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
        return this;
    }
}, Object.assign(THREE.AnimationClip, {
    parse: function(a) {
        for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(THREE.KeyframeTrack.parse(c[e]).scale(d));
        return new THREE.AnimationClip(a.name, a.duration, b);
    },
    toJSON: function(a) {
        var b = [], c = a.tracks;
        a = {
            name: a.name,
            duration: a.duration,
            tracks: b
        };
        for (var d = 0, e = c.length; d !== e; ++d) b.push(THREE.KeyframeTrack.toJSON(c[d]));
        return a;
    },
    CreateFromMorphTargetSequence: function(a, b, c, d) {
        for (var e = b.length, f = [], g = 0; g < e; g++) {
            var h = [], i = [];
            h.push((g + e - 1) % e, g, (g + 1) % e), i.push(0, 1, 0);
            var j = THREE.AnimationUtils.getKeyframeOrder(h), h = THREE.AnimationUtils.sortedArray(h, 1, j), i = THREE.AnimationUtils.sortedArray(i, 1, j);
            d || 0 !== h[0] || (h.push(e), i.push(i[0])), f.push(new THREE.NumberKeyframeTrack(".morphTargetInfluences[" + b[g].name + "]", h, i).scale(1 / c));
        }
        return new THREE.AnimationClip(a, -1, f);
    },
    findByName: function(a, b) {
        var c = a;
        Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
        for (var d = 0; d < c.length; d++) if (c[d].name === b) return c[d];
        return null;
    },
    CreateClipsFromMorphTargetSequences: function(a, b, c) {
        for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
            var h = a[f], i = h.name.match(e);
            if (i && 1 < i.length) {
                var j = i[1];
                (i = d[j]) || (d[j] = i = []), i.push(h);
            }
        }
        a = [];
        for (j in d) a.push(THREE.AnimationClip.CreateFromMorphTargetSequence(j, d[j], b, c));
        return a;
    },
    parseAnimation: function(a, b, c) {
        if (!a) return console.error("  no animation in JSONLoader data"), null;
        c = function(a, b, c, d, e) {
            if (0 !== c.length) {
                var f = [], g = [];
                THREE.AnimationUtils.flattenJSON(c, f, g, d), 0 !== f.length && e.push(new a(b, f, g));
            }
        };
        var d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30;
        a = a.hierarchy || [];
        for (var h = 0; h < a.length; h++) {
            var i = a[h].keys;
            if (i && 0 !== i.length) if (i[0].morphTargets) {
                for (var f = {}, j = 0; j < i.length; j++) if (i[j].morphTargets) for (var k = 0; k < i[j].morphTargets.length; k++) f[i[j].morphTargets[k]] = -1;
                for (var l in f) {
                    for (var m = [], n = [], k = 0; k !== i[j].morphTargets.length; ++k) {
                        var o = i[j];
                        m.push(o.time), n.push(o.morphTarget === l ? 1 : 0);
                    }
                    d.push(new THREE.NumberKeyframeTrack(".morphTargetInfluence[" + l + "]", m, n));
                }
                f = f.length * (g || 1);
            } else j = ".bones[" + b[h].name + "]", c(THREE.VectorKeyframeTrack, j + ".position", i, "pos", d), 
            c(THREE.QuaternionKeyframeTrack, j + ".quaternion", i, "rot", d), c(THREE.VectorKeyframeTrack, j + ".scale", i, "scl", d);
        }
        return 0 === d.length ? null : new THREE.AnimationClip(e, f, d);
    }
}), THREE.AnimationMixer = function(a) {
    this._root = a, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1;
}, Object.assign(THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {
    clipAction: function(a, b) {
        var c = b || this._root, d = c.uuid, e = "string" == typeof a ? THREE.AnimationClip.findByName(c, a) : a, c = null !== e ? e.uuid : a, f = this._actionsByClip[c], g = null;
        if (void 0 !== f) {
            if (g = f.actionByRoot[d], void 0 !== g) return g;
            g = f.knownActions[0], null === e && (e = g._clip);
        }
        return null === e ? null : (e = new THREE.AnimationMixer._Action(this, e, b), this._bindAction(e, g), 
        this._addInactiveAction(e, c, d), e);
    },
    existingAction: function(a, b) {
        var c = b || this._root, d = c.uuid, c = "string" == typeof a ? THREE.AnimationClip.findByName(c, a) : a, c = this._actionsByClip[c ? c.uuid : a];
        return void 0 !== c ? c.actionByRoot[d] || null : null;
    },
    stopAllAction: function() {
        for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
        for (e = 0; e !== d; ++e) c[e].useCount = 0;
        return this;
    },
    update: function(a) {
        a *= this.timeScale;
        for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) {
            var h = b[g];
            h.enabled && h._update(d, a, e, f);
        }
        for (a = this._bindings, b = this._nActiveBindings, g = 0; g !== b; ++g) a[g].apply(f);
        return this;
    },
    getRoot: function() {
        return this._root;
    },
    uncacheClip: function(a) {
        var b = this._actions;
        a = a.uuid;
        var c = this._actionsByClip, d = c[a];
        if (void 0 !== d) {
            for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) {
                var g = d[e];
                this._deactivateAction(g);
                var h = g._cacheIndex, i = b[b.length - 1];
                g._cacheIndex = null, g._byClipCacheIndex = null, i._cacheIndex = h, b[h] = i, b.pop(), 
                this._removeInactiveBindingsForAction(g);
            }
            delete c[a];
        }
    },
    uncacheRoot: function(a) {
        a = a.uuid;
        var b, c = this._actionsByClip;
        for (b in c) {
            var d = c[b].actionByRoot[a];
            void 0 !== d && (this._deactivateAction(d), this._removeInactiveAction(d));
        }
        if (b = this._bindingsByRootAndName[a], void 0 !== b) for (var e in b) a = b[e], 
        a.restoreOriginalState(), this._removeInactiveBinding(a);
    },
    uncacheAction: function(a, b) {
        var c = this.existingAction(a, b);
        null !== c && (this._deactivateAction(c), this._removeInactiveAction(c));
    }
}), THREE.AnimationMixer._Action = THREE.AnimationAction._new, Object.assign(THREE.AnimationMixer.prototype, {
    _bindAction: function(a, b) {
        var c = a._localRoot || this._root, d = a._clip.tracks, e = d.length, f = a._propertyBindings, g = a._interpolants, h = c.uuid, i = this._bindingsByRootAndName, j = i[h];
        for (void 0 === j && (j = {}, i[h] = j), i = 0; i !== e; ++i) {
            var k = d[i], l = k.name, m = j[l];
            if (void 0 === m) {
                if (m = f[i], void 0 !== m) {
                    null === m._cacheIndex && (++m.referenceCount, this._addInactiveBinding(m, h, l));
                    continue;
                }
                m = new THREE.PropertyMixer(THREE.PropertyBinding.create(c, l, b && b._propertyBindings[i].binding.parsedPath), k.ValueTypeName, k.getValueSize()), 
                ++m.referenceCount, this._addInactiveBinding(m, h, l);
            }
            f[i] = m, g[i].resultBuffer = m.buffer;
        }
    },
    _activateAction: function(a) {
        if (!this._isActiveAction(a)) {
            if (null === a._cacheIndex) {
                var b = (a._localRoot || this._root).uuid, c = a._clip.uuid, d = this._actionsByClip[c];
                this._bindAction(a, d && d.knownActions[0]), this._addInactiveAction(a, c, b);
            }
            for (b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                var e = b[c];
                0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState());
            }
            this._lendAction(a);
        }
    },
    _deactivateAction: function(a) {
        if (this._isActiveAction(a)) {
            for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                var e = b[c];
                0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e));
            }
            this._takeBackAction(a);
        }
    },
    _initMemoryManager: function() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], 
        this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], 
        this._nActiveControlInterpolants = 0;
        var a = this;
        this.stats = {
            actions: {
                get total() {
                    return a._actions.length;
                },
                get inUse() {
                    return a._nActiveActions;
                }
            },
            bindings: {
                get total() {
                    return a._bindings.length;
                },
                get inUse() {
                    return a._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total() {
                    return a._controlInterpolants.length;
                },
                get inUse() {
                    return a._nActiveControlInterpolants;
                }
            }
        };
    },
    _isActiveAction: function(a) {
        return a = a._cacheIndex, null !== a && a < this._nActiveActions;
    },
    _addInactiveAction: function(a, b, c) {
        var d = this._actions, e = this._actionsByClip, f = e[b];
        void 0 === f ? (f = {
            knownActions: [ a ],
            actionByRoot: {}
        }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, 
        b.push(a)), a._cacheIndex = d.length, d.push(a), f.actionByRoot[c] = a;
    },
    _removeInactiveAction: function(a) {
        var b = this._actions, c = b[b.length - 1], d = a._cacheIndex;
        c._cacheIndex = d, b[d] = c, b.pop(), a._cacheIndex = null;
        var c = a._clip.uuid, d = this._actionsByClip, e = d[c], f = e.knownActions, g = f[f.length - 1], h = a._byClipCacheIndex;
        g._byClipCacheIndex = h, f[h] = g, f.pop(), a._byClipCacheIndex = null, delete e.actionByRoot[(b._localRoot || this._root).uuid], 
        0 === f.length && delete d[c], this._removeInactiveBindingsForAction(a);
    },
    _removeInactiveBindingsForAction: function(a) {
        a = a._propertyBindings;
        for (var b = 0, c = a.length; b !== c; ++b) {
            var d = a[b];
            0 === --d.referenceCount && this._removeInactiveBinding(d);
        }
    },
    _lendAction: function(a) {
        var b = this._actions, c = a._cacheIndex, d = this._nActiveActions++, e = b[d];
        a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e;
    },
    _takeBackAction: function(a) {
        var b = this._actions, c = a._cacheIndex, d = --this._nActiveActions, e = b[d];
        a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e;
    },
    _addInactiveBinding: function(a, b, c) {
        var d = this._bindingsByRootAndName, e = d[b], f = this._bindings;
        void 0 === e && (e = {}, d[b] = e), e[c] = a, a._cacheIndex = f.length, f.push(a);
    },
    _removeInactiveBinding: function(a) {
        var b = this._bindings, c = a.binding, d = c.rootNode.uuid, c = c.path, e = this._bindingsByRootAndName, f = e[d], g = b[b.length - 1];
        a = a._cacheIndex, g._cacheIndex = a, b[a] = g, b.pop(), delete f[c];
        a: {
            for (var h in f) break a;
            delete e[d];
        }
    },
    _lendBinding: function(a) {
        var b = this._bindings, c = a._cacheIndex, d = this._nActiveBindings++, e = b[d];
        a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e;
    },
    _takeBackBinding: function(a) {
        var b = this._bindings, c = a._cacheIndex, d = --this._nActiveBindings, e = b[d];
        a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e;
    },
    _lendControlInterpolant: function() {
        var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b];
        return void 0 === c && (c = new THREE.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), 
        c.__cacheIndex = b, a[b] = c), c;
    },
    _takeBackControlInterpolant: function(a) {
        var b = this._controlInterpolants, c = a.__cacheIndex, d = --this._nActiveControlInterpolants, e = b[d];
        a.__cacheIndex = d, b[d] = a, e.__cacheIndex = c, b[c] = e;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1)
}), THREE.AnimationObjectGroup = function(a) {
    this.uuid = THREE.Math.generateUUID(), this._objects = Array.prototype.slice.call(arguments), 
    this.nCachedObjects_ = 0;
    var b = {};
    this._indicesByUUID = b;
    for (var c = 0, d = arguments.length; c !== d; ++c) b[arguments[c].uuid] = c;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    var e = this;
    this.stats = {
        objects: {
            get total() {
                return e._objects.length;
            },
            get inUse() {
                return this.total - e.nCachedObjects_;
            }
        },
        get bindingsPerObject() {
            return e._bindings.length;
        }
    };
}, THREE.AnimationObjectGroup.prototype = {
    constructor: THREE.AnimationObjectGroup,
    add: function(a) {
        for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._paths, g = this._parsedPaths, h = this._bindings, i = h.length, j = 0, k = arguments.length; j !== k; ++j) {
            var l = arguments[j], m = l.uuid, n = e[m];
            if (void 0 === n) {
                n = c++, e[m] = n, b.push(l);
                for (var m = 0, o = i; m !== o; ++m) h[m].push(new THREE.PropertyBinding(l, f[m], g[m]));
            } else if (n < d) {
                var p = b[n], q = --d, o = b[q];
                for (e[o.uuid] = n, b[n] = o, e[m] = q, b[q] = l, m = 0, o = i; m !== o; ++m) {
                    var r = h[m], s = r[n];
                    r[n] = r[q], void 0 === s && (s = new THREE.PropertyBinding(l, f[m], g[m])), r[q] = s;
                }
            } else b[n] !== p && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...");
        }
        this.nCachedObjects_ = d;
    },
    remove: function(a) {
        for (var b = this._objects, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
            var i = arguments[g], j = i.uuid, k = d[j];
            if (void 0 !== k && k >= c) {
                var l = c++, m = b[l];
                for (d[m.uuid] = k, b[k] = m, d[j] = l, b[l] = i, i = 0, j = f; i !== j; ++i) {
                    var m = e[i], n = m[k];
                    m[k] = m[l], m[l] = n;
                }
            }
        }
        this.nCachedObjects_ = c;
    },
    uncache: function(a) {
        for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._bindings, g = f.length, h = 0, i = arguments.length; h !== i; ++h) {
            var j = arguments[h].uuid, k = e[j];
            if (void 0 !== k) if (delete e[j], k < d) {
                var j = --d, l = b[j], m = --c, n = b[m];
                for (e[l.uuid] = k, b[k] = l, e[n.uuid] = j, b[j] = n, b.pop(), l = 0, n = g; l !== n; ++l) {
                    var o = f[l], p = o[m];
                    o[k] = o[j], o[j] = p, o.pop();
                }
            } else for (m = --c, n = b[m], e[n.uuid] = k, b[k] = n, b.pop(), l = 0, n = g; l !== n; ++l) o = f[l], 
            o[k] = o[m], o.pop();
        }
        this.nCachedObjects_ = d;
    },
    subscribe_: function(a, b) {
        var c = this._bindingsIndicesByPath, d = c[a], e = this._bindings;
        if (void 0 !== d) return e[d];
        var f = this._paths, g = this._parsedPaths, h = this._objects, i = this.nCachedObjects_, j = Array(h.length), d = e.length;
        for (c[a] = d, f.push(a), g.push(b), e.push(j), c = i, d = h.length; c !== d; ++c) j[c] = new THREE.PropertyBinding(h[c], a, b);
        return j;
    },
    unsubscribe_: function(a) {
        var b = this._bindingsIndicesByPath, c = b[a];
        if (void 0 !== c) {
            var d = this._paths, e = this._parsedPaths, f = this._bindings, g = f.length - 1, h = f[g];
            b[a[g]] = c, f[c] = h, f.pop(), e[c] = e[g], e.pop(), d[c] = d[g], d.pop();
        }
    }
}, THREE.AnimationUtils = {
    arraySlice: function(a, b, c) {
        return THREE.AnimationUtils.isTypedArray(a) ? new a.constructor(a.subarray(b, c)) : a.slice(b, c);
    },
    convertArray: function(a, b, c) {
        return !a || !c && a.constructor === b ? a : "number" == typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a);
    },
    isTypedArray: function(a) {
        return ArrayBuffer.isView(a) && !(a instanceof DataView);
    },
    getKeyframeOrder: function(a) {
        for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
        return c.sort(function(b, c) {
            return a[b] - a[c];
        }), c;
    },
    sortedArray: function(a, b, c) {
        for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f) for (var h = c[f] * b, i = 0; i !== b; ++i) e[g++] = a[h + i];
        return e;
    },
    flattenJSON: function(a, b, c, d) {
        for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d]; ) f = a[e++];
        if (void 0 !== f) {
            var g = f[d];
            if (void 0 !== g) if (Array.isArray(g)) {
                do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f);
            } else if (void 0 !== g.toArray) {
                do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f);
            } else do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f);
        }
    }
}, THREE.KeyframeTrack = function(a, b, c, d) {
    if (void 0 === a) throw Error("track name is undefined");
    if (void 0 === b || 0 === b.length) throw Error("no keyframes in track named " + a);
    this.name = a, this.times = THREE.AnimationUtils.convertArray(b, this.TimeBufferType), 
    this.values = THREE.AnimationUtils.convertArray(c, this.ValueBufferType), this.setInterpolation(d || this.DefaultInterpolation), 
    this.validate(), this.optimize();
}, THREE.KeyframeTrack.prototype = {
    constructor: THREE.KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: THREE.InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(a) {
        return new THREE.DiscreteInterpolant(this.times, this.values, this.getValueSize(), a);
    },
    InterpolantFactoryMethodLinear: function(a) {
        return new THREE.LinearInterpolant(this.times, this.values, this.getValueSize(), a);
    },
    InterpolantFactoryMethodSmooth: function(a) {
        return new THREE.CubicInterpolant(this.times, this.values, this.getValueSize(), a);
    },
    setInterpolation: function(a) {
        var b;
        switch (a) {
          case THREE.InterpolateDiscrete:
            b = this.InterpolantFactoryMethodDiscrete;
            break;

          case THREE.InterpolateLinear:
            b = this.InterpolantFactoryMethodLinear;
            break;

          case THREE.InterpolateSmooth:
            b = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === b) {
            if (b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, 
            void 0 === this.createInterpolant) {
                if (a === this.DefaultInterpolation) throw Error(b);
                this.setInterpolation(this.DefaultInterpolation);
            }
            console.warn(b);
        } else this.createInterpolant = b;
    },
    getInterpolation: function() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return THREE.InterpolateDiscrete;

          case this.InterpolantFactoryMethodLinear:
            return THREE.InterpolateLinear;

          case this.InterpolantFactoryMethodSmooth:
            return THREE.InterpolateSmooth;
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length;
    },
    shift: function(a) {
        if (0 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
        return this;
    },
    scale: function(a) {
        if (1 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
        return this;
    },
    trim: function(a, b) {
        for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a; ) ++e;
        for (;-1 !== f && c[f] > b; ) --f;
        return ++f, 0 === e && f === d || (e >= f && (f = Math.max(f, 1), e = f - 1), d = this.getValueSize(), 
        this.times = THREE.AnimationUtils.arraySlice(c, e, f), this.values = THREE.AnimationUtils.arraySlice(this.values, e * d, f * d)), 
        this;
    },
    validate: function() {
        var a = !0, b = this.getValueSize();
        0 !== b - Math.floor(b) && (console.error("invalid value size in track", this), 
        a = !1);
        var c = this.times, b = this.values, d = c.length;
        0 === d && (console.error("track is empty", this), a = !1);
        for (var e = null, f = 0; f !== d; f++) {
            var g = c[f];
            if ("number" == typeof g && isNaN(g)) {
                console.error("time is not a valid number", this, f, g), a = !1;
                break;
            }
            if (null !== e && e > g) {
                console.error("out of order keys", this, f, g, e), a = !1;
                break;
            }
            e = g;
        }
        if (void 0 !== b && THREE.AnimationUtils.isTypedArray(b)) for (f = 0, c = b.length; f !== c; ++f) if (d = b[f], 
        isNaN(d)) {
            console.error("value is not a valid number", this, f, d), a = !1;
            break;
        }
        return a;
    },
    optimize: function() {
        for (var a = this.times, b = this.values, c = this.getValueSize(), d = 1, e = 1, f = a.length - 1; e <= f; ++e) {
            var g = !1, h = a[e];
            if (h !== a[e + 1] && (1 !== e || h !== h[0])) for (var i = e * c, j = i - c, k = i + c, h = 0; h !== c; ++h) {
                var l = b[i + h];
                if (l !== b[j + h] || l !== b[k + h]) {
                    g = !0;
                    break;
                }
            }
            if (g) {
                if (e !== d) for (a[d] = a[e], g = e * c, i = d * c, h = 0; h !== c; ++h) b[i + h] = b[g + h];
                ++d;
            }
        }
        return d !== a.length && (this.times = THREE.AnimationUtils.arraySlice(a, 0, d), 
        this.values = THREE.AnimationUtils.arraySlice(b, 0, d * c)), this;
    }
}, Object.assign(THREE.KeyframeTrack, {
    parse: function(a) {
        if (void 0 === a.type) throw Error("track type undefined, can not parse");
        var b = THREE.KeyframeTrack._getTrackTypeForValueTypeName(a.type);
        if (void 0 === a.times) {
            var c = [], d = [];
            THREE.AnimationUtils.flattenJSON(a.keys, c, d, "value"), a.times = c, a.values = d;
        }
        return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation);
    },
    toJSON: function(a) {
        var b = a.constructor;
        if (void 0 !== b.toJSON) b = b.toJSON(a); else {
            var b = {
                name: a.name,
                times: THREE.AnimationUtils.convertArray(a.times, Array),
                values: THREE.AnimationUtils.convertArray(a.values, Array)
            }, c = a.getInterpolation();
            c !== a.DefaultInterpolation && (b.interpolation = c);
        }
        return b.type = a.ValueTypeName, b;
    },
    _getTrackTypeForValueTypeName: function(a) {
        switch (a.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return THREE.NumberKeyframeTrack;

          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return THREE.VectorKeyframeTrack;

          case "color":
            return THREE.ColorKeyframeTrack;

          case "quaternion":
            return THREE.QuaternionKeyframeTrack;

          case "bool":
          case "boolean":
            return THREE.BooleanKeyframeTrack;

          case "string":
            return THREE.StringKeyframeTrack;
        }
        throw Error("Unsupported typeName: " + a);
    }
}), THREE.PropertyBinding = function(a, b, c) {
    this.path = b, this.parsedPath = c || THREE.PropertyBinding.parseTrackName(b), this.node = THREE.PropertyBinding.findNode(a, this.parsedPath.nodeName) || a, 
    this.rootNode = a;
}, THREE.PropertyBinding.prototype = {
    constructor: THREE.PropertyBinding,
    getValue: function(a, b) {
        this.bind(), this.getValue(a, b);
    },
    setValue: function(a, b) {
        this.bind(), this.setValue(a, b);
    },
    bind: function() {
        var a = this.node, b = this.parsedPath, c = b.objectName, d = b.propertyName, e = b.propertyIndex;
        if (a || (this.node = a = THREE.PropertyBinding.findNode(this.rootNode, b.nodeName) || this.rootNode), 
        this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, 
        a) {
            if (c) {
                var f = b.objectIndex;
                switch (c) {
                  case "materials":
                    if (!a.material) return void console.error("  can not bind to material as node does not have a material", this);
                    if (!a.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                    a = a.material.materials;
                    break;

                  case "bones":
                    if (!a.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                    for (a = a.skeleton.bones, c = 0; c < a.length; c++) if (a[c].name === f) {
                        f = c;
                        break;
                    }
                    break;

                  default:
                    if (void 0 === a[c]) return void console.error("  can not bind to objectName of node, undefined", this);
                    a = a[c];
                }
                if (void 0 !== f) {
                    if (void 0 === a[f]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
                    a = a[f];
                }
            }
            if (f = a[d]) {
                if (b = this.Versioning.None, void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, 
                this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, 
                this.targetObject = a), c = this.BindingType.Direct, void 0 !== e) {
                    if ("morphTargetInfluences" === d) {
                        if (!a.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                        if (!a.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                        for (c = 0; c < this.node.geometry.morphTargets.length; c++) if (a.geometry.morphTargets[c].name === e) {
                            e = c;
                            break;
                        }
                    }
                    c = this.BindingType.ArrayElement, this.resolvedProperty = f, this.propertyIndex = e;
                } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, 
                this.resolvedProperty = f) : void 0 !== f.length ? (c = this.BindingType.EntireArray, 
                this.resolvedProperty = f) : this.propertyName = d;
                this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
            } else console.error("  trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a);
        } else console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
    },
    unbind: function() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
}, Object.assign(THREE.PropertyBinding.prototype, {
    _getValue_unavailable: function() {},
    _setValue_unavailable: function() {},
    _getValue_unbound: THREE.PropertyBinding.prototype.getValue,
    _setValue_unbound: THREE.PropertyBinding.prototype.setValue,
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [ function(a, b) {
        a[b] = this.node[this.propertyName];
    }, function(a, b) {
        for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d];
    }, function(a, b) {
        a[b] = this.resolvedProperty[this.propertyIndex];
    }, function(a, b) {
        this.resolvedProperty.toArray(a, b);
    } ],
    SetterByBindingTypeAndVersioning: [ [ function(a, b) {
        this.node[this.propertyName] = a[b];
    }, function(a, b) {
        this.node[this.propertyName] = a[b], this.targetObject.needsUpdate = !0;
    }, function(a, b) {
        this.node[this.propertyName] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0;
    } ], [ function(a, b) {
        for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
    }, function(a, b) {
        for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
        this.targetObject.needsUpdate = !0;
    }, function(a, b) {
        for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
    } ], [ function(a, b) {
        this.resolvedProperty[this.propertyIndex] = a[b];
    }, function(a, b) {
        this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.needsUpdate = !0;
    }, function(a, b) {
        this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0;
    } ], [ function(a, b) {
        this.resolvedProperty.fromArray(a, b);
    }, function(a, b) {
        this.resolvedProperty.fromArray(a, b), this.targetObject.needsUpdate = !0;
    }, function(a, b) {
        this.resolvedProperty.fromArray(a, b), this.targetObject.matrixWorldNeedsUpdate = !0;
    } ] ]
}), THREE.PropertyBinding.Composite = function(a, b, c) {
    c = c || THREE.PropertyBinding.parseTrackName(b), this._targetGroup = a, this._bindings = a.subscribe_(b, c);
}, THREE.PropertyBinding.Composite.prototype = {
    constructor: THREE.PropertyBinding.Composite,
    getValue: function(a, b) {
        this.bind();
        var c = this._bindings[this._targetGroup.nCachedObjects_];
        void 0 !== c && c.getValue(a, b);
    },
    setValue: function(a, b) {
        for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b);
    },
    bind: function() {
        for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind();
    },
    unbind: function() {
        for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind();
    }
}, THREE.PropertyBinding.create = function(a, b, c) {
    return a instanceof THREE.AnimationObjectGroup ? new THREE.PropertyBinding.Composite(a, b, c) : new THREE.PropertyBinding(a, b, c);
}, THREE.PropertyBinding.parseTrackName = function(a) {
    var b = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/, c = b.exec(a);
    if (!c) throw Error("cannot parse trackName at all: " + a);
    if (c.index === b.lastIndex && b.lastIndex++, b = {
        nodeName: c[3],
        objectName: c[5],
        objectIndex: c[7],
        propertyName: c[9],
        propertyIndex: c[11]
    }, null === b.propertyName || 0 === b.propertyName.length) throw Error("can not parse propertyName from trackName: " + a);
    return b;
}, THREE.PropertyBinding.findNode = function(a, b) {
    if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
    if (a.skeleton) {
        var c = function(a) {
            for (var c = 0; c < a.bones.length; c++) {
                var d = a.bones[c];
                if (d.name === b) return d;
            }
            return null;
        }(a.skeleton);
        if (c) return c;
    }
    if (a.children) {
        var d = function(a) {
            for (var c = 0; c < a.length; c++) {
                var e = a[c];
                if (e.name === b || e.uuid === b || (e = d(e.children))) return e;
            }
            return null;
        };
        if (c = d(a.children)) return c;
    }
    return null;
}, THREE.PropertyMixer = function(a, b, c) {
    switch (this.binding = a, this.valueSize = c, a = Float64Array, b) {
      case "quaternion":
        b = this._slerp;
        break;

      case "string":
      case "bool":
        a = Array, b = this._select;
        break;

      default:
        b = this._lerp;
    }
    this.buffer = new a(4 * c), this._mixBufferRegion = b, this.referenceCount = this.useCount = this.cumulativeWeight = 0;
}, THREE.PropertyMixer.prototype = {
    constructor: THREE.PropertyMixer,
    accumulate: function(a, b) {
        var c = this.buffer, d = this.valueSize, e = a * d + d, f = this.cumulativeWeight;
        if (0 === f) {
            for (f = 0; f !== d; ++f) c[e + f] = c[f];
            f = b;
        } else f += b, this._mixBufferRegion(c, e, 0, b / f, d);
        this.cumulativeWeight = f;
    },
    apply: function(a) {
        var b = this.valueSize, c = this.buffer;
        a = a * b + b;
        var d = this.cumulativeWeight, e = this.binding;
        this.cumulativeWeight = 0, 1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
        for (var d = b, f = b + b; d !== f; ++d) if (c[d] !== c[d + b]) {
            e.setValue(c, a);
            break;
        }
    },
    saveOriginalState: function() {
        var a = this.buffer, b = this.valueSize, c = 3 * b;
        this.binding.getValue(a, c);
        for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
        this.cumulativeWeight = 0;
    },
    restoreOriginalState: function() {
        this.binding.setValue(this.buffer, 3 * this.valueSize);
    },
    _select: function(a, b, c, d, e) {
        if (.5 <= d) for (d = 0; d !== e; ++d) a[b + d] = a[c + d];
    },
    _slerp: function(a, b, c, d, e) {
        THREE.Quaternion.slerpFlat(a, b, a, b, a, c, d);
    },
    _lerp: function(a, b, c, d, e) {
        for (var f = 1 - d, g = 0; g !== e; ++g) {
            var h = b + g;
            a[h] = a[h] * f + a[c + g] * d;
        }
    }
}, THREE.BooleanKeyframeTrack = function(a, b, c) {
    THREE.KeyframeTrack.call(this, a, b, c);
}, THREE.BooleanKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.BooleanKeyframeTrack,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: THREE.InterpolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
}), THREE.ColorKeyframeTrack = function(a, b, c, d) {
    THREE.KeyframeTrack.call(this, a, b, c, d);
}, THREE.ColorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.ColorKeyframeTrack,
    ValueTypeName: "color"
}), THREE.NumberKeyframeTrack = function(a, b, c, d) {
    THREE.KeyframeTrack.call(this, a, b, c, d);
}, THREE.NumberKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.NumberKeyframeTrack,
    ValueTypeName: "number"
}), THREE.QuaternionKeyframeTrack = function(a, b, c, d) {
    THREE.KeyframeTrack.call(this, a, b, c, d);
}, THREE.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.QuaternionKeyframeTrack,
    ValueTypeName: "quaternion",
    DefaultInterpolation: THREE.InterpolateLinear,
    InterpolantFactoryMethodLinear: function(a) {
        return new THREE.QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), a);
    },
    InterpolantFactoryMethodSmooth: void 0
}), THREE.StringKeyframeTrack = function(a, b, c, d) {
    THREE.KeyframeTrack.call(this, a, b, c, d);
}, THREE.StringKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.StringKeyframeTrack,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: THREE.InterpolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
}), THREE.VectorKeyframeTrack = function(a, b, c, d) {
    THREE.KeyframeTrack.call(this, a, b, c, d);
}, THREE.VectorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.VectorKeyframeTrack,
    ValueTypeName: "vector"
}), THREE.Audio = function(a) {
    THREE.Object3D.call(this), this.type = "Audio", this.context = a.context, this.source = this.context.createBufferSource(), 
    this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), 
    this.gain.connect(a.getInput()), this.autoplay = !1, this.startTime = 0, this.playbackRate = 1, 
    this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
}, THREE.Audio.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.Audio,
    getOutput: function() {
        return this.gain;
    },
    setNodeSource: function(a) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = a, 
        this.connect(), this;
    },
    setBuffer: function(a) {
        return this.source.buffer = a, this.sourceType = "buffer", this.autoplay && this.play(), 
        this;
    },
    play: function() {
        if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else {
            if (!1 !== this.hasPlaybackControl) {
                var a = this.context.createBufferSource();
                return a.buffer = this.source.buffer, a.loop = this.source.loop, a.onended = this.source.onended, 
                a.start(0, this.startTime), a.playbackRate.value = this.playbackRate, this.isPlaying = !0, 
                this.source = a, this.connect();
            }
            console.warn("THREE.Audio: this Audio has no playback control.");
        }
    },
    pause: function() {
        return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = this.context.currentTime, 
        this) : void console.warn("THREE.Audio: this Audio has no playback control.");
    },
    stop: function() {
        return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = 0, 
        this) : void console.warn("THREE.Audio: this Audio has no playback control.");
    },
    connect: function() {
        if (0 < this.filters.length) {
            this.source.connect(this.filters[0]);
            for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
    },
    disconnect: function() {
        if (0 < this.filters.length) {
            this.source.disconnect(this.filters[0]);
            for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
    },
    getFilters: function() {
        return this.filters;
    },
    setFilters: function(a) {
        return a || (a = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = a, 
        this.connect()) : this.filters = a, this;
    },
    getFilter: function() {
        return this.getFilters()[0];
    },
    setFilter: function(a) {
        return this.setFilters(a ? [ a ] : []);
    },
    setPlaybackRate: function(a) {
        return !1 !== this.hasPlaybackControl ? (this.playbackRate = a, !0 === this.isPlaying && (this.source.playbackRate.value = this.playbackRate), 
        this) : void console.warn("THREE.Audio: this Audio has no playback control.");
    },
    getPlaybackRate: function() {
        return this.playbackRate;
    },
    onEnded: function() {
        this.isPlaying = !1;
    },
    getLoop: function() {
        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), 
        !1) : this.source.loop;
    },
    setLoop: function(a) {
        !1 === this.hasPlaybackControl ? console.warn("THREE.Audio: this Audio has no playback control.") : this.source.loop = a;
    },
    getVolume: function() {
        return this.gain.gain.value;
    },
    setVolume: function(a) {
        return this.gain.gain.value = a, this;
    }
}), THREE.AudioAnalyser = function(a, b) {
    this.analyser = a.context.createAnalyser(), this.analyser.fftSize = void 0 !== b ? b : 2048, 
    this.data = new Uint8Array(this.analyser.frequencyBinCount), a.getOutput().connect(this.analyser);
}, Object.assign(THREE.AudioAnalyser.prototype, {
    getFrequencyData: function() {
        return this.analyser.getByteFrequencyData(this.data), this.data;
    },
    getAverageFrequency: function() {
        for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
        return a / b.length;
    }
}), Object.defineProperty(THREE, "AudioContext", {
    get: function() {
        var a;
        return function() {
            return void 0 === a && (a = new (window.AudioContext || window.webkitAudioContext)()), 
            a;
        };
    }()
}), THREE.PositionalAudio = function(a) {
    THREE.Audio.call(this, a), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
}, THREE.PositionalAudio.prototype = Object.assign(Object.create(THREE.Audio.prototype), {
    constructor: THREE.PositionalAudio,
    getOutput: function() {
        return this.panner;
    },
    getRefDistance: function() {
        return this.panner.refDistance;
    },
    setRefDistance: function(a) {
        this.panner.refDistance = a;
    },
    getRolloffFactor: function() {
        return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(a) {
        this.panner.rolloffFactor = a;
    },
    getDistanceModel: function() {
        return this.panner.distanceModel;
    },
    setDistanceModel: function(a) {
        this.panner.distanceModel = a;
    },
    getMaxDistance: function() {
        return this.panner.maxDistance;
    },
    setMaxDistance: function(a) {
        this.panner.maxDistance = a;
    },
    updateMatrixWorld: function() {
        var a = new THREE.Vector3();
        return function(b) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, b), a.setFromMatrixPosition(this.matrixWorld), 
            this.panner.setPosition(a.x, a.y, a.z);
        };
    }()
}), THREE.AudioListener = function() {
    THREE.Object3D.call(this), this.type = "AudioListener", this.context = THREE.AudioContext, 
    this.gain = this.context.createGain(), this.gain.connect(this.context.destination), 
    this.filter = null;
}, THREE.AudioListener.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.AudioListener,
    getInput: function() {
        return this.gain;
    },
    removeFilter: function() {
        null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), 
        this.gain.connect(this.context.destination), this.filter = null);
    },
    getFilter: function() {
        return this.filter;
    },
    setFilter: function(a) {
        null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), 
        this.filter = a, this.gain.connect(this.filter), this.filter.connect(this.context.destination);
    },
    getMasterVolume: function() {
        return this.gain.gain.value;
    },
    setMasterVolume: function(a) {
        this.gain.gain.value = a;
    },
    updateMatrixWorld: function() {
        var a = new THREE.Vector3(), b = new THREE.Quaternion(), c = new THREE.Vector3(), d = new THREE.Vector3();
        return function(e) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, e), e = this.context.listener;
            var f = this.up;
            this.matrixWorld.decompose(a, b, c), d.set(0, 0, -1).applyQuaternion(b), e.setPosition(a.x, a.y, a.z), 
            e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z);
        };
    }()
}), THREE.Camera = function() {
    THREE.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new THREE.Matrix4(), 
    this.projectionMatrix = new THREE.Matrix4();
}, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.constructor = THREE.Camera, 
THREE.Camera.prototype.getWorldDirection = function() {
    var a = new THREE.Quaternion();
    return function(b) {
        return b = b || new THREE.Vector3(), this.getWorldQuaternion(a), b.set(0, 0, -1).applyQuaternion(a);
    };
}(), THREE.Camera.prototype.lookAt = function() {
    var a = new THREE.Matrix4();
    return function(b) {
        a.lookAt(this.position, b, this.up), this.quaternion.setFromRotationMatrix(a);
    };
}(), THREE.Camera.prototype.clone = function() {
    return new this.constructor().copy(this);
}, THREE.Camera.prototype.copy = function(a) {
    return THREE.Object3D.prototype.copy.call(this, a), this.matrixWorldInverse.copy(a.matrixWorldInverse), 
    this.projectionMatrix.copy(a.projectionMatrix), this;
}, THREE.CubeCamera = function(a, b, c) {
    THREE.Object3D.call(this), this.type = "CubeCamera";
    var d = new THREE.PerspectiveCamera(90, 1, a, b);
    d.up.set(0, -1, 0), d.lookAt(new THREE.Vector3(1, 0, 0)), this.add(d);
    var e = new THREE.PerspectiveCamera(90, 1, a, b);
    e.up.set(0, -1, 0), e.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(e);
    var f = new THREE.PerspectiveCamera(90, 1, a, b);
    f.up.set(0, 0, 1), f.lookAt(new THREE.Vector3(0, 1, 0)), this.add(f);
    var g = new THREE.PerspectiveCamera(90, 1, a, b);
    g.up.set(0, 0, -1), g.lookAt(new THREE.Vector3(0, -1, 0)), this.add(g);
    var h = new THREE.PerspectiveCamera(90, 1, a, b);
    h.up.set(0, -1, 0), h.lookAt(new THREE.Vector3(0, 0, 1)), this.add(h);
    var i = new THREE.PerspectiveCamera(90, 1, a, b);
    i.up.set(0, -1, 0), i.lookAt(new THREE.Vector3(0, 0, -1)), this.add(i), this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    }), this.updateCubeMap = function(a, b) {
        null === this.parent && this.updateMatrixWorld();
        var c = this.renderTarget, j = c.texture.generateMipmaps;
        c.texture.generateMipmaps = !1, c.activeCubeFace = 0, a.render(b, d, c), c.activeCubeFace = 1, 
        a.render(b, e, c), c.activeCubeFace = 2, a.render(b, f, c), c.activeCubeFace = 3, 
        a.render(b, g, c), c.activeCubeFace = 4, a.render(b, h, c), c.texture.generateMipmaps = j, 
        c.activeCubeFace = 5, a.render(b, i, c), a.setRenderTarget(null);
    };
}, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CubeCamera.prototype.constructor = THREE.CubeCamera, 
THREE.OrthographicCamera = function(a, b, c, d, e, f) {
    THREE.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = a, 
    this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, 
    this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix();
}, THREE.OrthographicCamera.prototype = Object.assign(Object.create(THREE.Camera.prototype), {
    constructor: THREE.OrthographicCamera,
    copy: function(a) {
        return THREE.Camera.prototype.copy.call(this, a), this.left = a.left, this.right = a.right, 
        this.top = a.top, this.bottom = a.bottom, this.near = a.near, this.far = a.far, 
        this.zoom = a.zoom, this;
    },
    updateProjectionMatrix: function() {
        var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2;
        this.projectionMatrix.makeOrthographic(c - a, c + a, d + b, d - b, this.near, this.far);
    },
    toJSON: function(a) {
        return a = THREE.Object3D.prototype.toJSON.call(this, a), a.object.zoom = this.zoom, 
        a.object.left = this.left, a.object.right = this.right, a.object.top = this.top, 
        a.object.bottom = this.bottom, a.object.near = this.near, a.object.far = this.far, 
        a;
    }
}), THREE.PerspectiveCamera = function(a, b, c, d) {
    THREE.Camera.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== a ? a : 50, 
    this.zoom = 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, 
    this.focus = 10, this.aspect = void 0 !== b ? b : 1, this.view = null, this.filmGauge = 35, 
    this.filmOffset = 0, this.updateProjectionMatrix();
}, THREE.PerspectiveCamera.prototype = Object.assign(Object.create(THREE.Camera.prototype), {
    constructor: THREE.PerspectiveCamera,
    copy: function(a) {
        return THREE.Camera.prototype.copy.call(this, a), this.fov = a.fov, this.zoom = a.zoom, 
        this.near = a.near, this.far = a.far, this.focus = a.focus, this.aspect = a.aspect, 
        this.view = null === a.view ? null : Object.assign({}, a.view), this.filmGauge = a.filmGauge, 
        this.filmOffset = a.filmOffset, this;
    },
    setFocalLength: function(a) {
        a = .5 * this.getFilmHeight() / a, this.fov = 2 * THREE.Math.RAD2DEG * Math.atan(a), 
        this.updateProjectionMatrix();
    },
    getFocalLength: function() {
        var a = Math.tan(.5 * THREE.Math.DEG2RAD * this.fov);
        return .5 * this.getFilmHeight() / a;
    },
    getEffectiveFOV: function() {
        return 2 * THREE.Math.RAD2DEG * Math.atan(Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
        return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
        return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(a, b, c, d, e, f) {
        this.aspect = a / b, this.view = {
            fullWidth: a,
            fullHeight: b,
            offsetX: c,
            offsetY: d,
            width: e,
            height: f
        }, this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        this.view = null, this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        var a = this.near, b = a * Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom, c = 2 * b, d = this.aspect * c, e = -.5 * d, f = this.view;
        if (null !== f) var g = f.fullWidth, h = f.fullHeight, e = e + f.offsetX * d / g, b = b - f.offsetY * c / h, d = f.width / g * d, c = f.height / h * c;
        f = this.filmOffset, 0 !== f && (e += a * f / this.getFilmWidth()), this.projectionMatrix.makeFrustum(e, e + d, b - c, b, a, this.far);
    },
    toJSON: function(a) {
        return a = THREE.Object3D.prototype.toJSON.call(this, a), a.object.fov = this.fov, 
        a.object.zoom = this.zoom, a.object.near = this.near, a.object.far = this.far, a.object.focus = this.focus, 
        a.object.aspect = this.aspect, null !== this.view && (a.object.view = Object.assign({}, this.view)), 
        a.object.filmGauge = this.filmGauge, a.object.filmOffset = this.filmOffset, a;
    }
}), THREE.StereoCamera = function() {
    this.type = "StereoCamera", this.aspect = 1, this.cameraL = new THREE.PerspectiveCamera(), 
    this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new THREE.PerspectiveCamera(), 
    this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
}, Object.assign(THREE.StereoCamera.prototype, {
    update: function() {
        var a, b, c, d, e, f = new THREE.Matrix4(), g = new THREE.Matrix4();
        return function(h) {
            if (a !== h.focus || b !== h.fov || c !== h.aspect * this.aspect || d !== h.near || e !== h.far) {
                a = h.focus, b = h.fov, c = h.aspect * this.aspect, d = h.near, e = h.far;
                var i, j, k = h.projectionMatrix.clone(), l = .032 * d / a, m = d * Math.tan(THREE.Math.DEG2RAD * b * .5);
                g.elements[12] = -.032, f.elements[12] = .032, i = -m * c + l, j = m * c + l, k.elements[0] = 2 * d / (j - i), 
                k.elements[8] = (j + i) / (j - i), this.cameraL.projectionMatrix.copy(k), i = -m * c - l, 
                j = m * c - l, k.elements[0] = 2 * d / (j - i), k.elements[8] = (j + i) / (j - i), 
                this.cameraR.projectionMatrix.copy(k);
            }
            this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(g), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(f);
        };
    }()
}), THREE.Light = function(a, b) {
    THREE.Object3D.call(this), this.type = "Light", this.color = new THREE.Color(a), 
    this.intensity = void 0 !== b ? b : 1, this.receiveShadow = void 0;
}, THREE.Light.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.Light,
    copy: function(a) {
        return THREE.Object3D.prototype.copy.call(this, a), this.color.copy(a.color), this.intensity = a.intensity, 
        this;
    },
    toJSON: function(a) {
        return a = THREE.Object3D.prototype.toJSON.call(this, a), a.object.color = this.color.getHex(), 
        a.object.intensity = this.intensity, void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()), 
        void 0 !== this.distance && (a.object.distance = this.distance), void 0 !== this.angle && (a.object.angle = this.angle), 
        void 0 !== this.decay && (a.object.decay = this.decay), void 0 !== this.penumbra && (a.object.penumbra = this.penumbra), 
        a;
    }
}), THREE.LightShadow = function(a) {
    this.camera = a, this.bias = 0, this.radius = 1, this.mapSize = new THREE.Vector2(512, 512), 
    this.map = null, this.matrix = new THREE.Matrix4();
}, Object.assign(THREE.LightShadow.prototype, {
    copy: function(a) {
        return this.camera = a.camera.clone(), this.bias = a.bias, this.radius = a.radius, 
        this.mapSize.copy(a.mapSize), this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
}), THREE.AmbientLight = function(a, b) {
    THREE.Light.call(this, a, b), this.type = "AmbientLight", this.castShadow = void 0;
}, THREE.AmbientLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
    constructor: THREE.AmbientLight
}), THREE.DirectionalLight = function(a, b) {
    THREE.Light.call(this, a, b), this.type = "DirectionalLight", this.position.set(0, 1, 0), 
    this.updateMatrix(), this.target = new THREE.Object3D(), this.shadow = new THREE.DirectionalLightShadow();
}, THREE.DirectionalLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
    constructor: THREE.DirectionalLight,
    copy: function(a) {
        return THREE.Light.prototype.copy.call(this, a), this.target = a.target.clone(), 
        this.shadow = a.shadow.clone(), this;
    }
}), THREE.DirectionalLightShadow = function(a) {
    THREE.LightShadow.call(this, new THREE.OrthographicCamera(-5, 5, 5, -5, .5, 500));
}, THREE.DirectionalLightShadow.prototype = Object.assign(Object.create(THREE.LightShadow.prototype), {
    constructor: THREE.DirectionalLightShadow
}), THREE.HemisphereLight = function(a, b, c) {
    THREE.Light.call(this, a, c), this.type = "HemisphereLight", this.castShadow = void 0, 
    this.position.set(0, 1, 0), this.updateMatrix(), this.groundColor = new THREE.Color(b);
}, THREE.HemisphereLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
    constructor: THREE.HemisphereLight,
    copy: function(a) {
        return THREE.Light.prototype.copy.call(this, a), this.groundColor.copy(a.groundColor), 
        this;
    }
}), THREE.PointLight = function(a, b, c, d) {
    THREE.Light.call(this, a, b), this.type = "PointLight", Object.defineProperty(this, "power", {
        get: function() {
            return 4 * this.intensity * Math.PI;
        },
        set: function(a) {
            this.intensity = a / (4 * Math.PI);
        }
    }), this.distance = void 0 !== c ? c : 0, this.decay = void 0 !== d ? d : 1, this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, .5, 500));
}, THREE.PointLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
    constructor: THREE.PointLight,
    copy: function(a) {
        return THREE.Light.prototype.copy.call(this, a), this.distance = a.distance, this.decay = a.decay, 
        this.shadow = a.shadow.clone(), this;
    }
}), THREE.SpotLight = function(a, b, c, d, e, f) {
    THREE.Light.call(this, a, b), this.type = "SpotLight", this.position.set(0, 1, 0), 
    this.updateMatrix(), this.target = new THREE.Object3D(), Object.defineProperty(this, "power", {
        get: function() {
            return this.intensity * Math.PI;
        },
        set: function(a) {
            this.intensity = a / Math.PI;
        }
    }), this.distance = void 0 !== c ? c : 0, this.angle = void 0 !== d ? d : Math.PI / 3, 
    this.penumbra = void 0 !== e ? e : 0, this.decay = void 0 !== f ? f : 1, this.shadow = new THREE.SpotLightShadow();
}, THREE.SpotLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
    constructor: THREE.SpotLight,
    copy: function(a) {
        return THREE.Light.prototype.copy.call(this, a), this.distance = a.distance, this.angle = a.angle, 
        this.penumbra = a.penumbra, this.decay = a.decay, this.target = a.target.clone(), 
        this.shadow = a.shadow.clone(), this;
    }
}), THREE.SpotLightShadow = function() {
    THREE.LightShadow.call(this, new THREE.PerspectiveCamera(50, 1, .5, 500));
}, THREE.SpotLightShadow.prototype = Object.assign(Object.create(THREE.LightShadow.prototype), {
    constructor: THREE.SpotLightShadow,
    update: function(a) {
        var b = 2 * THREE.Math.RAD2DEG * a.angle, c = this.mapSize.width / this.mapSize.height;
        a = a.distance || 500;
        var d = this.camera;
        b === d.fov && c === d.aspect && a === d.far || (d.fov = b, d.aspect = c, d.far = a, 
        d.updateProjectionMatrix());
    }
}), THREE.AudioLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.AudioLoader.prototype = {
    constructor: THREE.AudioLoader,
    load: function(a, b, c, d) {
        var e = new THREE.XHRLoader(this.manager);
        e.setResponseType("arraybuffer"), e.load(a, function(a) {
            THREE.AudioContext.decodeAudioData(a, function(a) {
                b(a);
            });
        }, c, d);
    }
}, THREE.Cache = {
    enabled: !1,
    files: {},
    add: function(a, b) {
        !1 !== this.enabled && (this.files[a] = b);
    },
    get: function(a) {
        if (!1 !== this.enabled) return this.files[a];
    },
    remove: function(a) {
        delete this.files[a];
    },
    clear: function() {
        this.files = {};
    }
}, THREE.Loader = function() {
    this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {};
}, THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: void 0,
    extractUrlBase: function(a) {
        return a = a.split("/"), 1 === a.length ? "./" : (a.pop(), a.join("/") + "/");
    },
    initMaterials: function(a, b, c) {
        for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
        return d;
    },
    createMaterial: function() {
        var a, b, c;
        return function(d, e, f) {
            function g(a, c, d, g, h) {
                a = e + a;
                var j = THREE.Loader.Handlers.get(a);
                return null !== j ? a = j.load(a) : (b.setCrossOrigin(f), a = b.load(a)), void 0 !== c && (a.repeat.fromArray(c), 
                1 !== c[0] && (a.wrapS = THREE.RepeatWrapping), 1 !== c[1] && (a.wrapT = THREE.RepeatWrapping)), 
                void 0 !== d && a.offset.fromArray(d), void 0 !== g && ("repeat" === g[0] && (a.wrapS = THREE.RepeatWrapping), 
                "mirror" === g[0] && (a.wrapS = THREE.MirroredRepeatWrapping), "repeat" === g[1] && (a.wrapT = THREE.RepeatWrapping), 
                "mirror" === g[1] && (a.wrapT = THREE.MirroredRepeatWrapping)), void 0 !== h && (a.anisotropy = h), 
                c = THREE.Math.generateUUID(), i[c] = a, c;
            }
            void 0 === a && (a = new THREE.Color()), void 0 === b && (b = new THREE.TextureLoader()), 
            void 0 === c && (c = new THREE.MaterialLoader());
            var h, i = {}, j = {
                uuid: THREE.Math.generateUUID(),
                type: "MeshLambertMaterial"
            };
            for (h in d) {
                var k = d[h];
                switch (h) {
                  case "DbgColor":
                  case "DbgIndex":
                  case "opticalDensity":
                  case "illumination":
                    break;

                  case "DbgName":
                    j.name = k;
                    break;

                  case "blending":
                    j.blending = THREE[k];
                    break;

                  case "colorAmbient":
                  case "mapAmbient":
                    console.warn("THREE.Loader.createMaterial:", h, "is no longer supported.");
                    break;

                  case "colorDiffuse":
                    j.color = a.fromArray(k).getHex();
                    break;

                  case "colorSpecular":
                    j.specular = a.fromArray(k).getHex();
                    break;

                  case "colorEmissive":
                    j.emissive = a.fromArray(k).getHex();
                    break;

                  case "specularCoef":
                    j.shininess = k;
                    break;

                  case "shading":
                    "basic" === k.toLowerCase() && (j.type = "MeshBasicMaterial"), "phong" === k.toLowerCase() && (j.type = "MeshPhongMaterial");
                    break;

                  case "mapDiffuse":
                    j.map = g(k, d.mapDiffuseRepeat, d.mapDiffuseOffset, d.mapDiffuseWrap, d.mapDiffuseAnisotropy);
                    break;

                  case "mapDiffuseRepeat":
                  case "mapDiffuseOffset":
                  case "mapDiffuseWrap":
                  case "mapDiffuseAnisotropy":
                    break;

                  case "mapLight":
                    j.lightMap = g(k, d.mapLightRepeat, d.mapLightOffset, d.mapLightWrap, d.mapLightAnisotropy);
                    break;

                  case "mapLightRepeat":
                  case "mapLightOffset":
                  case "mapLightWrap":
                  case "mapLightAnisotropy":
                    break;

                  case "mapAO":
                    j.aoMap = g(k, d.mapAORepeat, d.mapAOOffset, d.mapAOWrap, d.mapAOAnisotropy);
                    break;

                  case "mapAORepeat":
                  case "mapAOOffset":
                  case "mapAOWrap":
                  case "mapAOAnisotropy":
                    break;

                  case "mapBump":
                    j.bumpMap = g(k, d.mapBumpRepeat, d.mapBumpOffset, d.mapBumpWrap, d.mapBumpAnisotropy);
                    break;

                  case "mapBumpScale":
                    j.bumpScale = k;
                    break;

                  case "mapBumpRepeat":
                  case "mapBumpOffset":
                  case "mapBumpWrap":
                  case "mapBumpAnisotropy":
                    break;

                  case "mapNormal":
                    j.normalMap = g(k, d.mapNormalRepeat, d.mapNormalOffset, d.mapNormalWrap, d.mapNormalAnisotropy);
                    break;

                  case "mapNormalFactor":
                    j.normalScale = [ k, k ];
                    break;

                  case "mapNormalRepeat":
                  case "mapNormalOffset":
                  case "mapNormalWrap":
                  case "mapNormalAnisotropy":
                    break;

                  case "mapSpecular":
                    j.specularMap = g(k, d.mapSpecularRepeat, d.mapSpecularOffset, d.mapSpecularWrap, d.mapSpecularAnisotropy);
                    break;

                  case "mapSpecularRepeat":
                  case "mapSpecularOffset":
                  case "mapSpecularWrap":
                  case "mapSpecularAnisotropy":
                    break;

                  case "mapAlpha":
                    j.alphaMap = g(k, d.mapAlphaRepeat, d.mapAlphaOffset, d.mapAlphaWrap, d.mapAlphaAnisotropy);
                    break;

                  case "mapAlphaRepeat":
                  case "mapAlphaOffset":
                  case "mapAlphaWrap":
                  case "mapAlphaAnisotropy":
                    break;

                  case "flipSided":
                    j.side = THREE.BackSide;
                    break;

                  case "doubleSided":
                    j.side = THREE.DoubleSide;
                    break;

                  case "transparency":
                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), 
                    j.opacity = k;
                    break;

                  case "depthTest":
                  case "depthWrite":
                  case "colorWrite":
                  case "opacity":
                  case "reflectivity":
                  case "transparent":
                  case "visible":
                  case "wireframe":
                    j[h] = k;
                    break;

                  case "vertexColors":
                    !0 === k && (j.vertexColors = THREE.VertexColors), "face" === k && (j.vertexColors = THREE.FaceColors);
                    break;

                  default:
                    console.error("THREE.Loader.createMaterial: Unsupported", h, k);
                }
            }
            return "MeshBasicMaterial" === j.type && delete j.emissive, "MeshPhongMaterial" !== j.type && delete j.specular, 
            1 > j.opacity && (j.transparent = !0), c.setTextures(i), c.parse(j);
        };
    }()
}, THREE.Loader.Handlers = {
    handlers: [],
    add: function(a, b) {
        this.handlers.push(a, b);
    },
    get: function(a) {
        for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
            var e = b[c + 1];
            if (b[c].test(a)) return e;
        }
        return null;
    }
};

THREE.XHRLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};

THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function(a, b, c, d) {
        void 0 !== this.path && (a = this.path + a);
        var e = this, f = THREE.Cache.get(a);
        if (void 0 !== f) return b && setTimeout(function() {
            b(f);
        }, 0), f;
        var g = new XMLHttpRequest();
        return g.overrideMimeType("text/plain"), g.open("GET", a, !0), g.addEventListener("load", function(c) {
            var f = c.target.response;
            THREE.Cache.add(a, f), 200 === this.status ? (b && b(f), e.manager.itemEnd(a)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."), 
            b && b(f), e.manager.itemEnd(a)) : (d && d(c), e.manager.itemError(a));
        }, !1), void 0 !== c && g.addEventListener("progress", function(a) {
            c(a);
        }, !1), g.addEventListener("error", function(b) {
            d && d(b), e.manager.itemError(a);
        }, !1), void 0 !== this.responseType && (g.responseType = this.responseType), void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials), 
        g.send(null), e.manager.itemStart(a), g;
    },
    setPath: function(a) {
        this.path = a;
    },
    setResponseType: function(a) {
        this.responseType = a;
    },
    setWithCredentials: function(a) {
        this.withCredentials = a;
    }
}, THREE.FontLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.FontLoader.prototype = {
    constructor: THREE.FontLoader,
    load: function(a, b, c, d) {
        var e = this;
        new THREE.XHRLoader(this.manager).load(a, function(a) {
            var c;
            try {
                c = JSON.parse(a);
            } catch (b) {
                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), 
                c = JSON.parse(a.substring(65, a.length - 2));
            }
            a = e.parse(c), b && b(a);
        }, c, d);
    },
    parse: function(a) {
        return new THREE.Font(a);
    }
}, THREE.ImageLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function(a, b, c, d) {
        void 0 !== this.path && (a = this.path + a);
        var e = this, f = THREE.Cache.get(a);
        if (void 0 !== f) return e.manager.itemStart(a), b ? setTimeout(function() {
            b(f), e.manager.itemEnd(a);
        }, 0) : e.manager.itemEnd(a), f;
        var g = document.createElement("img");
        return g.addEventListener("load", function(c) {
            THREE.Cache.add(a, this), b && b(this), e.manager.itemEnd(a);
        }, !1), void 0 !== c && g.addEventListener("progress", function(a) {
            c(a);
        }, !1), g.addEventListener("error", function(b) {
            d && d(b), e.manager.itemError(a);
        }, !1), void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin), e.manager.itemStart(a), 
        g.src = a, g;
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    setPath: function(a) {
        this.path = a;
    }
}, THREE.JSONLoader = function(a) {
    "boolean" == typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), 
    a = void 0), this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.withCredentials = !1;
}, THREE.JSONLoader.prototype = {
    constructor: THREE.JSONLoader,
    get statusDomElement() {
        return void 0 === this._statusDomElement && (this._statusDomElement = document.createElement("div")), 
        console.warn("THREE.JSONLoader: .statusDomElement has been removed."), this._statusDomElement;
    },
    load: function(a, b, c, d) {
        var e = this, f = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : THREE.Loader.prototype.extractUrlBase(a), g = new THREE.XHRLoader(this.manager);
        g.setWithCredentials(this.withCredentials), g.load(a, function(c) {
            c = JSON.parse(c);
            var d = c.metadata;
            if (void 0 !== d && (d = d.type, void 0 !== d)) {
                if ("object" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
                if ("scene" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.SceneLoader instead.");
            }
            c = e.parse(c, f), b(c.geometry, c.materials);
        }, c, d);
    },
    setTexturePath: function(a) {
        this.texturePath = a;
    },
    parse: function(a, b) {
        var c = new THREE.Geometry(), d = void 0 !== a.scale ? 1 / a.scale : 1;
        return function(b) {
            var d, e, f, g, h, i, j, k, l, m, n, o, p, q = a.faces;
            i = a.vertices;
            var r = a.normals, s = a.colors, t = 0;
            if (void 0 !== a.uvs) {
                for (d = 0; d < a.uvs.length; d++) a.uvs[d].length && t++;
                for (d = 0; d < t; d++) c.faceVertexUvs[d] = [];
            }
            for (g = 0, h = i.length; g < h; ) d = new THREE.Vector3(), d.x = i[g++] * b, d.y = i[g++] * b, 
            d.z = i[g++] * b, c.vertices.push(d);
            for (g = 0, h = q.length; g < h; ) if (b = q[g++], l = 1 & b, f = 2 & b, d = 8 & b, 
            j = 16 & b, m = 32 & b, i = 64 & b, b &= 128, l) {
                if (l = new THREE.Face3(), l.a = q[g], l.b = q[g + 1], l.c = q[g + 3], n = new THREE.Face3(), 
                n.a = q[g + 1], n.b = q[g + 2], n.c = q[g + 3], g += 4, f && (f = q[g++], l.materialIndex = f, 
                n.materialIndex = f), f = c.faces.length, d) for (d = 0; d < t; d++) for (o = a.uvs[d], 
                c.faceVertexUvs[d][f] = [], c.faceVertexUvs[d][f + 1] = [], e = 0; 4 > e; e++) k = q[g++], 
                p = o[2 * k], k = o[2 * k + 1], p = new THREE.Vector2(p, k), 2 !== e && c.faceVertexUvs[d][f].push(p), 
                0 !== e && c.faceVertexUvs[d][f + 1].push(p);
                if (j && (j = 3 * q[g++], l.normal.set(r[j++], r[j++], r[j]), n.normal.copy(l.normal)), 
                m) for (d = 0; 4 > d; d++) j = 3 * q[g++], m = new THREE.Vector3(r[j++], r[j++], r[j]), 
                2 !== d && l.vertexNormals.push(m), 0 !== d && n.vertexNormals.push(m);
                if (i && (i = q[g++], i = s[i], l.color.setHex(i), n.color.setHex(i)), b) for (d = 0; 4 > d; d++) i = q[g++], 
                i = s[i], 2 !== d && l.vertexColors.push(new THREE.Color(i)), 0 !== d && n.vertexColors.push(new THREE.Color(i));
                c.faces.push(l), c.faces.push(n);
            } else {
                if (l = new THREE.Face3(), l.a = q[g++], l.b = q[g++], l.c = q[g++], f && (f = q[g++], 
                l.materialIndex = f), f = c.faces.length, d) for (d = 0; d < t; d++) for (o = a.uvs[d], 
                c.faceVertexUvs[d][f] = [], e = 0; 3 > e; e++) k = q[g++], p = o[2 * k], k = o[2 * k + 1], 
                p = new THREE.Vector2(p, k), c.faceVertexUvs[d][f].push(p);
                if (j && (j = 3 * q[g++], l.normal.set(r[j++], r[j++], r[j])), m) for (d = 0; 3 > d; d++) j = 3 * q[g++], 
                m = new THREE.Vector3(r[j++], r[j++], r[j]), l.vertexNormals.push(m);
                if (i && (i = q[g++], l.color.setHex(s[i])), b) for (d = 0; 3 > d; d++) i = q[g++], 
                l.vertexColors.push(new THREE.Color(s[i]));
                c.faces.push(l);
            }
        }(d), function() {
            var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
            if (a.skinWeights) for (var d = 0, e = a.skinWeights.length; d < e; d += b) c.skinWeights.push(new THREE.Vector4(a.skinWeights[d], 1 < b ? a.skinWeights[d + 1] : 0, 2 < b ? a.skinWeights[d + 2] : 0, 3 < b ? a.skinWeights[d + 3] : 0));
            if (a.skinIndices) for (d = 0, e = a.skinIndices.length; d < e; d += b) c.skinIndices.push(new THREE.Vector4(a.skinIndices[d], 1 < b ? a.skinIndices[d + 1] : 0, 2 < b ? a.skinIndices[d + 2] : 0, 3 < b ? a.skinIndices[d + 3] : 0));
            c.bones = a.bones, c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match.");
        }(), function(b) {
            if (void 0 !== a.morphTargets) for (var d = 0, e = a.morphTargets.length; d < e; d++) {
                c.morphTargets[d] = {}, c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [];
                for (var f = c.morphTargets[d].vertices, g = a.morphTargets[d].vertices, h = 0, i = g.length; h < i; h += 3) {
                    var j = new THREE.Vector3();
                    j.x = g[h] * b, j.y = g[h + 1] * b, j.z = g[h + 2] * b, f.push(j);
                }
            }
            if (void 0 !== a.morphColors && 0 < a.morphColors.length) for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), 
            b = c.faces, f = a.morphColors[0].colors, d = 0, e = b.length; d < e; d++) b[d].color.fromArray(f, 3 * d);
        }(d), function() {
            var b = [], d = [];
            void 0 !== a.animation && d.push(a.animation), void 0 !== a.animations && (a.animations.length ? d = d.concat(a.animations) : d.push(a.animations));
            for (var e = 0; e < d.length; e++) {
                var f = THREE.AnimationClip.parseAnimation(d[e], c.bones);
                f && b.push(f);
            }
            c.morphTargets && (d = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(c.morphTargets, 10), 
            b = b.concat(d)), 0 < b.length && (c.animations = b);
        }(), c.computeFaceNormals(), c.computeBoundingSphere(), void 0 === a.materials || 0 === a.materials.length ? {
            geometry: c
        } : (d = THREE.Loader.prototype.initMaterials(a.materials, b, this.crossOrigin), 
        {
            geometry: c,
            materials: d
        });
    }
}, THREE.LoadingManager = function(a, b, c) {
    var d = this, e = !1, f = 0, g = 0;
    this.onStart = void 0, this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function(a) {
        g++, !1 === e && void 0 !== d.onStart && d.onStart(a, f, g), e = !0;
    }, this.itemEnd = function(a) {
        f++, void 0 !== d.onProgress && d.onProgress(a, f, g), f === g && (e = !1, void 0 !== d.onLoad) && d.onLoad();
    }, this.itemError = function(a) {
        void 0 !== d.onError && d.onError(a);
    };
}, THREE.DefaultLoadingManager = new THREE.LoadingManager(), THREE.BufferGeometryLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader,
    load: function(a, b, c, d) {
        var e = this;
        new THREE.XHRLoader(e.manager).load(a, function(a) {
            b(e.parse(JSON.parse(a)));
        }, c, d);
    },
    parse: function(a) {
        var b = new THREE.BufferGeometry(), c = a.data.index, d = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: Uint8ClampedArray,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };
        void 0 !== c && (c = new d[c.type](c.array), b.setIndex(new THREE.BufferAttribute(c, 1)));
        var e, f = a.data.attributes;
        for (e in f) {
            var g = f[e], c = new d[g.type](g.array);
            b.addAttribute(e, new THREE.BufferAttribute(c, g.itemSize, g.normalized));
        }
        if (d = a.data.groups || a.data.drawcalls || a.data.offsets, void 0 !== d) for (e = 0, 
        c = d.length; e !== c; ++e) f = d[e], b.addGroup(f.start, f.count, f.materialIndex);
        return a = a.data.boundingSphere, void 0 !== a && (d = new THREE.Vector3(), void 0 !== a.center && d.fromArray(a.center), 
        b.boundingSphere = new THREE.Sphere(d, a.radius)), b;
    }
}, THREE.MaterialLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.textures = {};
}, THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader,
    load: function(a, b, c, d) {
        var e = this;
        new THREE.XHRLoader(e.manager).load(a, function(a) {
            b(e.parse(JSON.parse(a)));
        }, c, d);
    },
    setTextures: function(a) {
        this.textures = a;
    },
    getTexture: function(a) {
        var b = this.textures;
        return void 0 === b[a] && console.warn("THREE.MaterialLoader: Undefined texture", a), 
        b[a];
    },
    parse: function(a) {
        var b = new THREE[a.type]();
        if (void 0 !== a.uuid && (b.uuid = a.uuid), void 0 !== a.name && (b.name = a.name), 
        void 0 !== a.color && b.color.setHex(a.color), void 0 !== a.roughness && (b.roughness = a.roughness), 
        void 0 !== a.metalness && (b.metalness = a.metalness), void 0 !== a.emissive && b.emissive.setHex(a.emissive), 
        void 0 !== a.specular && b.specular.setHex(a.specular), void 0 !== a.shininess && (b.shininess = a.shininess), 
        void 0 !== a.uniforms && (b.uniforms = a.uniforms), void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader), 
        void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader), void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors), 
        void 0 !== a.shading && (b.shading = a.shading), void 0 !== a.blending && (b.blending = a.blending), 
        void 0 !== a.side && (b.side = a.side), void 0 !== a.opacity && (b.opacity = a.opacity), 
        void 0 !== a.transparent && (b.transparent = a.transparent), void 0 !== a.alphaTest && (b.alphaTest = a.alphaTest), 
        void 0 !== a.depthTest && (b.depthTest = a.depthTest), void 0 !== a.depthWrite && (b.depthWrite = a.depthWrite), 
        void 0 !== a.colorWrite && (b.colorWrite = a.colorWrite), void 0 !== a.wireframe && (b.wireframe = a.wireframe), 
        void 0 !== a.wireframeLinewidth && (b.wireframeLinewidth = a.wireframeLinewidth), 
        void 0 !== a.size && (b.size = a.size), void 0 !== a.sizeAttenuation && (b.sizeAttenuation = a.sizeAttenuation), 
        void 0 !== a.map && (b.map = this.getTexture(a.map)), void 0 !== a.alphaMap && (b.alphaMap = this.getTexture(a.alphaMap), 
        b.transparent = !0), void 0 !== a.bumpMap && (b.bumpMap = this.getTexture(a.bumpMap)), 
        void 0 !== a.bumpScale && (b.bumpScale = a.bumpScale), void 0 !== a.normalMap && (b.normalMap = this.getTexture(a.normalMap)), 
        void 0 !== a.normalScale) {
            var c = a.normalScale;
            !1 === Array.isArray(c) && (c = [ c, c ]), b.normalScale = new THREE.Vector2().fromArray(c);
        }
        if (void 0 !== a.displacementMap && (b.displacementMap = this.getTexture(a.displacementMap)), 
        void 0 !== a.displacementScale && (b.displacementScale = a.displacementScale), void 0 !== a.displacementBias && (b.displacementBias = a.displacementBias), 
        void 0 !== a.roughnessMap && (b.roughnessMap = this.getTexture(a.roughnessMap)), 
        void 0 !== a.metalnessMap && (b.metalnessMap = this.getTexture(a.metalnessMap)), 
        void 0 !== a.emissiveMap && (b.emissiveMap = this.getTexture(a.emissiveMap)), void 0 !== a.emissiveIntensity && (b.emissiveIntensity = a.emissiveIntensity), 
        void 0 !== a.specularMap && (b.specularMap = this.getTexture(a.specularMap)), void 0 !== a.envMap && (b.envMap = this.getTexture(a.envMap), 
        b.combine = THREE.MultiplyOperation), a.reflectivity && (b.reflectivity = a.reflectivity), 
        void 0 !== a.lightMap && (b.lightMap = this.getTexture(a.lightMap)), void 0 !== a.lightMapIntensity && (b.lightMapIntensity = a.lightMapIntensity), 
        void 0 !== a.aoMap && (b.aoMap = this.getTexture(a.aoMap)), void 0 !== a.aoMapIntensity && (b.aoMapIntensity = a.aoMapIntensity), 
        void 0 !== a.materials) for (var c = 0, d = a.materials.length; c < d; c++) b.materials.push(this.parse(a.materials[c]));
        return b;
    }
}, THREE.ObjectLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.texturePath = "";
}, THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader,
    load: function(a, b, c, d) {
        "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
        var e = this;
        new THREE.XHRLoader(e.manager).load(a, function(a) {
            e.parse(JSON.parse(a), b);
        }, c, d);
    },
    setTexturePath: function(a) {
        this.texturePath = a;
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    parse: function(a, b) {
        var c = this.parseGeometries(a.geometries), d = this.parseImages(a.images, function() {
            void 0 !== b && b(e);
        }), d = this.parseTextures(a.textures, d), d = this.parseMaterials(a.materials, d), e = this.parseObject(a.object, c, d);
        return a.animations && (e.animations = this.parseAnimations(a.animations)), void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e), 
        e;
    },
    parseGeometries: function(a) {
        var b = {};
        if (void 0 !== a) for (var c = new THREE.JSONLoader(), d = new THREE.BufferGeometryLoader(), e = 0, f = a.length; e < f; e++) {
            var g, h = a[e];
            switch (h.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                g = new THREE[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                break;

              case "BoxGeometry":
              case "BoxBufferGeometry":
              case "CubeGeometry":
                g = new THREE[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                break;

              case "CircleGeometry":
              case "CircleBufferGeometry":
                g = new THREE[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
                break;

              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                g = new THREE[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                break;

              case "ConeGeometry":
              case "ConeBufferGeometry":
                g = new THREE[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                break;

              case "SphereGeometry":
              case "SphereBufferGeometry":
                g = new THREE[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                break;

              case "DodecahedronGeometry":
              case "IcosahedronGeometry":
              case "OctahedronGeometry":
              case "TetrahedronGeometry":
                g = new THREE[h.type](h.radius, h.detail);
                break;

              case "RingGeometry":
              case "RingBufferGeometry":
                g = new THREE[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
                break;

              case "TorusGeometry":
              case "TorusBufferGeometry":
                g = new THREE[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                break;

              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                g = new THREE[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
                break;

              case "LatheGeometry":
              case "LatheBufferGeometry":
                g = new THREE[h.type](h.points, h.segments, h.phiStart, h.phiLength);
                break;

              case "BufferGeometry":
                g = d.parse(h);
                break;

              case "Geometry":
                g = c.parse(h.data, this.texturePath).geometry;
                break;

              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
                continue;
            }
            g.uuid = h.uuid, void 0 !== h.name && (g.name = h.name), b[h.uuid] = g;
        }
        return b;
    },
    parseMaterials: function(a, b) {
        var c = {};
        if (void 0 !== a) {
            var d = new THREE.MaterialLoader();
            d.setTextures(b);
            for (var e = 0, f = a.length; e < f; e++) {
                var g = d.parse(a[e]);
                c[g.uuid] = g;
            }
        }
        return c;
    },
    parseAnimations: function(a) {
        for (var b = [], c = 0; c < a.length; c++) {
            var d = THREE.AnimationClip.parse(a[c]);
            b.push(d);
        }
        return b;
    },
    parseImages: function(a, b) {
        function c(a) {
            return d.manager.itemStart(a), g.load(a, function() {
                d.manager.itemEnd(a);
            });
        }
        var d = this, e = {};
        if (void 0 !== a && 0 < a.length) {
            var f = new THREE.LoadingManager(b), g = new THREE.ImageLoader(f);
            g.setCrossOrigin(this.crossOrigin);
            for (var f = 0, h = a.length; f < h; f++) {
                var i = a[f], j = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i.url) ? i.url : d.texturePath + i.url;
                e[i.uuid] = c(j);
            }
        }
        return e;
    },
    parseTextures: function(a, b) {
        function c(a) {
            return "number" == typeof a ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), 
            THREE[a]);
        }
        var d = {};
        if (void 0 !== a) for (var e = 0, f = a.length; e < f; e++) {
            var g = a[e];
            void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid), 
            void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
            var h = new THREE.Texture(b[g.image]);
            h.needsUpdate = !0, h.uuid = g.uuid, void 0 !== g.name && (h.name = g.name), void 0 !== g.mapping && (h.mapping = c(g.mapping)), 
            void 0 !== g.offset && (h.offset = new THREE.Vector2(g.offset[0], g.offset[1])), 
            void 0 !== g.repeat && (h.repeat = new THREE.Vector2(g.repeat[0], g.repeat[1])), 
            void 0 !== g.minFilter && (h.minFilter = c(g.minFilter)), void 0 !== g.magFilter && (h.magFilter = c(g.magFilter)), 
            void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy), Array.isArray(g.wrap) && (h.wrapS = c(g.wrap[0]), 
            h.wrapT = c(g.wrap[1])), d[g.uuid] = h;
        }
        return d;
    },
    parseObject: function() {
        var a = new THREE.Matrix4();
        return function(b, c, d) {
            function e(a) {
                return void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a), 
                c[a];
            }
            function f(a) {
                if (void 0 !== a) return void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a), 
                d[a];
            }
            var g;
            switch (b.type) {
              case "Scene":
                g = new THREE.Scene();
                break;

              case "PerspectiveCamera":
                g = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far), void 0 !== b.focus && (g.focus = b.focus), 
                void 0 !== b.zoom && (g.zoom = b.zoom), void 0 !== b.filmGauge && (g.filmGauge = b.filmGauge), 
                void 0 !== b.filmOffset && (g.filmOffset = b.filmOffset), void 0 !== b.view && (g.view = Object.assign({}, b.view));
                break;

              case "OrthographicCamera":
                g = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
                break;

              case "AmbientLight":
                g = new THREE.AmbientLight(b.color, b.intensity);
                break;

              case "DirectionalLight":
                g = new THREE.DirectionalLight(b.color, b.intensity);
                break;

              case "PointLight":
                g = new THREE.PointLight(b.color, b.intensity, b.distance, b.decay);
                break;

              case "SpotLight":
                g = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.penumbra, b.decay);
                break;

              case "HemisphereLight":
                g = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
                break;

              case "Mesh":
                g = e(b.geometry);
                var h = f(b.material);
                g = g.bones && 0 < g.bones.length ? new THREE.SkinnedMesh(g, h) : new THREE.Mesh(g, h);
                break;

              case "LOD":
                g = new THREE.LOD();
                break;

              case "Line":
                g = new THREE.Line(e(b.geometry), f(b.material), b.mode);
                break;

              case "PointCloud":
              case "Points":
                g = new THREE.Points(e(b.geometry), f(b.material));
                break;

              case "Sprite":
                g = new THREE.Sprite(f(b.material));
                break;

              case "Group":
                g = new THREE.Group();
                break;

              default:
                g = new THREE.Object3D();
            }
            if (g.uuid = b.uuid, void 0 !== b.name && (g.name = b.name), void 0 !== b.matrix ? (a.fromArray(b.matrix), 
            a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position), 
            void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.scale && g.scale.fromArray(b.scale)), 
            void 0 !== b.castShadow && (g.castShadow = b.castShadow), void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow), 
            void 0 !== b.visible && (g.visible = b.visible), void 0 !== b.userData && (g.userData = b.userData), 
            void 0 !== b.children) for (var i in b.children) g.add(this.parseObject(b.children[i], c, d));
            if ("LOD" === b.type) for (b = b.levels, h = 0; h < b.length; h++) {
                var j = b[h];
                i = g.getObjectByProperty("uuid", j.object), void 0 !== i && g.addLevel(i, j.distance);
            }
            return g;
        };
    }()
}, THREE.TextureLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function(a, b, c, d) {
        var e = new THREE.Texture(), f = new THREE.ImageLoader(this.manager);
        return f.setCrossOrigin(this.crossOrigin), f.setPath(this.path), f.load(a, function(a) {
            e.image = a, e.needsUpdate = !0, void 0 !== b && b(e);
        }, c, d), e;
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    setPath: function(a) {
        this.path = a;
    }
}, THREE.CubeTextureLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.CubeTextureLoader.prototype = {
    constructor: THREE.CubeTextureLoader,
    load: function(a, b, c, d) {
        function e(c) {
            g.load(a[c], function(a) {
                f.images[c] = a, h++, 6 === h && (f.needsUpdate = !0, b && b(f));
            }, void 0, d);
        }
        var f = new THREE.CubeTexture(), g = new THREE.ImageLoader(this.manager);
        g.setCrossOrigin(this.crossOrigin), g.setPath(this.path);
        var h = 0;
        for (c = 0; c < a.length; ++c) e(c);
        return f;
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a;
    },
    setPath: function(a) {
        this.path = a;
    }
}, THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this._parser = null;
}, THREE.BinaryTextureLoader.prototype = {
    constructor: THREE.BinaryTextureLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.DataTexture(), g = new THREE.XHRLoader(this.manager);
        return g.setResponseType("arraybuffer"), g.load(a, function(a) {
            (a = e._parser(a)) && (void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, 
            f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : THREE.ClampToEdgeWrapping, 
            f.wrapT = void 0 !== a.wrapT ? a.wrapT : THREE.ClampToEdgeWrapping, f.magFilter = void 0 !== a.magFilter ? a.magFilter : THREE.LinearFilter, 
            f.minFilter = void 0 !== a.minFilter ? a.minFilter : THREE.LinearMipMapLinearFilter, 
            f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), 
            void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 
            1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, b && b(f, a));
        }, c, d), f;
    }
}, THREE.CompressedTextureLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this._parser = null;
}, THREE.CompressedTextureLoader.prototype = {
    constructor: THREE.CompressedTextureLoader,
    load: function(a, b, c, d) {
        function e(e) {
            i.load(a[e], function(a) {
                a = f._parser(a, !0), g[e] = {
                    width: a.width,
                    height: a.height,
                    format: a.format,
                    mipmaps: a.mipmaps
                }, j += 1, 6 === j && (1 === a.mipmapCount && (h.minFilter = THREE.LinearFilter), 
                h.format = a.format, h.needsUpdate = !0, b && b(h));
            }, c, d);
        }
        var f = this, g = [], h = new THREE.CompressedTexture();
        h.image = g;
        var i = new THREE.XHRLoader(this.manager);
        if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(a)) for (var j = 0, k = 0, l = a.length; k < l; ++k) e(k); else i.load(a, function(a) {
            if (a = f._parser(a, !0), a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
                g[d] = {
                    mipmaps: []
                };
                for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), 
                g[d].format = a.format, g[d].width = a.width, g[d].height = a.height;
            } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
            1 === a.mipmapCount && (h.minFilter = THREE.LinearFilter), h.format = a.format, 
            h.needsUpdate = !0, b && b(h);
        }, c, d);
        return h;
    },
    setPath: function(a) {
        this.path = a;
    }
}, THREE.Material = function() {
    Object.defineProperty(this, "id", {
        value: THREE.MaterialIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Material", 
    this.lights = this.fog = !0, this.blending = THREE.NormalBlending, this.side = THREE.FrontSide, 
    this.shading = THREE.SmoothShading, this.vertexColors = THREE.NoColors, this.opacity = 1, 
    this.transparent = !1, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, 
    this.blendEquation = THREE.AddEquation, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, 
    this.depthFunc = THREE.LessEqualDepth, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, 
    this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, 
    this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.premultipliedAlpha = !1, 
    this.overdraw = 0, this._needsUpdate = this.visible = !0;
}, THREE.Material.prototype = {
    constructor: THREE.Material,
    get needsUpdate() {
        return this._needsUpdate;
    },
    set needsUpdate(a) {
        !0 === a && this.update(), this._needsUpdate = a;
    },
    setValues: function(a) {
        if (void 0 !== a) for (var b in a) {
            var c = a[b];
            if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined."); else {
                var d = this[b];
                void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c;
            }
        }
    },
    toJSON: function(a) {
        function b(a) {
            var b, c = [];
            for (b in a) {
                var d = a[b];
                delete d.metadata, c.push(d);
            }
            return c;
        }
        var c = void 0 === a;
        c && (a = {
            textures: {},
            images: {}
        });
        var d = {
            metadata: {
                version: 4.4,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        return d.uuid = this.uuid, d.type = this.type, "" !== this.name && (d.name = this.name), 
        this.color instanceof THREE.Color && (d.color = this.color.getHex()), .5 !== this.roughness && (d.roughness = this.roughness), 
        .5 !== this.metalness && (d.metalness = this.metalness), this.emissive instanceof THREE.Color && (d.emissive = this.emissive.getHex()), 
        this.specular instanceof THREE.Color && (d.specular = this.specular.getHex()), void 0 !== this.shininess && (d.shininess = this.shininess), 
        this.map instanceof THREE.Texture && (d.map = this.map.toJSON(a).uuid), this.alphaMap instanceof THREE.Texture && (d.alphaMap = this.alphaMap.toJSON(a).uuid), 
        this.lightMap instanceof THREE.Texture && (d.lightMap = this.lightMap.toJSON(a).uuid), 
        this.bumpMap instanceof THREE.Texture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, 
        d.bumpScale = this.bumpScale), this.normalMap instanceof THREE.Texture && (d.normalMap = this.normalMap.toJSON(a).uuid, 
        d.normalScale = this.normalScale.toArray()), this.displacementMap instanceof THREE.Texture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, 
        d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias), 
        this.roughnessMap instanceof THREE.Texture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid), 
        this.metalnessMap instanceof THREE.Texture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid), 
        this.emissiveMap instanceof THREE.Texture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid), 
        this.specularMap instanceof THREE.Texture && (d.specularMap = this.specularMap.toJSON(a).uuid), 
        this.envMap instanceof THREE.Texture && (d.envMap = this.envMap.toJSON(a).uuid, 
        d.reflectivity = this.reflectivity), void 0 !== this.size && (d.size = this.size), 
        void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation), this.blending !== THREE.NormalBlending && (d.blending = this.blending), 
        this.shading !== THREE.SmoothShading && (d.shading = this.shading), this.side !== THREE.FrontSide && (d.side = this.side), 
        this.vertexColors !== THREE.NoColors && (d.vertexColors = this.vertexColors), 1 > this.opacity && (d.opacity = this.opacity), 
        !0 === this.transparent && (d.transparent = this.transparent), 0 < this.alphaTest && (d.alphaTest = this.alphaTest), 
        !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha), 
        !0 === this.wireframe && (d.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth), 
        c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a)), 
        d;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        this.name = a.name, this.fog = a.fog, this.lights = a.lights, this.blending = a.blending, 
        this.side = a.side, this.vertexColors = a.vertexColors, this.opacity = a.opacity, 
        this.transparent = a.transparent, this.blendSrc = a.blendSrc, this.blendDst = a.blendDst, 
        this.blendEquation = a.blendEquation, this.blendSrcAlpha = a.blendSrcAlpha, this.blendDstAlpha = a.blendDstAlpha, 
        this.blendEquationAlpha = a.blendEquationAlpha, this.depthFunc = a.depthFunc, this.depthTest = a.depthTest, 
        this.depthWrite = a.depthWrite, this.colorWrite = a.colorWrite, this.precision = a.precision, 
        this.polygonOffset = a.polygonOffset, this.polygonOffsetFactor = a.polygonOffsetFactor, 
        this.polygonOffsetUnits = a.polygonOffsetUnits, this.alphaTest = a.alphaTest, this.premultipliedAlpha = a.premultipliedAlpha, 
        this.overdraw = a.overdraw, this.visible = a.visible, this.clipShadows = a.clipShadows, 
        a = a.clippingPlanes;
        var b = null;
        if (null !== a) for (var c = a.length, b = Array(c), d = 0; d !== c; ++d) b[d] = a[d].clone();
        return this.clippingPlanes = b, this;
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        });
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}, Object.assign(THREE.Material.prototype, THREE.EventDispatcher.prototype), THREE.MaterialIdCount = 0, 
THREE.LineBasicMaterial = function(a) {
    THREE.Material.call(this), this.type = "LineBasicMaterial", this.color = new THREE.Color(16777215), 
    this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(a);
}, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial, THREE.LineBasicMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, 
    this.linecap = a.linecap, this.linejoin = a.linejoin, this;
}, THREE.LineDashedMaterial = function(a) {
    THREE.Material.call(this), this.type = "LineDashedMaterial", this.color = new THREE.Color(16777215), 
    this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, 
    this.setValues(a);
}, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial, THREE.LineDashedMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, 
    this.scale = a.scale, this.dashSize = a.dashSize, this.gapSize = a.gapSize, this;
}, THREE.MeshBasicMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshBasicMaterial", this.color = new THREE.Color(16777215), 
    this.aoMap = this.map = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, 
    this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
    this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
    this.lights = this.morphTargets = this.skinning = !1, this.setValues(a);
}, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial, THREE.MeshBasicMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, 
    this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.specularMap = a.specularMap, 
    this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, 
    this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, 
    this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, 
    this.skinning = a.skinning, this.morphTargets = a.morphTargets, this;
}, THREE.MeshDepthMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshDepthMaterial", this.depthPacking = THREE.BasicDepthPacking, 
    this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, 
    this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.lights = this.fog = !1, this.setValues(a);
}, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial, THREE.MeshDepthMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.depthPacking = a.depthPacking, 
    this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.map = a.map, 
    this.alphaMap = a.alphaMap, this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, 
    this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, 
    this;
}, THREE.MeshLambertMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshLambertMaterial", this.color = new THREE.Color(16777215), 
    this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, 
    this.aoMapIntensity = 1, this.emissive = new THREE.Color(0), this.emissiveIntensity = 1, 
    this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = THREE.MultiplyOperation, 
    this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, 
    this.setValues(a);
}, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial, THREE.MeshLambertMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, 
    this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, 
    this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, 
    this.emissiveIntensity = a.emissiveIntensity, this.specularMap = a.specularMap, 
    this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, 
    this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, 
    this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, 
    this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, 
    this;
}, THREE.MeshNormalMaterial = function(a) {
    THREE.Material.call(this, a), this.type = "MeshNormalMaterial", this.wireframe = !1, 
    this.wireframeLinewidth = 1, this.morphTargets = this.lights = this.fog = !1, this.setValues(a);
}, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial, THREE.MeshNormalMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.wireframe = a.wireframe, 
    this.wireframeLinewidth = a.wireframeLinewidth, this;
}, THREE.MeshPhongMaterial = function(a) {
    THREE.Material.call(this), this.type = "MeshPhongMaterial", this.color = new THREE.Color(16777215), 
    this.specular = new THREE.Color(1118481), this.shininess = 30, this.lightMap = this.map = null, 
    this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new THREE.Color(0), 
    this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, 
    this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.displacementMap = null, 
    this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, 
    this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
    this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", 
    this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a);
}, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial, THREE.MeshPhongMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.specular.copy(a.specular), 
    this.shininess = a.shininess, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, 
    this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), 
    this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, 
    this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, 
    this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, 
    this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, 
    this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, 
    this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, 
    this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, 
    this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, 
    this.morphNormals = a.morphNormals, this;
}, THREE.MeshStandardMaterial = function(a) {
    THREE.Material.call(this), this.defines = {
        STANDARD: ""
    }, this.type = "MeshStandardMaterial", this.color = new THREE.Color(16777215), this.metalness = this.roughness = .5, 
    this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, 
    this.aoMapIntensity = 1, this.emissive = new THREE.Color(0), this.emissiveIntensity = 1, 
    this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, 
    this.normalScale = new THREE.Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, 
    this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, 
    this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, 
    this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, 
    this.setValues(a);
}, THREE.MeshStandardMaterial.prototype = Object.create(THREE.Material.prototype), 
THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial, THREE.MeshStandardMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.defines = {
        STANDARD: ""
    }, this.color.copy(a.color), this.roughness = a.roughness, this.metalness = a.metalness, 
    this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, 
    this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), 
    this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, 
    this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, 
    this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, 
    this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, 
    this.roughnessMap = a.roughnessMap, this.metalnessMap = a.metalnessMap, this.alphaMap = a.alphaMap, 
    this.envMap = a.envMap, this.envMapIntensity = a.envMapIntensity, this.refractionRatio = a.refractionRatio, 
    this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, 
    this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, 
    this.morphNormals = a.morphNormals, this;
}, THREE.MeshPhysicalMaterial = function(a) {
    THREE.MeshStandardMaterial.call(this), this.defines = {
        PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.setValues(a);
}, THREE.MeshPhysicalMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype), 
THREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial, THREE.MeshPhysicalMaterial.prototype.copy = function(a) {
    return THREE.MeshStandardMaterial.prototype.copy.call(this, a), this.defines = {
        PHYSICAL: ""
    }, this.reflectivity = a.reflectivity, this;
}, THREE.MultiMaterial = function(a) {
    this.uuid = THREE.Math.generateUUID(), this.type = "MultiMaterial", this.materials = a instanceof Array ? a : [], 
    this.visible = !0;
}, THREE.MultiMaterial.prototype = {
    constructor: THREE.MultiMaterial,
    toJSON: function(a) {
        for (var b = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        }, c = this.materials, d = 0, e = c.length; d < e; d++) {
            var f = c[d].toJSON(a);
            delete f.metadata, b.materials.push(f);
        }
        return b.visible = this.visible, b;
    },
    clone: function() {
        for (var a = new this.constructor(), b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
        return a.visible = this.visible, a;
    }
}, THREE.PointsMaterial = function(a) {
    THREE.Material.call(this), this.type = "PointsMaterial", this.color = new THREE.Color(16777215), 
    this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(a);
}, THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype), THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial, 
THREE.PointsMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, 
    this.size = a.size, this.sizeAttenuation = a.sizeAttenuation, this;
}, THREE.ShaderMaterial = function(a) {
    THREE.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, 
    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", 
    this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, 
    this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1
    }, this.defaultAttributeValues = {
        color: [ 1, 1, 1 ],
        uv: [ 0, 0 ],
        uv2: [ 0, 0 ]
    }, this.index0AttributeName = void 0, void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), 
    this.setValues(a));
}, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial, 
THREE.ShaderMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.fragmentShader = a.fragmentShader, 
    this.vertexShader = a.vertexShader, this.uniforms = THREE.UniformsUtils.clone(a.uniforms), 
    this.defines = a.defines, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, 
    this.lights = a.lights, this.clipping = a.clipping, this.skinning = a.skinning, 
    this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this.extensions = a.extensions, 
    this;
}, THREE.ShaderMaterial.prototype.toJSON = function(a) {
    return a = THREE.Material.prototype.toJSON.call(this, a), a.uniforms = this.uniforms, 
    a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader, a;
}, THREE.RawShaderMaterial = function(a) {
    THREE.ShaderMaterial.call(this, a), this.type = "RawShaderMaterial";
}, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), 
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial, THREE.SpriteMaterial = function(a) {
    THREE.Material.call(this), this.type = "SpriteMaterial", this.color = new THREE.Color(16777215), 
    this.map = null, this.rotation = 0, this.lights = this.fog = !1, this.setValues(a);
}, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial, 
THREE.SpriteMaterial.prototype.copy = function(a) {
    return THREE.Material.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, 
    this.rotation = a.rotation, this;
}, THREE.ShadowMaterial = function() {
    THREE.ShaderMaterial.call(this, {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.lights, {
            opacity: {
                value: 1
            }
        } ]),
        vertexShader: THREE.ShaderChunk.shadow_vert,
        fragmentShader: THREE.ShaderChunk.shadow_frag
    }), this.transparent = this.lights = !0, Object.defineProperties(this, {
        opacity: {
            enumerable: !0,
            get: function() {
                return this.uniforms.opacity.value;
            },
            set: function(a) {
                this.uniforms.opacity.value = a;
            }
        }
    });
}, THREE.ShadowMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), 
THREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial, THREE.Texture = function(a, b, c, d, e, f, g, h, i, j) {
    Object.defineProperty(this, "id", {
        value: THREE.TextureIdCount++
    }), this.uuid = THREE.Math.generateUUID(), this.sourceFile = this.name = "", this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE, 
    this.mipmaps = [], this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING, 
    this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping, 
    this.magFilter = void 0 !== e ? e : THREE.LinearFilter, this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter, 
    this.anisotropy = void 0 !== i ? i : 1, this.format = void 0 !== g ? g : THREE.RGBAFormat, 
    this.type = void 0 !== h ? h : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), 
    this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, 
    this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== j ? j : THREE.LinearEncoding, 
    this.version = 0, this.onUpdate = null;
}, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping, 
THREE.Texture.prototype = {
    constructor: THREE.Texture,
    set needsUpdate(a) {
        !0 === a && this.version++;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.image = a.image, this.mipmaps = a.mipmaps.slice(0), this.mapping = a.mapping, 
        this.wrapS = a.wrapS, this.wrapT = a.wrapT, this.magFilter = a.magFilter, this.minFilter = a.minFilter, 
        this.anisotropy = a.anisotropy, this.format = a.format, this.type = a.type, this.offset.copy(a.offset), 
        this.repeat.copy(a.repeat), this.generateMipmaps = a.generateMipmaps, this.premultiplyAlpha = a.premultiplyAlpha, 
        this.flipY = a.flipY, this.unpackAlignment = a.unpackAlignment, this.encoding = a.encoding, 
        this;
    },
    toJSON: function(a) {
        if (void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
        var b = {
            metadata: {
                version: 4.4,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [ this.repeat.x, this.repeat.y ],
            offset: [ this.offset.x, this.offset.y ],
            wrap: [ this.wrapS, this.wrapT ],
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };
        if (void 0 !== this.image) {
            var c = this.image;
            if (void 0 === c.uuid && (c.uuid = THREE.Math.generateUUID()), void 0 === a.images[c.uuid]) {
                var d, e = a.images, f = c.uuid, g = c.uuid;
                void 0 !== c.toDataURL ? d = c : (d = document.createElement("canvas"), d.width = c.width, 
                d.height = c.height, d.getContext("2d").drawImage(c, 0, 0, c.width, c.height)), 
                d = 2048 < d.width || 2048 < d.height ? d.toDataURL("image/jpeg", .6) : d.toDataURL("image/png"), 
                e[f] = {
                    uuid: g,
                    url: d
                };
            }
            b.image = c.uuid;
        }
        return a.textures[this.uuid] = b;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    },
    transformUv: function(a) {
        if (this.mapping === THREE.UVMapping) {
            if (a.multiply(this.repeat), a.add(this.offset), 0 > a.x || 1 < a.x) switch (this.wrapS) {
              case THREE.RepeatWrapping:
                a.x -= Math.floor(a.x);
                break;

              case THREE.ClampToEdgeWrapping:
                a.x = 0 > a.x ? 0 : 1;
                break;

              case THREE.MirroredRepeatWrapping:
                1 === Math.abs(Math.floor(a.x) % 2) ? a.x = Math.ceil(a.x) - a.x : a.x -= Math.floor(a.x);
            }
            if (0 > a.y || 1 < a.y) switch (this.wrapT) {
              case THREE.RepeatWrapping:
                a.y -= Math.floor(a.y);
                break;

              case THREE.ClampToEdgeWrapping:
                a.y = 0 > a.y ? 0 : 1;
                break;

              case THREE.MirroredRepeatWrapping:
                1 === Math.abs(Math.floor(a.y) % 2) ? a.y = Math.ceil(a.y) - a.y : a.y -= Math.floor(a.y);
            }
            this.flipY && (a.y = 1 - a.y);
        }
    }
}, Object.assign(THREE.Texture.prototype, THREE.EventDispatcher.prototype), THREE.TextureIdCount = 0, 
THREE.DepthTexture = function(a, b, c, d, e, f, g, h, i) {
    THREE.Texture.call(this, null, d, e, f, g, h, THREE.DepthFormat, c, i), this.image = {
        width: a,
        height: b
    }, this.type = void 0 !== c ? c : THREE.UnsignedShortType, this.magFilter = void 0 !== g ? g : THREE.NearestFilter, 
    this.minFilter = void 0 !== h ? h : THREE.NearestFilter, this.generateMipmaps = this.flipY = !1;
}, THREE.DepthTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DepthTexture.prototype.constructor = THREE.DepthTexture, 
THREE.CanvasTexture = function(a, b, c, d, e, f, g, h, i) {
    THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), this.needsUpdate = !0;
}, THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture, 
THREE.CubeTexture = function(a, b, c, d, e, f, g, h, i, j) {
    a = void 0 !== a ? a : [], b = void 0 !== b ? b : THREE.CubeReflectionMapping, THREE.Texture.call(this, a, b, c, d, e, f, g, h, i, j), 
    this.flipY = !1;
}, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.prototype.constructor = THREE.CubeTexture, 
Object.defineProperty(THREE.CubeTexture.prototype, "images", {
    get: function() {
        return this.image;
    },
    set: function(a) {
        this.image = a;
    }
}), THREE.CompressedTexture = function(a, b, c, d, e, f, g, h, i, j, k, l) {
    THREE.Texture.call(this, null, f, g, h, i, j, d, e, k, l), this.image = {
        width: b,
        height: c
    }, this.mipmaps = a, this.generateMipmaps = this.flipY = !1;
}, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture, 
THREE.DataTexture = function(a, b, c, d, e, f, g, h, i, j, k, l) {
    THREE.Texture.call(this, null, f, g, h, i, j, d, e, k, l), this.image = {
        data: a,
        width: b,
        height: c
    }, this.magFilter = void 0 !== i ? i : THREE.NearestFilter, this.minFilter = void 0 !== j ? j : THREE.NearestFilter, 
    this.generateMipmaps = this.flipY = !1;
}, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.constructor = THREE.DataTexture, 
THREE.VideoTexture = function(a, b, c, d, e, f, g, h, i) {
    function j() {
        requestAnimationFrame(j), a.readyState >= a.HAVE_CURRENT_DATA && (k.needsUpdate = !0);
    }
    THREE.Texture.call(this, a, b, c, d, e, f, g, h, i), this.generateMipmaps = !1;
    var k = this;
    j();
}, THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype), THREE.VideoTexture.prototype.constructor = THREE.VideoTexture, 
THREE.Group = function() {
    THREE.Object3D.call(this), this.type = "Group";
}, THREE.Group.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.Group
}), THREE.Points = function(a, b) {
    THREE.Object3D.call(this), this.type = "Points", this.geometry = void 0 !== a ? a : new THREE.BufferGeometry(), 
    this.material = void 0 !== b ? b : new THREE.PointsMaterial({
        color: 16777215 * Math.random()
    });
}, THREE.Points.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.Points,
    raycast: function() {
        var a = new THREE.Matrix4(), b = new THREE.Ray(), c = new THREE.Sphere();
        return function(d, e) {
            function f(a, c) {
                var f = b.distanceSqToPoint(a);
                if (f < k) {
                    var h = b.closestPointToPoint(a);
                    h.applyMatrix4(i);
                    var j = d.ray.origin.distanceTo(h);
                    j < d.near || j > d.far || e.push({
                        distance: j,
                        distanceToRay: Math.sqrt(f),
                        point: h.clone(),
                        index: c,
                        face: null,
                        object: g
                    });
                }
            }
            var g = this, h = this.geometry, i = this.matrixWorld, j = d.params.Points.threshold;
            if (null === h.boundingSphere && h.computeBoundingSphere(), c.copy(h.boundingSphere), 
            c.applyMatrix4(i), !1 !== d.ray.intersectsSphere(c)) {
                a.getInverse(i), b.copy(d.ray).applyMatrix4(a);
                var j = j / ((this.scale.x + this.scale.y + this.scale.z) / 3), k = j * j, j = new THREE.Vector3();
                if (h instanceof THREE.BufferGeometry) {
                    var l = h.index, h = h.attributes.position.array;
                    if (null !== l) for (var m = l.array, l = 0, n = m.length; l < n; l++) {
                        var o = m[l];
                        j.fromArray(h, 3 * o), f(j, o);
                    } else for (l = 0, m = h.length / 3; l < m; l++) j.fromArray(h, 3 * l), f(j, l);
                } else for (j = h.vertices, l = 0, m = j.length; l < m; l++) f(j[l], l);
            }
        };
    }(),
    clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
}), THREE.Line = function(a, b, c) {
    return 1 === c ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), 
    new THREE.LineSegments(a, b)) : (THREE.Object3D.call(this), this.type = "Line", 
    this.geometry = void 0 !== a ? a : new THREE.BufferGeometry(), void (this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
        color: 16777215 * Math.random()
    })));
}, THREE.Line.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.Line,
    raycast: function() {
        var a = new THREE.Matrix4(), b = new THREE.Ray(), c = new THREE.Sphere();
        return function(d, e) {
            var f = d.linePrecision, f = f * f, g = this.geometry, h = this.matrixWorld;
            if (null === g.boundingSphere && g.computeBoundingSphere(), c.copy(g.boundingSphere), 
            c.applyMatrix4(h), !1 !== d.ray.intersectsSphere(c)) {
                a.getInverse(h), b.copy(d.ray).applyMatrix4(a);
                var i = new THREE.Vector3(), j = new THREE.Vector3(), h = new THREE.Vector3(), k = new THREE.Vector3(), l = this instanceof THREE.LineSegments ? 2 : 1;
                if (g instanceof THREE.BufferGeometry) {
                    var m = g.index, n = g.attributes.position.array;
                    if (null !== m) for (var m = m.array, g = 0, o = m.length - 1; g < o; g += l) {
                        var p = m[g + 1];
                        i.fromArray(n, 3 * m[g]), j.fromArray(n, 3 * p), p = b.distanceSqToSegment(i, j, k, h), 
                        p > f || (k.applyMatrix4(this.matrixWorld), p = d.ray.origin.distanceTo(k), p < d.near || p > d.far || e.push({
                            distance: p,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: g,
                            face: null,
                            faceIndex: null,
                            object: this
                        }));
                    } else for (g = 0, o = n.length / 3 - 1; g < o; g += l) i.fromArray(n, 3 * g), j.fromArray(n, 3 * g + 3), 
                    p = b.distanceSqToSegment(i, j, k, h), p > f || (k.applyMatrix4(this.matrixWorld), 
                    p = d.ray.origin.distanceTo(k), p < d.near || p > d.far || e.push({
                        distance: p,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: g,
                        face: null,
                        faceIndex: null,
                        object: this
                    }));
                } else if (g instanceof THREE.Geometry) for (i = g.vertices, j = i.length, g = 0; g < j - 1; g += l) p = b.distanceSqToSegment(i[g], i[g + 1], k, h), 
                p > f || (k.applyMatrix4(this.matrixWorld), p = d.ray.origin.distanceTo(k), p < d.near || p > d.far || e.push({
                    distance: p,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: g,
                    face: null,
                    faceIndex: null,
                    object: this
                }));
            }
        };
    }(),
    clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
}), THREE.LineSegments = function(a, b) {
    THREE.Line.call(this, a, b), this.type = "LineSegments";
}, THREE.LineSegments.prototype = Object.assign(Object.create(THREE.Line.prototype), {
    constructor: THREE.LineSegments
}), THREE.Mesh = function(a, b) {
    THREE.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new THREE.BufferGeometry(), 
    this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
        color: 16777215 * Math.random()
    }), this.drawMode = THREE.TrianglesDrawMode, this.updateMorphTargets();
}, THREE.Mesh.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.Mesh,
    setDrawMode: function(a) {
        this.drawMode = a;
    },
    updateMorphTargets: function() {
        if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
            this.morphTargetBase = -1, this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++) this.morphTargetInfluences.push(0), 
            this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;
        }
    },
    getMorphTargetIndexByName: function(a) {
        return void 0 !== this.morphTargetDictionary[a] ? this.morphTargetDictionary[a] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0."), 
        0);
    },
    raycast: function() {
        function a(a, b, c, d, e, f, g) {
            return THREE.Triangle.barycoordFromPoint(a, b, c, d, p), e.multiplyScalar(p.x), 
            f.multiplyScalar(p.y), g.multiplyScalar(p.z), e.add(f).add(g), e.clone();
        }
        function b(a, b, c, d, e, f, g) {
            var h = a.material;
            return null === (h.side === THREE.BackSide ? c.intersectTriangle(f, e, d, !0, g) : c.intersectTriangle(d, e, f, h.side !== THREE.DoubleSide, g)) ? null : (r.copy(g), 
            r.applyMatrix4(a.matrixWorld), c = b.ray.origin.distanceTo(r), c < b.near || c > b.far ? null : {
                distance: c,
                point: r.clone(),
                object: a
            });
        }
        function c(c, d, e, f, j, k, l, p) {
            return g.fromArray(f, 3 * k), h.fromArray(f, 3 * l), i.fromArray(f, 3 * p), (c = b(c, d, e, g, h, i, q)) && (j && (m.fromArray(j, 2 * k), 
            n.fromArray(j, 2 * l), o.fromArray(j, 2 * p), c.uv = a(q, g, h, i, m, n, o)), c.face = new THREE.Face3(k, l, p, THREE.Triangle.normal(g, h, i)), 
            c.faceIndex = k), c;
        }
        var d = new THREE.Matrix4(), e = new THREE.Ray(), f = new THREE.Sphere(), g = new THREE.Vector3(), h = new THREE.Vector3(), i = new THREE.Vector3(), j = new THREE.Vector3(), k = new THREE.Vector3(), l = new THREE.Vector3(), m = new THREE.Vector2(), n = new THREE.Vector2(), o = new THREE.Vector2(), p = new THREE.Vector3(), q = new THREE.Vector3(), r = new THREE.Vector3();
        return function(p, r) {
            var s = this.geometry, t = this.material, u = this.matrixWorld;
            if (void 0 !== t && (null === s.boundingSphere && s.computeBoundingSphere(), f.copy(s.boundingSphere), 
            f.applyMatrix4(u), !1 !== p.ray.intersectsSphere(f) && (d.getInverse(u), e.copy(p.ray).applyMatrix4(d), 
            null === s.boundingBox || !1 !== e.intersectsBox(s.boundingBox)))) {
                var v, w;
                if (s instanceof THREE.BufferGeometry) {
                    var x, y, t = s.index, u = s.attributes, s = u.position.array;
                    if (void 0 !== u.uv && (v = u.uv.array), null !== t) for (var u = t.array, z = 0, A = u.length; z < A; z += 3) t = u[z], 
                    x = u[z + 1], y = u[z + 2], (w = c(this, p, e, s, v, t, x, y)) && (w.faceIndex = Math.floor(z / 3), 
                    r.push(w)); else for (z = 0, A = s.length; z < A; z += 9) t = z / 3, x = t + 1, 
                    y = t + 2, (w = c(this, p, e, s, v, t, x, y)) && (w.index = t, r.push(w));
                } else if (s instanceof THREE.Geometry) {
                    var B, C, u = t instanceof THREE.MultiMaterial, z = !0 === u ? t.materials : null, A = s.vertices;
                    x = s.faces, y = s.faceVertexUvs[0], 0 < y.length && (v = y);
                    for (var D = 0, E = x.length; D < E; D++) {
                        var F = x[D];
                        if (w = !0 === u ? z[F.materialIndex] : t, void 0 !== w) {
                            if (y = A[F.a], B = A[F.b], C = A[F.c], !0 === w.morphTargets) {
                                w = s.morphTargets;
                                var G = this.morphTargetInfluences;
                                g.set(0, 0, 0), h.set(0, 0, 0), i.set(0, 0, 0);
                                for (var H = 0, I = w.length; H < I; H++) {
                                    var J = G[H];
                                    if (0 !== J) {
                                        var K = w[H].vertices;
                                        g.addScaledVector(j.subVectors(K[F.a], y), J), h.addScaledVector(k.subVectors(K[F.b], B), J), 
                                        i.addScaledVector(l.subVectors(K[F.c], C), J);
                                    }
                                }
                                g.add(y), h.add(B), i.add(C), y = g, B = h, C = i;
                            }
                            (w = b(this, p, e, y, B, C, q)) && (v && (G = v[D], m.copy(G[0]), n.copy(G[1]), 
                            o.copy(G[2]), w.uv = a(q, y, B, C, m, n, o)), w.face = F, w.faceIndex = D, r.push(w));
                        }
                    }
                }
            }
        };
    }(),
    clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
}), THREE.Bone = function(a) {
    THREE.Object3D.call(this), this.type = "Bone", this.skin = a;
}, THREE.Bone.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.Bone,
    copy: function(a) {
        return THREE.Object3D.prototype.copy.call(this, a), this.skin = a.skin, this;
    }
}), THREE.Skeleton = function(a, b, c) {
    if (this.useVertexTexture = void 0 === c || c, this.identityMatrix = new THREE.Matrix4(), 
    a = a || [], this.bones = a.slice(0), this.useVertexTexture ? (a = Math.sqrt(4 * this.bones.length), 
    a = THREE.Math.nextPowerOfTwo(Math.ceil(a)), this.boneTextureHeight = this.boneTextureWidth = a = Math.max(a, 4), 
    this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), 
    this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType)) : this.boneMatrices = new Float32Array(16 * this.bones.length), 
    void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (console.warn("THREE.Skeleton bonInverses is the wrong length."), 
    this.boneInverses = [], b = 0, a = this.bones.length; b < a; b++) this.boneInverses.push(new THREE.Matrix4());
}, Object.assign(THREE.Skeleton.prototype, {
    calculateInverses: function() {
        this.boneInverses = [];
        for (var a = 0, b = this.bones.length; a < b; a++) {
            var c = new THREE.Matrix4();
            this.bones[a] && c.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(c);
        }
    },
    pose: function() {
        for (var a, b = 0, c = this.bones.length; b < c; b++) (a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
        for (b = 0, c = this.bones.length; b < c; b++) (a = this.bones[b]) && (a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), 
        a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale));
    },
    update: function() {
        var a = new THREE.Matrix4();
        return function() {
            for (var b = 0, c = this.bones.length; b < c; b++) a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix, this.boneInverses[b]), 
            a.toArray(this.boneMatrices, 16 * b);
            this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
        };
    }(),
    clone: function() {
        return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
    }
}), THREE.SkinnedMesh = function(a, b, c) {
    if (THREE.Mesh.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", 
    this.bindMatrix = new THREE.Matrix4(), this.bindMatrixInverse = new THREE.Matrix4(), 
    a = [], this.geometry && void 0 !== this.geometry.bones) {
        for (var d, e = 0, f = this.geometry.bones.length; e < f; ++e) d = this.geometry.bones[e], 
        b = new THREE.Bone(this), a.push(b), b.name = d.name, b.position.fromArray(d.pos), 
        b.quaternion.fromArray(d.rotq), void 0 !== d.scl && b.scale.fromArray(d.scl);
        for (e = 0, f = this.geometry.bones.length; e < f; ++e) d = this.geometry.bones[e], 
        -1 !== d.parent && null !== d.parent && void 0 !== a[d.parent] ? a[d.parent].add(a[e]) : this.add(a[e]);
    }
    this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(a, void 0, c), this.matrixWorld);
}, THREE.SkinnedMesh.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {
    constructor: THREE.SkinnedMesh,
    bind: function(a, b) {
        this.skeleton = a, void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), 
        b = this.matrixWorld), this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b);
    },
    pose: function() {
        this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
        if (this.geometry instanceof THREE.Geometry) for (var a = 0; a < this.geometry.skinWeights.length; a++) {
            var b = this.geometry.skinWeights[a], c = 1 / b.lengthManhattan();
            1 / 0 !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0);
        } else if (this.geometry instanceof THREE.BufferGeometry) for (var b = new THREE.Vector4(), d = this.geometry.attributes.skinWeight, a = 0; a < d.count; a++) b.x = d.getX(a), 
        b.y = d.getY(a), b.z = d.getZ(a), b.w = d.getW(a), c = 1 / b.lengthManhattan(), 
        1 / 0 !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0), d.setXYZW(a, b.x, b.y, b.z, b.w);
    },
    updateMatrixWorld: function(a) {
        THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode);
    },
    clone: function() {
        return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this);
    }
}), THREE.LOD = function() {
    THREE.Object3D.call(this), this.type = "LOD", Object.defineProperties(this, {
        levels: {
            enumerable: !0,
            value: []
        }
    });
}, THREE.LOD.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.LOD,
    copy: function(a) {
        THREE.Object3D.prototype.copy.call(this, a, !1), a = a.levels;
        for (var b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            this.addLevel(d.object.clone(), d.distance);
        }
        return this;
    },
    addLevel: function(a, b) {
        void 0 === b && (b = 0), b = Math.abs(b);
        for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++) ;
        c.splice(d, 0, {
            distance: b,
            object: a
        }), this.add(a);
    },
    getObjectForDistance: function(a) {
        for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++) ;
        return b[c - 1].object;
    },
    raycast: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            a.setFromMatrixPosition(this.matrixWorld);
            var d = b.ray.origin.distanceTo(a);
            this.getObjectForDistance(d).raycast(b, c);
        };
    }(),
    update: function() {
        var a = new THREE.Vector3(), b = new THREE.Vector3();
        return function(c) {
            var d = this.levels;
            if (1 < d.length) {
                a.setFromMatrixPosition(c.matrixWorld), b.setFromMatrixPosition(this.matrixWorld), 
                c = a.distanceTo(b), d[0].object.visible = !0;
                for (var e = 1, f = d.length; e < f && c >= d[e].distance; e++) d[e - 1].object.visible = !1, 
                d[e].object.visible = !0;
                for (;e < f; e++) d[e].object.visible = !1;
            }
        };
    }(),
    toJSON: function(a) {
        a = THREE.Object3D.prototype.toJSON.call(this, a), a.object.levels = [];
        for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            a.object.levels.push({
                object: e.object.uuid,
                distance: e.distance
            });
        }
        return a;
    }
}), THREE.Sprite = function(a) {
    THREE.Object3D.call(this), this.type = "Sprite", this.material = void 0 !== a ? a : new THREE.SpriteMaterial();
}, THREE.Sprite.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.Sprite,
    raycast: function() {
        var a = new THREE.Vector3();
        return function(b, c) {
            a.setFromMatrixPosition(this.matrixWorld);
            var d = b.ray.distanceSqToPoint(a);
            d > this.scale.x * this.scale.y / 4 || c.push({
                distance: Math.sqrt(d),
                point: this.position,
                face: null,
                object: this
            });
        };
    }(),
    clone: function() {
        return new this.constructor(this.material).copy(this);
    }
}), THREE.LensFlare = function(a, b, c, d, e) {
    THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3(), 
    this.customUpdateCallback = void 0, void 0 !== a && this.add(a, b, c, d, e);
}, THREE.LensFlare.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
    constructor: THREE.LensFlare,
    copy: function(a) {
        THREE.Object3D.prototype.copy.call(this, a), this.positionScreen.copy(a.positionScreen), 
        this.customUpdateCallback = a.customUpdateCallback;
        for (var b = 0, c = a.lensFlares.length; b < c; b++) this.lensFlares.push(a.lensFlares[b]);
        return this;
    },
    add: function(a, b, c, d, e, f) {
        void 0 === b && (b = -1), void 0 === c && (c = 0), void 0 === f && (f = 1), void 0 === e && (e = new THREE.Color(16777215)), 
        void 0 === d && (d = THREE.NormalBlending), c = Math.min(c, Math.max(0, c)), this.lensFlares.push({
            texture: a,
            size: b,
            distance: c,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 0,
            opacity: f,
            color: e,
            blending: d
        });
    },
    updateLensFlares: function() {
        var a, b, c = this.lensFlares.length, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
        for (a = 0; a < c; a++) b = this.lensFlares[a], b.x = this.positionScreen.x + d * b.distance, 
        b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, 
        b.rotation += .25 * (b.wantedRotation - b.rotation);
    }
}), THREE.Scene = function() {
    THREE.Object3D.call(this), this.type = "Scene", this.overrideMaterial = this.fog = null, 
    this.autoUpdate = !0;
}, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.constructor = THREE.Scene, 
THREE.Scene.prototype.copy = function(a, b) {
    return THREE.Object3D.prototype.copy.call(this, a, b), null !== a.fog && (this.fog = a.fog.clone()), 
    null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()), 
    this.autoUpdate = a.autoUpdate, this.matrixAutoUpdate = a.matrixAutoUpdate, this;
}, THREE.Fog = function(a, b, c) {
    this.name = "", this.color = new THREE.Color(a), this.near = void 0 !== b ? b : 1, 
    this.far = void 0 !== c ? c : 1e3;
}, THREE.Fog.prototype.clone = function() {
    return new THREE.Fog(this.color.getHex(), this.near, this.far);
}, THREE.FogExp2 = function(a, b) {
    this.name = "", this.color = new THREE.Color(a), this.density = void 0 !== b ? b : 25e-5;
}, THREE.FogExp2.prototype.clone = function() {
    return new THREE.FogExp2(this.color.getHex(), this.density);
}, THREE.ShaderChunk = {}, THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", 
THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n", 
THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", 
THREE.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n", 
THREE.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", 
THREE.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n", THREE.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n", 
THREE.ShaderChunk.bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", 
THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n", 
THREE.ShaderChunk.clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n", 
THREE.ShaderChunk.clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", 
THREE.ShaderChunk.clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n", 
THREE.ShaderChunk.clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n", 
THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", 
THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n", 
THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", 
THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", 
THREE.ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n", 
THREE.ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n", 
THREE.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n", 
THREE.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", 
THREE.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n", 
THREE.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", 
THREE.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n", 
THREE.ShaderChunk.encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n", 
THREE.ShaderChunk.encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", 
THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n", 
THREE.ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n", 
THREE.ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n", 
THREE.ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n", 
THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", 
THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", 
THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", 
THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", 
THREE.ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n", 
THREE.ShaderChunk.lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n", 
THREE.ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", 
THREE.ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n", 
THREE.ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#endif\n", 
THREE.ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t#endif\n};\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", 
THREE.ShaderChunk.lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n", 
THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif", 
THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n", 
THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif", 
THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n", 
THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n", 
THREE.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n", 
THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", 
THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n", 
THREE.ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n", 
THREE.ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", 
THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", 
THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", 
THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n", 
THREE.ShaderChunk.normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", 
THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n", 
THREE.ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", 
THREE.ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", 
THREE.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n", 
THREE.ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

THREE.ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n", 
THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n", 
THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n", 
THREE.ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n", 
THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", 
THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n", 
THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n", 
THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", 
THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", 
THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", 
THREE.ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", 
THREE.ShaderChunk.tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", 
THREE.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", 
THREE.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", 
THREE.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", 
THREE.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", 
THREE.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n", 
THREE.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif", 
THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n", 
THREE.UniformsUtils = {
    merge: function(a) {
        for (var b = {}, c = 0; c < a.length; c++) {
            var d, e = this.clone(a[c]);
            for (d in e) b[d] = e[d];
        }
        return b;
    },
    clone: function(a) {
        var b, c = {};
        for (b in a) {
            c[b] = {};
            for (var d in a[b]) {
                var e = a[b][d];
                e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix3 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? c[b][d] = e.clone() : Array.isArray(e) ? c[b][d] = e.slice() : c[b][d] = e;
            }
        }
        return c;
    }
}, THREE.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "1f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        specularMap: {
            type: "t",
            value: null
        },
        alphaMap: {
            type: "t",
            value: null
        },
        envMap: {
            type: "t",
            value: null
        },
        flipEnvMap: {
            type: "1f",
            value: -1
        },
        reflectivity: {
            type: "1f",
            value: 1
        },
        refractionRatio: {
            type: "1f",
            value: .98
        }
    },
    aomap: {
        aoMap: {
            type: "t",
            value: null
        },
        aoMapIntensity: {
            type: "1f",
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            type: "t",
            value: null
        },
        lightMapIntensity: {
            type: "1f",
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            type: "t",
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            type: "t",
            value: null
        },
        bumpScale: {
            type: "1f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null
        },
        normalScale: {
            type: "v2",
            value: new THREE.Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            type: "t",
            value: null
        },
        displacementScale: {
            type: "1f",
            value: 1
        },
        displacementBias: {
            type: "1f",
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            type: "t",
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            type: "t",
            value: null
        }
    },
    fog: {
        fogDensity: {
            type: "1f",
            value: 25e-5
        },
        fogNear: {
            type: "1f",
            value: 1
        },
        fogFar: {
            type: "1f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "3fv",
            value: []
        },
        directionalLights: {
            type: "sa",
            value: [],
            properties: {
                direction: {
                    type: "v3"
                },
                color: {
                    type: "c"
                },
                shadow: {
                    type: "1i"
                },
                shadowBias: {
                    type: "1f"
                },
                shadowRadius: {
                    type: "1f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        directionalShadowMap: {
            type: "tv",
            value: []
        },
        directionalShadowMatrix: {
            type: "m4v",
            value: []
        },
        spotLights: {
            type: "sa",
            value: [],
            properties: {
                color: {
                    type: "c"
                },
                position: {
                    type: "v3"
                },
                direction: {
                    type: "v3"
                },
                distance: {
                    type: "1f"
                },
                coneCos: {
                    type: "1f"
                },
                penumbraCos: {
                    type: "1f"
                },
                decay: {
                    type: "1f"
                },
                shadow: {
                    type: "1i"
                },
                shadowBias: {
                    type: "1f"
                },
                shadowRadius: {
                    type: "1f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        spotShadowMap: {
            type: "tv",
            value: []
        },
        spotShadowMatrix: {
            type: "m4v",
            value: []
        },
        pointLights: {
            type: "sa",
            value: [],
            properties: {
                color: {
                    type: "c"
                },
                position: {
                    type: "v3"
                },
                decay: {
                    type: "1f"
                },
                distance: {
                    type: "1f"
                },
                shadow: {
                    type: "1i"
                },
                shadowBias: {
                    type: "1f"
                },
                shadowRadius: {
                    type: "1f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        pointShadowMap: {
            type: "tv",
            value: []
        },
        pointShadowMatrix: {
            type: "m4v",
            value: []
        },
        hemisphereLights: {
            type: "sa",
            value: [],
            properties: {
                direction: {
                    type: "v3"
                },
                skyColor: {
                    type: "c"
                },
                groundColor: {
                    type: "c"
                }
            }
        }
    },
    points: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "1f",
            value: 1
        },
        size: {
            type: "1f",
            value: 1
        },
        scale: {
            type: "1f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        }
    }
}, THREE.ShaderChunk.cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\t#include <logdepthbuf_fragment>\n}\n", 
THREE.ShaderChunk.cube_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", 
THREE.ShaderChunk.depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n", 
THREE.ShaderChunk.depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", 
THREE.ShaderChunk.distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n", 
THREE.ShaderChunk.distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n", 
THREE.ShaderChunk.equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <logdepthbuf_fragment>\n}\n", 
THREE.ShaderChunk.equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", 
THREE.ShaderChunk.linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
THREE.ShaderChunk.linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", 
THREE.ShaderChunk.meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
THREE.ShaderChunk.meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n", 
THREE.ShaderChunk.meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
THREE.ShaderChunk.meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
THREE.ShaderChunk.meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
THREE.ShaderChunk.meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
THREE.ShaderChunk.meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
THREE.ShaderChunk.meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
THREE.ShaderChunk.normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n", 
THREE.ShaderChunk.normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", 
THREE.ShaderChunk.points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", 
THREE.ShaderChunk.points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
THREE.ShaderChunk.shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n", 
THREE.ShaderChunk.shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", 
THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.fog ]),
        vertexShader: THREE.ShaderChunk.meshbasic_vert,
        fragmentShader: THREE.ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            }
        } ]),
        vertexShader: THREE.ShaderChunk.meshlambert_vert,
        fragmentShader: THREE.ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "1f",
                value: 30
            }
        } ]),
        vertexShader: THREE.ShaderChunk.meshphong_vert,
        fragmentShader: THREE.ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.roughnessmap, THREE.UniformsLib.metalnessmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            roughness: {
                type: "1f",
                value: .5
            },
            metalness: {
                type: "1f",
                value: 0
            },
            envMapIntensity: {
                type: "1f",
                value: 1
            }
        } ]),
        vertexShader: THREE.ShaderChunk.meshphysical_vert,
        fragmentShader: THREE.ShaderChunk.meshphysical_frag
    },
    points: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.points, THREE.UniformsLib.fog ]),
        vertexShader: THREE.ShaderChunk.points_vert,
        fragmentShader: THREE.ShaderChunk.points_frag
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.fog, {
            scale: {
                type: "1f",
                value: 1
            },
            dashSize: {
                type: "1f",
                value: 1
            },
            totalSize: {
                type: "1f",
                value: 2
            }
        } ]),
        vertexShader: THREE.ShaderChunk.linedashed_vert,
        fragmentShader: THREE.ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.common, THREE.UniformsLib.displacementmap ]),
        vertexShader: THREE.ShaderChunk.depth_vert,
        fragmentShader: THREE.ShaderChunk.depth_frag
    },
    normal: {
        uniforms: {
            opacity: {
                type: "1f",
                value: 1
            }
        },
        vertexShader: THREE.ShaderChunk.normal_vert,
        fragmentShader: THREE.ShaderChunk.normal_frag
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "1f",
                value: -1
            }
        },
        vertexShader: THREE.ShaderChunk.cube_vert,
        fragmentShader: THREE.ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "1f",
                value: -1
            }
        },
        vertexShader: THREE.ShaderChunk.equirect_vert,
        fragmentShader: THREE.ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: {
            lightPos: {
                type: "v3",
                value: new THREE.Vector3()
            }
        },
        vertexShader: THREE.ShaderChunk.distanceRGBA_vert,
        fragmentShader: THREE.ShaderChunk.distanceRGBA_frag
    }
}, THREE.ShaderLib.physical = {
    uniforms: THREE.UniformsUtils.merge([ THREE.ShaderLib.standard.uniforms, {} ]),
    vertexShader: THREE.ShaderChunk.meshphysical_vert,
    fragmentShader: THREE.ShaderChunk.meshphysical_frag
}, THREE.WebGLRenderer = function(a) {
    function b(a, b, c, d) {
        !0 === G && (a *= d, b *= d, c *= d), va.clearColor(a, b, c, d);
    }
    function c() {
        va.init(), va.scissor(X.copy(ea).multiplyScalar(da)), va.viewport(Z.copy(ga).multiplyScalar(da)), 
        b(_.r, _.g, _.b, aa);
    }
    function d() {
        W = R = null, V = "", U = -1, va.reset();
    }
    function e(a) {
        a.preventDefault(), d(), c(), wa.clear();
    }
    function f(a) {
        a = a.target, a.removeEventListener("dispose", f);
        a: {
            var b = wa.get(a);
            if (a.image && b.__image__webglTextureCube) ra.deleteTexture(b.__image__webglTextureCube); else {
                if (void 0 === b.__webglInit) break a;
                ra.deleteTexture(b.__webglTexture);
            }
            wa.delete(a);
        }
        pa.textures--;
    }
    function g(a) {
        a = a.target, a.removeEventListener("dispose", g);
        var b = wa.get(a), c = wa.get(a.texture);
        if (a) {
            if (void 0 !== c.__webglTexture && ra.deleteTexture(c.__webglTexture), a.depthTexture && a.depthTexture.dispose(), 
            a instanceof THREE.WebGLRenderTargetCube) for (c = 0; 6 > c; c++) ra.deleteFramebuffer(b.__webglFramebuffer[c]), 
            b.__webglDepthbuffer && ra.deleteRenderbuffer(b.__webglDepthbuffer[c]); else ra.deleteFramebuffer(b.__webglFramebuffer), 
            b.__webglDepthbuffer && ra.deleteRenderbuffer(b.__webglDepthbuffer);
            wa.delete(a.texture), wa.delete(a);
        }
        pa.textures--;
    }
    function h(a) {
        a = a.target, a.removeEventListener("dispose", h), i(a), wa.delete(a);
    }
    function i(a) {
        var b = wa.get(a).program;
        a.program = void 0, void 0 !== b && ya.releaseProgram(b);
    }
    function j(a, b) {
        return Math.abs(b[0]) - Math.abs(a[0]);
    }
    function k(a, b) {
        return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
    }
    function l(a, b) {
        return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;
    }
    function m(a, b, c, d, e) {
        var f;
        c.transparent ? (d = L, f = ++M) : (d = J, f = ++K), f = d[f], void 0 !== f ? (f.id = a.id, 
        f.object = a, f.geometry = b, f.material = c, f.z = na.z, f.group = e) : (f = {
            id: a.id,
            object: a,
            geometry: b,
            material: c,
            z: na.z,
            group: e
        }, d.push(f));
    }
    function n(a) {
        if (!ha.intersectsSphere(a)) return !1;
        var b = ia.numPlanes;
        if (0 === b) return !0;
        var c = Q.clippingPlanes, d = a.center;
        a = -a.radius;
        var e = 0;
        do if (c[e].distanceToPoint(d) < a) return !1; while (++e !== b);
        return !0;
    }
    function o(a, b) {
        if (!1 !== a.visible) {
            if (a.layers.test(b.layers)) if (a instanceof THREE.Light) I.push(a); else if (a instanceof THREE.Sprite) {
                var c;
                (c = !1 === a.frustumCulled) || (la.center.set(0, 0, 0), la.radius = .7071067811865476, 
                la.applyMatrix4(a.matrixWorld), c = !0 === n(la)), c && O.push(a);
            } else if (a instanceof THREE.LensFlare) P.push(a); else if (a instanceof THREE.ImmediateRenderObject) !0 === Q.sortObjects && (na.setFromMatrixPosition(a.matrixWorld), 
            na.applyProjection(ma)), m(a, null, a.material, na.z, null); else if ((a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Points) && (a instanceof THREE.SkinnedMesh && a.skeleton.update(), 
            (c = !1 === a.frustumCulled) || (c = a.geometry, null === c.boundingSphere && c.computeBoundingSphere(), 
            la.copy(c.boundingSphere).applyMatrix4(a.matrixWorld), c = !0 === n(la)), c)) {
                var d = a.material;
                if (!0 === d.visible) if (!0 === Q.sortObjects && (na.setFromMatrixPosition(a.matrixWorld), 
                na.applyProjection(ma)), c = xa.update(a), d instanceof THREE.MultiMaterial) for (var e = c.groups, f = d.materials, d = 0, g = e.length; d < g; d++) {
                    var h = e[d], i = f[h.materialIndex];
                    !0 === i.visible && m(a, c, i, na.z, h);
                } else m(a, c, d, na.z, null);
            }
            for (c = a.children, d = 0, g = c.length; d < g; d++) o(c[d], b);
        }
    }
    function p(a, b, c, d) {
        for (var e = 0, f = a.length; e < f; e++) {
            var g = a[e], h = g.object, i = g.geometry, j = void 0 === d ? g.material : d, g = g.group;
            if (h.modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, h.matrixWorld), h.normalMatrix.getNormalMatrix(h.modelViewMatrix), 
            h instanceof THREE.ImmediateRenderObject) {
                q(j);
                var k = r(b, c, j, h);
                V = "", h.render(function(a) {
                    Q.renderBufferImmediate(a, k, j);
                });
            } else Q.renderBufferDirect(b, c, i, j, h, g);
        }
    }
    function q(a) {
        a.side !== THREE.DoubleSide ? va.enable(ra.CULL_FACE) : va.disable(ra.CULL_FACE), 
        va.setFlipSided(a.side === THREE.BackSide), !0 === a.transparent ? va.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha) : va.setBlending(THREE.NoBlending), 
        va.setDepthFunc(a.depthFunc), va.setDepthTest(a.depthTest), va.setDepthWrite(a.depthWrite), 
        va.setColorWrite(a.colorWrite), va.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits);
    }
    function r(a, b, c, d) {
        $ = 0;
        var e = wa.get(c);
        if (ja && ((ka || a !== W) && ia.setState(c.clippingPlanes, c.clipShadows, a, e, a === W && c.id === U), 
        void 0 !== e.numClippingPlanes && e.numClippingPlanes !== ia.numPlanes && (c.needsUpdate = !0)), 
        void 0 === e.program && (c.needsUpdate = !0), void 0 !== e.lightsHash && e.lightsHash !== oa.hash && (c.needsUpdate = !0), 
        c.needsUpdate) {
            a: {
                var f = wa.get(c), g = ya.getParameters(c, oa, b, ia.numPlanes, d), j = ya.getProgramCode(c, g), k = f.program, l = !0;
                if (void 0 === k) c.addEventListener("dispose", h); else if (k.code !== j) i(c); else {
                    if (void 0 !== g.shaderID) break a;
                    l = !1;
                }
                if (l && (g.shaderID ? (k = THREE.ShaderLib[g.shaderID], f.__webglShader = {
                    name: c.type,
                    uniforms: THREE.UniformsUtils.clone(k.uniforms),
                    vertexShader: k.vertexShader,
                    fragmentShader: k.fragmentShader
                }) : f.__webglShader = {
                    name: c.type,
                    uniforms: c.uniforms,
                    vertexShader: c.vertexShader,
                    fragmentShader: c.fragmentShader
                }, c.__webglShader = f.__webglShader, k = ya.acquireProgram(c, g, j), f.program = k, 
                c.program = k), g = k.getAttributes(), c.morphTargets) for (j = c.numSupportedMorphTargets = 0; j < Q.maxMorphTargets; j++) 0 <= g["morphTarget" + j] && c.numSupportedMorphTargets++;
                if (c.morphNormals) for (j = c.numSupportedMorphNormals = 0; j < Q.maxMorphNormals; j++) 0 <= g["morphNormal" + j] && c.numSupportedMorphNormals++;
                g = f.__webglShader.uniforms, (c instanceof THREE.ShaderMaterial || c instanceof THREE.RawShaderMaterial) && !0 !== c.clipping || (f.numClippingPlanes = ia.numPlanes, 
                g.clippingPlanes = ia.uniform), c.lights && (f.lightsHash = oa.hash, g.ambientLightColor.value = oa.ambient, 
                g.directionalLights.value = oa.directional, g.spotLights.value = oa.spot, g.pointLights.value = oa.point, 
                g.hemisphereLights.value = oa.hemi, g.directionalShadowMap.value = oa.directionalShadowMap, 
                g.directionalShadowMatrix.value = oa.directionalShadowMatrix, g.spotShadowMap.value = oa.spotShadowMap, 
                g.spotShadowMatrix.value = oa.spotShadowMatrix, g.pointShadowMap.value = oa.pointShadowMap, 
                g.pointShadowMatrix.value = oa.pointShadowMatrix), j = f.program.getUniforms(), 
                j = THREE.WebGLUniforms.seqWithValue(j.seq, g), f.uniformsList = j, f.dynamicUniforms = THREE.WebGLUniforms.splitDynamic(j, g);
            }
            c.needsUpdate = !1;
        }
        var m = !1, l = k = !1, f = e.program, j = f.getUniforms(), g = e.__webglShader.uniforms;
        if (f.id !== R && (ra.useProgram(f.program), R = f.id, l = k = m = !0), c.id !== U && (U = c.id, 
        k = !0), (m || a !== W) && (j.set(ra, a, "projectionMatrix"), ua.logarithmicDepthBuffer && j.setValue(ra, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)), 
        a !== W && (W = a, l = k = !0), (c instanceof THREE.ShaderMaterial || c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshStandardMaterial || c.envMap) && (m = j.map.cameraPosition, 
        void 0 !== m && m.setValue(ra, na.setFromMatrixPosition(a.matrixWorld))), (c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshLambertMaterial || c instanceof THREE.MeshBasicMaterial || c instanceof THREE.MeshStandardMaterial || c instanceof THREE.ShaderMaterial || c.skinning) && j.setValue(ra, "viewMatrix", a.matrixWorldInverse), 
        j.set(ra, Q, "toneMappingExposure"), j.set(ra, Q, "toneMappingWhitePoint")), c.skinning && (j.setOptional(ra, d, "bindMatrix"), 
        j.setOptional(ra, d, "bindMatrixInverse"), m = d.skeleton) && (ua.floatVertexTextures && m.useVertexTexture ? (j.set(ra, m, "boneTexture"), 
        j.set(ra, m, "boneTextureWidth"), j.set(ra, m, "boneTextureHeight")) : j.setOptional(ra, m, "boneMatrices")), 
        k) {
            if (c.lights && (k = l, g.ambientLightColor.needsUpdate = k, g.directionalLights.needsUpdate = k, 
            g.pointLights.needsUpdate = k, g.spotLights.needsUpdate = k, g.hemisphereLights.needsUpdate = k), 
            b && c.fog && (g.fogColor.value = b.color, b instanceof THREE.Fog ? (g.fogNear.value = b.near, 
            g.fogFar.value = b.far) : b instanceof THREE.FogExp2 && (g.fogDensity.value = b.density)), 
            c instanceof THREE.MeshBasicMaterial || c instanceof THREE.MeshLambertMaterial || c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshStandardMaterial || c instanceof THREE.MeshDepthMaterial) {
                g.opacity.value = c.opacity, g.diffuse.value = c.color, c.emissive && g.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity), 
                g.map.value = c.map, g.specularMap.value = c.specularMap, g.alphaMap.value = c.alphaMap, 
                c.aoMap && (g.aoMap.value = c.aoMap, g.aoMapIntensity.value = c.aoMapIntensity);
                var n;
                c.map ? n = c.map : c.specularMap ? n = c.specularMap : c.displacementMap ? n = c.displacementMap : c.normalMap ? n = c.normalMap : c.bumpMap ? n = c.bumpMap : c.roughnessMap ? n = c.roughnessMap : c.metalnessMap ? n = c.metalnessMap : c.alphaMap ? n = c.alphaMap : c.emissiveMap && (n = c.emissiveMap), 
                void 0 !== n && (n instanceof THREE.WebGLRenderTarget && (n = n.texture), b = n.offset, 
                n = n.repeat, g.offsetRepeat.value.set(b.x, b.y, n.x, n.y)), g.envMap.value = c.envMap, 
                g.flipEnvMap.value = c.envMap instanceof THREE.CubeTexture ? -1 : 1, g.reflectivity.value = c.reflectivity, 
                g.refractionRatio.value = c.refractionRatio;
            }
            c instanceof THREE.LineBasicMaterial ? (g.diffuse.value = c.color, g.opacity.value = c.opacity) : c instanceof THREE.LineDashedMaterial ? (g.diffuse.value = c.color, 
            g.opacity.value = c.opacity, g.dashSize.value = c.dashSize, g.totalSize.value = c.dashSize + c.gapSize, 
            g.scale.value = c.scale) : c instanceof THREE.PointsMaterial ? (g.diffuse.value = c.color, 
            g.opacity.value = c.opacity, g.size.value = c.size * da, g.scale.value = .5 * A.clientHeight, 
            g.map.value = c.map, null !== c.map && (n = c.map.offset, c = c.map.repeat, g.offsetRepeat.value.set(n.x, n.y, c.x, c.y))) : c instanceof THREE.MeshLambertMaterial ? (c.lightMap && (g.lightMap.value = c.lightMap, 
            g.lightMapIntensity.value = c.lightMapIntensity), c.emissiveMap && (g.emissiveMap.value = c.emissiveMap)) : c instanceof THREE.MeshPhongMaterial ? (g.specular.value = c.specular, 
            g.shininess.value = Math.max(c.shininess, 1e-4), c.lightMap && (g.lightMap.value = c.lightMap, 
            g.lightMapIntensity.value = c.lightMapIntensity), c.emissiveMap && (g.emissiveMap.value = c.emissiveMap), 
            c.bumpMap && (g.bumpMap.value = c.bumpMap, g.bumpScale.value = c.bumpScale), c.normalMap && (g.normalMap.value = c.normalMap, 
            g.normalScale.value.copy(c.normalScale)), c.displacementMap && (g.displacementMap.value = c.displacementMap, 
            g.displacementScale.value = c.displacementScale, g.displacementBias.value = c.displacementBias)) : c instanceof THREE.MeshPhysicalMaterial ? s(g, c) : c instanceof THREE.MeshStandardMaterial ? s(g, c) : c instanceof THREE.MeshDepthMaterial ? c.displacementMap && (g.displacementMap.value = c.displacementMap, 
            g.displacementScale.value = c.displacementScale, g.displacementBias.value = c.displacementBias) : c instanceof THREE.MeshNormalMaterial && (g.opacity.value = c.opacity), 
            THREE.WebGLUniforms.upload(ra, e.uniformsList, g, Q);
        }
        return j.set(ra, d, "modelViewMatrix"), j.set(ra, d, "normalMatrix"), j.setValue(ra, "modelMatrix", d.matrixWorld), 
        e = e.dynamicUniforms, null !== e && (THREE.WebGLUniforms.evalDynamic(e, g, d, a), 
        THREE.WebGLUniforms.upload(ra, e, g, Q)), f;
    }
    function s(a, b) {
        a.roughness.value = b.roughness, a.metalness.value = b.metalness, b.roughnessMap && (a.roughnessMap.value = b.roughnessMap), 
        b.metalnessMap && (a.metalnessMap.value = b.metalnessMap), b.lightMap && (a.lightMap.value = b.lightMap, 
        a.lightMapIntensity.value = b.lightMapIntensity), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), 
        b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, 
        a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, 
        a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), 
        b.envMap && (a.envMapIntensity.value = b.envMapIntensity);
    }
    function t(a, b, c) {
        c ? (ra.texParameteri(a, ra.TEXTURE_WRAP_S, z(b.wrapS)), ra.texParameteri(a, ra.TEXTURE_WRAP_T, z(b.wrapT)), 
        ra.texParameteri(a, ra.TEXTURE_MAG_FILTER, z(b.magFilter)), ra.texParameteri(a, ra.TEXTURE_MIN_FILTER, z(b.minFilter))) : (ra.texParameteri(a, ra.TEXTURE_WRAP_S, ra.CLAMP_TO_EDGE), 
        ra.texParameteri(a, ra.TEXTURE_WRAP_T, ra.CLAMP_TO_EDGE), b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", b), 
        ra.texParameteri(a, ra.TEXTURE_MAG_FILTER, y(b.magFilter)), ra.texParameteri(a, ra.TEXTURE_MIN_FILTER, y(b.minFilter)), 
        b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", b)), 
        !(c = ta.get("EXT_texture_filter_anisotropic")) || b.type === THREE.FloatType && null === ta.get("OES_texture_float_linear") || b.type === THREE.HalfFloatType && null === ta.get("OES_texture_half_float_linear") || !(1 < b.anisotropy || wa.get(b).__currentAnisotropy) || (ra.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, Q.getMaxAnisotropy())), 
        wa.get(b).__currentAnisotropy = b.anisotropy);
    }
    function u(a, b) {
        if (a.width > b || a.height > b) {
            var c = b / Math.max(a.width, a.height), d = document.createElement("canvas");
            return d.width = Math.floor(a.width * c), d.height = Math.floor(a.height * c), d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height), 
            console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a), 
            d;
        }
        return a;
    }
    function v(a) {
        return THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height);
    }
    function w(a, b, c, d) {
        var e = z(b.texture.format), f = z(b.texture.type);
        va.texImage2D(d, 0, e, b.width, b.height, 0, e, f, null), ra.bindFramebuffer(ra.FRAMEBUFFER, a), 
        ra.framebufferTexture2D(ra.FRAMEBUFFER, c, d, wa.get(b.texture).__webglTexture, 0), 
        ra.bindFramebuffer(ra.FRAMEBUFFER, null);
    }
    function x(a, b) {
        ra.bindRenderbuffer(ra.RENDERBUFFER, a), b.depthBuffer && !b.stencilBuffer ? (ra.renderbufferStorage(ra.RENDERBUFFER, ra.DEPTH_COMPONENT16, b.width, b.height), 
        ra.framebufferRenderbuffer(ra.FRAMEBUFFER, ra.DEPTH_ATTACHMENT, ra.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (ra.renderbufferStorage(ra.RENDERBUFFER, ra.DEPTH_STENCIL, b.width, b.height), 
        ra.framebufferRenderbuffer(ra.FRAMEBUFFER, ra.DEPTH_STENCIL_ATTACHMENT, ra.RENDERBUFFER, a)) : ra.renderbufferStorage(ra.RENDERBUFFER, ra.RGBA4, b.width, b.height), 
        ra.bindRenderbuffer(ra.RENDERBUFFER, null);
    }
    function y(a) {
        return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? ra.NEAREST : ra.LINEAR;
    }
    function z(a) {
        var b;
        if (a === THREE.RepeatWrapping) return ra.REPEAT;
        if (a === THREE.ClampToEdgeWrapping) return ra.CLAMP_TO_EDGE;
        if (a === THREE.MirroredRepeatWrapping) return ra.MIRRORED_REPEAT;
        if (a === THREE.NearestFilter) return ra.NEAREST;
        if (a === THREE.NearestMipMapNearestFilter) return ra.NEAREST_MIPMAP_NEAREST;
        if (a === THREE.NearestMipMapLinearFilter) return ra.NEAREST_MIPMAP_LINEAR;
        if (a === THREE.LinearFilter) return ra.LINEAR;
        if (a === THREE.LinearMipMapNearestFilter) return ra.LINEAR_MIPMAP_NEAREST;
        if (a === THREE.LinearMipMapLinearFilter) return ra.LINEAR_MIPMAP_LINEAR;
        if (a === THREE.UnsignedByteType) return ra.UNSIGNED_BYTE;
        if (a === THREE.UnsignedShort4444Type) return ra.UNSIGNED_SHORT_4_4_4_4;
        if (a === THREE.UnsignedShort5551Type) return ra.UNSIGNED_SHORT_5_5_5_1;
        if (a === THREE.UnsignedShort565Type) return ra.UNSIGNED_SHORT_5_6_5;
        if (a === THREE.ByteType) return ra.BYTE;
        if (a === THREE.ShortType) return ra.SHORT;
        if (a === THREE.UnsignedShortType) return ra.UNSIGNED_SHORT;
        if (a === THREE.IntType) return ra.INT;
        if (a === THREE.UnsignedIntType) return ra.UNSIGNED_INT;
        if (a === THREE.FloatType) return ra.FLOAT;
        if (b = ta.get("OES_texture_half_float"), null !== b && a === THREE.HalfFloatType) return b.HALF_FLOAT_OES;
        if (a === THREE.AlphaFormat) return ra.ALPHA;
        if (a === THREE.RGBFormat) return ra.RGB;
        if (a === THREE.RGBAFormat) return ra.RGBA;
        if (a === THREE.LuminanceFormat) return ra.LUMINANCE;
        if (a === THREE.LuminanceAlphaFormat) return ra.LUMINANCE_ALPHA;
        if (a === THREE.DepthFormat) return ra.DEPTH_COMPONENT;
        if (a === THREE.AddEquation) return ra.FUNC_ADD;
        if (a === THREE.SubtractEquation) return ra.FUNC_SUBTRACT;
        if (a === THREE.ReverseSubtractEquation) return ra.FUNC_REVERSE_SUBTRACT;
        if (a === THREE.ZeroFactor) return ra.ZERO;
        if (a === THREE.OneFactor) return ra.ONE;
        if (a === THREE.SrcColorFactor) return ra.SRC_COLOR;
        if (a === THREE.OneMinusSrcColorFactor) return ra.ONE_MINUS_SRC_COLOR;
        if (a === THREE.SrcAlphaFactor) return ra.SRC_ALPHA;
        if (a === THREE.OneMinusSrcAlphaFactor) return ra.ONE_MINUS_SRC_ALPHA;
        if (a === THREE.DstAlphaFactor) return ra.DST_ALPHA;
        if (a === THREE.OneMinusDstAlphaFactor) return ra.ONE_MINUS_DST_ALPHA;
        if (a === THREE.DstColorFactor) return ra.DST_COLOR;
        if (a === THREE.OneMinusDstColorFactor) return ra.ONE_MINUS_DST_COLOR;
        if (a === THREE.SrcAlphaSaturateFactor) return ra.SRC_ALPHA_SATURATE;
        if (b = ta.get("WEBGL_compressed_texture_s3tc"), null !== b) {
            if (a === THREE.RGB_S3TC_DXT1_Format) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT1_Format) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT3_Format) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === THREE.RGBA_S3TC_DXT5_Format) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (b = ta.get("WEBGL_compressed_texture_pvrtc"), null !== b) {
            if (a === THREE.RGB_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGB_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (b = ta.get("WEBGL_compressed_texture_etc1"), null !== b && a === THREE.RGB_ETC1_Format) return b.COMPRESSED_RGB_ETC1_WEBGL;
        if (b = ta.get("EXT_blend_minmax"), null !== b) {
            if (a === THREE.MinEquation) return b.MIN_EXT;
            if (a === THREE.MaxEquation) return b.MAX_EXT;
        }
        return 0;
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION), a = a || {};
    var A = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"), B = void 0 !== a.context ? a.context : null, C = void 0 !== a.alpha && a.alpha, D = void 0 === a.depth || a.depth, E = void 0 === a.stencil || a.stencil, F = void 0 !== a.antialias && a.antialias, G = void 0 === a.premultipliedAlpha || a.premultipliedAlpha, H = void 0 !== a.preserveDrawingBuffer && a.preserveDrawingBuffer, I = [], J = [], K = -1, L = [], M = -1, N = new Float32Array(8), O = [], P = [];
    this.domElement = A, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, 
    this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, 
    this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMapping = THREE.LinearToneMapping, 
    this.toneMappingWhitePoint = this.toneMappingExposure = 1, this.maxMorphTargets = 8, 
    this.maxMorphNormals = 4, this.autoScaleCubemaps = !0;
    var Q = this, R = null, S = null, T = null, U = -1, V = "", W = null, X = new THREE.Vector4(), Y = null, Z = new THREE.Vector4(), $ = 0, _ = new THREE.Color(0), aa = 0, ba = A.width, ca = A.height, da = 1, ea = new THREE.Vector4(0, 0, ba, ca), fa = !1, ga = new THREE.Vector4(0, 0, ba, ca), ha = new THREE.Frustum(), ia = new THREE.WebGLClipping(), ja = !1, ka = !1, la = new THREE.Sphere(), ma = new THREE.Matrix4(), na = new THREE.Vector3(), oa = {
        hash: "",
        ambient: [ 0, 0, 0 ],
        directional: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        point: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        shadows: []
    }, pa = {
        geometries: 0,
        textures: 0
    }, qa = {
        calls: 0,
        vertices: 0,
        faces: 0,
        points: 0
    };
    this.info = {
        render: qa,
        memory: pa,
        programs: null
    };
    var ra;
    try {
        if (C = {
            alpha: C,
            depth: D,
            stencil: E,
            antialias: F,
            premultipliedAlpha: G,
            preserveDrawingBuffer: H
        }, ra = B || A.getContext("webgl", C) || A.getContext("experimental-webgl", C), 
        null === ra) {
            if (null !== A.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
            throw "Error creating WebGL context.";
        }
        void 0 === ra.getShaderPrecisionFormat && (ra.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            };
        }), A.addEventListener("webglcontextlost", e, !1);
    } catch (a) {
        console.error("THREE.WebGLRenderer: " + a);
    }
    var sa = "undefined" != typeof WebGL2RenderingContext && ra instanceof WebGL2RenderingContext, ta = new THREE.WebGLExtensions(ra);
    ta.get("WEBGL_depth_texture"), ta.get("OES_texture_float"), ta.get("OES_texture_float_linear"), 
    ta.get("OES_texture_half_float"), ta.get("OES_texture_half_float_linear"), ta.get("OES_standard_derivatives"), 
    ta.get("ANGLE_instanced_arrays"), ta.get("OES_element_index_uint") && (THREE.BufferGeometry.MaxIndex = 4294967296);
    var ua = new THREE.WebGLCapabilities(ra, ta, a), va = new THREE.WebGLState(ra, ta, z), wa = new THREE.WebGLProperties(), xa = new THREE.WebGLObjects(ra, wa, this.info), ya = new THREE.WebGLPrograms(this, ua), za = new THREE.WebGLLights();
    this.info.programs = ya.programs;
    var Aa = new THREE.WebGLBufferRenderer(ra, ta, qa), Ba = new THREE.WebGLIndexedBufferRenderer(ra, ta, qa);
    c(), this.context = ra, this.capabilities = ua, this.extensions = ta, this.properties = wa, 
    this.state = va;
    var Ca = new THREE.WebGLShadowMap(this, oa, xa);
    this.shadowMap = Ca;
    var Da = new THREE.SpritePlugin(this, O), Ea = new THREE.LensFlarePlugin(this, P);
    this.getContext = function() {
        return ra;
    }, this.getContextAttributes = function() {
        return ra.getContextAttributes();
    }, this.forceContextLoss = function() {
        ta.get("WEBGL_lose_context").loseContext();
    }, this.getMaxAnisotropy = function() {
        var a;
        return function() {
            if (void 0 !== a) return a;
            var b = ta.get("EXT_texture_filter_anisotropic");
            return a = null !== b ? ra.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        };
    }(), this.getPrecision = function() {
        return ua.precision;
    }, this.getPixelRatio = function() {
        return da;
    }, this.setPixelRatio = function(a) {
        void 0 !== a && (da = a, this.setSize(ga.z, ga.w, !1));
    }, this.getSize = function() {
        return {
            width: ba,
            height: ca
        };
    }, this.setSize = function(a, b, c) {
        ba = a, ca = b, A.width = a * da, A.height = b * da, !1 !== c && (A.style.width = a + "px", 
        A.style.height = b + "px"), this.setViewport(0, 0, a, b);
    }, this.setViewport = function(a, b, c, d) {
        va.viewport(ga.set(a, b, c, d));
    }, this.setScissor = function(a, b, c, d) {
        va.scissor(ea.set(a, b, c, d));
    }, this.setScissorTest = function(a) {
        va.setScissorTest(fa = a);
    }, this.getClearColor = function() {
        return _;
    }, this.setClearColor = function(a, c) {
        _.set(a), aa = void 0 !== c ? c : 1, b(_.r, _.g, _.b, aa);
    }, this.getClearAlpha = function() {
        return aa;
    }, this.setClearAlpha = function(a) {
        aa = a, b(_.r, _.g, _.b, aa);
    }, this.clear = function(a, b, c) {
        var d = 0;
        (void 0 === a || a) && (d |= ra.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= ra.DEPTH_BUFFER_BIT), 
        (void 0 === c || c) && (d |= ra.STENCIL_BUFFER_BIT), ra.clear(d);
    }, this.clearColor = function() {
        this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
        this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
        this.clear(!1, !1, !0);
    }, this.clearTarget = function(a, b, c, d) {
        this.setRenderTarget(a), this.clear(b, c, d);
    }, this.resetGLState = d, this.dispose = function() {
        A.removeEventListener("webglcontextlost", e, !1);
    }, this.renderBufferImmediate = function(a, b, c) {
        va.initAttributes();
        var d = wa.get(a);
        if (a.hasPositions && !d.position && (d.position = ra.createBuffer()), a.hasNormals && !d.normal && (d.normal = ra.createBuffer()), 
        a.hasUvs && !d.uv && (d.uv = ra.createBuffer()), a.hasColors && !d.color && (d.color = ra.createBuffer()), 
        b = b.getAttributes(), a.hasPositions && (ra.bindBuffer(ra.ARRAY_BUFFER, d.position), 
        ra.bufferData(ra.ARRAY_BUFFER, a.positionArray, ra.DYNAMIC_DRAW), va.enableAttribute(b.position), 
        ra.vertexAttribPointer(b.position, 3, ra.FLOAT, !1, 0, 0)), a.hasNormals) {
            if (ra.bindBuffer(ra.ARRAY_BUFFER, d.normal), "MeshPhongMaterial" !== c.type && "MeshStandardMaterial" !== c.type && "MeshPhysicalMaterial" !== c.type && c.shading === THREE.FlatShading) for (var e = 0, f = 3 * a.count; e < f; e += 9) {
                var g = a.normalArray, h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3, i = (g[e + 1] + g[e + 4] + g[e + 7]) / 3, j = (g[e + 2] + g[e + 5] + g[e + 8]) / 3;
                g[e + 0] = h, g[e + 1] = i, g[e + 2] = j, g[e + 3] = h, g[e + 4] = i, g[e + 5] = j, 
                g[e + 6] = h, g[e + 7] = i, g[e + 8] = j;
            }
            ra.bufferData(ra.ARRAY_BUFFER, a.normalArray, ra.DYNAMIC_DRAW), va.enableAttribute(b.normal), 
            ra.vertexAttribPointer(b.normal, 3, ra.FLOAT, !1, 0, 0);
        }
        a.hasUvs && c.map && (ra.bindBuffer(ra.ARRAY_BUFFER, d.uv), ra.bufferData(ra.ARRAY_BUFFER, a.uvArray, ra.DYNAMIC_DRAW), 
        va.enableAttribute(b.uv), ra.vertexAttribPointer(b.uv, 2, ra.FLOAT, !1, 0, 0)), 
        a.hasColors && c.vertexColors !== THREE.NoColors && (ra.bindBuffer(ra.ARRAY_BUFFER, d.color), 
        ra.bufferData(ra.ARRAY_BUFFER, a.colorArray, ra.DYNAMIC_DRAW), va.enableAttribute(b.color), 
        ra.vertexAttribPointer(b.color, 3, ra.FLOAT, !1, 0, 0)), va.disableUnusedAttributes(), 
        ra.drawArrays(ra.TRIANGLES, 0, a.count), a.count = 0;
    }, this.renderBufferDirect = function(a, b, c, d, e, f) {
        q(d);
        var g = r(a, b, d, e), h = !1;
        if (a = c.id + "_" + g.id + "_" + d.wireframe, a !== V && (V = a, h = !0), b = e.morphTargetInfluences, 
        void 0 !== b) {
            a = [];
            for (var i = 0, h = b.length; i < h; i++) {
                var k = b[i];
                a.push([ k, i ]);
            }
            a.sort(j), 8 < a.length && (a.length = 8);
            for (var l = c.morphAttributes, i = 0, h = a.length; i < h; i++) k = a[i], N[i] = k[0], 
            0 !== k[0] ? (b = k[1], !0 === d.morphTargets && l.position && c.addAttribute("morphTarget" + i, l.position[b]), 
            !0 === d.morphNormals && l.normal && c.addAttribute("morphNormal" + i, l.normal[b])) : (!0 === d.morphTargets && c.removeAttribute("morphTarget" + i), 
            !0 === d.morphNormals && c.removeAttribute("morphNormal" + i));
            g.getUniforms().setValue(ra, "morphTargetInfluences", N), h = !0;
        }
        if (b = c.index, i = c.attributes.position, !0 === d.wireframe && (b = xa.getWireframeAttribute(c)), 
        null !== b ? (a = Ba, a.setIndex(b)) : a = Aa, h) {
            var m, h = void 0;
            if (c instanceof THREE.InstancedBufferGeometry && (m = ta.get("ANGLE_instanced_arrays"), 
            null === m)) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else {
                void 0 === h && (h = 0), va.initAttributes();
                var n, k = c.attributes, g = g.getAttributes(), l = d.defaultAttributeValues;
                for (n in g) {
                    var o = g[n];
                    if (0 <= o) {
                        var p = k[n];
                        if (void 0 !== p) {
                            var s = ra.FLOAT, t = p.array, u = p.normalized;
                            t instanceof Float32Array ? s = ra.FLOAT : t instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : t instanceof Uint16Array ? s = ra.UNSIGNED_SHORT : t instanceof Int16Array ? s = ra.SHORT : t instanceof Uint32Array ? s = ra.UNSIGNED_INT : t instanceof Int32Array ? s = ra.INT : t instanceof Int8Array ? s = ra.BYTE : t instanceof Uint8Array && (s = ra.UNSIGNED_BYTE);
                            var t = p.itemSize, v = xa.getAttributeBuffer(p);
                            if (p instanceof THREE.InterleavedBufferAttribute) {
                                var w = p.data, x = w.stride, p = p.offset;
                                w instanceof THREE.InstancedInterleavedBuffer ? (va.enableAttributeAndDivisor(o, w.meshPerAttribute, m), 
                                void 0 === c.maxInstancedCount && (c.maxInstancedCount = w.meshPerAttribute * w.count)) : va.enableAttribute(o), 
                                ra.bindBuffer(ra.ARRAY_BUFFER, v), ra.vertexAttribPointer(o, t, s, u, x * w.array.BYTES_PER_ELEMENT, (h * x + p) * w.array.BYTES_PER_ELEMENT);
                            } else p instanceof THREE.InstancedBufferAttribute ? (va.enableAttributeAndDivisor(o, p.meshPerAttribute, m), 
                            void 0 === c.maxInstancedCount && (c.maxInstancedCount = p.meshPerAttribute * p.count)) : va.enableAttribute(o), 
                            ra.bindBuffer(ra.ARRAY_BUFFER, v), ra.vertexAttribPointer(o, t, s, u, 0, h * t * p.array.BYTES_PER_ELEMENT);
                        } else if (void 0 !== l && (s = l[n], void 0 !== s)) switch (s.length) {
                          case 2:
                            ra.vertexAttrib2fv(o, s);
                            break;

                          case 3:
                            ra.vertexAttrib3fv(o, s);
                            break;

                          case 4:
                            ra.vertexAttrib4fv(o, s);
                            break;

                          default:
                            ra.vertexAttrib1fv(o, s);
                        }
                    }
                }
                va.disableUnusedAttributes();
            }
            null !== b && ra.bindBuffer(ra.ELEMENT_ARRAY_BUFFER, xa.getAttributeBuffer(b));
        }
        if (m = 1 / 0, null !== b ? m = b.count : void 0 !== i && (m = i.count), n = c.drawRange.start, 
        b = c.drawRange.count, i = null !== f ? f.start : 0, h = null !== f ? f.count : 1 / 0, 
        f = Math.max(0, n, i), m = Math.min(0 + m, n + b, i + h) - 1, m = Math.max(0, m - f + 1), 
        e instanceof THREE.Mesh) if (!0 === d.wireframe) va.setLineWidth(d.wireframeLinewidth * (null === S ? da : 1)), 
        a.setMode(ra.LINES); else switch (e.drawMode) {
          case THREE.TrianglesDrawMode:
            a.setMode(ra.TRIANGLES);
            break;

          case THREE.TriangleStripDrawMode:
            a.setMode(ra.TRIANGLE_STRIP);
            break;

          case THREE.TriangleFanDrawMode:
            a.setMode(ra.TRIANGLE_FAN);
        } else e instanceof THREE.Line ? (d = d.linewidth, void 0 === d && (d = 1), va.setLineWidth(d * (null === S ? da : 1)), 
        e instanceof THREE.LineSegments ? a.setMode(ra.LINES) : a.setMode(ra.LINE_STRIP)) : e instanceof THREE.Points && a.setMode(ra.POINTS);
        c instanceof THREE.InstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, f, m) : a.render(f, m);
    }, this.render = function(a, b, c, d) {
        if (!1 == b instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else {
            var e = a.fog;
            V = "", U = -1, W = null, !0 === a.autoUpdate && a.updateMatrixWorld(), null === b.parent && b.updateMatrixWorld(), 
            b.matrixWorldInverse.getInverse(b.matrixWorld), ma.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), 
            ha.setFromMatrix(ma), I.length = 0, M = K = -1, O.length = 0, P.length = 0, ka = this.localClippingEnabled, 
            ja = ia.init(this.clippingPlanes, ka, b), o(a, b), J.length = K + 1, L.length = M + 1, 
            !0 === Q.sortObjects && (J.sort(k), L.sort(l)), ja && ia.beginShadows();
            for (var f = I, g = 0, h = 0, i = f.length; h < i; h++) {
                var j = f[h];
                j.castShadow && (oa.shadows[g++] = j);
            }
            oa.shadows.length = g, Ca.render(a, b);
            for (var m, n, q, r, f = I, s = j = 0, t = 0, u = b.matrixWorldInverse, w = 0, x = 0, y = 0, z = 0, g = 0, h = f.length; g < h; g++) if (i = f[g], 
            m = i.color, n = i.intensity, q = i.distance, r = i.shadow && i.shadow.map ? i.shadow.map.texture : null, 
            i instanceof THREE.AmbientLight) j += m.r * n, s += m.g * n, t += m.b * n; else if (i instanceof THREE.DirectionalLight) {
                var A = za.get(i);
                A.color.copy(i.color).multiplyScalar(i.intensity), A.direction.setFromMatrixPosition(i.matrixWorld), 
                na.setFromMatrixPosition(i.target.matrixWorld), A.direction.sub(na), A.direction.transformDirection(u), 
                (A.shadow = i.castShadow) && (A.shadowBias = i.shadow.bias, A.shadowRadius = i.shadow.radius, 
                A.shadowMapSize = i.shadow.mapSize), oa.directionalShadowMap[w] = r, oa.directionalShadowMatrix[w] = i.shadow.matrix, 
                oa.directional[w++] = A;
            } else i instanceof THREE.SpotLight ? (A = za.get(i), A.position.setFromMatrixPosition(i.matrixWorld), 
            A.position.applyMatrix4(u), A.color.copy(m).multiplyScalar(n), A.distance = q, A.direction.setFromMatrixPosition(i.matrixWorld), 
            na.setFromMatrixPosition(i.target.matrixWorld), A.direction.sub(na), A.direction.transformDirection(u), 
            A.coneCos = Math.cos(i.angle), A.penumbraCos = Math.cos(i.angle * (1 - i.penumbra)), 
            A.decay = 0 === i.distance ? 0 : i.decay, (A.shadow = i.castShadow) && (A.shadowBias = i.shadow.bias, 
            A.shadowRadius = i.shadow.radius, A.shadowMapSize = i.shadow.mapSize), oa.spotShadowMap[y] = r, 
            oa.spotShadowMatrix[y] = i.shadow.matrix, oa.spot[y++] = A) : i instanceof THREE.PointLight ? (A = za.get(i), 
            A.position.setFromMatrixPosition(i.matrixWorld), A.position.applyMatrix4(u), A.color.copy(i.color).multiplyScalar(i.intensity), 
            A.distance = i.distance, A.decay = 0 === i.distance ? 0 : i.decay, (A.shadow = i.castShadow) && (A.shadowBias = i.shadow.bias, 
            A.shadowRadius = i.shadow.radius, A.shadowMapSize = i.shadow.mapSize), oa.pointShadowMap[x] = r, 
            void 0 === oa.pointShadowMatrix[x] && (oa.pointShadowMatrix[x] = new THREE.Matrix4()), 
            na.setFromMatrixPosition(i.matrixWorld).negate(), oa.pointShadowMatrix[x].identity().setPosition(na), 
            oa.point[x++] = A) : i instanceof THREE.HemisphereLight && (A = za.get(i), A.direction.setFromMatrixPosition(i.matrixWorld), 
            A.direction.transformDirection(u), A.direction.normalize(), A.skyColor.copy(i.color).multiplyScalar(n), 
            A.groundColor.copy(i.groundColor).multiplyScalar(n), oa.hemi[z++] = A);
            oa.ambient[0] = j, oa.ambient[1] = s, oa.ambient[2] = t, oa.directional.length = w, 
            oa.spot.length = y, oa.point.length = x, oa.hemi.length = z, oa.hash = w + "," + x + "," + y + "," + z + "," + oa.shadows.length, 
            ja && ia.endShadows(), qa.calls = 0, qa.vertices = 0, qa.faces = 0, qa.points = 0, 
            void 0 === c && (c = null), this.setRenderTarget(c), (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), 
            a.overrideMaterial ? (d = a.overrideMaterial, p(J, b, e, d), p(L, b, e, d)) : (va.setBlending(THREE.NoBlending), 
            p(J, b, e), p(L, b, e)), Da.render(a, b), Ea.render(a, b, Z), c && (a = c.texture, 
            a.generateMipmaps && v(c) && a.minFilter !== THREE.NearestFilter && a.minFilter !== THREE.LinearFilter && (a = c instanceof THREE.WebGLRenderTargetCube ? ra.TEXTURE_CUBE_MAP : ra.TEXTURE_2D, 
            c = wa.get(c.texture).__webglTexture, va.bindTexture(a, c), ra.generateMipmap(a), 
            va.bindTexture(a, null))), va.setDepthTest(!0), va.setDepthWrite(!0), va.setColorWrite(!0);
        }
    }, this.setFaceCulling = function(a, b) {
        va.setCullFace(a), va.setFlipSided(b === THREE.FrontFaceDirectionCW);
    }, this.allocTextureUnit = function() {
        var a = $;
        return a >= ua.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + ua.maxTextures), 
        $ += 1, a;
    }, this.setTexture2D = function() {
        var a = !1;
        return function(b, c) {
            b instanceof THREE.WebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), 
            a = !0), b = b.texture);
            var d = b, e = wa.get(d);
            if (0 < d.version && e.__version !== d.version) {
                var g = d.image;
                if (void 0 === g) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", d); else if (!1 === g.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", d); else {
                    void 0 === e.__webglInit && (e.__webglInit = !0, d.addEventListener("dispose", f), 
                    e.__webglTexture = ra.createTexture(), pa.textures++), va.activeTexture(ra.TEXTURE0 + c), 
                    va.bindTexture(ra.TEXTURE_2D, e.__webglTexture), ra.pixelStorei(ra.UNPACK_FLIP_Y_WEBGL, d.flipY), 
                    ra.pixelStorei(ra.UNPACK_PREMULTIPLY_ALPHA_WEBGL, d.premultiplyAlpha), ra.pixelStorei(ra.UNPACK_ALIGNMENT, d.unpackAlignment);
                    var h = u(d.image, ua.maxTextureSize);
                    if ((d.wrapS !== THREE.ClampToEdgeWrapping || d.wrapT !== THREE.ClampToEdgeWrapping || d.minFilter !== THREE.NearestFilter && d.minFilter !== THREE.LinearFilter) && !1 === v(h)) if (g = h, 
                    g instanceof HTMLImageElement || g instanceof HTMLCanvasElement) {
                        var i = document.createElement("canvas");
                        i.width = THREE.Math.nearestPowerOfTwo(g.width), i.height = THREE.Math.nearestPowerOfTwo(g.height), 
                        i.getContext("2d").drawImage(g, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + g.width + "x" + g.height + "). Resized to " + i.width + "x" + i.height, g), 
                        h = i;
                    } else h = g;
                    var g = v(h), i = z(d.format), j = z(d.type);
                    t(ra.TEXTURE_2D, d, g);
                    var k = d.mipmaps;
                    if (d instanceof THREE.DepthTexture) {
                        if (k = ra.DEPTH_COMPONENT, d.type === THREE.FloatType) {
                            if (!sa) throw Error("Float Depth Texture only supported in WebGL2.0");
                            k = ra.DEPTH_COMPONENT32F;
                        } else sa && (k = ra.DEPTH_COMPONENT16);
                        va.texImage2D(ra.TEXTURE_2D, 0, k, h.width, h.height, 0, i, j, null);
                    } else if (d instanceof THREE.DataTexture) if (0 < k.length && g) {
                        for (var l = 0, m = k.length; l < m; l++) h = k[l], va.texImage2D(ra.TEXTURE_2D, l, i, h.width, h.height, 0, i, j, h.data);
                        d.generateMipmaps = !1;
                    } else va.texImage2D(ra.TEXTURE_2D, 0, i, h.width, h.height, 0, i, j, h.data); else if (d instanceof THREE.CompressedTexture) for (l = 0, 
                    m = k.length; l < m; l++) h = k[l], d.format !== THREE.RGBAFormat && d.format !== THREE.RGBFormat ? -1 < va.getCompressedTextureFormats().indexOf(i) ? va.compressedTexImage2D(ra.TEXTURE_2D, l, i, h.width, h.height, 0, h.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : va.texImage2D(ra.TEXTURE_2D, l, i, h.width, h.height, 0, i, j, h.data); else if (0 < k.length && g) {
                        for (l = 0, m = k.length; l < m; l++) h = k[l], va.texImage2D(ra.TEXTURE_2D, l, i, i, j, h);
                        d.generateMipmaps = !1;
                    } else va.texImage2D(ra.TEXTURE_2D, 0, i, i, j, h);
                    d.generateMipmaps && g && ra.generateMipmap(ra.TEXTURE_2D), e.__version = d.version, 
                    d.onUpdate && d.onUpdate(d);
                }
            } else va.activeTexture(ra.TEXTURE0 + c), va.bindTexture(ra.TEXTURE_2D, e.__webglTexture);
        };
    }(), this.setTexture = function() {
        var a = !1;
        return function(b, c) {
            a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), 
            a = !0), Q.setTexture2D(b, c);
        };
    }(), this.setTextureCube = function() {
        var a = !1;
        return function(b, c) {
            if (b instanceof THREE.WebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), 
            a = !0), b = b.texture), b instanceof THREE.CubeTexture || Array.isArray(b.image) && 6 === b.image.length) {
                var d = b, e = wa.get(d);
                if (6 === d.image.length) if (0 < d.version && e.__version !== d.version) {
                    e.__image__webglTextureCube || (d.addEventListener("dispose", f), e.__image__webglTextureCube = ra.createTexture(), 
                    pa.textures++), va.activeTexture(ra.TEXTURE0 + c), va.bindTexture(ra.TEXTURE_CUBE_MAP, e.__image__webglTextureCube), 
                    ra.pixelStorei(ra.UNPACK_FLIP_Y_WEBGL, d.flipY);
                    for (var g = d instanceof THREE.CompressedTexture, h = d.image[0] instanceof THREE.DataTexture, i = [], j = 0; 6 > j; j++) i[j] = !Q.autoScaleCubemaps || g || h ? h ? d.image[j].image : d.image[j] : u(d.image[j], ua.maxCubemapSize);
                    var k = v(i[0]), l = z(d.format), m = z(d.type);
                    for (t(ra.TEXTURE_CUBE_MAP, d, k), j = 0; 6 > j; j++) if (g) for (var n, o = i[j].mipmaps, p = 0, q = o.length; p < q; p++) n = o[p], 
                    d.format !== THREE.RGBAFormat && d.format !== THREE.RGBFormat ? -1 < va.getCompressedTextureFormats().indexOf(l) ? va.compressedTexImage2D(ra.TEXTURE_CUBE_MAP_POSITIVE_X + j, p, l, n.width, n.height, 0, n.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : va.texImage2D(ra.TEXTURE_CUBE_MAP_POSITIVE_X + j, p, l, n.width, n.height, 0, l, m, n.data); else h ? va.texImage2D(ra.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, l, i[j].width, i[j].height, 0, l, m, i[j].data) : va.texImage2D(ra.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, l, l, m, i[j]);
                    d.generateMipmaps && k && ra.generateMipmap(ra.TEXTURE_CUBE_MAP), e.__version = d.version, 
                    d.onUpdate && d.onUpdate(d);
                } else va.activeTexture(ra.TEXTURE0 + c), va.bindTexture(ra.TEXTURE_CUBE_MAP, e.__image__webglTextureCube);
            } else d = b, va.activeTexture(ra.TEXTURE0 + c), va.bindTexture(ra.TEXTURE_CUBE_MAP, wa.get(d).__webglTexture);
        };
    }(), this.getCurrentRenderTarget = function() {
        return S;
    }, this.setRenderTarget = function(a) {
        if ((S = a) && void 0 === wa.get(a).__webglFramebuffer) {
            var b = wa.get(a), c = wa.get(a.texture);
            a.addEventListener("dispose", g), c.__webglTexture = ra.createTexture(), pa.textures++;
            var d = a instanceof THREE.WebGLRenderTargetCube, e = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height);
            if (d) {
                b.__webglFramebuffer = [];
                for (var f = 0; 6 > f; f++) b.__webglFramebuffer[f] = ra.createFramebuffer();
            } else b.__webglFramebuffer = ra.createFramebuffer();
            if (d) {
                for (va.bindTexture(ra.TEXTURE_CUBE_MAP, c.__webglTexture), t(ra.TEXTURE_CUBE_MAP, a.texture, e), 
                f = 0; 6 > f; f++) w(b.__webglFramebuffer[f], a, ra.COLOR_ATTACHMENT0, ra.TEXTURE_CUBE_MAP_POSITIVE_X + f);
                a.texture.generateMipmaps && e && ra.generateMipmap(ra.TEXTURE_CUBE_MAP), va.bindTexture(ra.TEXTURE_CUBE_MAP, null);
            } else va.bindTexture(ra.TEXTURE_2D, c.__webglTexture), t(ra.TEXTURE_2D, a.texture, e), 
            w(b.__webglFramebuffer, a, ra.COLOR_ATTACHMENT0, ra.TEXTURE_2D), a.texture.generateMipmaps && e && ra.generateMipmap(ra.TEXTURE_2D), 
            va.bindTexture(ra.TEXTURE_2D, null);
            if (a.depthBuffer) {
                if (b = wa.get(a), c = a instanceof THREE.WebGLRenderTargetCube, a.depthTexture) {
                    if (c) throw Error("target.depthTexture not supported in Cube render targets");
                    if (a instanceof THREE.WebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported!");
                    if (ra.bindFramebuffer(ra.FRAMEBUFFER, b.__webglFramebuffer), !(a.depthTexture instanceof THREE.DepthTexture)) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    wa.get(a.depthTexture).__webglTexture && a.depthTexture.image.width === a.width && a.depthTexture.image.height === a.height || (a.depthTexture.image.width = a.width, 
                    a.depthTexture.image.height = a.height, a.depthTexture.needsUpdate = !0), Q.setTexture2D(a.depthTexture, 0), 
                    b = wa.get(a.depthTexture).__webglTexture, ra.framebufferTexture2D(ra.FRAMEBUFFER, ra.DEPTH_ATTACHMENT, ra.TEXTURE_2D, b, 0);
                } else if (c) for (b.__webglDepthbuffer = [], c = 0; 6 > c; c++) ra.bindFramebuffer(ra.FRAMEBUFFER, b.__webglFramebuffer[c]), 
                b.__webglDepthbuffer[c] = ra.createRenderbuffer(), x(b.__webglDepthbuffer[c], a); else ra.bindFramebuffer(ra.FRAMEBUFFER, b.__webglFramebuffer), 
                b.__webglDepthbuffer = ra.createRenderbuffer(), x(b.__webglDepthbuffer, a);
                ra.bindFramebuffer(ra.FRAMEBUFFER, null);
            }
        }
        b = a instanceof THREE.WebGLRenderTargetCube, a ? (c = wa.get(a), c = b ? c.__webglFramebuffer[a.activeCubeFace] : c.__webglFramebuffer, 
        X.copy(a.scissor), Y = a.scissorTest, Z.copy(a.viewport)) : (c = null, X.copy(ea).multiplyScalar(da), 
        Y = fa, Z.copy(ga).multiplyScalar(da)), T !== c && (ra.bindFramebuffer(ra.FRAMEBUFFER, c), 
        T = c), va.scissor(X), va.setScissorTest(Y), va.viewport(Z), b && (b = wa.get(a.texture), 
        ra.framebufferTexture2D(ra.FRAMEBUFFER, ra.COLOR_ATTACHMENT0, ra.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, b.__webglTexture, a.activeMipMapLevel));
    }, this.readRenderTargetPixels = function(a, b, c, d, e, f) {
        if (!1 == a instanceof THREE.WebGLRenderTarget) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); else {
            var g = wa.get(a).__webglFramebuffer;
            if (g) {
                var h = !1;
                g !== T && (ra.bindFramebuffer(ra.FRAMEBUFFER, g), h = !0);
                try {
                    var i = a.texture;
                    i.format !== THREE.RGBAFormat && z(i.format) !== ra.getParameter(ra.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : i.type === THREE.UnsignedByteType || z(i.type) === ra.getParameter(ra.IMPLEMENTATION_COLOR_READ_TYPE) || i.type === THREE.FloatType && ta.get("WEBGL_color_buffer_float") || i.type === THREE.HalfFloatType && ta.get("EXT_color_buffer_half_float") ? ra.checkFramebufferStatus(ra.FRAMEBUFFER) === ra.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && ra.readPixels(b, c, d, e, z(i.format), z(i.type), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                } finally {
                    h && ra.bindFramebuffer(ra.FRAMEBUFFER, T);
                }
            }
        }
    };
}, THREE.WebGLRenderTarget = function(a, b, c) {
    this.uuid = THREE.Math.generateUUID(), this.width = a, this.height = b, this.scissor = new THREE.Vector4(0, 0, a, b), 
    this.scissorTest = !1, this.viewport = new THREE.Vector4(0, 0, a, b), c = c || {}, 
    void 0 === c.minFilter && (c.minFilter = THREE.LinearFilter), this.texture = new THREE.Texture(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding), 
    this.depthBuffer = void 0 === c.depthBuffer || c.depthBuffer, this.stencilBuffer = void 0 === c.stencilBuffer || c.stencilBuffer, 
    this.depthTexture = null;
}, Object.assign(THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {
    setSize: function(a, b) {
        this.width === a && this.height === b || (this.width = a, this.height = b, this.dispose()), 
        this.viewport.set(0, 0, a, b), this.scissor.set(0, 0, a, b);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(a) {
        return this.width = a.width, this.height = a.height, this.viewport.copy(a.viewport), 
        this.texture = a.texture.clone(), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, 
        this.depthTexture = a.depthTexture, this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}), THREE.WebGLRenderTargetCube = function(a, b, c) {
    THREE.WebGLRenderTarget.call(this, a, b, c), this.activeMipMapLevel = this.activeCubeFace = 0;
}, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), 
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube, 
THREE.WebGLBufferRenderer = function(a, b, c) {
    var d;
    this.setMode = function(a) {
        d = a;
    }, this.render = function(b, e) {
        a.drawArrays(d, b, e), c.calls++, c.vertices += e, d === a.TRIANGLES && (c.faces += e / 3);
    }, this.renderInstances = function(e) {
        var f = b.get("ANGLE_instanced_arrays");
        if (null === f) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else {
            var g = e.attributes.position, h = 0, h = g instanceof THREE.InterleavedBufferAttribute ? g.data.count : g.count;
            f.drawArraysInstancedANGLE(d, 0, h, e.maxInstancedCount), c.calls++, c.vertices += h * e.maxInstancedCount, 
            d === a.TRIANGLES && (c.faces += e.maxInstancedCount * h / 3);
        }
    };
}, THREE.WebGLClipping = function() {
    function a() {
        j.value !== d && (j.value = d, j.needsUpdate = 0 < e), c.numPlanes = e;
    }
    function b(a, b, d, e) {
        var f = null !== a ? a.length : 0, g = null;
        if (0 !== f) {
            if (g = j.value, !0 !== e || null === g) for (e = d + 4 * f, b = b.matrixWorldInverse, 
            i.getNormalMatrix(b), (null === g || g.length < e) && (g = new Float32Array(e)), 
            e = 0; e !== f; ++e, d += 4) h.copy(a[e]).applyMatrix4(b, i), h.normal.toArray(g, d), 
            g[d + 3] = h.constant;
            j.value = g, j.needsUpdate = !0;
        }
        return c.numPlanes = f, g;
    }
    var c = this, d = null, e = 0, f = !1, g = !1, h = new THREE.Plane(), i = new THREE.Matrix3(), j = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = j, this.numPlanes = 0, this.init = function(a, c, g) {
        var h = 0 !== a.length || c || 0 !== e || f;
        return f = c, d = b(a, g, 0), e = a.length, h;
    }, this.beginShadows = function() {
        g = !0, b(null);
    }, this.endShadows = function() {
        g = !1, a();
    }, this.setState = function(c, h, i, k, l) {
        if (!f || null === c || 0 === c.length || g && !h) g ? b(null) : a(); else {
            h = g ? 0 : e;
            var m = 4 * h, n = k.clippingState || null;
            for (j.value = n, n = b(c, i, m, l), c = 0; c !== m; ++c) n[c] = d[c];
            k.clippingState = n, this.numPlanes += h;
        }
    };
}, THREE.WebGLIndexedBufferRenderer = function(a, b, c) {
    var d, e, f;
    this.setMode = function(a) {
        d = a;
    }, this.setIndex = function(c) {
        c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (e = a.UNSIGNED_INT, 
        f = 4) : (e = a.UNSIGNED_SHORT, f = 2);
    }, this.render = function(b, g) {
        a.drawElements(d, g, e, b * f), c.calls++, c.vertices += g, d === a.TRIANGLES && (c.faces += g / 3);
    }, this.renderInstances = function(g, h, i) {
        var j = b.get("ANGLE_instanced_arrays");
        null === j ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (j.drawElementsInstancedANGLE(d, i, e, h * f, g.maxInstancedCount), 
        c.calls++, c.vertices += i * g.maxInstancedCount, d === a.TRIANGLES && (c.faces += g.maxInstancedCount * i / 3));
    };
}, THREE.WebGLExtensions = function(a) {
    var b = {};
    this.get = function(c) {
        if (void 0 !== b[c]) return b[c];
        var d;
        switch (c) {
          case "WEBGL_depth_texture":
            d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
            break;

          case "EXT_texture_filter_anisotropic":
            d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;

          case "WEBGL_compressed_texture_s3tc":
            d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;

          case "WEBGL_compressed_texture_pvrtc":
            d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;

          case "WEBGL_compressed_texture_etc1":
            d = a.getExtension("WEBGL_compressed_texture_etc1");
            break;

          default:
            d = a.getExtension(c);
        }
        return null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."), 
        b[c] = d;
    };
}, THREE.WebGLCapabilities = function(a, b, c) {
    function d(b) {
        if ("highp" === b) {
            if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
            b = "mediump";
        }
        return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp";
    }
    this.getMaxPrecision = d, this.precision = void 0 !== c.precision ? c.precision : "highp", 
    this.logarithmicDepthBuffer = void 0 !== c.logarithmicDepthBuffer && c.logarithmicDepthBuffer, 
    this.maxTextures = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), this.maxVertexTextures = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
    this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), this.maxCubemapSize = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE), 
    this.maxAttributes = a.getParameter(a.MAX_VERTEX_ATTRIBS), this.maxVertexUniforms = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS), 
    this.maxVaryings = a.getParameter(a.MAX_VARYING_VECTORS), this.maxFragmentUniforms = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS), 
    this.vertexTextures = 0 < this.maxVertexTextures, this.floatFragmentTextures = !!b.get("OES_texture_float"), 
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures, c = d(this.precision), 
    c !== this.precision && (console.warn("THREE.WebGLRenderer:", this.precision, "not supported, using", c, "instead."), 
    this.precision = c), this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!b.get("EXT_frag_depth"));
}, THREE.WebGLGeometries = function(a, b, c) {
    function d(a) {
        var g = a.target;
        a = f[g.id], null !== a.index && e(a.index);
        var h, i = a.attributes;
        for (h in i) e(i[h]);
        g.removeEventListener("dispose", d), delete f[g.id], h = b.get(g), h.wireframe && e(h.wireframe), 
        b.delete(g), g = b.get(a), g.wireframe && e(g.wireframe), b.delete(a), c.memory.geometries--;
    }
    function e(c) {
        var d;
        d = c instanceof THREE.InterleavedBufferAttribute ? b.get(c.data).__webglBuffer : b.get(c).__webglBuffer, 
        void 0 !== d && (a.deleteBuffer(d), c instanceof THREE.InterleavedBufferAttribute ? b.delete(c.data) : b.delete(c));
    }
    var f = {};
    this.get = function(a) {
        var b = a.geometry;
        if (void 0 !== f[b.id]) return f[b.id];
        b.addEventListener("dispose", d);
        var e;
        return b instanceof THREE.BufferGeometry ? e = b : b instanceof THREE.Geometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = new THREE.BufferGeometry().setFromObject(a)), 
        e = b._bufferGeometry), f[b.id] = e, c.memory.geometries++, e;
    };
}, THREE.WebGLLights = function() {
    var a = {};
    this.get = function(b) {
        if (void 0 !== a[b.id]) return a[b.id];
        var c;
        switch (b.type) {
          case "DirectionalLight":
            c = {
                direction: new THREE.Vector3(),
                color: new THREE.Color(),
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2()
            };
            break;

          case "SpotLight":
            c = {
                position: new THREE.Vector3(),
                direction: new THREE.Vector3(),
                color: new THREE.Color(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2()
            };
            break;

          case "PointLight":
            c = {
                position: new THREE.Vector3(),
                color: new THREE.Color(),
                distance: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2()
            };
            break;

          case "HemisphereLight":
            c = {
                direction: new THREE.Vector3(),
                skyColor: new THREE.Color(),
                groundColor: new THREE.Color()
            };
        }
        return a[b.id] = c;
    };
}, THREE.WebGLObjects = function(a, b, c) {
    function d(c, d) {
        var e = c instanceof THREE.InterleavedBufferAttribute ? c.data : c, f = b.get(e);
        void 0 === f.__webglBuffer ? (f.__webglBuffer = a.createBuffer(), a.bindBuffer(d, f.__webglBuffer), 
        a.bufferData(d, e.array, e.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW), f.version = e.version) : f.version !== e.version && (a.bindBuffer(d, f.__webglBuffer), 
        !1 === e.dynamic || -1 === e.updateRange.count ? a.bufferSubData(d, 0, e.array) : 0 === e.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(d, e.updateRange.offset * e.array.BYTES_PER_ELEMENT, e.array.subarray(e.updateRange.offset, e.updateRange.offset + e.updateRange.count)), 
        e.updateRange.count = 0), f.version = e.version);
    }
    function e(a, b, c) {
        if (b > c) {
            var d = b;
            b = c, c = d;
        }
        return d = a[b], void 0 === d ? (a[b] = [ c ], !0) : -1 === d.indexOf(c) && (d.push(c), 
        !0);
    }
    var f = new THREE.WebGLGeometries(a, b, c);
    this.getAttributeBuffer = function(a) {
        return a instanceof THREE.InterleavedBufferAttribute ? b.get(a.data).__webglBuffer : b.get(a).__webglBuffer;
    }, this.getWireframeAttribute = function(c) {
        var f = b.get(c);
        if (void 0 !== f.wireframe) return f.wireframe;
        var g = [], h = c.index, i = c.attributes;
        if (c = i.position, null !== h) for (var i = {}, h = h.array, j = 0, k = h.length; j < k; j += 3) {
            var l = h[j + 0], m = h[j + 1], n = h[j + 2];
            e(i, l, m) && g.push(l, m), e(i, m, n) && g.push(m, n), e(i, n, l) && g.push(n, l);
        } else for (h = i.position.array, j = 0, k = h.length / 3 - 1; j < k; j += 3) l = j + 0, 
        m = j + 1, n = j + 2, g.push(l, m, m, n, n, l);
        return g = new THREE.BufferAttribute(new (65535 < c.count ? Uint32Array : Uint16Array)(g), 1), 
        d(g, a.ELEMENT_ARRAY_BUFFER), f.wireframe = g;
    }, this.update = function(b) {
        var c = f.get(b);
        b.geometry instanceof THREE.Geometry && c.updateFromObject(b), b = c.index;
        var e = c.attributes;
        null !== b && d(b, a.ELEMENT_ARRAY_BUFFER);
        for (var g in e) d(e[g], a.ARRAY_BUFFER);
        b = c.morphAttributes;
        for (g in b) for (var e = b[g], h = 0, i = e.length; h < i; h++) d(e[h], a.ARRAY_BUFFER);
        return c;
    };
}, THREE.WebGLProgram = function() {
    function a(a) {
        switch (a) {
          case THREE.LinearEncoding:
            return [ "Linear", "( value )" ];

          case THREE.sRGBEncoding:
            return [ "sRGB", "( value )" ];

          case THREE.RGBEEncoding:
            return [ "RGBE", "( value )" ];

          case THREE.RGBM7Encoding:
            return [ "RGBM", "( value, 7.0 )" ];

          case THREE.RGBM16Encoding:
            return [ "RGBM", "( value, 16.0 )" ];

          case THREE.RGBDEncoding:
            return [ "RGBD", "( value, 256.0 )" ];

          case THREE.GammaEncoding:
            return [ "Gamma", "( value, float( GAMMA_FACTOR ) )" ];

          default:
            throw Error("unsupported encoding: " + a);
        }
    }
    function b(b, c) {
        var d = a(c);
        return "vec4 " + b + "( vec4 value ) { return " + d[0] + "ToLinear" + d[1] + "; }";
    }
    function c(b, c) {
        var d = a(c);
        return "vec4 " + b + "( vec4 value ) { return LinearTo" + d[0] + d[1] + "; }";
    }
    function d(a, b) {
        var c;
        switch (b) {
          case THREE.LinearToneMapping:
            c = "Linear";
            break;

          case THREE.ReinhardToneMapping:
            c = "Reinhard";
            break;

          case THREE.Uncharted2ToneMapping:
            c = "Uncharted2";
            break;

          case THREE.CineonToneMapping:
            c = "OptimizedCineon";
            break;

          default:
            throw Error("unsupported toneMapping: " + b);
        }
        return "vec3 " + a + "( vec3 color ) { return " + c + "ToneMapping( color ); }";
    }
    function e(a, b, c) {
        return a = a || {}, [ a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : "" ].filter(g).join("\n");
    }
    function f(a) {
        var b, c = [];
        for (b in a) {
            var d = a[b];
            !1 !== d && c.push("#define " + b + " " + d);
        }
        return c.join("\n");
    }
    function g(a) {
        return "" !== a;
    }
    function h(a, b) {
        return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights);
    }
    function i(a) {
        return a.replace(/#include +<([\w\d.]+)>/g, function(a, b) {
            var c = THREE.ShaderChunk[b];
            if (void 0 === c) throw Error("Can not resolve #include <" + b + ">");
            return i(c);
        });
    }
    function j(a) {
        return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(a, b, c, d) {
            for (a = "", b = parseInt(b); b < parseInt(c); b++) a += d.replace(/\[ i \]/g, "[ " + b + " ]");
            return a;
        });
    }
    var k = 0;
    return function(a, l, m, n) {
        var o = a.context, p = m.extensions, q = m.defines, r = m.__webglShader.vertexShader, s = m.__webglShader.fragmentShader, t = "SHADOWMAP_TYPE_BASIC";
        n.shadowMapType === THREE.PCFShadowMap ? t = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === THREE.PCFSoftShadowMap && (t = "SHADOWMAP_TYPE_PCF_SOFT");
        var u = "ENVMAP_TYPE_CUBE", v = "ENVMAP_MODE_REFLECTION", w = "ENVMAP_BLENDING_MULTIPLY";
        if (n.envMap) {
            switch (m.envMap.mapping) {
              case THREE.CubeReflectionMapping:
              case THREE.CubeRefractionMapping:
                u = "ENVMAP_TYPE_CUBE";
                break;

              case THREE.CubeUVReflectionMapping:
              case THREE.CubeUVRefractionMapping:
                u = "ENVMAP_TYPE_CUBE_UV";
                break;

              case THREE.EquirectangularReflectionMapping:
              case THREE.EquirectangularRefractionMapping:
                u = "ENVMAP_TYPE_EQUIREC";
                break;

              case THREE.SphericalReflectionMapping:
                u = "ENVMAP_TYPE_SPHERE";
            }
            switch (m.envMap.mapping) {
              case THREE.CubeRefractionMapping:
              case THREE.EquirectangularRefractionMapping:
                v = "ENVMAP_MODE_REFRACTION";
            }
            switch (m.combine) {
              case THREE.MultiplyOperation:
                w = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case THREE.MixOperation:
                w = "ENVMAP_BLENDING_MIX";
                break;

              case THREE.AddOperation:
                w = "ENVMAP_BLENDING_ADD";
            }
        }
        var x = 0 < a.gammaFactor ? a.gammaFactor : 1, p = e(p, n, a.extensions), y = f(q), z = o.createProgram();
        m instanceof THREE.RawShaderMaterial ? t = q = "" : (q = [ "precision " + n.precision + " float;", "precision " + n.precision + " int;", "#define SHADER_NAME " + m.__webglShader.name, y, n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + x, "#define MAX_BONES " + n.maxBones, n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + v : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + n.numClippingPlanes, n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + t : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n" ].filter(g).join("\n"), 
        t = [ p, "precision " + n.precision + " float;", "precision " + n.precision + " int;", "#define SHADER_NAME " + m.__webglShader.name, y, n.alphaTest ? "#define ALPHATEST " + n.alphaTest : "", "#define GAMMA_FACTOR " + x, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + v : "", n.envMap ? "#define " + w : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + n.numClippingPlanes, n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + t : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", n.envMap && a.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", n.toneMapping !== THREE.NoToneMapping ? "#define TONE_MAPPING" : "", n.toneMapping !== THREE.NoToneMapping ? THREE.ShaderChunk.tonemapping_pars_fragment : "", n.toneMapping !== THREE.NoToneMapping ? d("toneMapping", n.toneMapping) : "", n.outputEncoding || n.mapEncoding || n.envMapEncoding || n.emissiveMapEncoding ? THREE.ShaderChunk.encodings_pars_fragment : "", n.mapEncoding ? b("mapTexelToLinear", n.mapEncoding) : "", n.envMapEncoding ? b("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? b("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.outputEncoding ? c("linearToOutputTexel", n.outputEncoding) : "", n.depthPacking ? "#define DEPTH_PACKING " + m.depthPacking : "", "\n" ].filter(g).join("\n")), 
        r = i(r, n), r = h(r, n), s = i(s, n), s = h(s, n), !1 == m instanceof THREE.ShaderMaterial && (r = j(r), 
        s = j(s)), s = t + s, r = THREE.WebGLShader(o, o.VERTEX_SHADER, q + r), s = THREE.WebGLShader(o, o.FRAGMENT_SHADER, s), 
        o.attachShader(z, r), o.attachShader(z, s), void 0 !== m.index0AttributeName ? o.bindAttribLocation(z, 0, m.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(z, 0, "position"), 
        o.linkProgram(z), n = o.getProgramInfoLog(z), u = o.getShaderInfoLog(r), v = o.getShaderInfoLog(s), 
        x = w = !0, !1 === o.getProgramParameter(z, o.LINK_STATUS) ? (w = !1, console.error("THREE.WebGLProgram: shader error: ", o.getError(), "gl.VALIDATE_STATUS", o.getProgramParameter(z, o.VALIDATE_STATUS), "gl.getProgramInfoLog", n, u, v)) : "" !== n ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", n) : "" !== u && "" !== v || (x = !1), 
        x && (this.diagnostics = {
            runnable: w,
            material: m,
            programLog: n,
            vertexShader: {
                log: u,
                prefix: q
            },
            fragmentShader: {
                log: v,
                prefix: t
            }
        }), o.deleteShader(r), o.deleteShader(s);
        var A;
        this.getUniforms = function() {
            return void 0 === A && (A = new THREE.WebGLUniforms(o, z, a)), A;
        };
        var B;
        return this.getAttributes = function() {
            if (void 0 === B) {
                for (var a = {}, b = o.getProgramParameter(z, o.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) {
                    var d = o.getActiveAttrib(z, c).name;
                    a[d] = o.getAttribLocation(z, d);
                }
                B = a;
            }
            return B;
        }, this.destroy = function() {
            o.deleteProgram(z), this.program = void 0;
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), 
                    this.getAttributes();
                }
            }
        }), this.id = k++, this.code = l, this.usedTimes = 1, this.program = z, this.vertexShader = r, 
        this.fragmentShader = s, this;
    };
}(), THREE.WebGLPrograms = function(a, b) {
    function c(a, b) {
        var c;
        return a ? a instanceof THREE.Texture ? c = a.encoding : a instanceof THREE.WebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), 
        c = a.texture.encoding) : c = THREE.LinearEncoding, c === THREE.LinearEncoding && b && (c = THREE.GammaEncoding), 
        c;
    }
    var d = [], e = {
        MeshDepthMaterial: "depth",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points"
    }, f = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes depthPacking".split(" ");
    this.getParameters = function(d, f, g, h, i) {
        var j, k = e[d.type];
        b.floatVertexTextures && i && i.skeleton && i.skeleton.useVertexTexture ? j = 1024 : (j = Math.floor((b.maxVertexUniforms - 20) / 4), 
        void 0 !== i && i instanceof THREE.SkinnedMesh && (j = Math.min(i.skeleton.bones.length, j), 
        j < i.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + i.skeleton.bones.length + ", this GPU supports just " + j + " (try OpenGL instead of ANGLE)")));
        var l = a.getPrecision();
        null !== d.precision && (l = b.getMaxPrecision(d.precision), l !== d.precision && console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", l, "instead."));
        var m = a.getCurrentRenderTarget();
        return {
            shaderID: k,
            precision: l,
            supportsVertexTextures: b.vertexTextures,
            outputEncoding: c(m ? m.texture : null, a.gammaOutput),
            map: !!d.map,
            mapEncoding: c(d.map, a.gammaInput),
            envMap: !!d.envMap,
            envMapMode: d.envMap && d.envMap.mapping,
            envMapEncoding: c(d.envMap, a.gammaInput),
            envMapCubeUV: !!d.envMap && (d.envMap.mapping === THREE.CubeUVReflectionMapping || d.envMap.mapping === THREE.CubeUVRefractionMapping),
            lightMap: !!d.lightMap,
            aoMap: !!d.aoMap,
            emissiveMap: !!d.emissiveMap,
            emissiveMapEncoding: c(d.emissiveMap, a.gammaInput),
            bumpMap: !!d.bumpMap,
            normalMap: !!d.normalMap,
            displacementMap: !!d.displacementMap,
            roughnessMap: !!d.roughnessMap,
            metalnessMap: !!d.metalnessMap,
            specularMap: !!d.specularMap,
            alphaMap: !!d.alphaMap,
            combine: d.combine,
            vertexColors: d.vertexColors,
            fog: g,
            useFog: d.fog,
            fogExp: g instanceof THREE.FogExp2,
            flatShading: d.shading === THREE.FlatShading,
            sizeAttenuation: d.sizeAttenuation,
            logarithmicDepthBuffer: b.logarithmicDepthBuffer,
            skinning: d.skinning,
            maxBones: j,
            useVertexTexture: b.floatVertexTextures && i && i.skeleton && i.skeleton.useVertexTexture,
            morphTargets: d.morphTargets,
            morphNormals: d.morphNormals,
            maxMorphTargets: a.maxMorphTargets,
            maxMorphNormals: a.maxMorphNormals,
            numDirLights: f.directional.length,
            numPointLights: f.point.length,
            numSpotLights: f.spot.length,
            numHemiLights: f.hemi.length,
            numClippingPlanes: h,
            shadowMapEnabled: a.shadowMap.enabled && i.receiveShadow && 0 < f.shadows.length,
            shadowMapType: a.shadowMap.type,
            toneMapping: a.toneMapping,
            physicallyCorrectLights: a.physicallyCorrectLights,
            premultipliedAlpha: d.premultipliedAlpha,
            alphaTest: d.alphaTest,
            doubleSided: d.side === THREE.DoubleSide,
            flipSided: d.side === THREE.BackSide,
            depthPacking: void 0 !== d.depthPacking && d.depthPacking
        };
    }, this.getProgramCode = function(a, b) {
        var c = [];
        if (b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader)), 
        void 0 !== a.defines) for (var d in a.defines) c.push(d), c.push(a.defines[d]);
        for (d = 0; d < f.length; d++) c.push(b[f[d]]);
        return c.join();
    }, this.acquireProgram = function(b, c, e) {
        for (var f, g = 0, h = d.length; g < h; g++) {
            var i = d[g];
            if (i.code === e) {
                f = i, ++f.usedTimes;
                break;
            }
        }
        return void 0 === f && (f = new THREE.WebGLProgram(a, e, b, c), d.push(f)), f;
    }, this.releaseProgram = function(a) {
        if (0 === --a.usedTimes) {
            var b = d.indexOf(a);
            d[b] = d[d.length - 1], d.pop(), a.destroy();
        }
    }, this.programs = d;
}, THREE.WebGLProperties = function() {
    var a = {};
    this.get = function(b) {
        b = b.uuid;
        var c = a[b];
        return void 0 === c && (c = {}, a[b] = c), c;
    }, this.delete = function(b) {
        delete a[b.uuid];
    }, this.clear = function() {
        a = {};
    };
}, THREE.WebGLShader = function() {
    function a(a) {
        a = a.split("\n");
        for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
        return a.join("\n");
    }
    return function(b, c, d) {
        var e = b.createShader(c);
        return b.shaderSource(e, d), b.compileShader(e), !1 === b.getShaderParameter(e, b.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), 
        "" !== b.getShaderInfoLog(e) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", c === b.VERTEX_SHADER ? "vertex" : "fragment", b.getShaderInfoLog(e), a(d)), 
        e;
    };
}(), THREE.WebGLShadowMap = function(a, b, c) {
    function d(b, c, d, e) {
        var f = b.geometry, g = null, g = o, h = b.customDepthMaterial;
        return d && (g = p, h = b.customDistanceMaterial), h ? g = h : (b = b instanceof THREE.SkinnedMesh && c.skinning, 
        h = 0, void 0 !== f.morphTargets && 0 < f.morphTargets.length && c.morphTargets && (h |= 1), 
        b && (h |= 2), g = g[h]), a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (h = g.uuid, 
        f = c.uuid, b = q[h], void 0 === b && (b = {}, q[h] = b), h = b[f], void 0 === h && (h = g.clone(), 
        b[f] = h), g = h), g.visible = c.visible, g.wireframe = c.wireframe, f = c.side, 
        A.renderSingleSided && f == THREE.DoubleSide && (f = THREE.FrontSide), A.renderReverseSided && (f === THREE.FrontSide ? f = THREE.BackSide : f === THREE.BackSide && (f = THREE.FrontSide)), 
        g.side = f, g.clipShadows = c.clipShadows, g.clippingPlanes = c.clippingPlanes, 
        g.wireframeLinewidth = c.wireframeLinewidth, g.linewidth = c.linewidth, d && void 0 !== g.uniforms.lightPos && g.uniforms.lightPos.value.copy(e), 
        g;
    }
    function e(a, b, c) {
        if (!1 !== a.visible) {
            a.layers.test(b.layers) && (a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Points) && a.castShadow && (!1 === a.frustumCulled || !0 === h.intersectsObject(a)) && !0 === a.material.visible && (a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), 
            n.push(a)), a = a.children;
            for (var d = 0, f = a.length; d < f; d++) e(a[d], b, c);
        }
    }
    var f = a.context, g = a.state, h = new THREE.Frustum(), i = new THREE.Matrix4(), j = b.shadows, k = new THREE.Vector2(), l = new THREE.Vector3(), m = new THREE.Vector3(), n = [], o = Array(4), p = Array(4), q = {}, r = [ new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0) ], s = [ new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1) ], t = [ new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4() ];
    b = new THREE.MeshDepthMaterial(), b.depthPacking = THREE.RGBADepthPacking, b.clipping = !0;
    for (var u = THREE.ShaderLib.distanceRGBA, v = THREE.UniformsUtils.clone(u.uniforms), w = 0; 4 !== w; ++w) {
        var x = 0 !== (1 & w), y = 0 !== (2 & w), z = b.clone();
        z.morphTargets = x, z.skinning = y, o[w] = z, x = new THREE.ShaderMaterial({
            defines: {
                USE_SHADOWMAP: ""
            },
            uniforms: v,
            vertexShader: u.vertexShader,
            fragmentShader: u.fragmentShader,
            morphTargets: x,
            skinning: y,
            clipping: !0
        }), p[w] = x;
    }
    var A = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = THREE.PCFShadowMap, 
    this.renderSingleSided = this.renderReverseSided = !0, this.render = function(b, o) {
        if (!1 !== A.enabled && (!1 !== A.autoUpdate || !1 !== A.needsUpdate) && 0 !== j.length) {
            g.clearColor(1, 1, 1, 1), g.disable(f.BLEND), g.setDepthTest(!0), g.setScissorTest(!1);
            for (var p, q, u = 0, v = j.length; u < v; u++) {
                var w = j[u], x = w.shadow;
                if (void 0 === x) console.warn("THREE.WebGLShadowMap:", w, "has no shadow."); else {
                    var y = x.camera;
                    if (k.copy(x.mapSize), w instanceof THREE.PointLight) {
                        p = 6, q = !0;
                        var z = k.x, B = k.y;
                        t[0].set(2 * z, B, z, B), t[1].set(0, B, z, B), t[2].set(3 * z, B, z, B), t[3].set(z, B, z, B), 
                        t[4].set(3 * z, 0, z, B), t[5].set(z, 0, z, B), k.x *= 4, k.y *= 2;
                    } else p = 1, q = !1;
                    for (null === x.map && (x.map = new THREE.WebGLRenderTarget(k.x, k.y, {
                        minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBAFormat
                    }), y.updateProjectionMatrix()), x instanceof THREE.SpotLightShadow && x.update(w), 
                    z = x.map, x = x.matrix, m.setFromMatrixPosition(w.matrixWorld), y.position.copy(m), 
                    a.setRenderTarget(z), a.clear(), z = 0; z < p; z++) {
                        q ? (l.copy(y.position), l.add(r[z]), y.up.copy(s[z]), y.lookAt(l), g.viewport(t[z])) : (l.setFromMatrixPosition(w.target.matrixWorld), 
                        y.lookAt(l)), y.updateMatrixWorld(), y.matrixWorldInverse.getInverse(y.matrixWorld), 
                        x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), x.multiply(y.projectionMatrix), 
                        x.multiply(y.matrixWorldInverse), i.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse), 
                        h.setFromMatrix(i), n.length = 0, e(b, o, y);
                        for (var B = 0, C = n.length; B < C; B++) {
                            var D = n[B], E = c.update(D), F = D.material;
                            if (F instanceof THREE.MultiMaterial) for (var G = E.groups, F = F.materials, H = 0, I = G.length; H < I; H++) {
                                var J = G[H], K = F[J.materialIndex];
                                !0 === K.visible && (K = d(D, K, q, m), a.renderBufferDirect(y, null, E, K, D, J));
                            } else K = d(D, F, q, m), a.renderBufferDirect(y, null, E, K, D, null);
                        }
                    }
                }
            }
            p = a.getClearColor(), q = a.getClearAlpha(), a.setClearColor(p, q), A.needsUpdate = !1;
        }
    };
}, THREE.WebGLState = function(a, b, c) {
    function d(b, c, d) {
        var e = new Uint8Array(3), f = a.createTexture();
        for (a.bindTexture(b, f), a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST), 
        b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGB, 1, 1, 0, a.RGB, a.UNSIGNED_BYTE, e);
        return f;
    }
    var e = this;
    this.buffers = {
        color: new THREE.WebGLColorBuffer(a, this),
        depth: new THREE.WebGLDepthBuffer(a, this),
        stencil: new THREE.WebGLStencilBuffer(a, this)
    };
    var f = a.getParameter(a.MAX_VERTEX_ATTRIBS), g = new Uint8Array(f), h = new Uint8Array(f), i = new Uint8Array(f), j = {}, k = null, l = null, m = null, n = null, o = null, p = null, q = null, r = null, s = !1, t = null, u = null, v = null, w = null, x = null, y = null, z = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), A = null, B = {}, C = new THREE.Vector4(), D = new THREE.Vector4(), E = {};
    E[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1), E[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6), 
    this.init = function() {
        this.clearColor(0, 0, 0, 1), this.clearDepth(1), this.clearStencil(0), this.enable(a.DEPTH_TEST), 
        this.setDepthFunc(THREE.LessEqualDepth), this.setFlipSided(!1), this.setCullFace(THREE.CullFaceBack), 
        this.enable(a.CULL_FACE), this.enable(a.BLEND), this.setBlending(THREE.NormalBlending);
    }, this.initAttributes = function() {
        for (var a = 0, b = g.length; a < b; a++) g[a] = 0;
    }, this.enableAttribute = function(c) {
        g[c] = 1, 0 === h[c] && (a.enableVertexAttribArray(c), h[c] = 1), 0 !== i[c] && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0), 
        i[c] = 0);
    }, this.enableAttributeAndDivisor = function(b, c, d) {
        g[b] = 1, 0 === h[b] && (a.enableVertexAttribArray(b), h[b] = 1), i[b] !== c && (d.vertexAttribDivisorANGLE(b, c), 
        i[b] = c);
    }, this.disableUnusedAttributes = function() {
        for (var b = 0, c = h.length; b !== c; ++b) h[b] !== g[b] && (a.disableVertexAttribArray(b), 
        h[b] = 0);
    }, this.enable = function(b) {
        !0 !== j[b] && (a.enable(b), j[b] = !0);
    }, this.disable = function(b) {
        !1 !== j[b] && (a.disable(b), j[b] = !1);
    }, this.getCompressedTextureFormats = function() {
        if (null === k && (k = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1"))) for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) k.push(c[d]);
        return k;
    }, this.setBlending = function(b, d, e, f, g, h, i, j) {
        b !== THREE.NoBlending ? (this.enable(a.BLEND), b === l && j === s || (b === THREE.AdditiveBlending ? j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), 
        a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), 
        a.blendFunc(a.SRC_ALPHA, a.ONE)) : b === THREE.SubtractiveBlending ? j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), 
        a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), 
        a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : b === THREE.MultiplyBlending ? j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), 
        a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), 
        a.blendFunc(a.ZERO, a.SRC_COLOR)) : j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), 
        a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), 
        a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), 
        l = b, s = j), b === THREE.CustomBlending ? (g = g || d, h = h || e, i = i || f, 
        d === m && g === p || (a.blendEquationSeparate(c(d), c(g)), m = d, p = g), e === n && f === o && h === q && i === r || (a.blendFuncSeparate(c(e), c(f), c(h), c(i)), 
        n = e, o = f, q = h, r = i)) : r = q = p = o = n = m = null) : (this.disable(a.BLEND), 
        l = b);
    }, this.setColorWrite = function(a) {
        this.buffers.color.setMask(a);
    }, this.setDepthTest = function(a) {
        this.buffers.depth.setTest(a);
    }, this.setDepthWrite = function(a) {
        this.buffers.depth.setMask(a);
    }, this.setDepthFunc = function(a) {
        this.buffers.depth.setFunc(a);
    }, this.setStencilTest = function(a) {
        this.buffers.stencil.setTest(a);
    }, this.setStencilWrite = function(a) {
        this.buffers.stencil.setMask(a);
    }, this.setStencilFunc = function(a, b, c) {
        this.buffers.stencil.setFunc(a, b, c);
    }, this.setStencilOp = function(a, b, c) {
        this.buffers.stencil.setOp(a, b, c);
    }, this.setFlipSided = function(b) {
        t !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), t = b);
    }, this.setCullFace = function(b) {
        b !== THREE.CullFaceNone ? (this.enable(a.CULL_FACE), b !== u && (b === THREE.CullFaceBack ? a.cullFace(a.BACK) : b === THREE.CullFaceFront ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : this.disable(a.CULL_FACE), 
        u = b;
    }, this.setLineWidth = function(b) {
        b !== v && (a.lineWidth(b), v = b);
    }, this.setPolygonOffset = function(b, c, d) {
        b ? (this.enable(a.POLYGON_OFFSET_FILL), (w !== c || x !== d) && (a.polygonOffset(c, d), 
        w = c, x = d)) : this.disable(a.POLYGON_OFFSET_FILL);
    }, this.getScissorTest = function() {
        return y;
    }, this.setScissorTest = function(b) {
        (y = b) ? this.enable(a.SCISSOR_TEST) : this.disable(a.SCISSOR_TEST);
    }, this.activeTexture = function(b) {
        void 0 === b && (b = a.TEXTURE0 + z - 1), A !== b && (a.activeTexture(b), A = b);
    }, this.bindTexture = function(b, c) {
        null === A && e.activeTexture();
        var d = B[A];
        void 0 === d && (d = {
            type: void 0,
            texture: void 0
        }, B[A] = d), d.type === b && d.texture === c || (a.bindTexture(b, c || E[b]), d.type = b, 
        d.texture = c);
    }, this.compressedTexImage2D = function() {
        try {
            a.compressedTexImage2D.apply(a, arguments);
        } catch (a) {
            console.error(a);
        }
    }, this.texImage2D = function() {
        try {
            a.texImage2D.apply(a, arguments);
        } catch (a) {
            console.error(a);
        }
    }, this.clearColor = function(a, b, c, d) {
        this.buffers.color.setClear(a, b, c, d);
    }, this.clearDepth = function(a) {
        this.buffers.depth.setClear(a);
    }, this.clearStencil = function(a) {
        this.buffers.stencil.setClear(a);
    }, this.scissor = function(b) {
        !1 === C.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), C.copy(b));
    }, this.viewport = function(b) {
        !1 === D.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), D.copy(b));
    }, this.reset = function() {
        for (var b = 0; b < h.length; b++) 1 === h[b] && (a.disableVertexAttribArray(b), 
        h[b] = 0);
        j = {}, A = k = null, B = {}, u = t = l = null, this.buffers.color.reset(), this.buffers.depth.reset(), 
        this.buffers.stencil.reset();
    };
}, THREE.WebGLColorBuffer = function(a, b) {
    var c = !1, d = new THREE.Vector4(), e = null, f = new THREE.Vector4();
    this.setMask = function(b) {
        e === b || c || (a.colorMask(b, b, b, b), e = b);
    }, this.setLocked = function(a) {
        c = a;
    }, this.setClear = function(b, c, e, g) {
        d.set(b, c, e, g), !1 === f.equals(d) && (a.clearColor(b, c, e, g), f.copy(d));
    }, this.reset = function() {
        c = !1, e = null, f = new THREE.Vector4();
    };
}, THREE.WebGLDepthBuffer = function(a, b) {
    var c = !1, d = null, e = null, f = null;
    this.setTest = function(c) {
        c ? b.enable(a.DEPTH_TEST) : b.disable(a.DEPTH_TEST);
    }, this.setMask = function(b) {
        d === b || c || (a.depthMask(b), d = b);
    }, this.setFunc = function(b) {
        if (e !== b) {
            if (b) switch (b) {
              case THREE.NeverDepth:
                a.depthFunc(a.NEVER);
                break;

              case THREE.AlwaysDepth:
                a.depthFunc(a.ALWAYS);
                break;

              case THREE.LessDepth:
                a.depthFunc(a.LESS);
                break;

              case THREE.LessEqualDepth:
                a.depthFunc(a.LEQUAL);
                break;

              case THREE.EqualDepth:
                a.depthFunc(a.EQUAL);
                break;

              case THREE.GreaterEqualDepth:
                a.depthFunc(a.GEQUAL);
                break;

              case THREE.GreaterDepth:
                a.depthFunc(a.GREATER);
                break;

              case THREE.NotEqualDepth:
                a.depthFunc(a.NOTEQUAL);
                break;

              default:
                a.depthFunc(a.LEQUAL);
            } else a.depthFunc(a.LEQUAL);
            e = b;
        }
    }, this.setLocked = function(a) {
        c = a;
    }, this.setClear = function(b) {
        f !== b && (a.clearDepth(b), f = b);
    }, this.reset = function() {
        c = !1, f = e = d = null;
    };
}, THREE.WebGLStencilBuffer = function(a, b) {
    var c = !1, d = null, e = null, f = null, g = null, h = null, i = null, j = null, k = null;
    this.setTest = function(c) {
        c ? b.enable(a.STENCIL_TEST) : b.disable(a.STENCIL_TEST);
    }, this.setMask = function(b) {
        d === b || c || (a.stencilMask(b), d = b);
    }, this.setFunc = function(b, c, d) {
        e === b && f === c && g === d || (a.stencilFunc(b, c, d), e = b, f = c, g = d);
    }, this.setOp = function(b, c, d) {
        h === b && i === c && j === d || (a.stencilOp(b, c, d), h = b, i = c, j = d);
    }, this.setLocked = function(a) {
        c = a;
    }, this.setClear = function(b) {
        k !== b && (a.clearStencil(b), k = b);
    }, this.reset = function() {
        c = !1, k = j = i = h = g = f = e = d = null;
    };
}, THREE.WebGLUniforms = function() {
    var a = [], b = [], c = function(b, c, d) {
        var e = b[0];
        if (0 >= e || 0 < e) return b;
        var f = c * d, g = a[f];
        if (void 0 === g && (g = new Float32Array(f), a[f] = g), 0 !== c) for (e.toArray(g, 0), 
        e = 1, f = 0; e !== c; ++e) f += d, b[e].toArray(g, f);
        return g;
    }, d = function(a, c) {
        var d = b[c];
        void 0 === d && (d = new Int32Array(c), b[c] = d);
        for (var e = 0; e !== c; ++e) d[e] = a.allocTextureUnit();
        return d;
    }, e = function(a, b) {
        a.uniform1f(this.addr, b);
    }, f = function(a, b) {
        a.uniform1i(this.addr, b);
    }, g = function(a, b) {
        void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y);
    }, h = function(a, b) {
        void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b);
    }, i = function(a, b) {
        void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w);
    }, j = function(a, b) {
        a.uniformMatrix2fv(this.addr, !1, b.elements || b);
    }, k = function(a, b) {
        a.uniformMatrix3fv(this.addr, !1, b.elements || b);
    }, l = function(a, b) {
        a.uniformMatrix4fv(this.addr, !1, b.elements || b);
    }, m = function(a, b, c) {
        var d = c.allocTextureUnit();
        a.uniform1i(this.addr, d), b && c.setTexture2D(b, d);
    }, n = function(a, b, c) {
        var d = c.allocTextureUnit();
        a.uniform1i(this.addr, d), b && c.setTextureCube(b, d);
    }, o = function(a, b) {
        a.uniform2iv(this.addr, b);
    }, p = function(a, b) {
        a.uniform3iv(this.addr, b);
    }, q = function(a, b) {
        a.uniform4iv(this.addr, b);
    }, r = function(a) {
        switch (a) {
          case 5126:
            return e;

          case 35664:
            return g;

          case 35665:
            return h;

          case 35666:
            return i;

          case 35674:
            return j;

          case 35675:
            return k;

          case 35676:
            return l;

          case 35678:
            return m;

          case 35680:
            return n;

          case 5124:
          case 35670:
            return f;

          case 35667:
          case 35671:
            return o;

          case 35668:
          case 35672:
            return p;

          case 35669:
          case 35673:
            return q;
        }
    }, s = function(a, b) {
        a.uniform1fv(this.addr, b);
    }, t = function(a, b) {
        a.uniform1iv(this.addr, b);
    }, u = function(a, b) {
        a.uniform2fv(this.addr, c(b, this.size, 2));
    }, v = function(a, b) {
        a.uniform3fv(this.addr, c(b, this.size, 3));
    }, w = function(a, b) {
        a.uniform4fv(this.addr, c(b, this.size, 4));
    }, x = function(a, b) {
        a.uniformMatrix2fv(this.addr, !1, c(b, this.size, 4));
    }, y = function(a, b) {
        a.uniformMatrix3fv(this.addr, !1, c(b, this.size, 9));
    }, z = function(a, b) {
        a.uniformMatrix4fv(this.addr, !1, c(b, this.size, 16));
    }, A = function(a, b, c) {
        var e = b.length, f = d(c, e);
        for (a.uniform1iv(this.addr, f), a = 0; a !== e; ++a) {
            var g = b[a];
            g && c.setTexture2D(g, f[a]);
        }
    }, B = function(a, b, c) {
        var e = b.length, f = d(c, e);
        for (a.uniform1iv(this.addr, f), a = 0; a !== e; ++a) {
            var g = b[a];
            g && c.setTextureCube(g, f[a]);
        }
    }, C = function(a) {
        switch (a) {
          case 5126:
            return s;

          case 35664:
            return u;

          case 35665:
            return v;

          case 35666:
            return w;

          case 35674:
            return x;

          case 35675:
            return y;

          case 35676:
            return z;

          case 35678:
            return A;

          case 35680:
            return B;

          case 5124:
          case 35670:
            return t;

          case 35667:
          case 35671:
            return o;

          case 35668:
          case 35672:
            return p;

          case 35669:
          case 35673:
            return q;
        }
    }, D = function(a, b, c) {
        this.id = a, this.addr = c, this.setValue = r(b.type);
    }, E = function(a, b, c) {
        this.id = a, this.addr = c, this.size = b.size, this.setValue = C(b.type);
    }, F = function(a) {
        this.id = a, this.seq = [], this.map = {};
    };
    F.prototype.setValue = function(a, b) {
        for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {
            var f = c[d];
            f.setValue(a, b[f.id]);
        }
    };
    var G = /([\w\d_]+)(\])?(\[|\.)?/g, H = function(a, b, c) {
        this.seq = [], this.map = {}, this.renderer = c, c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
        for (var d = 0; d !== c; ++d) {
            var e = a.getActiveUniform(b, d), f = a.getUniformLocation(b, e.name), g = this, h = e.name, i = h.length;
            for (G.lastIndex = 0; ;) {
                var j = G.exec(h), k = G.lastIndex, l = j[1], m = j[3];
                if ("]" === j[2] && (l |= 0), void 0 === m || "[" === m && k + 2 === i) {
                    h = g, e = void 0 === m ? new D(l, e, f) : new E(l, e, f), h.seq.push(e), h.map[e.id] = e;
                    break;
                }
                m = g.map[l], void 0 === m && (m = new F(l), l = g, g = m, l.seq.push(g), l.map[g.id] = g), 
                g = m;
            }
        }
    };
    return H.prototype.setValue = function(a, b, c) {
        b = this.map[b], void 0 !== b && b.setValue(a, c, this.renderer);
    }, H.prototype.set = function(a, b, c) {
        var d = this.map[c];
        void 0 !== d && d.setValue(a, b[c], this.renderer);
    }, H.prototype.setOptional = function(a, b, c) {
        b = b[c], void 0 !== b && this.setValue(a, c, b);
    }, H.upload = function(a, b, c, d) {
        for (var e = 0, f = b.length; e !== f; ++e) {
            var g = b[e], h = c[g.id];
            !1 !== h.needsUpdate && g.setValue(a, h.value, d);
        }
    }, H.seqWithValue = function(a, b) {
        for (var c = [], d = 0, e = a.length; d !== e; ++d) {
            var f = a[d];
            f.id in b && c.push(f);
        }
        return c;
    }, H.splitDynamic = function(a, b) {
        for (var c = null, d = a.length, e = 0, f = 0; f !== d; ++f) {
            var g = a[f], h = b[g.id];
            h && !0 === h.dynamic ? (null === c && (c = []), c.push(g)) : (e < f && (a[e] = g), 
            ++e);
        }
        return e < d && (a.length = e), c;
    }, H.evalDynamic = function(a, b, c, d) {
        for (var e = 0, f = a.length; e !== f; ++e) {
            var g = b[a[e].id], h = g.onUpdateCallback;
            void 0 !== h && h.call(g, c, d);
        }
    }, H;
}(), THREE.LensFlarePlugin = function(a, b) {
    var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = a.context, t = a.state;
    this.render = function(u, v, w) {
        if (0 !== b.length) {
            u = new THREE.Vector3();
            var x = w.w / w.z, y = .5 * w.z, z = .5 * w.w, A = 16 / w.w, B = new THREE.Vector2(A * x, A), C = new THREE.Vector3(1, 1, 0), D = new THREE.Vector2(1, 1), E = new THREE.Box2();
            if (E.min.set(0, 0), E.max.set(w.z - 16, w.w - 16), void 0 === p) {
                var A = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1 ]), F = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
                m = s.createBuffer(), n = s.createBuffer(), s.bindBuffer(s.ARRAY_BUFFER, m), s.bufferData(s.ARRAY_BUFFER, A, s.STATIC_DRAW), 
                s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, n), s.bufferData(s.ELEMENT_ARRAY_BUFFER, F, s.STATIC_DRAW), 
                q = s.createTexture(), r = s.createTexture(), t.bindTexture(s.TEXTURE_2D, q), s.texImage2D(s.TEXTURE_2D, 0, s.RGB, 16, 16, 0, s.RGB, s.UNSIGNED_BYTE, null), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST), 
                t.bindTexture(s.TEXTURE_2D, r), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, 16, 16, 0, s.RGBA, s.UNSIGNED_BYTE, null), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), 
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST);
                var A = o = {
                    vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                    fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                }, F = s.createProgram(), G = s.createShader(s.FRAGMENT_SHADER), H = s.createShader(s.VERTEX_SHADER), I = "precision " + a.getPrecision() + " float;\n";
                s.shaderSource(G, I + A.fragmentShader), s.shaderSource(H, I + A.vertexShader), 
                s.compileShader(G), s.compileShader(H), s.attachShader(F, G), s.attachShader(F, H), 
                s.linkProgram(F), p = F, k = s.getAttribLocation(p, "position"), l = s.getAttribLocation(p, "uv"), 
                c = s.getUniformLocation(p, "renderType"), d = s.getUniformLocation(p, "map"), e = s.getUniformLocation(p, "occlusionMap"), 
                f = s.getUniformLocation(p, "opacity"), g = s.getUniformLocation(p, "color"), h = s.getUniformLocation(p, "scale"), 
                i = s.getUniformLocation(p, "rotation"), j = s.getUniformLocation(p, "screenPosition");
            }
            for (s.useProgram(p), t.initAttributes(), t.enableAttribute(k), t.enableAttribute(l), 
            t.disableUnusedAttributes(), s.uniform1i(e, 0), s.uniform1i(d, 1), s.bindBuffer(s.ARRAY_BUFFER, m), 
            s.vertexAttribPointer(k, 2, s.FLOAT, !1, 16, 0), s.vertexAttribPointer(l, 2, s.FLOAT, !1, 16, 8), 
            s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, n), t.disable(s.CULL_FACE), t.setDepthWrite(!1), 
            F = 0, G = b.length; F < G; F++) if (A = 16 / w.w, B.set(A * x, A), H = b[F], u.set(H.matrixWorld.elements[12], H.matrixWorld.elements[13], H.matrixWorld.elements[14]), 
            u.applyMatrix4(v.matrixWorldInverse), u.applyProjection(v.projectionMatrix), C.copy(u), 
            D.x = w.x + C.x * y + y - 8, D.y = w.y + C.y * z + z - 8, !0 === E.containsPoint(D)) {
                t.activeTexture(s.TEXTURE0), t.bindTexture(s.TEXTURE_2D, null), t.activeTexture(s.TEXTURE1), 
                t.bindTexture(s.TEXTURE_2D, q), s.copyTexImage2D(s.TEXTURE_2D, 0, s.RGB, D.x, D.y, 16, 16, 0), 
                s.uniform1i(c, 0), s.uniform2f(h, B.x, B.y), s.uniform3f(j, C.x, C.y, C.z), t.disable(s.BLEND), 
                t.enable(s.DEPTH_TEST), s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0), t.activeTexture(s.TEXTURE0), 
                t.bindTexture(s.TEXTURE_2D, r), s.copyTexImage2D(s.TEXTURE_2D, 0, s.RGBA, D.x, D.y, 16, 16, 0), 
                s.uniform1i(c, 1), t.disable(s.DEPTH_TEST), t.activeTexture(s.TEXTURE1), t.bindTexture(s.TEXTURE_2D, q), 
                s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0), H.positionScreen.copy(C), H.customUpdateCallback ? H.customUpdateCallback(H) : H.updateLensFlares(), 
                s.uniform1i(c, 2), t.enable(s.BLEND);
                for (var I = 0, J = H.lensFlares.length; I < J; I++) {
                    var K = H.lensFlares[I];
                    .001 < K.opacity && .001 < K.scale && (C.x = K.x, C.y = K.y, C.z = K.z, A = K.size * K.scale / w.w, 
                    B.x = A * x, B.y = A, s.uniform3f(j, C.x, C.y, C.z), s.uniform2f(h, B.x, B.y), s.uniform1f(i, K.rotation), 
                    s.uniform1f(f, K.opacity), s.uniform3f(g, K.color.r, K.color.g, K.color.b), t.setBlending(K.blending, K.blendEquation, K.blendSrc, K.blendDst), 
                    a.setTexture2D(K.texture, 1), s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0));
                }
            }
            t.enable(s.CULL_FACE), t.enable(s.DEPTH_TEST), t.setDepthWrite(!0), a.resetGLState();
        }
    };
}, THREE.SpritePlugin = function(a, b) {
    function c(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id;
    }
    var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y = a.context, z = a.state, A = new THREE.Vector3(), B = new THREE.Quaternion(), C = new THREE.Vector3();
    this.render = function(D, E) {
        if (0 !== b.length) {
            if (void 0 === w) {
                var F = new Float32Array([ -.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1 ]), G = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
                u = y.createBuffer(), v = y.createBuffer(), y.bindBuffer(y.ARRAY_BUFFER, u), y.bufferData(y.ARRAY_BUFFER, F, y.STATIC_DRAW), 
                y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, v), y.bufferData(y.ELEMENT_ARRAY_BUFFER, G, y.STATIC_DRAW);
                var F = y.createProgram(), G = y.createShader(y.VERTEX_SHADER), H = y.createShader(y.FRAGMENT_SHADER);
                y.shaderSource(G, [ "precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}" ].join("\n")), 
                y.shaderSource(H, [ "precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}" ].join("\n")), 
                y.compileShader(G), y.compileShader(H), y.attachShader(F, G), y.attachShader(F, H), 
                y.linkProgram(F), w = F, s = y.getAttribLocation(w, "position"), t = y.getAttribLocation(w, "uv"), 
                d = y.getUniformLocation(w, "uvOffset"), e = y.getUniformLocation(w, "uvScale"), 
                f = y.getUniformLocation(w, "rotation"), g = y.getUniformLocation(w, "scale"), h = y.getUniformLocation(w, "color"), 
                i = y.getUniformLocation(w, "map"), j = y.getUniformLocation(w, "opacity"), k = y.getUniformLocation(w, "modelViewMatrix"), 
                l = y.getUniformLocation(w, "projectionMatrix"), m = y.getUniformLocation(w, "fogType"), 
                n = y.getUniformLocation(w, "fogDensity"), o = y.getUniformLocation(w, "fogNear"), 
                p = y.getUniformLocation(w, "fogFar"), q = y.getUniformLocation(w, "fogColor"), 
                r = y.getUniformLocation(w, "alphaTest"), F = document.createElement("canvas"), 
                F.width = 8, F.height = 8, G = F.getContext("2d"), G.fillStyle = "white", G.fillRect(0, 0, 8, 8), 
                x = new THREE.Texture(F), x.needsUpdate = !0;
            }
            y.useProgram(w), z.initAttributes(), z.enableAttribute(s), z.enableAttribute(t), 
            z.disableUnusedAttributes(), z.disable(y.CULL_FACE), z.enable(y.BLEND), y.bindBuffer(y.ARRAY_BUFFER, u), 
            y.vertexAttribPointer(s, 2, y.FLOAT, !1, 16, 0), y.vertexAttribPointer(t, 2, y.FLOAT, !1, 16, 8), 
            y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, v), y.uniformMatrix4fv(l, !1, E.projectionMatrix.elements), 
            z.activeTexture(y.TEXTURE0), y.uniform1i(i, 0), G = F = 0, (H = D.fog) ? (y.uniform3f(q, H.color.r, H.color.g, H.color.b), 
            H instanceof THREE.Fog ? (y.uniform1f(o, H.near), y.uniform1f(p, H.far), y.uniform1i(m, 1), 
            G = F = 1) : H instanceof THREE.FogExp2 && (y.uniform1f(n, H.density), y.uniform1i(m, 2), 
            G = F = 2)) : (y.uniform1i(m, 0), G = F = 0);
            for (var H = 0, I = b.length; H < I; H++) {
                var J = b[H];
                J.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, J.matrixWorld), J.z = -J.modelViewMatrix.elements[14];
            }
            b.sort(c);
            for (var K = [], H = 0, I = b.length; H < I; H++) {
                var J = b[H], L = J.material;
                y.uniform1f(r, L.alphaTest), y.uniformMatrix4fv(k, !1, J.modelViewMatrix.elements), 
                J.matrixWorld.decompose(A, B, C), K[0] = C.x, K[1] = C.y, J = 0, D.fog && L.fog && (J = G), 
                F !== J && (y.uniform1i(m, J), F = J), null !== L.map ? (y.uniform2f(d, L.map.offset.x, L.map.offset.y), 
                y.uniform2f(e, L.map.repeat.x, L.map.repeat.y)) : (y.uniform2f(d, 0, 0), y.uniform2f(e, 1, 1)), 
                y.uniform1f(j, L.opacity), y.uniform3f(h, L.color.r, L.color.g, L.color.b), y.uniform1f(f, L.rotation), 
                y.uniform2fv(g, K), z.setBlending(L.blending, L.blendEquation, L.blendSrc, L.blendDst), 
                z.setDepthTest(L.depthTest), z.setDepthWrite(L.depthWrite), L.map ? a.setTexture2D(L.map, 0) : a.setTexture2D(x, 0), 
                y.drawElements(y.TRIANGLES, 6, y.UNSIGNED_SHORT, 0);
            }
            z.enable(y.CULL_FACE), a.resetGLState();
        }
    };
}, Object.assign(THREE, {
    Face4: function(a, b, c, d, e, f, g) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), 
        new THREE.Face3(a, b, c, e, f, g);
    },
    LineStrip: 0,
    LinePieces: 1,
    MeshFaceMaterial: THREE.MultiMaterial,
    PointCloud: function(a, b) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new THREE.Points(a, b);
    },
    Particle: THREE.Sprite,
    ParticleSystem: function(a, b) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new THREE.Points(a, b);
    },
    PointCloudMaterial: function(a) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), 
        new THREE.PointsMaterial(a);
    },
    ParticleBasicMaterial: function(a) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), 
        new THREE.PointsMaterial(a);
    },
    ParticleSystemMaterial: function(a) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), 
        new THREE.PointsMaterial(a);
    },
    Vertex: function(a, b, c) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), 
        new THREE.Vector3(a, b, c);
    }
}), Object.assign(THREE.Box2.prototype, {
    empty: function() {
        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(a) {
        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), 
        this.intersectsBox(a);
    }
}), Object.assign(THREE.Box3.prototype, {
    empty: function() {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    },
    isIntersectionBox: function(a) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), 
        this.intersectsBox(a);
    },
    isIntersectionSphere: function(a) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
        this.intersectsSphere(a);
    }
}), Object.assign(THREE.Matrix3.prototype, {
    multiplyVector3: function(a) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), 
        a.applyMatrix3(this);
    },
    multiplyVector3Array: function(a) {
        return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), 
        this.applyToVector3Array(a);
    }
}), Object.assign(THREE.Matrix4.prototype, {
    extractPosition: function(a) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), 
        this.copyPosition(a);
    },
    setRotationFromQuaternion: function(a) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), 
        this.makeRotationFromQuaternion(a);
    },
    multiplyVector3: function(a) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), 
        a.applyProjection(this);
    },
    multiplyVector4: function(a) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
        a.applyMatrix4(this);
    },
    multiplyVector3Array: function(a) {
        return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), 
        this.applyToVector3Array(a);
    },
    rotateAxis: function(a) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), 
        a.transformDirection(this);
    },
    crossVector: function(a) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
        a.applyMatrix4(this);
    },
    translate: function(a) {
        console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function(a) {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function(a) {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function(a) {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function(a, b) {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    }
}), Object.assign(THREE.Plane.prototype, {
    isIntersectionLine: function(a) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), 
        this.intersectsLine(a);
    }
}), Object.assign(THREE.Quaternion.prototype, {
    multiplyVector3: function(a) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), 
        a.applyQuaternion(this);
    }
}), Object.assign(THREE.Ray.prototype, {
    isIntersectionBox: function(a) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), 
        this.intersectsBox(a);
    },
    isIntersectionPlane: function(a) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), 
        this.intersectsPlane(a);
    },
    isIntersectionSphere: function(a) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
        this.intersectsSphere(a);
    }
}), Object.assign(THREE.Vector3.prototype, {
    setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(a) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), 
        this.setFromMatrixPosition(a);
    },
    getScaleFromMatrix: function(a) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), 
        this.setFromMatrixScale(a);
    },
    getColumnFromMatrix: function(a, b) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), 
        this.setFromMatrixColumn(b, a);
    }
}), Object.assign(THREE.Object3D.prototype, {
    getChildByName: function(a) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), 
        this.getObjectByName(a);
    },
    renderDepth: function(a) {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    },
    translate: function(a, b) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), 
        this.translateOnAxis(b, a);
    }
}), Object.defineProperties(THREE.Object3D.prototype, {
    eulerOrder: {
        get: function() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
        },
        set: function(a) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = a;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function(a) {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
    }
}), Object.defineProperties(THREE.LOD.prototype, {
    objects: {
        get: function() {
            return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
        }
    }
}), THREE.PerspectiveCamera.prototype.setLens = function(a, b) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), 
    void 0 !== b && (this.filmGauge = b), this.setFocalLength(a);
}, Object.defineProperties(THREE.Light.prototype, {
    onlyShadow: {
        set: function(a) {
            console.warn("THREE.Light: .onlyShadow has been removed.");
        }
    },
    shadowCameraFov: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = a;
        }
    },
    shadowCameraLeft: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = a;
        }
    },
    shadowCameraRight: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = a;
        }
    },
    shadowCameraTop: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = a;
        }
    },
    shadowCameraBottom: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), 
            this.shadow.camera.bottom = a;
        }
    },
    shadowCameraNear: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = a;
        }
    },
    shadowCameraFar: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = a;
        }
    },
    shadowCameraVisible: {
        set: function(a) {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
    },
    shadowBias: {
        set: function(a) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = a;
        }
    },
    shadowDarkness: {
        set: function(a) {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
    },
    shadowMapWidth: {
        set: function(a) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = a;
        }
    },
    shadowMapHeight: {
        set: function(a) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = a;
        }
    }
}), Object.defineProperties(THREE.BufferAttribute.prototype, {
    length: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), 
            this.array.length;
        }
    }
}), Object.assign(THREE.BufferGeometry.prototype, {
    addIndex: function(a) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), 
        this.setIndex(a);
    },
    addDrawCall: function(a, b, c) {
        void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), 
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(a, b);
    },
    clearDrawCalls: function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), 
        this.clearGroups();
    },
    computeTangents: function() {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
    },
    computeOffsets: function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }
}), Object.defineProperties(THREE.BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), 
            this.groups;
        }
    },
    offsets: {
        get: function() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), 
            this.groups;
        }
    }
}), Object.defineProperties(THREE.Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE." + this.type + ": .wrapAround has been removed.");
        },
        set: function(a) {
            console.warn("THREE." + this.type + ": .wrapAround has been removed.");
        }
    },
    wrapRGB: {
        get: function() {
            return console.warn("THREE." + this.type + ": .wrapRGB has been removed."), new THREE.Color();
        }
    }
}), Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
    metal: {
        get: function() {
            return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), 
            !1;
        },
        set: function(a) {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
        }
    }
}), Object.defineProperties(THREE.ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), 
            this.extensions.derivatives;
        },
        set: function(a) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), 
            this.extensions.derivatives = a;
        }
    }
}), THREE.EventDispatcher.prototype = Object.assign(Object.create({
    constructor: THREE.EventDispatcher,
    apply: function(a) {
        console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in."), 
        Object.assign(a, this);
    }
}), THREE.EventDispatcher.prototype), Object.assign(THREE.WebGLRenderer.prototype, {
    supportsFloatTextures: function() {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), 
        this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), 
        this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), 
        this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), 
        this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), 
        this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), 
        this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
        return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), 
        this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(a) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), 
        this.setScissorTest(a);
    },
    initMaterial: function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    }
}), Object.defineProperties(THREE.WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), 
            this.shadowMap.enabled = a;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = a;
        }
    },
    shadowMapCullFace: {
        get: function() {
            return this.shadowMap.cullFace;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), 
            this.shadowMap.cullFace = a;
        }
    }
}), Object.defineProperties(THREE.WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            return this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;
        },
        set: function(a) {
            a = a !== THREE.CullFaceBack, console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + "."), 
            this.renderReverseSided = a;
        }
    }
}), Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = a;
        }
    },
    wrapT: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = a;
        }
    },
    magFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
            this.texture.magFilter;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
            this.texture.magFilter = a;
        }
    },
    minFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
            this.texture.minFilter;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
            this.texture.minFilter = a;
        }
    },
    anisotropy: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
            this.texture.anisotropy;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
            this.texture.anisotropy = a;
        }
    },
    offset: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), 
            this.texture.offset;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = a;
        }
    },
    repeat: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), 
            this.texture.repeat;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = a;
        }
    },
    format: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), 
            this.texture.format;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = a;
        }
    },
    type: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = a;
        }
    },
    generateMipmaps: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
            this.texture.generateMipmaps;
        },
        set: function(a) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
            this.texture.generateMipmaps = a;
        }
    }
}), Object.assign(THREE.Audio.prototype, {
    load: function(a) {
        console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
        var b = this;
        return new THREE.AudioLoader().load(a, function(a) {
            b.setBuffer(a);
        }), this;
    }
}), Object.assign(THREE.AudioAnalyser.prototype, {
    getData: function(a) {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), 
        this.getFrequencyData();
    }
}), THREE.GeometryUtils = {
    merge: function(a, b, c) {
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
        var d;
        b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, 
        b = b.geometry), a.merge(b, d, c);
    },
    center: function(a) {
        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), 
        a.center();
    }
}, THREE.ImageUtils = {
    crossOrigin: void 0,
    loadTexture: function(a, b, c, d) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var e = new THREE.TextureLoader();
        return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), 
        a;
    },
    loadTextureCube: function(a, b, c, d) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var e = new THREE.CubeTextureLoader();
        return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), 
        a;
    },
    loadCompressedTexture: function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    },
    loadCompressedTextureCube: function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    }
}, THREE.Projector = function() {
    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), 
    this.projectVector = function(a, b) {
        console.warn("THREE.Projector: .projectVector() is now vector.project()."), a.project(b);
    }, this.unprojectVector = function(a, b) {
        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), 
        a.unproject(b);
    }, this.pickingRay = function(a, b) {
        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
    };
}, THREE.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), 
    this.domElement = document.createElement("canvas"), this.clear = function() {}, 
    this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {};
}, THREE.CurveUtils = {
    tangentQuadraticBezier: function(a, b, c, d) {
        return 2 * (1 - a) * (c - b) + 2 * a * (d - c);
    },
    tangentCubicBezier: function(a, b, c, d, e) {
        return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e;
    },
    tangentSpline: function(a, b, c, d, e) {
        return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a);
    },
    interpolate: function(a, b, c, d, e) {
        a = .5 * (c - a), d = .5 * (d - b);
        var f = e * e;
        return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b;
    }
}, THREE.SceneUtils = {
    createMultiMaterialObject: function(a, b) {
        for (var c = new THREE.Group(), d = 0, e = b.length; d < e; d++) c.add(new THREE.Mesh(a, b[d]));
        return c;
    },
    detach: function(a, b, c) {
        a.applyMatrix(b.matrixWorld), b.remove(a), c.add(a);
    },
    attach: function(a, b, c) {
        var d = new THREE.Matrix4();
        d.getInverse(c.matrixWorld), a.applyMatrix(d), b.remove(a), c.add(a);
    }
}, THREE.ShapeUtils = {
    area: function(a) {
        for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
        return .5 * c;
    },
    triangulate: function() {
        return function(a, b) {
            var c = a.length;
            if (3 > c) return null;
            var d, e, f, g = [], h = [], i = [];
            if (0 < THREE.ShapeUtils.area(a)) for (e = 0; e < c; e++) h[e] = e; else for (e = 0; e < c; e++) h[e] = c - 1 - e;
            var j = 2 * c;
            for (e = c - 1; 2 < c; ) {
                if (0 >= j--) {
                    console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                    break;
                }
                d = e, c <= d && (d = 0), e = d + 1, c <= e && (e = 0), f = e + 1, c <= f && (f = 0);
                var k;
                a: {
                    var l = k = void 0, m = void 0, n = void 0, o = void 0, p = void 0, q = void 0, r = void 0, s = void 0, l = a[h[d]].x, m = a[h[d]].y, n = a[h[e]].x, o = a[h[e]].y, p = a[h[f]].x, q = a[h[f]].y;
                    if (Number.EPSILON > (n - l) * (q - m) - (o - m) * (p - l)) k = !1; else {
                        var t = void 0, u = void 0, v = void 0, w = void 0, x = void 0, y = void 0, z = void 0, A = void 0, B = void 0, C = void 0, B = A = z = s = r = void 0, t = p - n, u = q - o, v = l - p, w = m - q, x = n - l, y = o - m;
                        for (k = 0; k < c; k++) if (r = a[h[k]].x, s = a[h[k]].y, !(r === l && s === m || r === n && s === o || r === p && s === q) && (z = r - l, 
                        A = s - m, B = r - n, C = s - o, r -= p, s -= q, B = t * C - u * B, z = x * A - y * z, 
                        A = v * s - w * r, B >= -Number.EPSILON && A >= -Number.EPSILON && z >= -Number.EPSILON)) {
                            k = !1;
                            break a;
                        }
                        k = !0;
                    }
                }
                if (k) {
                    for (g.push([ a[h[d]], a[h[e]], a[h[f]] ]), i.push([ h[d], h[e], h[f] ]), d = e, 
                    f = e + 1; f < c; d++, f++) h[d] = h[f];
                    c--, j = 2 * c;
                }
            }
            return b ? i : g;
        };
    }(),
    triangulateShape: function(a, b) {
        function c(a, b, c) {
            return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y;
        }
        function d(a, b, d, e, f) {
            var g = b.x - a.x, h = b.y - a.y, i = e.x - d.x, j = e.y - d.y, k = a.x - d.x, l = a.y - d.y, m = h * i - g * j, n = h * k - g * l;
            if (Math.abs(m) > Number.EPSILON) {
                if (0 < m) {
                    if (0 > n || n > m) return [];
                    if (i = j * k - i * l, 0 > i || i > m) return [];
                } else {
                    if (0 < n || n < m) return [];
                    if (i = j * k - i * l, 0 < i || i < m) return [];
                }
                return 0 === i ? !f || 0 !== n && n !== m ? [ a ] : [] : i === m ? !f || 0 !== n && n !== m ? [ b ] : [] : 0 === n ? [ d ] : n === m ? [ e ] : (f = i / m, 
                [ {
                    x: a.x + f * g,
                    y: a.y + f * h
                } ]);
            }
            return 0 !== n || j * k !== i * l ? [] : (h = 0 === g && 0 === h, i = 0 === i && 0 === j, 
            h && i ? a.x !== d.x || a.y !== d.y ? [] : [ a ] : h ? c(d, e, a) ? [ a ] : [] : i ? c(a, b, d) ? [ d ] : [] : (0 !== g ? (a.x < b.x ? (g = a, 
            i = a.x, h = b, a = b.x) : (g = b, i = b.x, h = a, a = a.x), d.x < e.x ? (b = d, 
            m = d.x, j = e, d = e.x) : (b = e, m = e.x, j = d, d = d.x)) : (a.y < b.y ? (g = a, 
            i = a.y, h = b, a = b.y) : (g = b, i = b.y, h = a, a = a.y), d.y < e.y ? (b = d, 
            m = d.y, j = e, d = e.y) : (b = e, m = e.y, j = d, d = d.y)), i <= m ? a < m ? [] : a === m ? f ? [] : [ b ] : a <= d ? [ b, h ] : [ b, j ] : i > d ? [] : i === d ? f ? [] : [ g ] : a <= d ? [ g, h ] : [ g, j ]));
        }
        function e(a, b, c, d) {
            var e = b.x - a.x, f = b.y - a.y;
            b = c.x - a.x, c = c.y - a.y;
            var g = d.x - a.x;
            return d = d.y - a.y, a = e * c - f * b, e = e * d - f * g, Math.abs(a) > Number.EPSILON ? (b = g * c - d * b, 
            0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e;
        }
        var f, g, h, i, j, k = {};
        for (h = a.concat(), f = 0, g = b.length; f < g; f++) Array.prototype.push.apply(h, b[f]);
        for (f = 0, g = h.length; f < g; f++) j = h[f].x + ":" + h[f].y, void 0 !== k[j] && console.warn("THREE.Shape: Duplicate point", j), 
        k[j] = f;
        f = function(a, b) {
            function c(a, b) {
                var c = q.length - 1, d = a - 1;
                0 > d && (d = c);
                var f = a + 1;
                return f > c && (f = 0), !!(c = e(q[a], q[d], q[f], h[b])) && (c = h.length - 1, 
                d = b - 1, 0 > d && (d = c), f = b + 1, f > c && (f = 0), !!(c = e(h[b], h[d], h[f], q[a])));
            }
            function f(a, b) {
                var c, e;
                for (c = 0; c < q.length; c++) if (e = c + 1, e %= q.length, e = d(a, b, q[c], q[e], !0), 
                0 < e.length) return !0;
                return !1;
            }
            function g(a, c) {
                var e, f, g, h;
                for (e = 0; e < r.length; e++) for (f = b[r[e]], g = 0; g < f.length; g++) if (h = g + 1, 
                h %= f.length, h = d(a, c, f[g], f[h], !0), 0 < h.length) return !0;
                return !1;
            }
            var h, i, j, k, l, m, n, o, p, q = a.concat(), r = [], s = [], t = 0;
            for (i = b.length; t < i; t++) r.push(t);
            n = 0;
            for (var u = 2 * r.length; 0 < r.length; ) {
                if (u--, 0 > u) {
                    console.log("Infinite Loop! Holes left:" + r.length + ", Probably Hole outside Shape!");
                    break;
                }
                for (j = n; j < q.length; j++) {
                    for (k = q[j], i = -1, t = 0; t < r.length; t++) if (l = r[t], m = k.x + ":" + k.y + ":" + l, 
                    void 0 === s[m]) {
                        for (h = b[l], o = 0; o < h.length; o++) if (l = h[o], c(j, o) && !f(k, l) && !g(k, l)) {
                            i = o, r.splice(t, 1), n = q.slice(0, j + 1), l = q.slice(j), o = h.slice(i), p = h.slice(0, i + 1), 
                            q = n.concat(o).concat(p).concat(l), n = j;
                            break;
                        }
                        if (0 <= i) break;
                        s[m] = !0;
                    }
                    if (0 <= i) break;
                }
            }
            return q;
        }(a, b);
        var l = THREE.ShapeUtils.triangulate(f, !1);
        for (f = 0, g = l.length; f < g; f++) for (i = l[f], h = 0; 3 > h; h++) j = i[h].x + ":" + i[h].y, 
        j = k[j], void 0 !== j && (i[h] = j);
        return l.concat();
    },
    isClockWise: function(a) {
        return 0 > THREE.ShapeUtils.area(a);
    },
    b2: function() {
        return function(a, b, c, d) {
            var e = 1 - a;
            return e * e * b + 2 * (1 - a) * a * c + a * a * d;
        };
    }(),
    b3: function() {
        return function(a, b, c, d, e) {
            var f = 1 - a, g = 1 - a;
            return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e;
        };
    }()
}, THREE.Curve = function() {}, THREE.Curve.prototype = {
    constructor: THREE.Curve,
    getPoint: function(a) {
        return console.warn("THREE.Curve: Warning, getPoint() not implemented!"), null;
    },
    getPointAt: function(a) {
        return a = this.getUtoTmapping(a), this.getPoint(a);
    },
    getPoints: function(a) {
        a || (a = 5);
        var b, c = [];
        for (b = 0; b <= a; b++) c.push(this.getPoint(b / a));
        return c;
    },
    getSpacedPoints: function(a) {
        a || (a = 5);
        var b, c = [];
        for (b = 0; b <= a; b++) c.push(this.getPointAt(b / a));
        return c;
    },
    getLength: function() {
        var a = this.getLengths();
        return a[a.length - 1];
    },
    getLengths: function(a) {
        if (a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var b, c, d = [], e = this.getPoint(0), f = 0;
        for (d.push(0), c = 1; c <= a; c++) b = this.getPoint(c / a), f += b.distanceTo(e), 
        d.push(f), e = b;
        return this.cacheArcLengths = d;
    },
    updateArcLengths: function() {
        this.needsUpdate = !0, this.getLengths();
    },
    getUtoTmapping: function(a, b) {
        var c, d = this.getLengths(), e = 0, f = d.length;
        c = b ? b : a * d[f - 1];
        for (var g, h = 0, i = f - 1; h <= i; ) if (e = Math.floor(h + (i - h) / 2), g = d[e] - c, 
        0 > g) h = e + 1; else {
            if (!(0 < g)) {
                i = e;
                break;
            }
            i = e - 1;
        }
        return e = i, d[e] === c ? e / (f - 1) : (h = d[e], d = (e + (c - h) / (d[e + 1] - h)) / (f - 1));
    },
    getTangent: function(a) {
        var b = a - 1e-4;
        return a += 1e-4, 0 > b && (b = 0), 1 < a && (a = 1), b = this.getPoint(b), this.getPoint(a).clone().sub(b).normalize();
    },
    getTangentAt: function(a) {
        return a = this.getUtoTmapping(a), this.getTangent(a);
    }
}, THREE.Curve.create = function(a, b) {
    return a.prototype = Object.create(THREE.Curve.prototype), a.prototype.constructor = a, 
    a.prototype.getPoint = b, a;
}, THREE.CurvePath = function() {
    this.curves = [], this.autoClose = !1;
}, THREE.CurvePath.prototype = Object.assign(Object.create(THREE.Curve.prototype), {
    constructor: THREE.CurvePath,
    add: function(a) {
        this.curves.push(a);
    },
    closePath: function() {
        var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
        a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));
    },
    getPoint: function(a) {
        for (var b = a * this.getLength(), c = this.getCurveLengths(), d = 0; d < c.length; ) {
            if (c[d] >= b) return a = this.curves[d], b = 1 - (c[d] - b) / a.getLength(), a.getPointAt(b);
            d++;
        }
        return null;
    },
    getLength: function() {
        var a = this.getCurveLengths();
        return a[a.length - 1];
    },
    getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), 
        a.push(b);
        return this.cacheLengths = a;
    },
    createPointsGeometry: function(a) {
        return a = this.getPoints(a), this.createGeometry(a);
    },
    createSpacedPointsGeometry: function(a) {
        return a = this.getSpacedPoints(a), this.createGeometry(a);
    },
    createGeometry: function(a) {
        for (var b = new THREE.Geometry(), c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            b.vertices.push(new THREE.Vector3(e.x, e.y, e.z || 0));
        }
        return b;
    }
}), THREE.Font = function(a) {
    this.data = a;
}, Object.assign(THREE.Font.prototype, {
    generateShapes: function(a, b, c) {
        void 0 === b && (b = 100), void 0 === c && (c = 4);
        var d = this.data;
        a = String(a).split("");
        var e = b / d.resolution, f = 0;
        b = [];
        for (var g = 0; g < a.length; g++) {
            var h;
            h = e;
            var i = f, j = d.glyphs[a[g]] || d.glyphs["?"];
            if (j) {
                var k = new THREE.Path(), l = [], m = THREE.ShapeUtils.b2, n = THREE.ShapeUtils.b3, o = void 0, p = void 0, q = p = o = void 0, r = void 0, s = void 0, t = void 0, u = void 0, v = void 0, r = void 0;
                if (j.o) for (var w = j._cachedOutline || (j._cachedOutline = j.o.split(" ")), x = 0, y = w.length; x < y; ) switch (w[x++]) {
                  case "m":
                    o = w[x++] * h + i, p = w[x++] * h, k.moveTo(o, p);
                    break;

                  case "l":
                    o = w[x++] * h + i, p = w[x++] * h, k.lineTo(o, p);
                    break;

                  case "q":
                    if (o = w[x++] * h + i, p = w[x++] * h, s = w[x++] * h + i, t = w[x++] * h, k.quadraticCurveTo(s, t, o, p), 
                    r = l[l.length - 1]) for (var q = r.x, r = r.y, z = 1; z <= c; z++) {
                        var A = z / c;
                        m(A, q, s, o), m(A, r, t, p);
                    }
                    break;

                  case "b":
                    if (o = w[x++] * h + i, p = w[x++] * h, s = w[x++] * h + i, t = w[x++] * h, u = w[x++] * h + i, 
                    v = w[x++] * h, k.bezierCurveTo(s, t, u, v, o, p), r = l[l.length - 1]) for (q = r.x, 
                    r = r.y, z = 1; z <= c; z++) A = z / c, n(A, q, s, u, o), n(A, r, t, v, p);
                }
                h = {
                    offset: j.ha * h,
                    path: k
                };
            } else h = void 0;
            f += h.offset, b.push(h.path);
        }
        for (c = [], d = 0, a = b.length; d < a; d++) Array.prototype.push.apply(c, b[d].toShapes());
        return c;
    }
}), THREE.Path = function(a) {
    THREE.CurvePath.call(this), this.actions = [], a && this.fromPoints(a);
}, THREE.Path.prototype = Object.assign(Object.create(THREE.CurvePath.prototype), {
    constructor: THREE.Path,
    fromPoints: function(a) {
        this.moveTo(a[0].x, a[0].y);
        for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y);
    },
    moveTo: function(a, b) {
        this.actions.push({
            action: "moveTo",
            args: [ a, b ]
        });
    },
    lineTo: function(a, b) {
        var c = this.actions[this.actions.length - 1].args, c = new THREE.LineCurve(new THREE.Vector2(c[c.length - 2], c[c.length - 1]), new THREE.Vector2(a, b));
        this.curves.push(c), this.actions.push({
            action: "lineTo",
            args: [ a, b ]
        });
    },
    quadraticCurveTo: function(a, b, c, d) {
        var e = this.actions[this.actions.length - 1].args, e = new THREE.QuadraticBezierCurve(new THREE.Vector2(e[e.length - 2], e[e.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
        this.curves.push(e), this.actions.push({
            action: "quadraticCurveTo",
            args: [ a, b, c, d ]
        });
    },
    bezierCurveTo: function(a, b, c, d, e, f) {
        var g = this.actions[this.actions.length - 1].args, g = new THREE.CubicBezierCurve(new THREE.Vector2(g[g.length - 2], g[g.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
        this.curves.push(g), this.actions.push({
            action: "bezierCurveTo",
            args: [ a, b, c, d, e, f ]
        });
    },
    splineThru: function(a) {
        var b = Array.prototype.slice.call(arguments), c = this.actions[this.actions.length - 1].args, c = [ new THREE.Vector2(c[c.length - 2], c[c.length - 1]) ];
        Array.prototype.push.apply(c, a), c = new THREE.SplineCurve(c), this.curves.push(c), 
        this.actions.push({
            action: "splineThru",
            args: b
        });
    },
    arc: function(a, b, c, d, e, f) {
        var g = this.actions[this.actions.length - 1].args;
        this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);
    },
    absarc: function(a, b, c, d, e, f) {
        this.absellipse(a, b, c, c, d, e, f);
    },
    ellipse: function(a, b, c, d, e, f, g, h) {
        var i = this.actions[this.actions.length - 1].args;
        this.absellipse(a + i[i.length - 2], b + i[i.length - 1], c, d, e, f, g, h);
    },
    absellipse: function(a, b, c, d, e, f, g, h) {
        var i = [ a, b, c, d, e, f, g, h || 0 ];
        a = new THREE.EllipseCurve(a, b, c, d, e, f, g, h), this.curves.push(a), a = a.getPoint(1), 
        i.push(a.x), i.push(a.y), this.actions.push({
            action: "ellipse",
            args: i
        });
    },
    getSpacedPoints: function(a) {
        a || (a = 40);
        for (var b = [], c = 0; c < a; c++) b.push(this.getPoint(c / a));
        return this.autoClose && b.push(b[0]), b;
    },
    getPoints: function(a) {
        a = a || 12;
        for (var b, c, d, e, f, g, h, i, j, k, l = THREE.ShapeUtils.b2, m = THREE.ShapeUtils.b3, n = [], o = 0, p = this.actions.length; o < p; o++) {
            j = this.actions[o];
            var q = j.args;
            switch (j.action) {
              case "moveTo":
                n.push(new THREE.Vector2(q[0], q[1]));
                break;

              case "lineTo":
                n.push(new THREE.Vector2(q[0], q[1]));
                break;

              case "quadraticCurveTo":
                for (b = q[2], c = q[3], f = q[0], g = q[1], 0 < n.length ? (j = n[n.length - 1], 
                h = j.x, i = j.y) : (j = this.actions[o - 1].args, h = j[j.length - 2], i = j[j.length - 1]), 
                q = 1; q <= a; q++) k = q / a, j = l(k, h, f, b), k = l(k, i, g, c), n.push(new THREE.Vector2(j, k));
                break;

              case "bezierCurveTo":
                for (b = q[4], c = q[5], f = q[0], g = q[1], d = q[2], e = q[3], 0 < n.length ? (j = n[n.length - 1], 
                h = j.x, i = j.y) : (j = this.actions[o - 1].args, h = j[j.length - 2], i = j[j.length - 1]), 
                q = 1; q <= a; q++) k = q / a, j = m(k, h, f, d, b), k = m(k, i, g, e, c), n.push(new THREE.Vector2(j, k));
                break;

              case "splineThru":
                for (j = this.actions[o - 1].args, k = [ new THREE.Vector2(j[j.length - 2], j[j.length - 1]) ], 
                j = a * q[0].length, k = k.concat(q[0]), k = new THREE.SplineCurve(k), q = 1; q <= j; q++) n.push(k.getPointAt(q / j));
                break;

              case "arc":
                for (b = q[0], c = q[1], g = q[2], d = q[3], j = q[4], f = !!q[5], h = j - d, i = 2 * a, 
                q = 1; q <= i; q++) k = q / i, f || (k = 1 - k), k = d + k * h, j = b + g * Math.cos(k), 
                k = c + g * Math.sin(k), n.push(new THREE.Vector2(j, k));
                break;

              case "ellipse":
                b = q[0], c = q[1], g = q[2], e = q[3], d = q[4], j = q[5], f = !!q[6];
                var r = q[7];
                h = j - d, i = 2 * a;
                var s, t;
                for (0 !== r && (s = Math.cos(r), t = Math.sin(r)), q = 1; q <= i; q++) {
                    if (k = q / i, f || (k = 1 - k), k = d + k * h, j = b + g * Math.cos(k), k = c + e * Math.sin(k), 
                    0 !== r) {
                        var u = j;
                        j = (u - b) * s - (k - c) * t + b, k = (u - b) * t + (k - c) * s + c;
                    }
                    n.push(new THREE.Vector2(j, k));
                }
            }
        }
        return a = n[n.length - 1], Math.abs(a.x - n[0].x) < Number.EPSILON && Math.abs(a.y - n[0].y) < Number.EPSILON && n.splice(n.length - 1, 1), 
        this.autoClose && n.push(n[0]), n;
    },
    toShapes: function(a, b) {
        function c(a) {
            for (var b = [], c = 0, d = a.length; c < d; c++) {
                var e = a[c], f = new THREE.Shape();
                f.actions = e.actions, f.curves = e.curves, b.push(f);
            }
            return b;
        }
        function d(a, b) {
            for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
                var g = b[e], h = b[f], i = h.x - g.x, j = h.y - g.y;
                if (Math.abs(j) > Number.EPSILON) {
                    if (0 > j && (g = b[f], i = -i, h = b[e], j = -j), !(a.y < g.y || a.y > h.y)) if (a.y === g.y) {
                        if (a.x === g.x) return !0;
                    } else {
                        if (e = j * (a.x - g.x) - i * (a.y - g.y), 0 === e) return !0;
                        0 > e || (d = !d);
                    }
                } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0;
            }
            return d;
        }
        var e = THREE.ShapeUtils.isClockWise, f = function(a) {
            for (var b = [], c = new THREE.Path(), d = 0, e = a.length; d < e; d++) {
                var f = a[d], g = f.args, f = f.action;
                "moveTo" === f && 0 !== c.actions.length && (b.push(c), c = new THREE.Path()), c[f].apply(c, g);
            }
            return 0 !== c.actions.length && b.push(c), b;
        }(this.actions);
        if (0 === f.length) return [];
        if (!0 === b) return c(f);
        var g, h, i, j = [];
        if (1 === f.length) return h = f[0], i = new THREE.Shape(), i.actions = h.actions, 
        i.curves = h.curves, j.push(i), j;
        var k = !e(f[0].getPoints()), k = a ? !k : k;
        i = [];
        var l, m = [], n = [], o = 0;
        m[o] = void 0, n[o] = [];
        for (var p = 0, q = f.length; p < q; p++) h = f[p], l = h.getPoints(), g = e(l), 
        (g = a ? !g : g) ? (!k && m[o] && o++, m[o] = {
            s: new THREE.Shape(),
            p: l
        }, m[o].s.actions = h.actions, m[o].s.curves = h.curves, k && o++, n[o] = []) : n[o].push({
            h: h,
            p: l[0]
        });
        if (!m[0]) return c(f);
        if (1 < m.length) {
            for (p = !1, h = [], e = 0, f = m.length; e < f; e++) i[e] = [];
            for (e = 0, f = m.length; e < f; e++) for (g = n[e], k = 0; k < g.length; k++) {
                for (o = g[k], l = !0, q = 0; q < m.length; q++) d(o.p, m[q].p) && (e !== q && h.push({
                    froms: e,
                    tos: q,
                    hole: k
                }), l ? (l = !1, i[q].push(o)) : p = !0);
                l && i[e].push(o);
            }
            0 < h.length && (p || (n = i));
        }
        for (p = 0, e = m.length; p < e; p++) for (i = m[p].s, j.push(i), h = n[p], f = 0, 
        g = h.length; f < g; f++) i.holes.push(h[f].h);
        return j;
    }
}), THREE.Shape = function() {
    THREE.Path.apply(this, arguments), this.holes = [];
}, THREE.Shape.prototype = Object.assign(Object.create(THREE.Path.prototype), {
    constructor: THREE.Shape,
    extrude: function(a) {
        return new THREE.ExtrudeGeometry(this, a);
    },
    makeGeometry: function(a) {
        return new THREE.ShapeGeometry(this, a);
    },
    getPointsHoles: function(a) {
        for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
        return b;
    },
    extractAllPoints: function(a) {
        return {
            shape: this.getPoints(a),
            holes: this.getPointsHoles(a)
        };
    },
    extractPoints: function(a) {
        return this.extractAllPoints(a);
    }
}), THREE.LineCurve = function(a, b) {
    this.v1 = a, this.v2 = b;
}, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.constructor = THREE.LineCurve, 
THREE.LineCurve.prototype.getPoint = function(a) {
    var b = this.v2.clone().sub(this.v1);
    return b.multiplyScalar(a).add(this.v1), b;
}, THREE.LineCurve.prototype.getPointAt = function(a) {
    return this.getPoint(a);
}, THREE.LineCurve.prototype.getTangent = function(a) {
    return this.v2.clone().sub(this.v1).normalize();
}, THREE.QuadraticBezierCurve = function(a, b, c) {
    this.v0 = a, this.v1 = b, this.v2 = c;
}, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), 
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve, THREE.QuadraticBezierCurve.prototype.getPoint = function(a) {
    var b = THREE.ShapeUtils.b2;
    return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y));
}, THREE.QuadraticBezierCurve.prototype.getTangent = function(a) {
    var b = THREE.CurveUtils.tangentQuadraticBezier;
    return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y)).normalize();
}, THREE.CubicBezierCurve = function(a, b, c, d) {
    this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d;
}, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve, 
THREE.CubicBezierCurve.prototype.getPoint = function(a) {
    var b = THREE.ShapeUtils.b3;
    return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
}, THREE.CubicBezierCurve.prototype.getTangent = function(a) {
    var b = THREE.CurveUtils.tangentCubicBezier;
    return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
}, THREE.SplineCurve = function(a) {
    this.points = void 0 == a ? [] : a;
}, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.constructor = THREE.SplineCurve, 
THREE.SplineCurve.prototype.getPoint = function(a) {
    var b = this.points;
    a *= b.length - 1;
    var c = Math.floor(a);
    a -= c;
    var d = b[0 === c ? c : c - 1], e = b[c], f = b[c > b.length - 2 ? b.length - 1 : c + 1], b = b[c > b.length - 3 ? b.length - 1 : c + 2], c = THREE.CurveUtils.interpolate;
    return new THREE.Vector2(c(d.x, e.x, f.x, b.x, a), c(d.y, e.y, f.y, b.y, a));
}, THREE.EllipseCurve = function(a, b, c, d, e, f, g, h) {
    this.aX = a, this.aY = b, this.xRadius = c, this.yRadius = d, this.aStartAngle = e, 
    this.aEndAngle = f, this.aClockwise = g, this.aRotation = h || 0;
}, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve, 
THREE.EllipseCurve.prototype.getPoint = function(a) {
    var b = this.aEndAngle - this.aStartAngle;
    0 > b && (b += 2 * Math.PI), b > 2 * Math.PI && (b -= 2 * Math.PI), b = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b, 
    a = this.aX + this.xRadius * Math.cos(b);
    var c = this.aY + this.yRadius * Math.sin(b);
    if (0 !== this.aRotation) {
        var b = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a;
        a = (e - this.aX) * b - (c - this.aY) * d + this.aX, c = (e - this.aX) * d + (c - this.aY) * b + this.aY;
    }
    return new THREE.Vector2(a, c);
}, THREE.ArcCurve = function(a, b, c, d, e, f) {
    THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);
}, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.ArcCurve.prototype.constructor = THREE.ArcCurve, 
THREE.LineCurve3 = THREE.Curve.create(function(a, b) {
    this.v1 = a, this.v2 = b;
}, function(a) {
    var b = new THREE.Vector3();
    return b.subVectors(this.v2, this.v1), b.multiplyScalar(a), b.add(this.v1), b;
}), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(a, b, c) {
    this.v0 = a, this.v1 = b, this.v2 = c;
}, function(a) {
    var b = THREE.ShapeUtils.b2;
    return new THREE.Vector3(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y), b(a, this.v0.z, this.v1.z, this.v2.z));
}), THREE.CubicBezierCurve3 = THREE.Curve.create(function(a, b, c, d) {
    this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d;
}, function(a) {
    var b = THREE.ShapeUtils.b3;
    return new THREE.Vector3(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
}), THREE.SplineCurve3 = THREE.Curve.create(function(a) {
    console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"), 
    this.points = void 0 == a ? [] : a;
}, function(a) {
    var b = this.points;
    a *= b.length - 1;
    var c = Math.floor(a);
    a -= c;
    var d = b[0 == c ? c : c - 1], e = b[c], f = b[c > b.length - 2 ? b.length - 1 : c + 1], b = b[c > b.length - 3 ? b.length - 1 : c + 2], c = THREE.CurveUtils.interpolate;
    return new THREE.Vector3(c(d.x, e.x, f.x, b.x, a), c(d.y, e.y, f.y, b.y, a), c(d.z, e.z, f.z, b.z, a));
}), THREE.CatmullRomCurve3 = function() {
    function a() {}
    var b = new THREE.Vector3(), c = new a(), d = new a(), e = new a();
    return a.prototype.init = function(a, b, c, d) {
        this.c0 = a, this.c1 = c, this.c2 = -3 * a + 3 * b - 2 * c - d, this.c3 = 2 * a - 2 * b + c + d;
    }, a.prototype.initNonuniformCatmullRom = function(a, b, c, d, e, f, g) {
        a = ((b - a) / e - (c - a) / (e + f) + (c - b) / f) * f, d = ((c - b) / f - (d - b) / (f + g) + (d - c) / g) * f, 
        this.init(b, c, a, d);
    }, a.prototype.initCatmullRom = function(a, b, c, d, e) {
        this.init(b, c, e * (c - a), e * (d - b));
    }, a.prototype.calc = function(a) {
        var b = a * a;
        return this.c0 + this.c1 * a + this.c2 * b + this.c3 * b * a;
    }, THREE.Curve.create(function(a) {
        this.points = a || [], this.closed = !1;
    }, function(a) {
        var f, g, h = this.points;
        g = h.length, 2 > g && console.log("duh, you need at least 2 points"), a *= g - (this.closed ? 0 : 1), 
        f = Math.floor(a), a -= f, this.closed ? f += 0 < f ? 0 : (Math.floor(Math.abs(f) / h.length) + 1) * h.length : 0 === a && f === g - 1 && (f = g - 2, 
        a = 1);
        var i, j, k;
        if (this.closed || 0 < f ? i = h[(f - 1) % g] : (b.subVectors(h[0], h[1]).add(h[0]), 
        i = b), j = h[f % g], k = h[(f + 1) % g], this.closed || f + 2 < g ? h = h[(f + 2) % g] : (b.subVectors(h[g - 1], h[g - 2]).add(h[g - 1]), 
        h = b), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
            var l = "chordal" === this.type ? .5 : .25;
            g = Math.pow(i.distanceToSquared(j), l), f = Math.pow(j.distanceToSquared(k), l), 
            l = Math.pow(k.distanceToSquared(h), l), 1e-4 > f && (f = 1), 1e-4 > g && (g = f), 
            1e-4 > l && (l = f), c.initNonuniformCatmullRom(i.x, j.x, k.x, h.x, g, f, l), d.initNonuniformCatmullRom(i.y, j.y, k.y, h.y, g, f, l), 
            e.initNonuniformCatmullRom(i.z, j.z, k.z, h.z, g, f, l);
        } else "catmullrom" === this.type && (g = void 0 !== this.tension ? this.tension : .5, 
        c.initCatmullRom(i.x, j.x, k.x, h.x, g), d.initCatmullRom(i.y, j.y, k.y, h.y, g), 
        e.initCatmullRom(i.z, j.z, k.z, h.z, g));
        return new THREE.Vector3(c.calc(a), d.calc(a), e.calc(a));
    });
}(), THREE.ClosedSplineCurve3 = function(a) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."), 
    THREE.CatmullRomCurve3.call(this, a), this.type = "catmullrom", this.closed = !0;
}, THREE.ClosedSplineCurve3.prototype = Object.create(THREE.CatmullRomCurve3.prototype), 
THREE.BoxGeometry = function(a, b, c, d, e, f) {
    THREE.Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
        width: a,
        height: b,
        depth: c,
        widthSegments: d,
        heightSegments: e,
        depthSegments: f
    }, this.fromBufferGeometry(new THREE.BoxBufferGeometry(a, b, c, d, e, f)), this.mergeVertices();
}, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry, 
THREE.CubeGeometry = THREE.BoxGeometry, THREE.BoxBufferGeometry = function(a, b, c, d, e, f) {
    function g(a, b, c, d, e, f, g, i, j, t, u) {
        var v = f / j, w = g / t, x = f / 2, y = g / 2, z = i / 2;
        g = j + 1;
        for (var A = t + 1, B = f = 0, C = new THREE.Vector3(), D = 0; D < A; D++) for (var E = D * w - y, F = 0; F < g; F++) C[a] = (F * v - x) * d, 
        C[b] = E * e, C[c] = z, l[o] = C.x, l[o + 1] = C.y, l[o + 2] = C.z, C[a] = 0, C[b] = 0, 
        C[c] = 0 < i ? 1 : -1, m[o] = C.x, m[o + 1] = C.y, m[o + 2] = C.z, n[p] = F / j, 
        n[p + 1] = 1 - D / t, o += 3, p += 2, f += 1;
        for (D = 0; D < t; D++) for (F = 0; F < j; F++) a = r + F + g * (D + 1), b = r + (F + 1) + g * (D + 1), 
        c = r + (F + 1) + g * D, k[q] = r + F + g * D, k[q + 1] = a, k[q + 2] = c, k[q + 3] = a, 
        k[q + 4] = b, k[q + 5] = c, q += 6, B += 6;
        h.addGroup(s, B, u), s += B, r += f;
    }
    THREE.BufferGeometry.call(this), this.type = "BoxBufferGeometry", this.parameters = {
        width: a,
        height: b,
        depth: c,
        widthSegments: d,
        heightSegments: e,
        depthSegments: f
    };
    var h = this;
    d = Math.floor(d) || 1, e = Math.floor(e) || 1, f = Math.floor(f) || 1;
    var i = function(a, b, c) {
        return a = 0 + (a + 1) * (b + 1) * 2 + (a + 1) * (c + 1) * 2, a += (c + 1) * (b + 1) * 2;
    }(d, e, f), j = function(a, b, c) {
        return a = 0 + a * b * 2 + a * c * 2, a += c * b * 2, 6 * a;
    }(d, e, f), k = new (65535 < j ? Uint32Array : Uint16Array)(j), l = new Float32Array(3 * i), m = new Float32Array(3 * i), n = new Float32Array(2 * i), o = 0, p = 0, q = 0, r = 0, s = 0;
    g("z", "y", "x", -1, -1, c, b, a, f, e, 0), g("z", "y", "x", 1, -1, c, b, -a, f, e, 1), 
    g("x", "z", "y", 1, 1, a, c, b, d, f, 2), g("x", "z", "y", 1, -1, a, c, -b, d, f, 3), 
    g("x", "y", "z", 1, -1, a, b, c, d, e, 4), g("x", "y", "z", -1, -1, a, b, -c, d, e, 5), 
    this.setIndex(new THREE.BufferAttribute(k, 1)), this.addAttribute("position", new THREE.BufferAttribute(l, 3)), 
    this.addAttribute("normal", new THREE.BufferAttribute(m, 3)), this.addAttribute("uv", new THREE.BufferAttribute(n, 2));
}, THREE.BoxBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry, THREE.CircleGeometry = function(a, b, c, d) {
    THREE.Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
        radius: a,
        segments: b,
        thetaStart: c,
        thetaLength: d
    }, this.fromBufferGeometry(new THREE.CircleBufferGeometry(a, b, c, d));
}, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry, 
THREE.CircleBufferGeometry = function(a, b, c, d) {
    THREE.BufferGeometry.call(this), this.type = "CircleBufferGeometry", this.parameters = {
        radius: a,
        segments: b,
        thetaStart: c,
        thetaLength: d
    }, a = a || 50, b = void 0 !== b ? Math.max(3, b) : 8, c = void 0 !== c ? c : 0, 
    d = void 0 !== d ? d : 2 * Math.PI;
    var e = b + 2, f = new Float32Array(3 * e), g = new Float32Array(3 * e), e = new Float32Array(2 * e);
    g[2] = 1, e[0] = .5, e[1] = .5;
    for (var h = 0, i = 3, j = 2; h <= b; h++, i += 3, j += 2) {
        var k = c + h / b * d;
        f[i] = a * Math.cos(k), f[i + 1] = a * Math.sin(k), g[i + 2] = 1, e[j] = (f[i] / a + 1) / 2, 
        e[j + 1] = (f[i + 1] / a + 1) / 2;
    }
    for (c = [], i = 1; i <= b; i++) c.push(i, i + 1, 0);
    this.setIndex(new THREE.BufferAttribute(new Uint16Array(c), 1)), this.addAttribute("position", new THREE.BufferAttribute(f, 3)), 
    this.addAttribute("normal", new THREE.BufferAttribute(g, 3)), this.addAttribute("uv", new THREE.BufferAttribute(e, 2)), 
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
}, THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry, THREE.CylinderBufferGeometry = function(a, b, c, d, e, f, g, h) {
    function i(c) {
        var e, f, i, k = new THREE.Vector2(), l = new THREE.Vector3(), m = 0, t = !0 === c ? a : b, w = !0 === c ? 1 : -1;
        for (f = r, e = 1; e <= d; e++) o.setXYZ(r, 0, u * w, 0), p.setXYZ(r, 0, w, 0), 
        k.x = .5, k.y = .5, q.setXY(r, k.x, k.y), r++;
        for (i = r, e = 0; e <= d; e++) {
            var x = e / d * h + g, y = Math.cos(x), x = Math.sin(x);
            l.x = t * x, l.y = u * w, l.z = t * y, o.setXYZ(r, l.x, l.y, l.z), p.setXYZ(r, 0, w, 0), 
            k.x = .5 * y + .5, k.y = .5 * x * w + .5, q.setXY(r, k.x, k.y), r++;
        }
        for (e = 0; e < d; e++) k = f + e, l = i + e, !0 === c ? (n.setX(s, l), s++, n.setX(s, l + 1)) : (n.setX(s, l + 1), 
        s++, n.setX(s, l)), s++, n.setX(s, k), s++, m += 3;
        j.addGroup(v, m, !0 === c ? 1 : 2), v += m;
    }
    THREE.BufferGeometry.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
        radiusTop: a,
        radiusBottom: b,
        height: c,
        radialSegments: d,
        heightSegments: e,
        openEnded: f,
        thetaStart: g,
        thetaLength: h
    };
    var j = this;
    a = void 0 !== a ? a : 20, b = void 0 !== b ? b : 20, c = void 0 !== c ? c : 100, 
    d = Math.floor(d) || 8, e = Math.floor(e) || 1, f = void 0 !== f && f, g = void 0 !== g ? g : 0, 
    h = void 0 !== h ? h : 2 * Math.PI;
    var k = 0;
    !1 === f && (0 < a && k++, 0 < b && k++);
    var l = function() {
        var a = (d + 1) * (e + 1);
        return !1 === f && (a += (d + 1) * k + d * k), a;
    }(), m = function() {
        var a = d * e * 6;
        return !1 === f && (a += d * k * 3), a;
    }(), n = new THREE.BufferAttribute(new (65535 < m ? Uint32Array : Uint16Array)(m), 1), o = new THREE.BufferAttribute(new Float32Array(3 * l), 3), p = new THREE.BufferAttribute(new Float32Array(3 * l), 3), q = new THREE.BufferAttribute(new Float32Array(2 * l), 2), r = 0, s = 0, t = [], u = c / 2, v = 0;
    !function() {
        var f, i, k = new THREE.Vector3(), l = new THREE.Vector3(), m = 0, w = (b - a) / c;
        for (i = 0; i <= e; i++) {
            var x = [], y = i / e, z = y * (b - a) + a;
            for (f = 0; f <= d; f++) {
                var A = f / d;
                l.x = z * Math.sin(A * h + g), l.y = -y * c + u, l.z = z * Math.cos(A * h + g), 
                o.setXYZ(r, l.x, l.y, l.z), k.copy(l), (0 === a && 0 === i || 0 === b && i === e) && (k.x = Math.sin(A * h + g), 
                k.z = Math.cos(A * h + g)), k.setY(Math.sqrt(k.x * k.x + k.z * k.z) * w).normalize(), 
                p.setXYZ(r, k.x, k.y, k.z), q.setXY(r, A, 1 - y), x.push(r), r++;
            }
            t.push(x);
        }
        for (f = 0; f < d; f++) for (i = 0; i < e; i++) k = t[i + 1][f], l = t[i + 1][f + 1], 
        w = t[i][f + 1], n.setX(s, t[i][f]), s++, n.setX(s, k), s++, n.setX(s, w), s++, 
        n.setX(s, k), s++, n.setX(s, l), s++, n.setX(s, w), s++, m += 6;
        j.addGroup(v, m, 0), v += m;
    }(), !1 === f && (0 < a && i(!0), 0 < b && i(!1)), this.setIndex(n), this.addAttribute("position", o), 
    this.addAttribute("normal", p), this.addAttribute("uv", q);
}, THREE.CylinderBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry, 
THREE.CylinderGeometry = function(a, b, c, d, e, f, g, h) {
    THREE.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
        radiusTop: a,
        radiusBottom: b,
        height: c,
        radialSegments: d,
        heightSegments: e,
        openEnded: f,
        thetaStart: g,
        thetaLength: h
    }, this.fromBufferGeometry(new THREE.CylinderBufferGeometry(a, b, c, d, e, f, g, h)), 
    this.mergeVertices();
}, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry, 
THREE.ConeBufferGeometry = function(a, b, c, d, e, f, g) {
    THREE.CylinderBufferGeometry.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeBufferGeometry", 
    this.parameters = {
        radius: a,
        height: b,
        radialSegments: c,
        heightSegments: d,
        thetaStart: f,
        thetaLength: g
    };
}, THREE.ConeBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry, THREE.ConeGeometry = function(a, b, c, d, e, f, g) {
    THREE.CylinderGeometry.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeGeometry", 
    this.parameters = {
        radius: a,
        height: b,
        radialSegments: c,
        heightSegments: d,
        openEnded: e,
        thetaStart: f,
        thetaLength: g
    };
}, THREE.ConeGeometry.prototype = Object.create(THREE.CylinderGeometry.prototype), 
THREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry, THREE.EdgesGeometry = function(a, b) {
    function c(a, b) {
        return a - b;
    }
    THREE.BufferGeometry.call(this);
    var d, e = Math.cos(THREE.Math.DEG2RAD * (void 0 !== b ? b : 1)), f = [ 0, 0 ], g = {}, h = [ "a", "b", "c" ];
    a instanceof THREE.BufferGeometry ? (d = new THREE.Geometry(), d.fromBufferGeometry(a)) : d = a.clone(), 
    d.mergeVertices(), d.computeFaceNormals();
    var i = d.vertices;
    d = d.faces;
    for (var j = 0, k = d.length; j < k; j++) for (var l = d[j], m = 0; 3 > m; m++) {
        f[0] = l[h[m]], f[1] = l[h[(m + 1) % 3]], f.sort(c);
        var n = f.toString();
        void 0 === g[n] ? g[n] = {
            vert1: f[0],
            vert2: f[1],
            face1: j,
            face2: void 0
        } : g[n].face2 = j;
    }
    f = [];
    for (n in g) h = g[n], (void 0 === h.face2 || d[h.face1].normal.dot(d[h.face2].normal) <= e) && (j = i[h.vert1], 
    f.push(j.x), f.push(j.y), f.push(j.z), j = i[h.vert2], f.push(j.x), f.push(j.y), 
    f.push(j.z));
    this.addAttribute("position", new THREE.BufferAttribute(new Float32Array(f), 3));
}, THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry, THREE.ExtrudeGeometry = function(a, b) {
    "undefined" != typeof a && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", 
    a = Array.isArray(a) ? a : [ a ], this.addShapeList(a, b), this.computeFaceNormals());
}, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry, 
THREE.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = a.length, d = 0; d < c; d++) this.addShape(a[d], b);
}, THREE.ExtrudeGeometry.prototype.addShape = function(a, b) {
    function c(a, b, c) {
        return b || console.error("THREE.ExtrudeGeometry: vec does not exist"), b.clone().multiplyScalar(c).add(a);
    }
    function d(a, b, c) {
        var d = 1, d = a.x - b.x, e = a.y - b.y, f = c.x - a.x, g = c.y - a.y, h = d * d + e * e;
        if (Math.abs(d * g - e * f) > Number.EPSILON) {
            var i = Math.sqrt(h), j = Math.sqrt(f * f + g * g), h = b.x - e / i;
            if (b = b.y + d / i, f = ((c.x - g / j - h) * g - (c.y + f / j - b) * f) / (d * g - e * f), 
            c = h + d * f - a.x, a = b + e * f - a.y, d = c * c + a * a, 2 >= d) return new THREE.Vector2(c, a);
            d = Math.sqrt(d / 2);
        } else a = !1, d > Number.EPSILON ? f > Number.EPSILON && (a = !0) : d < -Number.EPSILON ? f < -Number.EPSILON && (a = !0) : Math.sign(e) === Math.sign(g) && (a = !0), 
        a ? (c = -e, a = d, d = Math.sqrt(h)) : (c = d, a = e, d = Math.sqrt(h / 2));
        return new THREE.Vector2(c / d, a / d);
    }
    function e(a, b) {
        var c, d;
        for (M = a.length; 0 <= --M; ) {
            c = M, d = M - 1, 0 > d && (d = a.length - 1);
            for (var e = 0, f = s + 2 * p, e = 0; e < f; e++) {
                var g = K * e, h = K * (e + 1), i = b + c + g, g = b + d + g, j = b + d + h, h = b + c + h, i = i + A, g = g + A, j = j + A, h = h + A;
                z.faces.push(new THREE.Face3(i, g, h, null, null, 1)), z.faces.push(new THREE.Face3(g, j, h, null, null, 1)), 
                i = v.generateSideWallUV(z, i, g, j, h), z.faceVertexUvs[0].push([ i[0], i[1], i[3] ]), 
                z.faceVertexUvs[0].push([ i[1], i[2], i[3] ]);
            }
        }
    }
    function f(a, b, c) {
        z.vertices.push(new THREE.Vector3(a, b, c));
    }
    function g(a, b, c) {
        a += A, b += A, c += A, z.faces.push(new THREE.Face3(a, b, c, null, null, 0)), a = v.generateTopUV(z, a, b, c), 
        z.faceVertexUvs[0].push(a);
    }
    var h, i, j, k, l, m = void 0 !== b.amount ? b.amount : 100, n = void 0 !== b.bevelThickness ? b.bevelThickness : 6, o = void 0 !== b.bevelSize ? b.bevelSize : n - 2, p = void 0 !== b.bevelSegments ? b.bevelSegments : 3, q = void 0 === b.bevelEnabled || b.bevelEnabled, r = void 0 !== b.curveSegments ? b.curveSegments : 12, s = void 0 !== b.steps ? b.steps : 1, t = b.extrudePath, u = !1, v = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
    t && (h = t.getSpacedPoints(s), u = !0, q = !1, i = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(t, s, !1), 
    j = new THREE.Vector3(), k = new THREE.Vector3(), l = new THREE.Vector3()), q || (o = n = p = 0);
    var w, x, y, z = this, A = this.vertices.length, t = a.extractPoints(r), r = t.shape, B = t.holes;
    if (t = !THREE.ShapeUtils.isClockWise(r)) {
        for (r = r.reverse(), x = 0, y = B.length; x < y; x++) w = B[x], THREE.ShapeUtils.isClockWise(w) && (B[x] = w.reverse());
        t = !1;
    }
    var C = THREE.ShapeUtils.triangulateShape(r, B), D = r;
    for (x = 0, y = B.length; x < y; x++) w = B[x], r = r.concat(w);
    var E, F, G, H, I, J, K = r.length, L = C.length, t = [], M = 0;
    for (G = D.length, E = G - 1, F = M + 1; M < G; M++, E++, F++) E === G && (E = 0), 
    F === G && (F = 0), t[M] = d(D[M], D[E], D[F]);
    var N, O = [], P = t.concat();
    for (x = 0, y = B.length; x < y; x++) {
        for (w = B[x], N = [], M = 0, G = w.length, E = G - 1, F = M + 1; M < G; M++, E++, 
        F++) E === G && (E = 0), F === G && (F = 0), N[M] = d(w[M], w[E], w[F]);
        O.push(N), P = P.concat(N);
    }
    for (E = 0; E < p; E++) {
        for (G = E / p, H = n * (1 - G), F = o * Math.sin(G * Math.PI / 2), M = 0, G = D.length; M < G; M++) I = c(D[M], t[M], F), 
        f(I.x, I.y, -H);
        for (x = 0, y = B.length; x < y; x++) for (w = B[x], N = O[x], M = 0, G = w.length; M < G; M++) I = c(w[M], N[M], F), 
        f(I.x, I.y, -H);
    }
    for (F = o, M = 0; M < K; M++) I = q ? c(r[M], P[M], F) : r[M], u ? (k.copy(i.normals[0]).multiplyScalar(I.x), 
    j.copy(i.binormals[0]).multiplyScalar(I.y), l.copy(h[0]).add(k).add(j), f(l.x, l.y, l.z)) : f(I.x, I.y, 0);
    for (G = 1; G <= s; G++) for (M = 0; M < K; M++) I = q ? c(r[M], P[M], F) : r[M], 
    u ? (k.copy(i.normals[G]).multiplyScalar(I.x), j.copy(i.binormals[G]).multiplyScalar(I.y), 
    l.copy(h[G]).add(k).add(j), f(l.x, l.y, l.z)) : f(I.x, I.y, m / s * G);
    for (E = p - 1; 0 <= E; E--) {
        for (G = E / p, H = n * (1 - G), F = o * Math.sin(G * Math.PI / 2), M = 0, G = D.length; M < G; M++) I = c(D[M], t[M], F), 
        f(I.x, I.y, m + H);
        for (x = 0, y = B.length; x < y; x++) for (w = B[x], N = O[x], M = 0, G = w.length; M < G; M++) I = c(w[M], N[M], F), 
        u ? f(I.x, I.y + h[s - 1].y, h[s - 1].x + H) : f(I.x, I.y, m + H);
    }
    !function() {
        if (q) {
            var a;
            for (a = 0 * K, M = 0; M < L; M++) J = C[M], g(J[2] + a, J[1] + a, J[0] + a);
            for (a = s + 2 * p, a *= K, M = 0; M < L; M++) J = C[M], g(J[0] + a, J[1] + a, J[2] + a);
        } else {
            for (M = 0; M < L; M++) J = C[M], g(J[2], J[1], J[0]);
            for (M = 0; M < L; M++) J = C[M], g(J[0] + K * s, J[1] + K * s, J[2] + K * s);
        }
    }(), function() {
        var a = 0;
        for (e(D, a), a += D.length, x = 0, y = B.length; x < y; x++) w = B[x], e(w, a), 
        a += w.length;
    }();
}, THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function(a, b, c, d) {
        return a = a.vertices, b = a[b], c = a[c], d = a[d], [ new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y), new THREE.Vector2(d.x, d.y) ];
    },
    generateSideWallUV: function(a, b, c, d, e) {
        return a = a.vertices, b = a[b], c = a[c], d = a[d], e = a[e], .01 > Math.abs(b.y - c.y) ? [ new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z), new THREE.Vector2(e.x, 1 - e.z) ] : [ new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z), new THREE.Vector2(e.y, 1 - e.z) ];
    }
}, THREE.ShapeGeometry = function(a, b) {
    THREE.Geometry.call(this), this.type = "ShapeGeometry", !1 === Array.isArray(a) && (a = [ a ]), 
    this.addShapeList(a, b), this.computeFaceNormals();
}, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry, 
THREE.ShapeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = 0, d = a.length; c < d; c++) this.addShape(a[c], b);
    return this;
}, THREE.ShapeGeometry.prototype.addShape = function(a, b) {
    void 0 === b && (b = {});
    var c, d, e, f = b.material, g = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, h = this.vertices.length;
    c = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
    var i = c.shape, j = c.holes;
    if (!THREE.ShapeUtils.isClockWise(i)) for (i = i.reverse(), c = 0, d = j.length; c < d; c++) e = j[c], 
    THREE.ShapeUtils.isClockWise(e) && (j[c] = e.reverse());
    var k = THREE.ShapeUtils.triangulateShape(i, j);
    for (c = 0, d = j.length; c < d; c++) e = j[c], i = i.concat(e);
    for (j = i.length, d = k.length, c = 0; c < j; c++) e = i[c], this.vertices.push(new THREE.Vector3(e.x, e.y, 0));
    for (c = 0; c < d; c++) j = k[c], i = j[0] + h, e = j[1] + h, j = j[2] + h, this.faces.push(new THREE.Face3(i, e, j, null, null, f)), 
    this.faceVertexUvs[0].push(g.generateTopUV(this, i, e, j));
}, THREE.LatheBufferGeometry = function(a, b, c, d) {
    THREE.BufferGeometry.call(this), this.type = "LatheBufferGeometry", this.parameters = {
        points: a,
        segments: b,
        phiStart: c,
        phiLength: d
    }, b = Math.floor(b) || 12, c = c || 0, d = d || 2 * Math.PI, d = THREE.Math.clamp(d, 0, 2 * Math.PI);
    for (var e = (b + 1) * a.length, f = b * a.length * 6, g = new THREE.BufferAttribute(new (65535 < f ? Uint32Array : Uint16Array)(f), 1), h = new THREE.BufferAttribute(new Float32Array(3 * e), 3), i = new THREE.BufferAttribute(new Float32Array(2 * e), 2), j = 0, k = 0, l = 1 / b, m = new THREE.Vector3(), n = new THREE.Vector2(), e = 0; e <= b; e++) for (var f = c + e * l * d, o = Math.sin(f), p = Math.cos(f), f = 0; f <= a.length - 1; f++) m.x = a[f].x * o, 
    m.y = a[f].y, m.z = a[f].x * p, h.setXYZ(j, m.x, m.y, m.z), n.x = e / b, n.y = f / (a.length - 1), 
    i.setXY(j, n.x, n.y), j++;
    for (e = 0; e < b; e++) for (f = 0; f < a.length - 1; f++) c = f + e * a.length, 
    j = c + a.length, l = c + a.length + 1, m = c + 1, g.setX(k, c), k++, g.setX(k, j), 
    k++, g.setX(k, m), k++, g.setX(k, j), k++, g.setX(k, l), k++, g.setX(k, m), k++;
    if (this.setIndex(g), this.addAttribute("position", h), this.addAttribute("uv", i), 
    this.computeVertexNormals(), d === 2 * Math.PI) for (d = this.attributes.normal.array, 
    g = new THREE.Vector3(), h = new THREE.Vector3(), i = new THREE.Vector3(), c = b * a.length * 3, 
    f = e = 0; e < a.length; e++, f += 3) g.x = d[f + 0], g.y = d[f + 1], g.z = d[f + 2], 
    h.x = d[c + f + 0], h.y = d[c + f + 1], h.z = d[c + f + 2], i.addVectors(g, h).normalize(), 
    d[f + 0] = d[c + f + 0] = i.x, d[f + 1] = d[c + f + 1] = i.y, d[f + 2] = d[c + f + 2] = i.z;
}, THREE.LatheBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry, THREE.LatheGeometry = function(a, b, c, d) {
    THREE.Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
        points: a,
        segments: b,
        phiStart: c,
        phiLength: d
    }, this.fromBufferGeometry(new THREE.LatheBufferGeometry(a, b, c, d)), this.mergeVertices();
}, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry, 
THREE.PlaneGeometry = function(a, b, c, d) {
    THREE.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    }, this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d));
}, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneBufferGeometry = function(a, b, c, d) {
    THREE.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    };
    var e = a / 2, f = b / 2;
    c = Math.floor(c) || 1, d = Math.floor(d) || 1;
    var g = c + 1, h = d + 1, i = a / c, j = b / d;
    b = new Float32Array(g * h * 3), a = new Float32Array(g * h * 3);
    for (var k = new Float32Array(g * h * 2), l = 0, m = 0, n = 0; n < h; n++) for (var o = n * j - f, p = 0; p < g; p++) b[l] = p * i - e, 
    b[l + 1] = -o, a[l + 2] = 1, k[m] = p / c, k[m + 1] = 1 - n / d, l += 3, m += 2;
    for (l = 0, e = new (65535 < b.length / 3 ? Uint32Array : Uint16Array)(c * d * 6), 
    n = 0; n < d; n++) for (p = 0; p < c; p++) f = p + g * (n + 1), h = p + 1 + g * (n + 1), 
    i = p + 1 + g * n, e[l] = p + g * n, e[l + 1] = f, e[l + 2] = i, e[l + 3] = f, e[l + 4] = h, 
    e[l + 5] = i, l += 6;
    this.setIndex(new THREE.BufferAttribute(e, 1)), this.addAttribute("position", new THREE.BufferAttribute(b, 3)), 
    this.addAttribute("normal", new THREE.BufferAttribute(a, 3)), this.addAttribute("uv", new THREE.BufferAttribute(k, 2));
};

THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry, THREE.RingBufferGeometry = function(a, b, c, d, e, f) {
    THREE.BufferGeometry.call(this), this.type = "RingBufferGeometry", this.parameters = {
        innerRadius: a,
        outerRadius: b,
        thetaSegments: c,
        phiSegments: d,
        thetaStart: e,
        thetaLength: f
    }, a = a || 20, b = b || 50, e = void 0 !== e ? e : 0, f = void 0 !== f ? f : 2 * Math.PI, 
    c = void 0 !== c ? Math.max(3, c) : 8, d = void 0 !== d ? Math.max(1, d) : 1;
    var g, h, i = (c + 1) * (d + 1), j = c * d * 6, j = new THREE.BufferAttribute(new (65535 < j ? Uint32Array : Uint16Array)(j), 1), k = new THREE.BufferAttribute(new Float32Array(3 * i), 3), l = new THREE.BufferAttribute(new Float32Array(3 * i), 3), i = new THREE.BufferAttribute(new Float32Array(2 * i), 2), m = 0, n = 0, o = a, p = (b - a) / d, q = new THREE.Vector3(), r = new THREE.Vector2();
    for (a = 0; a <= d; a++) {
        for (h = 0; h <= c; h++) g = e + h / c * f, q.x = o * Math.cos(g), q.y = o * Math.sin(g), 
        k.setXYZ(m, q.x, q.y, q.z), l.setXYZ(m, 0, 0, 1), r.x = (q.x / b + 1) / 2, r.y = (q.y / b + 1) / 2, 
        i.setXY(m, r.x, r.y), m++;
        o += p;
    }
    for (a = 0; a < d; a++) for (b = a * (c + 1), h = 0; h < c; h++) e = g = h + b, 
    f = g + c + 1, m = g + c + 2, g += 1, j.setX(n, e), n++, j.setX(n, f), n++, j.setX(n, m), 
    n++, j.setX(n, e), n++, j.setX(n, m), n++, j.setX(n, g), n++;
    this.setIndex(j), this.addAttribute("position", k), this.addAttribute("normal", l), 
    this.addAttribute("uv", i);
}, THREE.RingBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry, THREE.RingGeometry = function(a, b, c, d, e, f) {
    THREE.Geometry.call(this), this.type = "RingGeometry", this.parameters = {
        innerRadius: a,
        outerRadius: b,
        thetaSegments: c,
        phiSegments: d,
        thetaStart: e,
        thetaLength: f
    }, this.fromBufferGeometry(new THREE.RingBufferGeometry(a, b, c, d, e, f));
}, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry.prototype.constructor = THREE.RingGeometry, 
THREE.SphereGeometry = function(a, b, c, d, e, f, g) {
    THREE.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
        radius: a,
        widthSegments: b,
        heightSegments: c,
        phiStart: d,
        phiLength: e,
        thetaStart: f,
        thetaLength: g
    }, this.fromBufferGeometry(new THREE.SphereBufferGeometry(a, b, c, d, e, f, g));
}, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry, 
THREE.SphereBufferGeometry = function(a, b, c, d, e, f, g) {
    THREE.BufferGeometry.call(this), this.type = "SphereBufferGeometry", this.parameters = {
        radius: a,
        widthSegments: b,
        heightSegments: c,
        phiStart: d,
        phiLength: e,
        thetaStart: f,
        thetaLength: g
    }, a = a || 50, b = Math.max(3, Math.floor(b) || 8), c = Math.max(2, Math.floor(c) || 6), 
    d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, f = void 0 !== f ? f : 0, 
    g = void 0 !== g ? g : Math.PI;
    for (var h = f + g, i = (b + 1) * (c + 1), j = new THREE.BufferAttribute(new Float32Array(3 * i), 3), k = new THREE.BufferAttribute(new Float32Array(3 * i), 3), i = new THREE.BufferAttribute(new Float32Array(2 * i), 2), l = 0, m = [], n = new THREE.Vector3(), o = 0; o <= c; o++) {
        for (var p = [], q = o / c, r = 0; r <= b; r++) {
            var s = r / b, t = -a * Math.cos(d + s * e) * Math.sin(f + q * g), u = a * Math.cos(f + q * g), v = a * Math.sin(d + s * e) * Math.sin(f + q * g);
            n.set(t, u, v).normalize(), j.setXYZ(l, t, u, v), k.setXYZ(l, n.x, n.y, n.z), i.setXY(l, s, 1 - q), 
            p.push(l), l++;
        }
        m.push(p);
    }
    for (d = [], o = 0; o < c; o++) for (r = 0; r < b; r++) e = m[o][r + 1], g = m[o][r], 
    l = m[o + 1][r], n = m[o + 1][r + 1], (0 !== o || 0 < f) && d.push(e, g, n), (o !== c - 1 || h < Math.PI) && d.push(g, l, n);
    this.setIndex(new (65535 < j.count ? THREE.Uint32Attribute : THREE.Uint16Attribute)(d, 1)), 
    this.addAttribute("position", j), this.addAttribute("normal", k), this.addAttribute("uv", i), 
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
}, THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry, THREE.TextGeometry = function(a, b) {
    b = b || {};
    var c = b.font;
    return !1 == c instanceof THREE.Font ? (console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), 
    new THREE.Geometry()) : (c = c.generateShapes(a, b.size, b.curveSegments), b.amount = void 0 !== b.height ? b.height : 50, 
    void 0 === b.bevelThickness && (b.bevelThickness = 10), void 0 === b.bevelSize && (b.bevelSize = 8), 
    void 0 === b.bevelEnabled && (b.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, c, b), 
    void (this.type = "TextGeometry"));
}, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), 
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry, THREE.TorusBufferGeometry = function(a, b, c, d, e) {
    THREE.BufferGeometry.call(this), this.type = "TorusBufferGeometry", this.parameters = {
        radius: a,
        tube: b,
        radialSegments: c,
        tubularSegments: d,
        arc: e
    }, a = a || 100, b = b || 40, c = Math.floor(c) || 8, d = Math.floor(d) || 6, e = e || 2 * Math.PI;
    var f, g, h = (c + 1) * (d + 1), i = c * d * 6, i = new (65535 < i ? Uint32Array : Uint16Array)(i), j = new Float32Array(3 * h), k = new Float32Array(3 * h), h = new Float32Array(2 * h), l = 0, m = 0, n = 0, o = new THREE.Vector3(), p = new THREE.Vector3(), q = new THREE.Vector3();
    for (f = 0; f <= c; f++) for (g = 0; g <= d; g++) {
        var r = g / d * e, s = f / c * Math.PI * 2;
        p.x = (a + b * Math.cos(s)) * Math.cos(r), p.y = (a + b * Math.cos(s)) * Math.sin(r), 
        p.z = b * Math.sin(s), j[l] = p.x, j[l + 1] = p.y, j[l + 2] = p.z, o.x = a * Math.cos(r), 
        o.y = a * Math.sin(r), q.subVectors(p, o).normalize(), k[l] = q.x, k[l + 1] = q.y, 
        k[l + 2] = q.z, h[m] = g / d, h[m + 1] = f / c, l += 3, m += 2;
    }
    for (f = 1; f <= c; f++) for (g = 1; g <= d; g++) a = (d + 1) * (f - 1) + g - 1, 
    b = (d + 1) * (f - 1) + g, e = (d + 1) * f + g, i[n] = (d + 1) * f + g - 1, i[n + 1] = a, 
    i[n + 2] = e, i[n + 3] = a, i[n + 4] = b, i[n + 5] = e, n += 6;
    this.setIndex(new THREE.BufferAttribute(i, 1)), this.addAttribute("position", new THREE.BufferAttribute(j, 3)), 
    this.addAttribute("normal", new THREE.BufferAttribute(k, 3)), this.addAttribute("uv", new THREE.BufferAttribute(h, 2));
}, THREE.TorusBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry, THREE.TorusGeometry = function(a, b, c, d, e) {
    THREE.Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
        radius: a,
        tube: b,
        radialSegments: c,
        tubularSegments: d,
        arc: e
    }, this.fromBufferGeometry(new THREE.TorusBufferGeometry(a, b, c, d, e));
}, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry, 
THREE.TorusKnotBufferGeometry = function(a, b, c, d, e, f) {
    function g(a, b, c, d, e) {
        var f = Math.cos(a), g = Math.sin(a);
        a *= c / b, b = Math.cos(a), e.x = d * (2 + b) * .5 * f, e.y = d * (2 + b) * g * .5, 
        e.z = d * Math.sin(a) * .5;
    }
    THREE.BufferGeometry.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
        radius: a,
        tube: b,
        tubularSegments: c,
        radialSegments: d,
        p: e,
        q: f
    }, a = a || 100, b = b || 40, c = Math.floor(c) || 64, d = Math.floor(d) || 8, e = e || 2, 
    f = f || 3;
    var h, i, j = (d + 1) * (c + 1), k = d * c * 6, k = new THREE.BufferAttribute(new (65535 < k ? Uint32Array : Uint16Array)(k), 1), l = new THREE.BufferAttribute(new Float32Array(3 * j), 3), m = new THREE.BufferAttribute(new Float32Array(3 * j), 3), j = new THREE.BufferAttribute(new Float32Array(2 * j), 2), n = 0, o = 0, p = new THREE.Vector3(), q = new THREE.Vector3(), r = new THREE.Vector2(), s = new THREE.Vector3(), t = new THREE.Vector3(), u = new THREE.Vector3(), v = new THREE.Vector3(), w = new THREE.Vector3();
    for (h = 0; h <= c; ++h) for (i = h / c * e * Math.PI * 2, g(i, e, f, a, s), g(i + .01, e, f, a, t), 
    v.subVectors(t, s), w.addVectors(t, s), u.crossVectors(v, w), w.crossVectors(u, v), 
    u.normalize(), w.normalize(), i = 0; i <= d; ++i) {
        var x = i / d * Math.PI * 2, y = -b * Math.cos(x), x = b * Math.sin(x);
        p.x = s.x + (y * w.x + x * u.x), p.y = s.y + (y * w.y + x * u.y), p.z = s.z + (y * w.z + x * u.z), 
        l.setXYZ(n, p.x, p.y, p.z), q.subVectors(p, s).normalize(), m.setXYZ(n, q.x, q.y, q.z), 
        r.x = h / c, r.y = i / d, j.setXY(n, r.x, r.y), n++;
    }
    for (i = 1; i <= c; i++) for (h = 1; h <= d; h++) a = (d + 1) * i + (h - 1), b = (d + 1) * i + h, 
    e = (d + 1) * (i - 1) + h, k.setX(o, (d + 1) * (i - 1) + (h - 1)), o++, k.setX(o, a), 
    o++, k.setX(o, e), o++, k.setX(o, a), o++, k.setX(o, b), o++, k.setX(o, e), o++;
    this.setIndex(k), this.addAttribute("position", l), this.addAttribute("normal", m), 
    this.addAttribute("uv", j);
}, THREE.TorusKnotBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry, 
THREE.TorusKnotGeometry = function(a, b, c, d, e, f, g) {
    THREE.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
        radius: a,
        tube: b,
        tubularSegments: c,
        radialSegments: d,
        p: e,
        q: f
    }, void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), 
    this.fromBufferGeometry(new THREE.TorusKnotBufferGeometry(a, b, c, d, e, f)), this.mergeVertices();
}, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry, THREE.TubeGeometry = function(a, b, c, d, e, f) {
    THREE.Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
        path: a,
        segments: b,
        radius: c,
        radialSegments: d,
        closed: e,
        taper: f
    }, b = b || 64, c = c || 1, d = d || 8, e = e || !1, f = f || THREE.TubeGeometry.NoTaper;
    var g, h, i, j, k, l, m, n, o, p, q = [], r = b + 1, s = new THREE.Vector3();
    for (n = new THREE.TubeGeometry.FrenetFrames(a, b, e), o = n.normals, p = n.binormals, 
    this.tangents = n.tangents, this.normals = o, this.binormals = p, n = 0; n < r; n++) for (q[n] = [], 
    i = n / (r - 1), m = a.getPointAt(i), g = o[n], h = p[n], k = c * f(i), i = 0; i < d; i++) j = i / d * 2 * Math.PI, 
    l = -k * Math.cos(j), j = k * Math.sin(j), s.copy(m), s.x += l * g.x + j * h.x, 
    s.y += l * g.y + j * h.y, s.z += l * g.z + j * h.z, q[n][i] = this.vertices.push(new THREE.Vector3(s.x, s.y, s.z)) - 1;
    for (n = 0; n < b; n++) for (i = 0; i < d; i++) f = e ? (n + 1) % b : n + 1, r = (i + 1) % d, 
    a = q[n][i], c = q[f][i], f = q[f][r], r = q[n][r], s = new THREE.Vector2(n / b, i / d), 
    o = new THREE.Vector2((n + 1) / b, i / d), p = new THREE.Vector2((n + 1) / b, (i + 1) / d), 
    g = new THREE.Vector2(n / b, (i + 1) / d), this.faces.push(new THREE.Face3(a, c, r)), 
    this.faceVertexUvs[0].push([ s, o, g ]), this.faces.push(new THREE.Face3(c, f, r)), 
    this.faceVertexUvs[0].push([ o.clone(), p, g.clone() ]);
    this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry, 
THREE.TubeGeometry.NoTaper = function(a) {
    return 1;
}, THREE.TubeGeometry.SinusoidalTaper = function(a) {
    return Math.sin(Math.PI * a);
}, THREE.TubeGeometry.FrenetFrames = function(a, b, c) {
    var d = new THREE.Vector3(), e = [], f = [], g = [], h = new THREE.Vector3(), i = new THREE.Matrix4();
    b += 1;
    var j, k, l;
    for (this.tangents = e, this.normals = f, this.binormals = g, j = 0; j < b; j++) k = j / (b - 1), 
    e[j] = a.getTangentAt(k), e[j].normalize();
    for (f[0] = new THREE.Vector3(), g[0] = new THREE.Vector3(), a = Number.MAX_VALUE, 
    j = Math.abs(e[0].x), k = Math.abs(e[0].y), l = Math.abs(e[0].z), j <= a && (a = j, 
    d.set(1, 0, 0)), k <= a && (a = k, d.set(0, 1, 0)), l <= a && d.set(0, 0, 1), h.crossVectors(e[0], d).normalize(), 
    f[0].crossVectors(e[0], h), g[0].crossVectors(e[0], f[0]), j = 1; j < b; j++) f[j] = f[j - 1].clone(), 
    g[j] = g[j - 1].clone(), h.crossVectors(e[j - 1], e[j]), h.length() > Number.EPSILON && (h.normalize(), 
    d = Math.acos(THREE.Math.clamp(e[j - 1].dot(e[j]), -1, 1)), f[j].applyMatrix4(i.makeRotationAxis(h, d))), 
    g[j].crossVectors(e[j], f[j]);
    if (c) for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 
    0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), j = 1; j < b; j++) f[j].applyMatrix4(i.makeRotationAxis(e[j], d * j)), 
    g[j].crossVectors(e[j], f[j]);
}, THREE.PolyhedronGeometry = function(a, b, c, d) {
    function e(a) {
        var b = a.normalize().clone();
        b.index = i.vertices.push(b) - 1;
        var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;
        return a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5, b.uv = new THREE.Vector2(c, 1 - a), 
        b;
    }
    function f(a, b, c, d) {
        d = new THREE.Face3(a.index, b.index, c.index, [ a.clone(), b.clone(), c.clone() ], void 0, d), 
        i.faces.push(d), q.copy(a).add(b).add(c).divideScalar(3), d = Math.atan2(q.z, -q.x), 
        i.faceVertexUvs[0].push([ h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d) ]);
    }
    function g(a, b) {
        for (var c = Math.pow(2, b), d = e(i.vertices[a.a]), g = e(i.vertices[a.b]), h = e(i.vertices[a.c]), j = [], k = a.materialIndex, l = 0; l <= c; l++) {
            j[l] = [];
            for (var m = e(d.clone().lerp(h, l / c)), n = e(g.clone().lerp(h, l / c)), o = c - l, p = 0; p <= o; p++) j[l][p] = 0 === p && l === c ? m : e(m.clone().lerp(n, p / o));
        }
        for (l = 0; l < c; l++) for (p = 0; p < 2 * (c - l) - 1; p++) d = Math.floor(p / 2), 
        0 === p % 2 ? f(j[l][d + 1], j[l + 1][d], j[l][d], k) : f(j[l][d + 1], j[l + 1][d + 1], j[l + 1][d], k);
    }
    function h(a, b, c) {
        return 0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y)), 0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5, a.y)), 
        a.clone();
    }
    THREE.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
        vertices: a,
        indices: b,
        radius: c,
        detail: d
    }, c = c || 1, d = d || 0;
    for (var i = this, j = 0, k = a.length; j < k; j += 3) e(new THREE.Vector3(a[j], a[j + 1], a[j + 2]));
    a = this.vertices;
    for (var l = [], m = j = 0, k = b.length; j < k; j += 3, m++) {
        var n = a[b[j]], o = a[b[j + 1]], p = a[b[j + 2]];
        l[m] = new THREE.Face3(n.index, o.index, p.index, [ n.clone(), o.clone(), p.clone() ], void 0, m);
    }
    for (var q = new THREE.Vector3(), j = 0, k = l.length; j < k; j++) g(l[j], d);
    for (j = 0, k = this.faceVertexUvs[0].length; j < k; j++) b = this.faceVertexUvs[0][j], 
    d = b[0].x, a = b[1].x, l = b[2].x, m = Math.max(d, a, l), n = Math.min(d, a, l), 
    .9 < m && .1 > n && (.2 > d && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > l && (b[2].x += 1));
    for (j = 0, k = this.vertices.length; j < k; j++) this.vertices[j].multiplyScalar(c);
    this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);
}, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry, THREE.DodecahedronGeometry = function(a, b) {
    var c = (1 + Math.sqrt(5)) / 2, d = 1 / c;
    THREE.PolyhedronGeometry.call(this, [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d ], [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ], a, b), 
    this.type = "DodecahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), 
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry, THREE.IcosahedronGeometry = function(a, b) {
    var c = (1 + Math.sqrt(5)) / 2;
    THREE.PolyhedronGeometry.call(this, [ -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1 ], [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ], a, b), 
    this.type = "IcosahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), 
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry, THREE.OctahedronGeometry = function(a, b) {
    THREE.PolyhedronGeometry.call(this, [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ], [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ], a, b), 
    this.type = "OctahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), 
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry, THREE.TetrahedronGeometry = function(a, b) {
    THREE.PolyhedronGeometry.call(this, [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ], [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ], a, b), 
    this.type = "TetrahedronGeometry", this.parameters = {
        radius: a,
        detail: b
    };
}, THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype), 
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry, THREE.ParametricGeometry = function(a, b, c) {
    THREE.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
        func: a,
        slices: b,
        stacks: c
    };
    var d, e, f, g, h = this.vertices, i = this.faces, j = this.faceVertexUvs[0], k = b + 1;
    for (d = 0; d <= c; d++) for (g = d / c, e = 0; e <= b; e++) f = e / b, f = a(f, g), 
    h.push(f);
    var l, m, n, o;
    for (d = 0; d < c; d++) for (e = 0; e < b; e++) a = d * k + e, h = d * k + e + 1, 
    g = (d + 1) * k + e + 1, f = (d + 1) * k + e, l = new THREE.Vector2(e / b, d / c), 
    m = new THREE.Vector2((e + 1) / b, d / c), n = new THREE.Vector2((e + 1) / b, (d + 1) / c), 
    o = new THREE.Vector2(e / b, (d + 1) / c), i.push(new THREE.Face3(a, h, f)), j.push([ l, m, o ]), 
    i.push(new THREE.Face3(h, g, f)), j.push([ m.clone(), n, o.clone() ]);
    this.computeFaceNormals(), this.computeVertexNormals();
}, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), 
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry, THREE.WireframeGeometry = function(a) {
    function b(a, b) {
        return a - b;
    }
    THREE.BufferGeometry.call(this);
    var c = [ 0, 0 ], d = {}, e = [ "a", "b", "c" ];
    if (a instanceof THREE.Geometry) {
        var f = a.vertices, g = a.faces, h = 0, i = new Uint32Array(6 * g.length);
        a = 0;
        for (var j = g.length; a < j; a++) for (var k = g[a], l = 0; 3 > l; l++) {
            c[0] = k[e[l]], c[1] = k[e[(l + 1) % 3]], c.sort(b);
            var m = c.toString();
            void 0 === d[m] && (i[2 * h] = c[0], i[2 * h + 1] = c[1], d[m] = !0, h++);
        }
        for (c = new Float32Array(6 * h), a = 0, j = h; a < j; a++) for (l = 0; 2 > l; l++) d = f[i[2 * a + l]], 
        h = 6 * a + 3 * l, c[h + 0] = d.x, c[h + 1] = d.y, c[h + 2] = d.z;
        this.addAttribute("position", new THREE.BufferAttribute(c, 3));
    } else if (a instanceof THREE.BufferGeometry) {
        if (null !== a.index) {
            for (j = a.index.array, f = a.attributes.position, e = a.groups, h = 0, 0 === e.length && a.addGroup(0, j.length), 
            i = new Uint32Array(2 * j.length), g = 0, k = e.length; g < k; ++g) {
                a = e[g], l = a.start, m = a.count, a = l;
                for (var n = l + m; a < n; a += 3) for (l = 0; 3 > l; l++) c[0] = j[a + l], c[1] = j[a + (l + 1) % 3], 
                c.sort(b), m = c.toString(), void 0 === d[m] && (i[2 * h] = c[0], i[2 * h + 1] = c[1], 
                d[m] = !0, h++);
            }
            for (c = new Float32Array(6 * h), a = 0, j = h; a < j; a++) for (l = 0; 2 > l; l++) h = 6 * a + 3 * l, 
            d = i[2 * a + l], c[h + 0] = f.getX(d), c[h + 1] = f.getY(d), c[h + 2] = f.getZ(d);
        } else for (f = a.attributes.position.array, h = f.length / 3, i = h / 3, c = new Float32Array(6 * h), 
        a = 0, j = i; a < j; a++) for (l = 0; 3 > l; l++) h = 18 * a + 6 * l, i = 9 * a + 3 * l, 
        c[h + 0] = f[i], c[h + 1] = f[i + 1], c[h + 2] = f[i + 2], d = 9 * a + (l + 1) % 3 * 3, 
        c[h + 3] = f[d], c[h + 4] = f[d + 1], c[h + 5] = f[d + 2];
        this.addAttribute("position", new THREE.BufferAttribute(c, 3));
    }
}, THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), 
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry, THREE.AxisHelper = function(a) {
    a = a || 1;
    var b = new Float32Array([ 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a ]), c = new Float32Array([ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ]);
    a = new THREE.BufferGeometry(), a.addAttribute("position", new THREE.BufferAttribute(b, 3)), 
    a.addAttribute("color", new THREE.BufferAttribute(c, 3)), b = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    }), THREE.LineSegments.call(this, a, b);
}, THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.AxisHelper.prototype.constructor = THREE.AxisHelper, 
THREE.ArrowHelper = function() {
    var a = new THREE.BufferGeometry();
    a.addAttribute("position", new THREE.Float32Attribute([ 0, 0, 0, 0, 1, 0 ], 3));
    var b = new THREE.CylinderBufferGeometry(0, .5, 1, 5, 1);
    return b.translate(0, -.5, 0), function(c, d, e, f, g, h) {
        THREE.Object3D.call(this), void 0 === f && (f = 16776960), void 0 === e && (e = 1), 
        void 0 === g && (g = .2 * e), void 0 === h && (h = .2 * g), this.position.copy(d), 
        this.line = new THREE.Line(a, new THREE.LineBasicMaterial({
            color: f
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({
            color: f
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(c), 
        this.setLength(e, g, h);
    };
}(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper, 
THREE.ArrowHelper.prototype.setDirection = function() {
    var a, b = new THREE.Vector3();
    return function(c) {
        .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (b.set(c.z, 0, -c.x).normalize(), 
        a = Math.acos(c.y), this.quaternion.setFromAxisAngle(b, a));
    };
}(), THREE.ArrowHelper.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = .2 * a), void 0 === c && (c = .2 * b), this.line.scale.set(1, Math.max(0, a - b), 1), 
    this.line.updateMatrix(), this.cone.scale.set(c, b, c), this.cone.position.y = a, 
    this.cone.updateMatrix();
}, THREE.ArrowHelper.prototype.setColor = function(a) {
    this.line.material.color.copy(a), this.cone.material.color.copy(a);
}, THREE.BoxHelper = function(a) {
    var b = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]), c = new Float32Array(24), d = new THREE.BufferGeometry();
    d.setIndex(new THREE.BufferAttribute(b, 1)), d.addAttribute("position", new THREE.BufferAttribute(c, 3)), 
    THREE.LineSegments.call(this, d, new THREE.LineBasicMaterial({
        color: 16776960
    })), void 0 !== a && this.update(a);
}, THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.BoxHelper.prototype.constructor = THREE.BoxHelper, 
THREE.BoxHelper.prototype.update = function() {
    var a = new THREE.Box3();
    return function(b) {
        if (b instanceof THREE.Box3 ? a.copy(b) : a.setFromObject(b), !a.isEmpty()) {
            b = a.min;
            var c = a.max, d = this.geometry.attributes.position, e = d.array;
            e[0] = c.x, e[1] = c.y, e[2] = c.z, e[3] = b.x, e[4] = c.y, e[5] = c.z, e[6] = b.x, 
            e[7] = b.y, e[8] = c.z, e[9] = c.x, e[10] = b.y, e[11] = c.z, e[12] = c.x, e[13] = c.y, 
            e[14] = b.z, e[15] = b.x, e[16] = c.y, e[17] = b.z, e[18] = b.x, e[19] = b.y, e[20] = b.z, 
            e[21] = c.x, e[22] = b.y, e[23] = b.z, d.needsUpdate = !0, this.geometry.computeBoundingSphere();
        }
    };
}(), THREE.BoundingBoxHelper = function(a, b) {
    var c = void 0 !== b ? b : 8947848;
    this.object = a, this.box = new THREE.Box3(), THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: c,
        wireframe: !0
    }));
}, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper, 
THREE.BoundingBoxHelper.prototype.update = function() {
    this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position);
}, THREE.CameraHelper = function(a) {
    function b(a, b, d) {
        c(a, d), c(b, d);
    }
    function c(a, b) {
        d.vertices.push(new THREE.Vector3()), d.colors.push(new THREE.Color(b)), void 0 === f[a] && (f[a] = []), 
        f[a].push(d.vertices.length - 1);
    }
    var d = new THREE.Geometry(), e = new THREE.LineBasicMaterial({
        color: 16777215,
        vertexColors: THREE.FaceColors
    }), f = {};
    b("n1", "n2", 16755200), b("n2", "n4", 16755200), b("n4", "n3", 16755200), b("n3", "n1", 16755200), 
    b("f1", "f2", 16755200), b("f2", "f4", 16755200), b("f4", "f3", 16755200), b("f3", "f1", 16755200), 
    b("n1", "f1", 16755200), b("n2", "f2", 16755200), b("n3", "f3", 16755200), b("n4", "f4", 16755200), 
    b("p", "n1", 16711680), b("p", "n2", 16711680), b("p", "n3", 16711680), b("p", "n4", 16711680), 
    b("u1", "u2", 43775), b("u2", "u3", 43775), b("u3", "u1", 43775), b("c", "t", 16777215), 
    b("p", "c", 3355443), b("cn1", "cn2", 3355443), b("cn3", "cn4", 3355443), b("cf1", "cf2", 3355443), 
    b("cf3", "cf4", 3355443), THREE.LineSegments.call(this, d, e), this.camera = a, 
    this.camera.updateProjectionMatrix(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, 
    this.pointMap = f, this.update();
}, THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.CameraHelper.prototype.constructor = THREE.CameraHelper, 
THREE.CameraHelper.prototype.update = function() {
    function a(a, f, g, h) {
        if (d.set(f, g, h).unproject(e), a = c[a], void 0 !== a) for (f = 0, g = a.length; f < g; f++) b.vertices[a[f]].copy(d);
    }
    var b, c, d = new THREE.Vector3(), e = new THREE.Camera();
    return function() {
        b = this.geometry, c = this.pointMap, e.projectionMatrix.copy(this.camera.projectionMatrix), 
        a("c", 0, 0, -1), a("t", 0, 0, 1), a("n1", -1, -1, -1), a("n2", 1, -1, -1), a("n3", -1, 1, -1), 
        a("n4", 1, 1, -1), a("f1", -1, -1, 1), a("f2", 1, -1, 1), a("f3", -1, 1, 1), a("f4", 1, 1, 1), 
        a("u1", .7, 1.1, -1), a("u2", -.7, 1.1, -1), a("u3", 0, 2, -1), a("cf1", -1, 0, 1), 
        a("cf2", 1, 0, 1), a("cf3", 0, -1, 1), a("cf4", 0, 1, 1), a("cn1", -1, 0, -1), a("cn2", 1, 0, -1), 
        a("cn3", 0, -1, -1), a("cn4", 0, 1, -1), b.verticesNeedUpdate = !0;
    };
}(), THREE.DirectionalLightHelper = function(a, b) {
    THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, void 0 === b && (b = 1);
    var c = new THREE.BufferGeometry();
    c.addAttribute("position", new THREE.Float32Attribute([ -b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0 ], 3));
    var d = new THREE.LineBasicMaterial({
        fog: !1
    });
    this.add(new THREE.Line(c, d)), c = new THREE.BufferGeometry(), c.addAttribute("position", new THREE.Float32Attribute([ 0, 0, 0, 0, 0, 1 ], 3)), 
    this.add(new THREE.Line(c, d)), this.update();
}, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), 
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper, 
THREE.DirectionalLightHelper.prototype.dispose = function() {
    var a = this.children[0], b = this.children[1];
    a.geometry.dispose(), a.material.dispose(), b.geometry.dispose(), b.material.dispose();
}, THREE.DirectionalLightHelper.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function() {
        a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), 
        c.subVectors(b, a);
        var d = this.children[0], e = this.children[1];
        d.lookAt(c), d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), 
        e.lookAt(c), e.scale.z = c.length();
    };
}(), THREE.EdgesHelper = function(a, b, c) {
    b = void 0 !== b ? b : 16777215, THREE.LineSegments.call(this, new THREE.EdgesGeometry(a.geometry, c), new THREE.LineBasicMaterial({
        color: b
    })), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper, 
THREE.FaceNormalsHelper = function(a, b, c, d) {
    this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16776960, 
    d = void 0 !== d ? d : 1, b = 0, c = this.object.geometry, c instanceof THREE.Geometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), 
    c = new THREE.BufferGeometry(), b = new THREE.Float32Attribute(6 * b, 3), c.addAttribute("position", b), 
    THREE.LineSegments.call(this, c, new THREE.LineBasicMaterial({
        color: a,
        linewidth: d
    })), this.matrixAutoUpdate = !1, this.update();
}, THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype), 
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper, THREE.FaceNormalsHelper.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Matrix3();
    return function() {
        this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
        for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices, f = f.faces, h = 0, i = 0, j = f.length; i < j; i++) {
            var k = f[i], l = k.normal;
            a.copy(g[k.a]).add(g[k.b]).add(g[k.c]).divideScalar(3).applyMatrix4(d), b.copy(l).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), 
            e.setXYZ(h, a.x, a.y, a.z), h += 1, e.setXYZ(h, b.x, b.y, b.z), h += 1;
        }
        return e.needsUpdate = !0, this;
    };
}(), THREE.GridHelper = function(a, b, c, d) {
    c = new THREE.Color(void 0 !== c ? c : 4473924), d = new THREE.Color(void 0 !== d ? d : 8947848);
    for (var e = [], f = [], g = -a, h = 0; g <= a; g += b) {
        e.push(-a, 0, g, a, 0, g), e.push(g, 0, -a, g, 0, a);
        var i = 0 === g ? c : d;
        i.toArray(f, h), h += 3, i.toArray(f, h), h += 3, i.toArray(f, h), h += 3, i.toArray(f, h), 
        h += 3;
    }
    a = new THREE.BufferGeometry(), a.addAttribute("position", new THREE.Float32Attribute(e, 3)), 
    a.addAttribute("color", new THREE.Float32Attribute(f, 3)), e = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    }), THREE.LineSegments.call(this, a, e);
}, THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype), THREE.GridHelper.prototype.constructor = THREE.GridHelper, 
THREE.GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
}, THREE.HemisphereLightHelper = function(a, b) {
    THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, this.colors = [ new THREE.Color(), new THREE.Color() ];
    var c = new THREE.SphereGeometry(b, 4, 2);
    c.rotateX(-Math.PI / 2);
    for (var d = 0; 8 > d; d++) c.faces[d].color = this.colors[4 > d ? 0 : 1];
    d = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: !0
    }), this.lightSphere = new THREE.Mesh(c, d), this.add(this.lightSphere), this.update();
}, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), 
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper, 
THREE.HemisphereLightHelper.prototype.dispose = function() {
    this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose();
}, THREE.HemisphereLightHelper.prototype.update = function() {
    var a = new THREE.Vector3();
    return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), 
        this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate()), 
        this.lightSphere.geometry.colorsNeedUpdate = !0;
    };
}(), THREE.PointLightHelper = function(a, b) {
    this.light = a, this.light.updateMatrixWorld();
    var c = new THREE.SphereBufferGeometry(b, 4, 2), d = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    d.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, c, d), 
    this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper, 
THREE.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose(), this.material.dispose();
}, THREE.PointLightHelper.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
}, THREE.SkeletonHelper = function(a) {
    this.bones = this.getBoneList(a);
    for (var b = new THREE.Geometry(), c = 0; c < this.bones.length; c++) this.bones[c].parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3()), 
    b.vertices.push(new THREE.Vector3()), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)));
    b.dynamic = !0, c = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    }), THREE.LineSegments.call(this, b, c), this.root = a, this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, this.update();
}, THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype), 
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper, THREE.SkeletonHelper.prototype.getBoneList = function(a) {
    var b = [];
    a instanceof THREE.Bone && b.push(a);
    for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
    return b;
}, THREE.SkeletonHelper.prototype.update = function() {
    for (var a = this.geometry, b = new THREE.Matrix4().getInverse(this.root.matrixWorld), c = new THREE.Matrix4(), d = 0, e = 0; e < this.bones.length; e++) {
        var f = this.bones[e];
        f.parent instanceof THREE.Bone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), 
        c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), 
        d += 2);
    }
    a.verticesNeedUpdate = !0, a.computeBoundingSphere();
}, THREE.SpotLightHelper = function(a) {
    THREE.Object3D.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, 
    this.matrixAutoUpdate = !1, a = new THREE.BufferGeometry();
    for (var b = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1 ], c = 0, d = 1; 32 > c; c++, 
    d++) {
        var e = c / 32 * Math.PI * 2, f = d / 32 * Math.PI * 2;
        b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1);
    }
    a.addAttribute("position", new THREE.Float32Attribute(b, 3)), b = new THREE.LineBasicMaterial({
        fog: !1
    }), this.cone = new THREE.LineSegments(a, b), this.add(this.cone), this.update();
}, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper, 
THREE.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
}, THREE.SpotLightHelper.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function() {
        var c = this.light.distance ? this.light.distance : 1e3, d = c * Math.tan(this.light.angle);
        this.cone.scale.set(d, d, c), a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), 
        this.cone.lookAt(b.sub(a)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
}(), THREE.VertexNormalsHelper = function(a, b, c, d) {
    this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16711680, 
    d = void 0 !== d ? d : 1, b = 0, c = this.object.geometry, c instanceof THREE.Geometry ? b = 3 * c.faces.length : c instanceof THREE.BufferGeometry && (b = c.attributes.normal.count), 
    c = new THREE.BufferGeometry(), b = new THREE.Float32Attribute(6 * b, 3), c.addAttribute("position", b), 
    THREE.LineSegments.call(this, c, new THREE.LineBasicMaterial({
        color: a,
        linewidth: d
    })), this.matrixAutoUpdate = !1, this.update();
}, THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype), 
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper, THREE.VertexNormalsHelper.prototype.update = function() {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Matrix3();
    return function() {
        var d = [ "a", "b", "c" ];
        this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
        var e = this.object.matrixWorld, f = this.geometry.attributes.position, g = this.object.geometry;
        if (g instanceof THREE.Geometry) for (var h = g.vertices, i = g.faces, j = g = 0, k = i.length; j < k; j++) for (var l = i[j], m = 0, n = l.vertexNormals.length; m < n; m++) {
            var o = l.vertexNormals[m];
            a.copy(h[l[d[m]]]).applyMatrix4(e), b.copy(o).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), 
            f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
        } else if (g instanceof THREE.BufferGeometry) for (d = g.attributes.position, h = g.attributes.normal, 
        m = g = 0, n = d.count; m < n; m++) a.set(d.getX(m), d.getY(m), d.getZ(m)).applyMatrix4(e), 
        b.set(h.getX(m), h.getY(m), h.getZ(m)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), 
        f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
        return f.needsUpdate = !0, this;
    };
}(), THREE.WireframeHelper = function(a, b) {
    var c = void 0 !== b ? b : 16777215;
    THREE.LineSegments.call(this, new THREE.WireframeGeometry(a.geometry), new THREE.LineBasicMaterial({
        color: c
    })), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1;
}, THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype), 
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper, THREE.ImmediateRenderObject = function(a) {
    THREE.Object3D.call(this), this.material = a, this.render = function(a) {};
}, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), 
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject, 
THREE.MorphBlendMesh = function(a, b) {
    THREE.Mesh.call(this, a, b), this.animationsMap = {}, this.animationsList = [];
    var c = this.geometry.morphTargets.length;
    this.createAnimation("__default", 0, c - 1, c / 1), this.setAnimationWeight("__default", 1);
}, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh, 
THREE.MorphBlendMesh.prototype.createAnimation = function(a, b, c, d) {
    b = {
        start: b,
        end: c,
        length: c - b + 1,
        fps: d,
        duration: (c - b) / d,
        lastFrame: 0,
        currentFrame: 0,
        active: !1,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: !1,
        mirroredLoop: !1
    }, this.animationsMap[a] = b, this.animationsList.push(b);
}, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(a) {
    for (var b, c = /([a-z]+)_?(\d+)/i, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
        var h = e.morphTargets[f].name.match(c);
        if (h && 1 < h.length) {
            var i = h[1];
            d[i] || (d[i] = {
                start: 1 / 0,
                end: -(1 / 0)
            }), h = d[i], f < h.start && (h.start = f), f > h.end && (h.end = f), b || (b = i);
        }
    }
    for (i in d) h = d[i], this.createAnimation(i, h.start, h.end, a);
    this.firstAnimation = b;
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(a) {
    (a = this.animationsMap[a]) && (a.direction = 1, a.directionBackwards = !1);
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(a) {
    (a = this.animationsMap[a]) && (a.direction = -1, a.directionBackwards = !0);
}, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.fps = b, c.duration = (c.end - c.start) / c.fps);
}, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.duration = b, c.fps = (c.end - c.start) / c.duration);
}, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.weight = b);
}, THREE.MorphBlendMesh.prototype.setAnimationTime = function(a, b) {
    var c = this.animationsMap[a];
    c && (c.time = b);
}, THREE.MorphBlendMesh.prototype.getAnimationTime = function(a) {
    var b = 0;
    return (a = this.animationsMap[a]) && (b = a.time), b;
}, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(a) {
    var b = -1;
    return (a = this.animationsMap[a]) && (b = a.duration), b;
}, THREE.MorphBlendMesh.prototype.playAnimation = function(a) {
    var b = this.animationsMap[a];
    b ? (b.time = 0, b.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()");
}, THREE.MorphBlendMesh.prototype.stopAnimation = function(a) {
    (a = this.animationsMap[a]) && (a.active = !1);
}, THREE.MorphBlendMesh.prototype.update = function(a) {
    for (var b = 0, c = this.animationsList.length; b < c; b++) {
        var d = this.animationsList[b];
        if (d.active) {
            var e = d.duration / d.length;
            d.time += d.direction * a, d.mirroredLoop ? (d.time > d.duration || 0 > d.time) && (d.direction *= -1, 
            d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, 
            d.directionBackwards = !1)) : (d.time %= d.duration, 0 > d.time && (d.time += d.duration));
            var f = d.start + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1), g = d.weight;
            f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, 
            this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f), 
            e = d.time % e / e, d.directionBackwards && (e = 1 - e), d.currentFrame !== d.lastFrame ? (this.morphTargetInfluences[d.currentFrame] = e * g, 
            this.morphTargetInfluences[d.lastFrame] = (1 - e) * g) : this.morphTargetInfluences[d.currentFrame] = g;
        }
    }
}, !function(a, b, c) {
    function d(c, f) {
        if (!b[c]) {
            if (!a[c]) {
                var g = "function" == typeof require && require;
                if (!f && g) return g(c, !0);
                if (e) return e(c, !0);
                throw new Error("Cannot find module '" + c + "'");
            }
            var h = b[c] = {
                exports: {}
            };
            a[c][0].call(h.exports, function(b) {
                var e = a[c][1][b];
                return d(e ? e : b);
            }, h, h.exports);
        }
        return b[c].exports;
    }
    for (var e = "function" == typeof require && require, f = 0; f < c.length; f++) d(c[f]);
    return d;
}({
    1: [ function(a, b, c) {}, {} ],
    2: [ function(a, b, c) {
        var d = b.exports = function(a) {
            this.pos = 0, this._buf = [], this.size = a;
        };
        d.prototype.get = function(a) {
            if (void 0 == a && (a = 0), !(a >= this.size || a >= this._buf.length)) return this._buf[(this.pos - a - 1) % this.size];
        }, d.prototype.push = function(a) {
            return this._buf[this.pos % this.size] = a, this.pos++;
        };
    }, {} ],
    3: [ function(a, b, c) {
        var d = a("../protocol").chooseProtocol, e = a("events").EventEmitter, f = a("underscore"), g = b.exports = function(a) {
            this.opts = f.defaults(a || {}, {
                host: "127.0.0.1",
                enableGestures: !1,
                port: 6437,
                background: !1,
                requestProtocolVersion: 4
            }), this.host = this.opts.host, this.port = this.opts.port, this.protocolVersionVerified = !1, 
            this.on("ready", function() {
                this.enableGestures(this.opts.enableGestures), this.setBackground(this.opts.background);
            });
        };
        g.prototype.getUrl = function() {
            return "ws://" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
        }, g.prototype.setBackground = function(a) {
            this.opts.background = a, this.protocol && this.protocol.sendBackground && this.background !== this.opts.background && (this.background = this.opts.background, 
            this.protocol.sendBackground(this, this.opts.background));
        }, g.prototype.handleOpen = function() {
            this.connected || (this.connected = !0, this.emit("connect"));
        }, g.prototype.enableGestures = function(a) {
            this.gesturesEnabled = !!a, this.send(this.protocol.encode({
                enableGestures: this.gesturesEnabled
            }));
        }, g.prototype.handleClose = function(a, b) {
            this.connected && (this.disconnect(), 1001 === a && this.opts.requestProtocolVersion > 1 && (this.protocolVersionVerified ? this.protocolVersionVerified = !1 : this.opts.requestProtocolVersion--), 
            this.startReconnection());
        }, g.prototype.startReconnection = function() {
            var a = this;
            this.reconnectionTimer = setInterval(function() {
                a.reconnect();
            }, 1e3);
        }, g.prototype.disconnect = function() {
            if (this.socket) return this.socket.close(), delete this.socket, delete this.protocol, 
            delete this.background, this.connected && (this.connected = !1, this.emit("disconnect")), 
            !0;
        }, g.prototype.reconnect = function() {
            this.connected ? clearInterval(this.reconnectionTimer) : (this.disconnect(), this.connect());
        }, g.prototype.handleData = function(a) {
            var b, c = JSON.parse(a);
            void 0 === this.protocol ? (b = this.protocol = d(c), this.protocolVersionVerified = !0, 
            this.emit("ready")) : b = this.protocol(c), this.emit(b.type, b);
        }, g.prototype.connect = function() {
            if (!this.socket) return this.socket = this.setupSocket(), !0;
        }, g.prototype.send = function(a) {
            this.socket.send(a);
        }, g.prototype.reportFocus = function(a) {
            this.focusedState !== a && (this.focusedState = a, this.emit(this.focusedState ? "focus" : "blur"), 
            this.protocol && this.protocol.sendFocused && this.protocol.sendFocused(this, this.focusedState));
        }, f.extend(g.prototype, e.prototype);
    }, {
        "../protocol": 13,
        events: 19,
        underscore: 22
    } ],
    4: [ function(a, b, c) {
        var d = b.exports = a("./base"), e = a("underscore"), f = b.exports = function(a) {
            d.call(this, a);
            var b = this;
            this.on("ready", function() {
                b.startFocusLoop();
            }), this.on("disconnect", function() {
                b.stopFocusLoop();
            });
        };
        e.extend(f.prototype, d.prototype), f.prototype.setupSocket = function() {
            var a = this, b = new WebSocket(this.getUrl());
            return b.onopen = function() {
                a.handleOpen();
            }, b.onclose = function(b) {
                a.handleClose(b.code, b.reason);
            }, b.onmessage = function(b) {
                a.handleData(b.data);
            }, b;
        }, f.prototype.startFocusLoop = function() {
            if (!this.focusDetectorTimer) {
                var a = this, b = null;
                b = "undefined" != typeof document.hidden ? "hidden" : "undefined" != typeof document.mozHidden ? "mozHidden" : "undefined" != typeof document.msHidden ? "msHidden" : "undefined" != typeof document.webkitHidden ? "webkitHidden" : void 0, 
                void 0 === a.windowVisible && (a.windowVisible = void 0 === b || document[b] === !1);
                var c = window.addEventListener("focus", function(b) {
                    a.windowVisible = !0, e();
                }), d = window.addEventListener("blur", function(b) {
                    a.windowVisible = !1, e();
                });
                this.on("disconnect", function() {
                    window.removeEventListener("focus", c), window.removeEventListener("blur", d);
                });
                var e = function() {
                    var c = void 0 === b || document[b] === !1;
                    a.reportFocus(c && a.windowVisible);
                };
                this.focusDetectorTimer = setInterval(e, 100);
            }
        }, f.prototype.stopFocusLoop = function() {
            this.focusDetectorTimer && (clearTimeout(this.focusDetectorTimer), delete this.focusDetectorTimer);
        };
    }, {
        "./base": 3,
        underscore: 22
    } ],
    5: [ function(a, b, c) {
        var d = a("__browserify_process"), e = a("./frame"), f = a("./hand"), g = a("./pointable"), h = a("./circular_buffer"), i = a("./pipeline"), j = a("events").EventEmitter, k = a("./gesture").gestureListener, l = a("underscore"), m = b.exports = function(b) {
            var c = "undefined" != typeof d && d.versions && d.versions.node, f = this;
            b = l.defaults(b || {}, {
                inNode: c
            }), this.inNode = b.inNode, b = l.defaults(b || {}, {
                frameEventName: this.useAnimationLoop() ? "animationFrame" : "deviceFrame",
                suppressAnimationLoop: !this.useAnimationLoop(),
                loopWhileDisconnected: !1,
                useAllPlugins: !1
            }), this.animationFrameRequested = !1, this.onAnimationFrame = function() {
                f.emit("animationFrame", f.lastConnectionFrame), f.loopWhileDisconnected && (f.connection.focusedState || f.connection.opts.background) ? window.requestAnimationFrame(f.onAnimationFrame) : f.animationFrameRequested = !1;
            }, this.suppressAnimationLoop = b.suppressAnimationLoop, this.loopWhileDisconnected = b.loopWhileDisconnected, 
            this.frameEventName = b.frameEventName, this.useAllPlugins = b.useAllPlugins, this.history = new h(200), 
            this.lastFrame = e.Invalid, this.lastValidFrame = e.Invalid, this.lastConnectionFrame = e.Invalid, 
            this.accumulatedGestures = [], void 0 === b.connectionType ? this.connectionType = a(this.inBrowser() ? "./connection/browser" : "./connection/node") : this.connectionType = b.connectionType, 
            this.connection = new this.connectionType(b), this.plugins = {}, this._pluginPipelineSteps = {}, 
            this._pluginExtendedMethods = {}, b.useAllPlugins && this.useRegisteredPlugins(), 
            this.setupConnectionEvents();
        };
        m.prototype.gesture = function(a, b) {
            var c = k(this, a);
            return void 0 !== b && c.stop(b), c;
        }, m.prototype.setBackground = function(a) {
            return this.connection.setBackground(a), this;
        }, m.prototype.inBrowser = function() {
            return !this.inNode;
        }, m.prototype.useAnimationLoop = function() {
            return this.inBrowser() && !this.inBackgroundPage();
        }, m.prototype.inBackgroundPage = function() {
            return "undefined" != typeof chrome && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window;
        }, m.prototype.connect = function() {
            return this.connection.connect(), this;
        }, m.prototype.runAnimationLoop = function() {
            this.suppressAnimationLoop || this.animationFrameRequested || (this.animationFrameRequested = !0, 
            window.requestAnimationFrame(this.onAnimationFrame));
        }, m.prototype.disconnect = function() {
            return this.connection.disconnect(), this;
        }, m.prototype.frame = function(a) {
            return this.history.get(a) || e.Invalid;
        }, m.prototype.loop = function(a) {
            switch (a.length) {
              case 1:
                this.on(this.frameEventName, a);
                break;

              case 2:
                var b = this, c = function(d) {
                    a(d, function() {
                        b.lastFrame != d ? c(b.lastFrame) : b.once(b.frameEventName, c);
                    });
                };
                this.once(this.frameEventName, c);
            }
            return this.connect();
        }, m.prototype.addStep = function(a) {
            this.pipeline || (this.pipeline = new i(this)), this.pipeline.addStep(a);
        }, m.prototype.processFrame = function(a) {
            a.gestures && (this.accumulatedGestures = this.accumulatedGestures.concat(a.gestures)), 
            this.lastConnectionFrame = a, this.runAnimationLoop(), this.emit("deviceFrame", a);
        }, m.prototype.processFinishedFrame = function(a) {
            if (this.lastFrame = a, a.valid && (this.lastValidFrame = a), a.controller = this, 
            a.historyIdx = this.history.push(a), a.gestures) {
                a.gestures = this.accumulatedGestures, this.accumulatedGestures = [];
                for (var b = 0; b != a.gestures.length; b++) this.emit("gesture", a.gestures[b], a);
            }
            this.pipeline && (a = this.pipeline.run(a), a || (a = e.Invalid)), this.emit("frame", a);
        }, m.prototype.setupConnectionEvents = function() {
            var a = this;
            this.connection.on("frame", function(b) {
                a.processFrame(b);
            }), this.on(this.frameEventName, function(b) {
                a.processFinishedFrame(b);
            }), this.connection.on("disconnect", function() {
                a.emit("disconnect");
            }), this.connection.on("ready", function() {
                a.emit("ready");
            }), this.connection.on("connect", function() {
                a.emit("connect");
            }), this.connection.on("focus", function() {
                a.emit("focus"), a.runAnimationLoop();
            }), this.connection.on("blur", function() {
                a.emit("blur");
            }), this.connection.on("protocol", function(b) {
                a.emit("protocol", b);
            }), this.connection.on("deviceConnect", function(b) {
                a.emit(b.state ? "deviceConnected" : "deviceDisconnected");
            });
        }, m._pluginFactories = {}, m.plugin = function(a, b) {
            if (this._pluginFactories[a]) throw 'Plugin "' + a + '" already registered';
            return this._pluginFactories[a] = b;
        }, m.plugins = function() {
            return l.keys(this._pluginFactories);
        }, m.prototype.use = function(a, b) {
            var c, d, h, j, k;
            if (d = "function" == typeof a ? a : m._pluginFactories[a], !d) throw "Leap Plugin " + a + " not found.";
            if (b || (b = {}), this.plugins[a]) return l.extend(this.plugins[a], b), this;
            this.plugins[a] = b, j = d.call(this, b);
            for (h in j) if (c = j[h], "function" == typeof c) this.pipeline || (this.pipeline = new i(this)), 
            this._pluginPipelineSteps[a] || (this._pluginPipelineSteps[a] = []), this._pluginPipelineSteps[a].push(this.pipeline.addWrappedStep(h, c)); else {
                switch (this._pluginExtendedMethods[a] || (this._pluginExtendedMethods[a] = []), 
                h) {
                  case "frame":
                    k = e;
                    break;

                  case "hand":
                    k = f;
                    break;

                  case "pointable":
                    k = g;
                    break;

                  default:
                    throw a + ' specifies invalid object type "' + h + '" for prototypical extension';
                }
                l.extend(k.prototype, c), l.extend(k.Invalid, c), this._pluginExtendedMethods[a].push([ k, c ]);
            }
            return this;
        }, m.prototype.stopUsing = function(a) {
            var b, c, d = this._pluginPipelineSteps[a], e = this._pluginExtendedMethods[a], f = 0;
            if (this.plugins[a]) {
                if (d) for (f = 0; f < d.length; f++) this.pipeline.removeStep(d[f]);
                if (e) for (f = 0; f < e.length; f++) {
                    b = e[f][0], c = e[f][1];
                    for (var g in c) delete b.prototype[g], delete b.Invalid[g];
                }
                return delete this.plugins[a], this;
            }
        }, m.prototype.useRegisteredPlugins = function() {
            for (var a in m._pluginFactories) this.use(a);
        }, l.extend(m.prototype, j.prototype);
    }, {
        "./circular_buffer": 2,
        "./connection/browser": 4,
        "./connection/node": 18,
        "./frame": 6,
        "./gesture": 7,
        "./hand": 8,
        "./pipeline": 11,
        "./pointable": 12,
        __browserify_process: 20,
        events: 19,
        underscore: 22
    } ],
    6: [ function(a, b, c) {
        var d = a("./hand"), e = a("./pointable"), f = a("./gesture").createGesture, g = a("gl-matrix"), h = g.mat3, i = g.vec3, j = a("./interaction_box"), k = a("underscore"), l = b.exports = function(a) {
            this.valid = !0, this.id = a.id, this.timestamp = a.timestamp, this.hands = [], 
            this.handsMap = {}, this.pointables = [], this.tools = [], this.fingers = [], a.interactionBox && (this.interactionBox = new j(a.interactionBox)), 
            this.gestures = [], this.pointablesMap = {}, this._translation = a.t, this._rotation = k.flatten(a.r), 
            this._scaleFactor = a.s, this.data = a, this.type = "frame", this.currentFrameRate = a.currentFrameRate;
            for (var b = {}, c = 0, g = a.hands.length; c != g; c++) {
                var h = new d(a.hands[c]);
                h.frame = this, this.hands.push(h), this.handsMap[h.id] = h, b[h.id] = c;
            }
            for (var i = 0, l = a.pointables.length; i != l; i++) {
                var m = new e(a.pointables[i]);
                if (m.frame = this, this.pointables.push(m), this.pointablesMap[m.id] = m, (m.tool ? this.tools : this.fingers).push(m), 
                void 0 !== m.handId && b.hasOwnProperty(m.handId)) {
                    var h = this.hands[b[m.handId]];
                    h.pointables.push(m), (m.tool ? h.tools : h.fingers).push(m);
                }
            }
            if (a.gestures) for (var n = 0, o = a.gestures.length; n != o; n++) this.gestures.push(f(a.gestures[n]));
        };
        l.prototype.tool = function(a) {
            var b = this.pointable(a);
            return b.tool ? b : e.Invalid;
        }, l.prototype.pointable = function(a) {
            return this.pointablesMap[a] || e.Invalid;
        }, l.prototype.finger = function(a) {
            var b = this.pointable(a);
            return b.tool ? e.Invalid : b;
        }, l.prototype.hand = function(a) {
            return this.handsMap[a] || d.Invalid;
        }, l.prototype.rotationAngle = function(a, b) {
            if (!this.valid || !a.valid) return 0;
            var c = this.rotationMatrix(a), d = .5 * (c[0] + c[4] + c[8] - 1), e = Math.acos(d);
            if (e = isNaN(e) ? 0 : e, void 0 !== b) {
                var f = this.rotationAxis(a);
                e *= i.dot(f, i.normalize(i.create(), b));
            }
            return e;
        }, l.prototype.rotationAxis = function(a) {
            return this.valid && a.valid ? i.normalize(i.create(), [ this._rotation[7] - a._rotation[5], this._rotation[2] - a._rotation[6], this._rotation[3] - a._rotation[1] ]) : i.create();
        }, l.prototype.rotationMatrix = function(a) {
            if (!this.valid || !a.valid) return h.create();
            var b = h.transpose(h.create(), this._rotation);
            return h.multiply(h.create(), a._rotation, b);
        }, l.prototype.scaleFactor = function(a) {
            return this.valid && a.valid ? Math.exp(this._scaleFactor - a._scaleFactor) : 1;
        }, l.prototype.translation = function(a) {
            return this.valid && a.valid ? i.subtract(i.create(), this._translation, a._translation) : i.create();
        }, l.prototype.toString = function() {
            var a = "Frame [ id:" + this.id + " | timestamp:" + this.timestamp + " | Hand count:(" + this.hands.length + ") | Pointable count:(" + this.pointables.length + ")";
            return this.gestures && (a += " | Gesture count:(" + this.gestures.length + ")"), 
            a += " ]";
        }, l.prototype.dump = function() {
            var a = "";
            a += "Frame Info:<br/>", a += this.toString(), a += "<br/><br/>Hands:<br/>";
            for (var b = 0, c = this.hands.length; b != c; b++) a += "  " + this.hands[b].toString() + "<br/>";
            a += "<br/><br/>Pointables:<br/>";
            for (var d = 0, e = this.pointables.length; d != e; d++) a += "  " + this.pointables[d].toString() + "<br/>";
            if (this.gestures) {
                a += "<br/><br/>Gestures:<br/>";
                for (var f = 0, g = this.gestures.length; f != g; f++) a += "  " + this.gestures[f].toString() + "<br/>";
            }
            return a += "<br/><br/>Raw JSON:<br/>", a += JSON.stringify(this.data);
        }, l.Invalid = {
            valid: !1,
            hands: [],
            fingers: [],
            tools: [],
            gestures: [],
            pointables: [],
            pointable: function() {
                return e.Invalid;
            },
            finger: function() {
                return e.Invalid;
            },
            hand: function() {
                return d.Invalid;
            },
            toString: function() {
                return "invalid frame";
            },
            dump: function() {
                return this.toString();
            },
            rotationAngle: function() {
                return 0;
            },
            rotationMatrix: function() {
                return h.create();
            },
            rotationAxis: function() {
                return i.create();
            },
            scaleFactor: function() {
                return 1;
            },
            translation: function() {
                return i.create();
            }
        };
    }, {
        "./gesture": 7,
        "./hand": 8,
        "./interaction_box": 10,
        "./pointable": 12,
        "gl-matrix": 21,
        underscore: 22
    } ],
    7: [ function(a, b, c) {
        var d = a("gl-matrix"), e = d.vec3, f = a("events").EventEmitter, g = a("underscore"), h = (c.createGesture = function(a) {
            var b;
            switch (a.type) {
              case "circle":
                b = new i(a);
                break;

              case "swipe":
                b = new j(a);
                break;

              case "screenTap":
                b = new k(a);
                break;

              case "keyTap":
                b = new l(a);
                break;

              default:
                throw "unkown gesture type";
            }
            return b.id = a.id, b.handIds = a.handIds, b.pointableIds = a.pointableIds, b.duration = a.duration, 
            b.state = a.state, b.type = a.type, b;
        }, c.gestureListener = function(a, b) {
            var c = {}, d = {};
            a.on("gesture", function(a, e) {
                if (a.type == b) {
                    if (("start" == a.state || "stop" == a.state) && void 0 === d[a.id]) {
                        var f = new h(a, e);
                        d[a.id] = f, g.each(c, function(a, b) {
                            f.on(b, a);
                        });
                    }
                    d[a.id].update(a, e), "stop" == a.state && delete d[a.id];
                }
            });
            var e = {
                start: function(a) {
                    return c.start = a, e;
                },
                stop: function(a) {
                    return c.stop = a, e;
                },
                complete: function(a) {
                    return c.stop = a, e;
                },
                update: function(a) {
                    return c.update = a, e;
                }
            };
            return e;
        }, c.Gesture = function(a, b) {
            this.gestures = [ a ], this.frames = [ b ];
        });
        h.prototype.update = function(a, b) {
            this.lastGesture = a, this.lastFrame = b, this.gestures.push(a), this.frames.push(b), 
            this.emit(a.state, this);
        }, h.prototype.translation = function() {
            return e.subtract(e.create(), this.lastGesture.startPosition, this.lastGesture.position);
        }, g.extend(h.prototype, f.prototype);
        var i = function(a) {
            this.center = a.center, this.normal = a.normal, this.progress = a.progress, this.radius = a.radius;
        };
        i.prototype.toString = function() {
            return "CircleGesture [" + JSON.stringify(this) + "]";
        };
        var j = function(a) {
            this.startPosition = a.startPosition, this.position = a.position, this.direction = a.direction, 
            this.speed = a.speed;
        };
        j.prototype.toString = function() {
            return "SwipeGesture [" + JSON.stringify(this) + "]";
        };
        var k = function(a) {
            this.position = a.position, this.direction = a.direction, this.progress = a.progress;
        };
        k.prototype.toString = function() {
            return "ScreenTapGesture [" + JSON.stringify(this) + "]";
        };
        var l = function(a) {
            this.position = a.position, this.direction = a.direction, this.progress = a.progress;
        };
        l.prototype.toString = function() {
            return "KeyTapGesture [" + JSON.stringify(this) + "]";
        };
    }, {
        events: 19,
        "gl-matrix": 21,
        underscore: 22
    } ],
    8: [ function(a, b, c) {
        var d = a("./pointable"), e = a("gl-matrix"), f = e.mat3, g = e.vec3, h = a("underscore"), i = b.exports = function(a) {
            this.id = a.id, this.palmPosition = a.palmPosition, this.direction = a.direction, 
            this.palmVelocity = a.palmVelocity, this.palmNormal = a.palmNormal, this.sphereCenter = a.sphereCenter, 
            this.sphereRadius = a.sphereRadius, this.valid = !0, this.pointables = [], this.fingers = [], 
            this.tools = [], this._translation = a.t, this._rotation = h.flatten(a.r), this._scaleFactor = a.s, 
            this.timeVisible = a.timeVisible, this.stabilizedPalmPosition = a.stabilizedPalmPosition;
        };
        i.prototype.finger = function(a) {
            var b = this.frame.finger(a);
            return b && b.handId == this.id ? b : d.Invalid;
        }, i.prototype.rotationAngle = function(a, b) {
            if (!this.valid || !a.valid) return 0;
            var c = a.hand(this.id);
            if (!c.valid) return 0;
            var d = this.rotationMatrix(a), e = .5 * (d[0] + d[4] + d[8] - 1), f = Math.acos(e);
            if (f = isNaN(f) ? 0 : f, void 0 !== b) {
                var h = this.rotationAxis(a);
                f *= g.dot(h, g.normalize(g.create(), b));
            }
            return f;
        }, i.prototype.rotationAxis = function(a) {
            if (!this.valid || !a.valid) return g.create();
            var b = a.hand(this.id);
            return b.valid ? g.normalize(g.create(), [ this._rotation[7] - b._rotation[5], this._rotation[2] - b._rotation[6], this._rotation[3] - b._rotation[1] ]) : g.create();
        }, i.prototype.rotationMatrix = function(a) {
            if (!this.valid || !a.valid) return f.create();
            var b = a.hand(this.id);
            if (!b.valid) return f.create();
            var c = f.transpose(f.create(), this._rotation), d = f.multiply(f.create(), b._rotation, c);
            return d;
        }, i.prototype.scaleFactor = function(a) {
            if (!this.valid || !a.valid) return 1;
            var b = a.hand(this.id);
            return b.valid ? Math.exp(this._scaleFactor - b._scaleFactor) : 1;
        }, i.prototype.translation = function(a) {
            if (!this.valid || !a.valid) return g.create();
            var b = a.hand(this.id);
            return b.valid ? [ this._translation[0] - b._translation[0], this._translation[1] - b._translation[1], this._translation[2] - b._translation[2] ] : g.create();
        }, i.prototype.toString = function() {
            return "Hand [ id: " + this.id + " | palm velocity:" + this.palmVelocity + " | sphere center:" + this.sphereCenter + " ] ";
        }, i.prototype.pitch = function() {
            return Math.atan2(this.direction[1], -this.direction[2]);
        }, i.prototype.yaw = function() {
            return Math.atan2(this.direction[0], -this.direction[2]);
        }, i.prototype.roll = function() {
            return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
        }, i.Invalid = {
            valid: !1,
            fingers: [],
            tools: [],
            pointables: [],
            pointable: function() {
                return d.Invalid;
            },
            finger: function() {
                return d.Invalid;
            },
            toString: function() {
                return "invalid frame";
            },
            dump: function() {
                return this.toString();
            },
            rotationAngle: function() {
                return 0;
            },
            rotationMatrix: function() {
                return f.create();
            },
            rotationAxis: function() {
                return g.create();
            },
            scaleFactor: function() {
                return 1;
            },
            translation: function() {
                return g.create();
            }
        };
    }, {
        "./pointable": 12,
        "gl-matrix": 21,
        underscore: 22
    } ],
    9: [ function(a, b, c) {
        a("./_header"), b.exports = {
            Controller: a("./controller"),
            Frame: a("./frame"),
            Gesture: a("./gesture"),
            Hand: a("./hand"),
            Pointable: a("./pointable"),
            InteractionBox: a("./interaction_box"),
            CircularBuffer: a("./circular_buffer"),
            UI: a("./ui"),
            glMatrix: a("gl-matrix"),
            mat3: a("gl-matrix").mat3,
            vec3: a("gl-matrix").vec3,
            loopController: void 0,
            version: a("./version.js"),
            loop: function(a, b) {
                return void 0 === b && (b = a, a = {}), a.useAllPlugins || (a.useAllPlugins = !0), 
                this.loopController || (this.loopController = new this.Controller(a)), this.loopController.loop(b), 
                this.loopController;
            },
            plugin: function(a, b) {
                this.Controller.plugin(a, b);
            }
        };
    }, {
        "./_header": 1,
        "./circular_buffer": 2,
        "./controller": 5,
        "./frame": 6,
        "./gesture": 7,
        "./hand": 8,
        "./interaction_box": 10,
        "./pointable": 12,
        "./ui": 14,
        "./version.js": 17,
        "gl-matrix": 21
    } ],
    10: [ function(a, b, c) {
        var d = a("gl-matrix"), e = d.vec3, f = b.exports = function(a) {
            this.valid = !0, this.center = a.center, this.size = a.size, this.width = a.size[0], 
            this.height = a.size[1], this.depth = a.size[2];
        };
        f.prototype.denormalizePoint = function(a) {
            return e.fromValues((a[0] - .5) * this.size[0] + this.center[0], (a[1] - .5) * this.size[1] + this.center[1], (a[2] - .5) * this.size[2] + this.center[2]);
        }, f.prototype.normalizePoint = function(a, b) {
            var c = e.fromValues((a[0] - this.center[0]) / this.size[0] + .5, (a[1] - this.center[1]) / this.size[1] + .5, (a[2] - this.center[2]) / this.size[2] + .5);
            return b && (c[0] = Math.min(Math.max(c[0], 0), 1), c[1] = Math.min(Math.max(c[1], 0), 1), 
            c[2] = Math.min(Math.max(c[2], 0), 1)), c;
        }, f.prototype.toString = function() {
            return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
        }, f.Invalid = {
            valid: !1
        };
    }, {
        "gl-matrix": 21
    } ],
    11: [ function(a, b, c) {
        var d = b.exports = function(a) {
            this.steps = [], this.controller = a;
        };
        d.prototype.addStep = function(a) {
            this.steps.push(a);
        }, d.prototype.run = function(a) {
            for (var b = this.steps.length, c = 0; c != b && a; c++) a = this.steps[c](a);
            return a;
        }, d.prototype.removeStep = function(a) {
            var b = this.steps.indexOf(a);
            if (b === -1) throw "Step not found in pipeline";
            this.steps.splice(b, 1);
        }, d.prototype.addWrappedStep = function(a, b) {
            var c = this.controller, d = function(d) {
                var e, f, g;
                for (e = "frame" == a ? [ d ] : d[a + "s"] || [], f = 0, g = e.length; f < g; f++) b.call(c, e[f]);
                return d;
            };
            return this.addStep(d), d;
        };
    }, {} ],
    12: [ function(a, b, c) {
        var d = a("gl-matrix"), e = (d.vec3, b.exports = function(a) {
            this.valid = !0, this.id = a.id, this.handId = a.handId, this.length = a.length, 
            this.tool = a.tool, this.width = a.width, this.direction = a.direction, this.stabilizedTipPosition = a.stabilizedTipPosition, 
            this.tipPosition = a.tipPosition, this.tipVelocity = a.tipVelocity, this.touchZone = a.touchZone, 
            this.touchDistance = a.touchDistance, this.timeVisible = a.timeVisible;
        });
        e.prototype.toString = function() {
            return 1 == this.tool ? "Pointable [ id:" + this.id + " " + this.length + "mmx | with:" + this.width + "mm | direction:" + this.direction + " ]" : "Pointable [ id:" + this.id + " " + this.length + "mmx | direction: " + this.direction + " ]";
        }, e.prototype.hand = function() {
            return this.frame.hand(this.handId);
        }, e.Invalid = {
            valid: !1
        };
    }, {
        "gl-matrix": 21
    } ],
    13: [ function(a, b, c) {
        var d = a("./frame"), e = function(a) {
            this.type = a.type, this.state = a.state;
        }, f = (c.chooseProtocol = function(a) {
            var b;
            switch (a.version) {
              case 1:
              case 2:
              case 3:
              case 4:
                b = f(a.version, function(a) {
                    return a.event ? new e(a.event) : new d(a);
                }), b.sendBackground = function(a, c) {
                    a.send(b.encode({
                        background: c
                    }));
                }, b.sendFocused = function(a, c) {
                    a.send(b.encode({
                        focused: c
                    }));
                };
                break;

              default:
                throw "unrecognized version";
            }
            return b;
        }, function(a, b) {
            var c = b;
            return c.encode = function(a) {
                return JSON.stringify(a);
            }, c.version = a, c.versionLong = "Version " + a, c.type = "protocol", c;
        });
    }, {
        "./frame": 6
    } ],
    14: [ function(a, b, c) {
        c.UI = {
            Region: a("./ui/region"),
            Cursor: a("./ui/cursor")
        };
    }, {
        "./ui/cursor": 15,
        "./ui/region": 16
    } ],
    15: [ function(a, b, c) {
        b.exports = function() {
            return function(a) {
                var b = a.pointables.sort(function(a, b) {
                    return a.z - b.z;
                })[0];
                return b && b.valid && (a.cursorPosition = b.tipPosition), a;
            };
        };
    }, {} ],
    16: [ function(a, b, c) {
        var d = a("events").EventEmitter, e = a("underscore"), f = b.exports = function(a, b) {
            this.start = new Vector(a), this.end = new Vector(b), this.enteredFrame = null;
        };
        f.prototype.hasPointables = function(a) {
            for (var b = 0; b != a.pointables.length; b++) {
                var c = a.pointables[b].tipPosition;
                if (c.x >= this.start.x && c.x <= this.end.x && c.y >= this.start.y && c.y <= this.end.y && c.z >= this.start.z && c.z <= this.end.z) return !0;
            }
            return !1;
        }, f.prototype.listener = function(a) {
            var b = this;
            return a && a.nearThreshold && this.setupNearRegion(a.nearThreshold), function(a) {
                return b.updatePosition(a);
            };
        }, f.prototype.clipper = function() {
            var a = this;
            return function(b) {
                return a.updatePosition(b), a.enteredFrame ? b : null;
            };
        }, f.prototype.setupNearRegion = function(a) {
            var b = this.nearRegion = new f([ this.start.x - a, this.start.y - a, this.start.z - a ], [ this.end.x + a, this.end.y + a, this.end.z + a ]), c = this;
            b.on("enter", function(a) {
                c.emit("near", a);
            }), b.on("exit", function(a) {
                c.emit("far", a);
            }), c.on("exit", function(a) {
                c.emit("near", a);
            });
        }, f.prototype.updatePosition = function(a) {
            return this.nearRegion && this.nearRegion.updatePosition(a), this.hasPointables(a) && null == this.enteredFrame ? (this.enteredFrame = a, 
            this.emit("enter", this.enteredFrame)) : this.hasPointables(a) || null == this.enteredFrame || (this.enteredFrame = null, 
            this.emit("exit", this.enteredFrame)), a;
        }, f.prototype.normalize = function(a) {
            return new Vector([ (a.x - this.start.x) / (this.end.x - this.start.x), (a.y - this.start.y) / (this.end.y - this.start.y), (a.z - this.start.z) / (this.end.z - this.start.z) ]);
        }, f.prototype.mapToXY = function(a, b, c) {
            var d = this.normalize(a), e = d.x, f = d.y;
            return e > 1 ? e = 1 : e < -1 && (e = -1), f > 1 ? f = 1 : f < -1 && (f = -1), [ (e + 1) / 2 * b, (1 - f) / 2 * c, d.z ];
        }, e.extend(f.prototype, d.prototype);
    }, {
        events: 19,
        underscore: 22
    } ],
    17: [ function(a, b, c) {
        b.exports = {
            full: "0.4.3",
            major: 0,
            minor: 4,
            dot: 3
        };
    }, {} ],
    18: [ function(a, b, c) {}, {} ],
    19: [ function(a, b, c) {
        function d(a, b) {
            if (a.indexOf) return a.indexOf(b);
            for (var c = 0; c < a.length; c++) if (b === a[c]) return c;
            return -1;
        }
        var e = a("__browserify_process");
        e.EventEmitter || (e.EventEmitter = function() {});
        var f = c.EventEmitter = e.EventEmitter, g = "function" == typeof Array.isArray ? Array.isArray : function(a) {
            return "[object Array]" === Object.prototype.toString.call(a);
        }, h = 10;
        f.prototype.setMaxListeners = function(a) {
            this._events || (this._events = {}), this._events.maxListeners = a;
        }, f.prototype.emit = function(a) {
            if ("error" === a && (!this._events || !this._events.error || g(this._events.error) && !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
            if (!this._events) return !1;
            var b = this._events[a];
            if (!b) return !1;
            if ("function" == typeof b) {
                switch (arguments.length) {
                  case 1:
                    b.call(this);
                    break;

                  case 2:
                    b.call(this, arguments[1]);
                    break;

                  case 3:
                    b.call(this, arguments[1], arguments[2]);
                    break;

                  default:
                    var c = Array.prototype.slice.call(arguments, 1);
                    b.apply(this, c);
                }
                return !0;
            }
            if (g(b)) {
                for (var c = Array.prototype.slice.call(arguments, 1), d = b.slice(), e = 0, f = d.length; e < f; e++) d[e].apply(this, c);
                return !0;
            }
            return !1;
        }, f.prototype.addListener = function(a, b) {
            if ("function" != typeof b) throw new Error("addListener only takes instances of Function");
            if (this._events || (this._events = {}), this.emit("newListener", a, b), this._events[a]) if (g(this._events[a])) {
                if (!this._events[a].warned) {
                    var c;
                    c = void 0 !== this._events.maxListeners ? this._events.maxListeners : h, c && c > 0 && this._events[a].length > c && (this._events[a].warned = !0, 
                    console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a].length), 
                    console.trace());
                }
                this._events[a].push(b);
            } else this._events[a] = [ this._events[a], b ]; else this._events[a] = b;
            return this;
        }, f.prototype.on = f.prototype.addListener, f.prototype.once = function(a, b) {
            var c = this;
            return c.on(a, function d() {
                c.removeListener(a, d), b.apply(this, arguments);
            }), this;
        }, f.prototype.removeListener = function(a, b) {
            if ("function" != typeof b) throw new Error("removeListener only takes instances of Function");
            if (!this._events || !this._events[a]) return this;
            var c = this._events[a];
            if (g(c)) {
                var e = d(c, b);
                if (e < 0) return this;
                c.splice(e, 1), 0 == c.length && delete this._events[a];
            } else this._events[a] === b && delete this._events[a];
            return this;
        }, f.prototype.removeAllListeners = function(a) {
            return 0 === arguments.length ? (this._events = {}, this) : (a && this._events && this._events[a] && (this._events[a] = null), 
            this);
        }, f.prototype.listeners = function(a) {
            return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), 
            g(this._events[a]) || (this._events[a] = [ this._events[a] ]), this._events[a];
        }, f.listenerCount = function(a, b) {
            var c;
            return c = a._events && a._events[b] ? "function" == typeof a._events[b] ? 1 : a._events[b].length : 0;
        };
    }, {
        __browserify_process: 20
    } ],
    20: [ function(a, b, c) {
        var d = b.exports = {};
        d.nextTick = function() {
            var a = "undefined" != typeof window && window.setImmediate, b = "undefined" != typeof window && window.postMessage && window.addEventListener;
            if (a) return function(a) {
                return window.setImmediate(a);
            };
            if (b) {
                var c = [];
                return window.addEventListener("message", function(a) {
                    if (a.source === window && "process-tick" === a.data && (a.stopPropagation(), c.length > 0)) {
                        var b = c.shift();
                        b();
                    }
                }, !0), function(a) {
                    c.push(a), window.postMessage("process-tick", "*");
                };
            }
            return function(a) {
                setTimeout(a, 0);
            };
        }(), d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.binding = function(a) {
            throw new Error("process.binding is not supported");
        }, d.cwd = function() {
            return "/";
        }, d.chdir = function(a) {
            throw new Error("process.chdir is not supported");
        };
    }, {} ],
    21: [ function(a, b, c) {
        !function() {
            "use strict";
            var a = {};
            "undefined" == typeof c ? "function" == typeof define && "object" == typeof define.amd && define.amd ? (a.exports = {}, 
            define(function() {
                return a.exports;
            })) : a.exports = window : a.exports = c, !function(a) {
                var b = {};
                if (!c) var c = 1e-6;
                b.create = function() {
                    return new Float32Array(2);
                }, b.clone = function(a) {
                    var b = new Float32Array(2);
                    return b[0] = a[0], b[1] = a[1], b;
                }, b.fromValues = function(a, b) {
                    var c = new Float32Array(2);
                    return c[0] = a, c[1] = b, c;
                }, b.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a;
                }, b.set = function(a, b, c) {
                    return a[0] = b, a[1] = c, a;
                }, b.add = function(a, b, c) {
                    return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a;
                }, b.sub = b.subtract = function(a, b, c) {
                    return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a;
                }, b.mul = b.multiply = function(a, b, c) {
                    return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a;
                }, b.div = b.divide = function(a, b, c) {
                    return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a;
                }, b.min = function(a, b, c) {
                    return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a;
                }, b.max = function(a, b, c) {
                    return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a;
                }, b.scale = function(a, b, c) {
                    return a[0] = b[0] * c, a[1] = b[1] * c, a;
                }, b.dist = b.distance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1];
                    return Math.sqrt(c * c + d * d);
                }, b.sqrDist = b.squaredDistance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1];
                    return c * c + d * d;
                }, b.len = b.length = function(a) {
                    var b = a[0], c = a[1];
                    return Math.sqrt(b * b + c * c);
                }, b.sqrLen = b.squaredLength = function(a) {
                    var b = a[0], c = a[1];
                    return b * b + c * c;
                }, b.negate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a;
                }, b.normalize = function(a, b) {
                    var c = b[0], d = b[1], e = c * c + d * d;
                    return e > 0 && (e = 1 / Math.sqrt(e), a[0] = b[0] * e, a[1] = b[1] * e), a;
                }, b.dot = function(a, b) {
                    return a[0] * b[0] + a[1] * b[1];
                }, b.cross = function(a, b, c) {
                    var d = b[0] * c[1] - b[1] * c[0];
                    return a[0] = a[1] = 0, a[2] = d, a;
                }, b.lerp = function(a, b, c, d) {
                    var e = b[0], f = b[1];
                    return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a;
                }, b.transformMat2 = function(a, b, c) {
                    var d = b[0], e = b[1];
                    return a[0] = d * c[0] + e * c[1], a[1] = d * c[2] + e * c[3], a;
                }, b.forEach = function() {
                    var a = new Float32Array(2);
                    return function(b, c, d, e, f, g) {
                        var h, i;
                        for (c || (c = 2), d || (d = 0), i = e ? Math.min(e * c + d, b.length) : b.length, 
                        h = d; h < i; h += c) a[0] = b[h], a[1] = b[h + 1], f(a, a, g), b[h] = a[0], b[h + 1] = a[1];
                        return b;
                    };
                }(), b.str = function(a) {
                    return "vec2(" + a[0] + ", " + a[1] + ")";
                }, "undefined" != typeof a && (a.vec2 = b);
                var d = {};
                if (!c) var c = 1e-6;
                d.create = function() {
                    return new Float32Array(3);
                }, d.clone = function(a) {
                    var b = new Float32Array(3);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b;
                }, d.fromValues = function(a, b, c) {
                    var d = new Float32Array(3);
                    return d[0] = a, d[1] = b, d[2] = c, d;
                }, d.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a;
                }, d.set = function(a, b, c, d) {
                    return a[0] = b, a[1] = c, a[2] = d, a;
                }, d.add = function(a, b, c) {
                    return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a;
                }, d.sub = d.subtract = function(a, b, c) {
                    return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a;
                }, d.mul = d.multiply = function(a, b, c) {
                    return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a;
                }, d.div = d.divide = function(a, b, c) {
                    return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a;
                }, d.min = function(a, b, c) {
                    return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), 
                    a;
                }, d.max = function(a, b, c) {
                    return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), 
                    a;
                }, d.scale = function(a, b, c) {
                    return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a;
                }, d.dist = d.distance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2];
                    return Math.sqrt(c * c + d * d + e * e);
                }, d.sqrDist = d.squaredDistance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2];
                    return c * c + d * d + e * e;
                }, d.len = d.length = function(a) {
                    var b = a[0], c = a[1], d = a[2];
                    return Math.sqrt(b * b + c * c + d * d);
                }, d.sqrLen = d.squaredLength = function(a) {
                    var b = a[0], c = a[1], d = a[2];
                    return b * b + c * c + d * d;
                }, d.negate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a;
                }, d.normalize = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = c * c + d * d + e * e;
                    return f > 0 && (f = 1 / Math.sqrt(f), a[0] = b[0] * f, a[1] = b[1] * f, a[2] = b[2] * f), 
                    a;
                }, d.dot = function(a, b) {
                    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                }, d.cross = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = c[0], h = c[1], i = c[2];
                    return a[0] = e * i - f * h, a[1] = f * g - d * i, a[2] = d * h - e * g, a;
                }, d.lerp = function(a, b, c, d) {
                    var e = b[0], f = b[1], g = b[2];
                    return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a[2] = g + d * (c[2] - g), 
                    a;
                }, d.transformMat4 = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2];
                    return a[0] = c[0] * d + c[4] * e + c[8] * f + c[12], a[1] = c[1] * d + c[5] * e + c[9] * f + c[13], 
                    a[2] = c[2] * d + c[6] * e + c[10] * f + c[14], a;
                }, d.transformQuat = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = c[0], h = c[1], i = c[2], j = c[3], k = j * d + h * f - i * e, l = j * e + i * d - g * f, m = j * f + g * e - h * d, n = -g * d - h * e - i * f;
                    return a[0] = k * j + n * -g + l * -i - m * -h, a[1] = l * j + n * -h + m * -g - k * -i, 
                    a[2] = m * j + n * -i + k * -h - l * -g, a;
                }, d.forEach = function() {
                    var a = new Float32Array(3);
                    return function(b, c, d, e, f, g) {
                        var h, i;
                        for (c || (c = 3), d || (d = 0), i = e ? Math.min(e * c + d, b.length) : b.length, 
                        h = d; h < i; h += c) a[0] = b[h], a[1] = b[h + 1], a[2] = b[h + 2], f(a, a, g), 
                        b[h] = a[0], b[h + 1] = a[1], b[h + 2] = a[2];
                        return b;
                    };
                }(), d.str = function(a) {
                    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
                }, "undefined" != typeof a && (a.vec3 = d);
                var e = {};
                if (!c) var c = 1e-6;
                e.create = function() {
                    return new Float32Array(4);
                }, e.clone = function(a) {
                    var b = new Float32Array(4);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
                }, e.fromValues = function(a, b, c, d) {
                    var e = new Float32Array(4);
                    return e[0] = a, e[1] = b, e[2] = c, e[3] = d, e;
                }, e.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
                }, e.set = function(a, b, c, d, e) {
                    return a[0] = b, a[1] = c, a[2] = d, a[3] = e, a;
                }, e.add = function(a, b, c) {
                    return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a[2] = b[2] + c[2], a[3] = b[3] + c[3], 
                    a;
                }, e.sub = e.subtract = function(a, b, c) {
                    return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a[2] = b[2] - c[2], a[3] = b[3] - c[3], 
                    a;
                }, e.mul = e.multiply = function(a, b, c) {
                    return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a[2] = b[2] * c[2], a[3] = b[3] * c[3], 
                    a;
                }, e.div = e.divide = function(a, b, c) {
                    return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a[2] = b[2] / c[2], a[3] = b[3] / c[3], 
                    a;
                }, e.min = function(a, b, c) {
                    return a[0] = Math.min(b[0], c[0]), a[1] = Math.min(b[1], c[1]), a[2] = Math.min(b[2], c[2]), 
                    a[3] = Math.min(b[3], c[3]), a;
                }, e.max = function(a, b, c) {
                    return a[0] = Math.max(b[0], c[0]), a[1] = Math.max(b[1], c[1]), a[2] = Math.max(b[2], c[2]), 
                    a[3] = Math.max(b[3], c[3]), a;
                }, e.scale = function(a, b, c) {
                    return a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c, a[3] = b[3] * c, a;
                }, e.dist = e.distance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2], f = b[3] - a[3];
                    return Math.sqrt(c * c + d * d + e * e + f * f);
                }, e.sqrDist = e.squaredDistance = function(a, b) {
                    var c = b[0] - a[0], d = b[1] - a[1], e = b[2] - a[2], f = b[3] - a[3];
                    return c * c + d * d + e * e + f * f;
                }, e.len = e.length = function(a) {
                    var b = a[0], c = a[1], d = a[2], e = a[3];
                    return Math.sqrt(b * b + c * c + d * d + e * e);
                }, e.sqrLen = e.squaredLength = function(a) {
                    var b = a[0], c = a[1], d = a[2], e = a[3];
                    return b * b + c * c + d * d + e * e;
                }, e.negate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = -b[3], a;
                }, e.normalize = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = c * c + d * d + e * e + f * f;
                    return g > 0 && (g = 1 / Math.sqrt(g), a[0] = b[0] * g, a[1] = b[1] * g, a[2] = b[2] * g, 
                    a[3] = b[3] * g), a;
                }, e.dot = function(a, b) {
                    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
                }, e.lerp = function(a, b, c, d) {
                    var e = b[0], f = b[1], g = b[2], h = b[3];
                    return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a[2] = g + d * (c[2] - g), 
                    a[3] = h + d * (c[3] - h), a;
                }, e.transformMat4 = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3];
                    return a[0] = c[0] * d + c[4] * e + c[8] * f + c[12] * g, a[1] = c[1] * d + c[5] * e + c[9] * f + c[13] * g, 
                    a[2] = c[2] * d + c[6] * e + c[10] * f + c[14] * g, a[3] = c[3] * d + c[7] * e + c[11] * f + c[15] * g, 
                    a;
                }, e.transformQuat = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = c[0], h = c[1], i = c[2], j = c[3], k = j * d + h * f - i * e, l = j * e + i * d - g * f, m = j * f + g * e - h * d, n = -g * d - h * e - i * f;
                    return a[0] = k * j + n * -g + l * -i - m * -h, a[1] = l * j + n * -h + m * -g - k * -i, 
                    a[2] = m * j + n * -i + k * -h - l * -g, a;
                }, e.forEach = function() {
                    var a = new Float32Array(4);
                    return function(b, c, d, e, f, g) {
                        var h, i;
                        for (c || (c = 4), d || (d = 0), i = e ? Math.min(e * c + d, b.length) : b.length, 
                        h = d; h < i; h += c) a[0] = b[h], a[1] = b[h + 1], a[2] = b[h + 2], a[3] = b[h + 3], 
                        f(a, a, g), b[h] = a[0], b[h + 1] = a[1], b[h + 2] = a[2], b[h + 3] = a[3];
                        return b;
                    };
                }(), e.str = function(a) {
                    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
                }, "undefined" != typeof a && (a.vec4 = e);
                var f = {}, g = new Float32Array([ 1, 0, 0, 1 ]);
                if (!c) var c = 1e-6;
                f.create = function() {
                    return new Float32Array(g);
                }, f.clone = function(a) {
                    var b = new Float32Array(4);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b;
                }, f.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a;
                }, f.identity = function(a) {
                    return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 1, a;
                }, f.transpose = function(a, b) {
                    if (a === b) {
                        var c = b[1];
                        a[1] = b[2], a[2] = c;
                    } else a[0] = b[0], a[1] = b[2], a[2] = b[1], a[3] = b[3];
                    return a;
                }, f.invert = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = c * f - e * d;
                    return g ? (g = 1 / g, a[0] = f * g, a[1] = -d * g, a[2] = -e * g, a[3] = c * g, 
                    a) : null;
                }, f.adjoint = function(a, b) {
                    var c = b[0];
                    return a[0] = b[3], a[1] = -b[1], a[2] = -b[2], a[3] = c, a;
                }, f.determinant = function(a) {
                    return a[0] * a[3] - a[2] * a[1];
                }, f.mul = f.multiply = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3];
                    return a[0] = d * h + e * j, a[1] = d * i + e * k, a[2] = f * h + g * j, a[3] = f * i + g * k, 
                    a;
                }, f.rotate = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = Math.sin(c), i = Math.cos(c);
                    return a[0] = d * i + e * h, a[1] = d * -h + e * i, a[2] = f * i + g * h, a[3] = f * -h + g * i, 
                    a;
                }, f.scale = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1];
                    return a[0] = d * h, a[1] = e * i, a[2] = f * h, a[3] = g * i, a;
                }, f.str = function(a) {
                    return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
                }, "undefined" != typeof a && (a.mat2 = f);
                var h = {}, i = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]);
                if (!c) var c = 1e-6;
                h.create = function() {
                    return new Float32Array(i);
                }, h.clone = function(a) {
                    var b = new Float32Array(9);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], 
                    b[6] = a[6], b[7] = a[7], b[8] = a[8], b;
                }, h.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], 
                    a[6] = b[6], a[7] = b[7], a[8] = b[8], a;
                }, h.identity = function(a) {
                    return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 1, a[5] = 0, a[6] = 0, a[7] = 0, 
                    a[8] = 1, a;
                }, h.transpose = function(a, b) {
                    if (a === b) {
                        var c = b[1], d = b[2], e = b[5];
                        a[1] = b[3], a[2] = b[6], a[3] = c, a[5] = b[7], a[6] = d, a[7] = e;
                    } else a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], 
                    a[6] = b[2], a[7] = b[5], a[8] = b[8];
                    return a;
                }, h.invert = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8], l = k * g - h * j, m = -k * f + h * i, n = j * f - g * i, o = c * l + d * m + e * n;
                    return o ? (o = 1 / o, a[0] = l * o, a[1] = (-k * d + e * j) * o, a[2] = (h * d - e * g) * o, 
                    a[3] = m * o, a[4] = (k * c - e * i) * o, a[5] = (-h * c + e * f) * o, a[6] = n * o, 
                    a[7] = (-j * c + d * i) * o, a[8] = (g * c - d * f) * o, a) : null;
                }, h.adjoint = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8];
                    return a[0] = g * k - h * j, a[1] = e * j - d * k, a[2] = d * h - e * g, a[3] = h * i - f * k, 
                    a[4] = c * k - e * i, a[5] = e * f - c * h, a[6] = f * j - g * i, a[7] = d * i - c * j, 
                    a[8] = c * g - d * f, a;
                }, h.determinant = function(a) {
                    var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], j = a[8];
                    return b * (j * f - g * i) + c * (-j * e + g * h) + d * (i * e - f * h);
                }, h.mul = h.multiply = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = b[4], i = b[5], j = b[6], k = b[7], l = b[8], m = c[0], n = c[1], o = c[2], p = c[3], q = c[4], r = c[5], s = c[6], t = c[7], u = c[8];
                    return a[0] = m * d + n * g + o * j, a[1] = m * e + n * h + o * k, a[2] = m * f + n * i + o * l, 
                    a[3] = p * d + q * g + r * j, a[4] = p * e + q * h + r * k, a[5] = p * f + q * i + r * l, 
                    a[6] = s * d + t * g + u * j, a[7] = s * e + t * h + u * k, a[8] = s * f + t * i + u * l, 
                    a;
                }, h.str = function(a) {
                    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
                }, "undefined" != typeof a && (a.mat3 = h);
                var j = {}, k = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);
                if (!c) var c = 1e-6;
                j.create = function() {
                    return new Float32Array(k);
                }, j.clone = function(a) {
                    var b = new Float32Array(16);
                    return b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], 
                    b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], 
                    b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], b;
                }, j.copy = function(a, b) {
                    return a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], 
                    a[6] = b[6], a[7] = b[7], a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], 
                    a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15], a;
                }, j.identity = function(a) {
                    return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, 
                    a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, 
                    a;
                }, j.transpose = function(a, b) {
                    if (a === b) {
                        var c = b[1], d = b[2], e = b[3], f = b[6], g = b[7], h = b[11];
                        a[1] = b[4], a[2] = b[8], a[3] = b[12], a[4] = c, a[6] = b[9], a[7] = b[13], a[8] = d, 
                        a[9] = f, a[11] = b[14], a[12] = e, a[13] = g, a[14] = h;
                    } else a[0] = b[0], a[1] = b[4], a[2] = b[8], a[3] = b[12], a[4] = b[1], a[5] = b[5], 
                    a[6] = b[9], a[7] = b[13], a[8] = b[2], a[9] = b[6], a[10] = b[10], a[11] = b[14], 
                    a[12] = b[3], a[13] = b[7], a[14] = b[11], a[15] = b[15];
                    return a;
                }, j.invert = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8], l = b[9], m = b[10], n = b[11], o = b[12], p = b[13], q = b[14], r = b[15], s = c * h - d * g, t = c * i - e * g, u = c * j - f * g, v = d * i - e * h, w = d * j - f * h, x = e * j - f * i, y = k * p - l * o, z = k * q - m * o, A = k * r - n * o, B = l * q - m * p, C = l * r - n * p, D = m * r - n * q, E = s * D - t * C + u * B + v * A - w * z + x * y;
                    return E ? (E = 1 / E, a[0] = (h * D - i * C + j * B) * E, a[1] = (e * C - d * D - f * B) * E, 
                    a[2] = (p * x - q * w + r * v) * E, a[3] = (m * w - l * x - n * v) * E, a[4] = (i * A - g * D - j * z) * E, 
                    a[5] = (c * D - e * A + f * z) * E, a[6] = (q * u - o * x - r * t) * E, a[7] = (k * x - m * u + n * t) * E, 
                    a[8] = (g * C - h * A + j * y) * E, a[9] = (d * A - c * C - f * y) * E, a[10] = (o * w - p * u + r * s) * E, 
                    a[11] = (l * u - k * w - n * s) * E, a[12] = (h * z - g * B - i * y) * E, a[13] = (c * B - d * z + e * y) * E, 
                    a[14] = (p * t - o * v - q * s) * E, a[15] = (k * v - l * t + m * s) * E, a) : null;
                }, j.adjoint = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], h = b[5], i = b[6], j = b[7], k = b[8], l = b[9], m = b[10], n = b[11], o = b[12], p = b[13], q = b[14], r = b[15];
                    return a[0] = h * (m * r - n * q) - l * (i * r - j * q) + p * (i * n - j * m), a[1] = -(d * (m * r - n * q) - l * (e * r - f * q) + p * (e * n - f * m)), 
                    a[2] = d * (i * r - j * q) - h * (e * r - f * q) + p * (e * j - f * i), a[3] = -(d * (i * n - j * m) - h * (e * n - f * m) + l * (e * j - f * i)), 
                    a[4] = -(g * (m * r - n * q) - k * (i * r - j * q) + o * (i * n - j * m)), a[5] = c * (m * r - n * q) - k * (e * r - f * q) + o * (e * n - f * m), 
                    a[6] = -(c * (i * r - j * q) - g * (e * r - f * q) + o * (e * j - f * i)), a[7] = c * (i * n - j * m) - g * (e * n - f * m) + k * (e * j - f * i), 
                    a[8] = g * (l * r - n * p) - k * (h * r - j * p) + o * (h * n - j * l), a[9] = -(c * (l * r - n * p) - k * (d * r - f * p) + o * (d * n - f * l)), 
                    a[10] = c * (h * r - j * p) - g * (d * r - f * p) + o * (d * j - f * h), a[11] = -(c * (h * n - j * l) - g * (d * n - f * l) + k * (d * j - f * h)), 
                    a[12] = -(g * (l * q - m * p) - k * (h * q - i * p) + o * (h * m - i * l)), a[13] = c * (l * q - m * p) - k * (d * q - e * p) + o * (d * m - e * l), 
                    a[14] = -(c * (h * q - i * p) - g * (d * q - e * p) + o * (d * i - e * h)), a[15] = c * (h * m - i * l) - g * (d * m - e * l) + k * (d * i - e * h), 
                    a;
                }, j.determinant = function(a) {
                    var b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], i = a[7], j = a[8], k = a[9], l = a[10], m = a[11], n = a[12], o = a[13], p = a[14], q = a[15], r = b * g - c * f, s = b * h - d * f, t = b * i - e * f, u = c * h - d * g, v = c * i - e * g, w = d * i - e * h, x = j * o - k * n, y = j * p - l * n, z = j * q - m * n, A = k * p - l * o, B = k * q - m * o, C = l * q - m * p;
                    return r * C - s * B + t * A + u * z - v * y + w * x;
                }, j.mul = j.multiply = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = b[4], i = b[5], j = b[6], k = b[7], l = b[8], m = b[9], n = b[10], o = b[11], p = b[12], q = b[13], r = b[14], s = b[15], t = c[0], u = c[1], v = c[2], w = c[3];
                    return a[0] = t * d + u * h + v * l + w * p, a[1] = t * e + u * i + v * m + w * q, 
                    a[2] = t * f + u * j + v * n + w * r, a[3] = t * g + u * k + v * o + w * s, t = c[4], 
                    u = c[5], v = c[6], w = c[7], a[4] = t * d + u * h + v * l + w * p, a[5] = t * e + u * i + v * m + w * q, 
                    a[6] = t * f + u * j + v * n + w * r, a[7] = t * g + u * k + v * o + w * s, t = c[8], 
                    u = c[9], v = c[10], w = c[11], a[8] = t * d + u * h + v * l + w * p, a[9] = t * e + u * i + v * m + w * q, 
                    a[10] = t * f + u * j + v * n + w * r, a[11] = t * g + u * k + v * o + w * s, t = c[12], 
                    u = c[13], v = c[14], w = c[15], a[12] = t * d + u * h + v * l + w * p, a[13] = t * e + u * i + v * m + w * q, 
                    a[14] = t * f + u * j + v * n + w * r, a[15] = t * g + u * k + v * o + w * s, a;
                }, j.translate = function(a, b, c) {
                    var d, e, f, g, h, i, j, k, l, m, n, o, p = c[0], q = c[1], r = c[2];
                    return b === a ? (a[12] = b[0] * p + b[4] * q + b[8] * r + b[12], a[13] = b[1] * p + b[5] * q + b[9] * r + b[13], 
                    a[14] = b[2] * p + b[6] * q + b[10] * r + b[14], a[15] = b[3] * p + b[7] * q + b[11] * r + b[15]) : (d = b[0], 
                    e = b[1], f = b[2], g = b[3], h = b[4], i = b[5], j = b[6], k = b[7], l = b[8], 
                    m = b[9], n = b[10], o = b[11], a[0] = d, a[1] = e, a[2] = f, a[3] = g, a[4] = h, 
                    a[5] = i, a[6] = j, a[7] = k, a[8] = l, a[9] = m, a[10] = n, a[11] = o, a[12] = d * p + h * q + l * r + b[12], 
                    a[13] = e * p + i * q + m * r + b[13], a[14] = f * p + j * q + n * r + b[14], a[15] = g * p + k * q + o * r + b[15]), 
                    a;
                }, j.scale = function(a, b, c) {
                    var d = c[0], e = c[1], f = c[2];
                    return a[0] = b[0] * d, a[1] = b[1] * d, a[2] = b[2] * d, a[3] = b[3] * d, a[4] = b[4] * e, 
                    a[5] = b[5] * e, a[6] = b[6] * e, a[7] = b[7] * e, a[8] = b[8] * f, a[9] = b[9] * f, 
                    a[10] = b[10] * f, a[11] = b[11] * f, a[12] = b[12], a[13] = b[13], a[14] = b[14], 
                    a[15] = b[15], a;
                }, j.rotate = function(a, b, d, e) {
                    var f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D = e[0], E = e[1], F = e[2], G = Math.sqrt(D * D + E * E + F * F);
                    return Math.abs(G) < c ? null : (G = 1 / G, D *= G, E *= G, F *= G, f = Math.sin(d), 
                    g = Math.cos(d), h = 1 - g, i = b[0], j = b[1], k = b[2], l = b[3], m = b[4], n = b[5], 
                    o = b[6], p = b[7], q = b[8], r = b[9], s = b[10], t = b[11], u = D * D * h + g, 
                    v = E * D * h + F * f, w = F * D * h - E * f, x = D * E * h - F * f, y = E * E * h + g, 
                    z = F * E * h + D * f, A = D * F * h + E * f, B = E * F * h - D * f, C = F * F * h + g, 
                    a[0] = i * u + m * v + q * w, a[1] = j * u + n * v + r * w, a[2] = k * u + o * v + s * w, 
                    a[3] = l * u + p * v + t * w, a[4] = i * x + m * y + q * z, a[5] = j * x + n * y + r * z, 
                    a[6] = k * x + o * y + s * z, a[7] = l * x + p * y + t * z, a[8] = i * A + m * B + q * C, 
                    a[9] = j * A + n * B + r * C, a[10] = k * A + o * B + s * C, a[11] = l * A + p * B + t * C, 
                    b !== a && (a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]), a);
                }, j.rotateX = function(a, b, c) {
                    var d = Math.sin(c), e = Math.cos(c), f = b[4], g = b[5], h = b[6], i = b[7], j = b[8], k = b[9], l = b[10], m = b[11];
                    return b !== a && (a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[12] = b[12], 
                    a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[4] = f * e + j * d, a[5] = g * e + k * d, 
                    a[6] = h * e + l * d, a[7] = i * e + m * d, a[8] = j * e - f * d, a[9] = k * e - g * d, 
                    a[10] = l * e - h * d, a[11] = m * e - i * d, a;
                }, j.rotateY = function(a, b, c) {
                    var d = Math.sin(c), e = Math.cos(c), f = b[0], g = b[1], h = b[2], i = b[3], j = b[8], k = b[9], l = b[10], m = b[11];
                    return b !== a && (a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[12] = b[12], 
                    a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = f * e - j * d, a[1] = g * e - k * d, 
                    a[2] = h * e - l * d, a[3] = i * e - m * d, a[8] = f * d + j * e, a[9] = g * d + k * e, 
                    a[10] = h * d + l * e, a[11] = i * d + m * e, a;
                }, j.rotateZ = function(a, b, c) {
                    var d = Math.sin(c), e = Math.cos(c), f = b[0], g = b[1], h = b[2], i = b[3], j = b[4], k = b[5], l = b[6], m = b[7];
                    return b !== a && (a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], 
                    a[13] = b[13], a[14] = b[14], a[15] = b[15]), a[0] = f * e + j * d, a[1] = g * e + k * d, 
                    a[2] = h * e + l * d, a[3] = i * e + m * d, a[4] = j * e - f * d, a[5] = k * e - g * d, 
                    a[6] = l * e - h * d, a[7] = m * e - i * d, a;
                }, j.fromRotationTranslation = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = d + d, i = e + e, j = f + f, k = d * h, l = d * i, m = d * j, n = e * i, o = e * j, p = f * j, q = g * h, r = g * i, s = g * j;
                    return a[0] = 1 - (n + p), a[1] = l + s, a[2] = m - r, a[3] = 0, a[4] = l - s, a[5] = 1 - (k + p), 
                    a[6] = o + q, a[7] = 0, a[8] = m + r, a[9] = o - q, a[10] = 1 - (k + n), a[11] = 0, 
                    a[12] = c[0], a[13] = c[1], a[14] = c[2], a[15] = 1, a;
                }, j.frustum = function(a, b, c, d, e, f, g) {
                    var h = 1 / (c - b), i = 1 / (e - d), j = 1 / (f - g);
                    return a[0] = 2 * f * h, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * f * i, 
                    a[6] = 0, a[7] = 0, a[8] = (c + b) * h, a[9] = (e + d) * i, a[10] = (g + f) * j, 
                    a[11] = -1, a[12] = 0, a[13] = 0, a[14] = g * f * 2 * j, a[15] = 0, a;
                }, j.perspective = function(a, b, c, d, e) {
                    var f = 1 / Math.tan(b / 2), g = 1 / (d - e);
                    return a[0] = f / c, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = f, a[6] = 0, 
                    a[7] = 0, a[8] = 0, a[9] = 0, a[10] = (e + d) * g, a[11] = -1, a[12] = 0, a[13] = 0, 
                    a[14] = 2 * e * d * g, a[15] = 0, a;
                }, j.ortho = function(a, b, c, d, e, f, g) {
                    var h = 1 / (b - c), i = 1 / (d - e), j = 1 / (f - g);
                    return a[0] = -2 * h, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * i, a[6] = 0, 
                    a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * j, a[11] = 0, a[12] = (b + c) * h, a[13] = (e + d) * i, 
                    a[14] = (g + f) * j, a[15] = 1, a;
                }, j.lookAt = function(a, b, d, e) {
                    var f, g, h, i, k, l, m, n, o, p, q = b[0], r = b[1], s = b[2], t = e[0], u = e[1], v = e[2], w = d[0], x = d[1], y = d[2];
                    return Math.abs(q - w) < c && Math.abs(r - x) < c && Math.abs(s - y) < c ? j.identity(a) : (m = q - w, 
                    n = r - x, o = s - y, p = 1 / Math.sqrt(m * m + n * n + o * o), m *= p, n *= p, 
                    o *= p, f = u * o - v * n, g = v * m - t * o, h = t * n - u * m, p = Math.sqrt(f * f + g * g + h * h), 
                    p ? (p = 1 / p, f *= p, g *= p, h *= p) : (f = 0, g = 0, h = 0), i = n * h - o * g, 
                    k = o * f - m * h, l = m * g - n * f, p = Math.sqrt(i * i + k * k + l * l), p ? (p = 1 / p, 
                    i *= p, k *= p, l *= p) : (i = 0, k = 0, l = 0), a[0] = f, a[1] = i, a[2] = m, a[3] = 0, 
                    a[4] = g, a[5] = k, a[6] = n, a[7] = 0, a[8] = h, a[9] = l, a[10] = o, a[11] = 0, 
                    a[12] = -(f * q + g * r + h * s), a[13] = -(i * q + k * r + l * s), a[14] = -(m * q + n * r + o * s), 
                    a[15] = 1, a);
                }, j.str = function(a) {
                    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
                }, "undefined" != typeof a && (a.mat4 = j);
                var l = {}, m = new Float32Array([ 0, 0, 0, 1 ]);
                if (!c) var c = 1e-6;
                l.create = function() {
                    return new Float32Array(m);
                }, l.clone = e.clone, l.fromValues = e.fromValues, l.copy = e.copy, l.set = e.set, 
                l.identity = function(a) {
                    return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a;
                }, l.setAxisAngle = function(a, b, c) {
                    c *= .5;
                    var d = Math.sin(c);
                    return a[0] = d * b[0], a[1] = d * b[1], a[2] = d * b[2], a[3] = Math.cos(c), a;
                }, l.add = e.add, l.mul = l.multiply = function(a, b, c) {
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3];
                    return a[0] = d * k + g * h + e * j - f * i, a[1] = e * k + g * i + f * h - d * j, 
                    a[2] = f * k + g * j + d * i - e * h, a[3] = g * k - d * h - e * i - f * j, a;
                }, l.scale = e.scale, l.rotateX = function(a, b, c) {
                    c *= .5;
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = Math.sin(c), i = Math.cos(c);
                    return a[0] = d * i + g * h, a[1] = e * i + f * h, a[2] = f * i - e * h, a[3] = g * i - d * h, 
                    a;
                }, l.rotateY = function(a, b, c) {
                    c *= .5;
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = Math.sin(c), i = Math.cos(c);
                    return a[0] = d * i - f * h, a[1] = e * i + g * h, a[2] = f * i + d * h, a[3] = g * i - e * h, 
                    a;
                }, l.rotateZ = function(a, b, c) {
                    c *= .5;
                    var d = b[0], e = b[1], f = b[2], g = b[3], h = Math.sin(c), i = Math.cos(c);
                    return a[0] = d * i + e * h, a[1] = e * i - d * h, a[2] = f * i + g * h, a[3] = g * i - f * h, 
                    a;
                }, l.calculateW = function(a, b) {
                    var c = b[0], d = b[1], e = b[2];
                    return a[0] = c, a[1] = d, a[2] = e, a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e)), 
                    a;
                }, l.dot = e.dot, l.lerp = e.lerp, l.slerp = function(a, b, c, d) {
                    var e, f, g, h, i = b[0], j = b[1], k = b[2], l = b[3], m = c[0], n = c[1], o = c[2], p = b[3], q = i * m + j * n + k * o + l * p;
                    return Math.abs(q) >= 1 ? (a !== b && (a[0] = i, a[1] = j, a[2] = k, a[3] = l), 
                    a) : (e = Math.acos(q), f = Math.sqrt(1 - q * q), Math.abs(f) < .001 ? (a[0] = .5 * i + .5 * m, 
                    a[1] = .5 * j + .5 * n, a[2] = .5 * k + .5 * o, a[3] = .5 * l + .5 * p, a) : (g = Math.sin((1 - d) * e) / f, 
                    h = Math.sin(d * e) / f, a[0] = i * g + m * h, a[1] = j * g + n * h, a[2] = k * g + o * h, 
                    a[3] = l * g + p * h, a));
                }, l.invert = function(a, b) {
                    var c = b[0], d = b[1], e = b[2], f = b[3], g = c * c + d * d + e * e + f * f, h = g ? 1 / g : 0;
                    return a[0] = -c * h, a[1] = -d * h, a[2] = -e * h, a[3] = f * h, a;
                }, l.conjugate = function(a, b) {
                    return a[0] = -b[0], a[1] = -b[1], a[2] = -b[2], a[3] = b[3], a;
                }, l.len = l.length = e.length, l.sqrLen = l.squaredLength = e.squaredLength, l.normalize = e.normalize, 
                l.str = function(a) {
                    return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
                }, "undefined" != typeof a && (a.quat = l);
            }(a.exports);
        }();
    }, {} ],
    22: [ function(a, b, c) {
        !function() {
            var a = this, d = a._, e = {}, f = Array.prototype, g = Object.prototype, h = Function.prototype, i = f.push, j = f.slice, k = f.concat, l = g.toString, m = g.hasOwnProperty, n = f.forEach, o = f.map, p = f.reduce, q = f.reduceRight, r = f.filter, s = f.every, t = f.some, u = f.indexOf, v = f.lastIndexOf, w = Array.isArray, x = Object.keys, y = h.bind, z = function(a) {
                return a instanceof z ? a : this instanceof z ? void (this._wrapped = a) : new z(a);
            };
            "undefined" != typeof c ? ("undefined" != typeof b && b.exports && (c = b.exports = z), 
            c._ = z) : a._ = z, z.VERSION = "1.4.4";
            var A = z.each = z.forEach = function(a, b, c) {
                if (null != a) if (n && a.forEach === n) a.forEach(b, c); else if (a.length === +a.length) {
                    for (var d = 0, f = a.length; d < f; d++) if (b.call(c, a[d], d, a) === e) return;
                } else for (var g in a) if (z.has(a, g) && b.call(c, a[g], g, a) === e) return;
            };
            z.map = z.collect = function(a, b, c) {
                var d = [];
                return null == a ? d : o && a.map === o ? a.map(b, c) : (A(a, function(a, e, f) {
                    d[d.length] = b.call(c, a, e, f);
                }), d);
            };
            var B = "Reduce of empty array with no initial value";
            z.reduce = z.foldl = z.inject = function(a, b, c, d) {
                var e = arguments.length > 2;
                if (null == a && (a = []), p && a.reduce === p) return d && (b = z.bind(b, d)), 
                e ? a.reduce(b, c) : a.reduce(b);
                if (A(a, function(a, f, g) {
                    e ? c = b.call(d, c, a, f, g) : (c = a, e = !0);
                }), !e) throw new TypeError(B);
                return c;
            }, z.reduceRight = z.foldr = function(a, b, c, d) {
                var e = arguments.length > 2;
                if (null == a && (a = []), q && a.reduceRight === q) return d && (b = z.bind(b, d)), 
                e ? a.reduceRight(b, c) : a.reduceRight(b);
                var f = a.length;
                if (f !== +f) {
                    var g = z.keys(a);
                    f = g.length;
                }
                if (A(a, function(h, i, j) {
                    i = g ? g[--f] : --f, e ? c = b.call(d, c, a[i], i, j) : (c = a[i], e = !0);
                }), !e) throw new TypeError(B);
                return c;
            }, z.find = z.detect = function(a, b, c) {
                var d;
                return C(a, function(a, e, f) {
                    if (b.call(c, a, e, f)) return d = a, !0;
                }), d;
            }, z.filter = z.select = function(a, b, c) {
                var d = [];
                return null == a ? d : r && a.filter === r ? a.filter(b, c) : (A(a, function(a, e, f) {
                    b.call(c, a, e, f) && (d[d.length] = a);
                }), d);
            }, z.reject = function(a, b, c) {
                return z.filter(a, function(a, d, e) {
                    return !b.call(c, a, d, e);
                }, c);
            }, z.every = z.all = function(a, b, c) {
                b || (b = z.identity);
                var d = !0;
                return null == a ? d : s && a.every === s ? a.every(b, c) : (A(a, function(a, f, g) {
                    if (!(d = d && b.call(c, a, f, g))) return e;
                }), !!d);
            };
            var C = z.some = z.any = function(a, b, c) {
                b || (b = z.identity);
                var d = !1;
                return null == a ? d : t && a.some === t ? a.some(b, c) : (A(a, function(a, f, g) {
                    if (d || (d = b.call(c, a, f, g))) return e;
                }), !!d);
            };
            z.contains = z.include = function(a, b) {
                return null != a && (u && a.indexOf === u ? a.indexOf(b) != -1 : C(a, function(a) {
                    return a === b;
                }));
            }, z.invoke = function(a, b) {
                var c = j.call(arguments, 2), d = z.isFunction(b);
                return z.map(a, function(a) {
                    return (d ? b : a[b]).apply(a, c);
                });
            }, z.pluck = function(a, b) {
                return z.map(a, function(a) {
                    return a[b];
                });
            }, z.where = function(a, b, c) {
                return z.isEmpty(b) ? c ? null : [] : z[c ? "find" : "filter"](a, function(a) {
                    for (var c in b) if (b[c] !== a[c]) return !1;
                    return !0;
                });
            }, z.findWhere = function(a, b) {
                return z.where(a, b, !0);
            }, z.max = function(a, b, c) {
                if (!b && z.isArray(a) && a[0] === +a[0] && a.length < 65535) return Math.max.apply(Math, a);
                if (!b && z.isEmpty(a)) return -(1 / 0);
                var d = {
                    computed: -(1 / 0),
                    value: -(1 / 0)
                };
                return A(a, function(a, e, f) {
                    var g = b ? b.call(c, a, e, f) : a;
                    g >= d.computed && (d = {
                        value: a,
                        computed: g
                    });
                }), d.value;
            }, z.min = function(a, b, c) {
                if (!b && z.isArray(a) && a[0] === +a[0] && a.length < 65535) return Math.min.apply(Math, a);
                if (!b && z.isEmpty(a)) return 1 / 0;
                var d = {
                    computed: 1 / 0,
                    value: 1 / 0
                };
                return A(a, function(a, e, f) {
                    var g = b ? b.call(c, a, e, f) : a;
                    g < d.computed && (d = {
                        value: a,
                        computed: g
                    });
                }), d.value;
            }, z.shuffle = function(a) {
                var b, c = 0, d = [];
                return A(a, function(a) {
                    b = z.random(c++), d[c - 1] = d[b], d[b] = a;
                }), d;
            };
            var D = function(a) {
                return z.isFunction(a) ? a : function(b) {
                    return b[a];
                };
            };
            z.sortBy = function(a, b, c) {
                var d = D(b);
                return z.pluck(z.map(a, function(a, b, e) {
                    return {
                        value: a,
                        index: b,
                        criteria: d.call(c, a, b, e)
                    };
                }).sort(function(a, b) {
                    var c = a.criteria, d = b.criteria;
                    if (c !== d) {
                        if (c > d || void 0 === c) return 1;
                        if (c < d || void 0 === d) return -1;
                    }
                    return a.index < b.index ? -1 : 1;
                }), "value");
            };
            var E = function(a, b, c, d) {
                var e = {}, f = D(b || z.identity);
                return A(a, function(b, g) {
                    var h = f.call(c, b, g, a);
                    d(e, h, b);
                }), e;
            };
            z.groupBy = function(a, b, c) {
                return E(a, b, c, function(a, b, c) {
                    (z.has(a, b) ? a[b] : a[b] = []).push(c);
                });
            }, z.countBy = function(a, b, c) {
                return E(a, b, c, function(a, b) {
                    z.has(a, b) || (a[b] = 0), a[b]++;
                });
            }, z.sortedIndex = function(a, b, c, d) {
                c = null == c ? z.identity : D(c);
                for (var e = c.call(d, b), f = 0, g = a.length; f < g; ) {
                    var h = f + g >>> 1;
                    c.call(d, a[h]) < e ? f = h + 1 : g = h;
                }
                return f;
            }, z.toArray = function(a) {
                return a ? z.isArray(a) ? j.call(a) : a.length === +a.length ? z.map(a, z.identity) : z.values(a) : [];
            }, z.size = function(a) {
                return null == a ? 0 : a.length === +a.length ? a.length : z.keys(a).length;
            }, z.first = z.head = z.take = function(a, b, c) {
                if (null != a) return null == b || c ? a[0] : j.call(a, 0, b);
            }, z.initial = function(a, b, c) {
                return j.call(a, 0, a.length - (null == b || c ? 1 : b));
            }, z.last = function(a, b, c) {
                if (null != a) return null == b || c ? a[a.length - 1] : j.call(a, Math.max(a.length - b, 0));
            }, z.rest = z.tail = z.drop = function(a, b, c) {
                return j.call(a, null == b || c ? 1 : b);
            }, z.compact = function(a) {
                return z.filter(a, z.identity);
            };
            var F = function(a, b, c) {
                return A(a, function(a) {
                    z.isArray(a) ? b ? i.apply(c, a) : F(a, b, c) : c.push(a);
                }), c;
            };
            z.flatten = function(a, b) {
                return F(a, b, []);
            }, z.without = function(a) {
                return z.difference(a, j.call(arguments, 1));
            }, z.uniq = z.unique = function(a, b, c, d) {
                z.isFunction(b) && (d = c, c = b, b = !1);
                var e = c ? z.map(a, c, d) : a, f = [], g = [];
                return A(e, function(c, d) {
                    (b ? d && g[g.length - 1] === c : z.contains(g, c)) || (g.push(c), f.push(a[d]));
                }), f;
            }, z.union = function() {
                return z.uniq(k.apply(f, arguments));
            }, z.intersection = function(a) {
                var b = j.call(arguments, 1);
                return z.filter(z.uniq(a), function(a) {
                    return z.every(b, function(b) {
                        return z.indexOf(b, a) >= 0;
                    });
                });
            }, z.difference = function(a) {
                var b = k.apply(f, j.call(arguments, 1));
                return z.filter(a, function(a) {
                    return !z.contains(b, a);
                });
            }, z.zip = function() {
                for (var a = j.call(arguments), b = z.max(z.pluck(a, "length")), c = new Array(b), d = 0; d < b; d++) c[d] = z.pluck(a, "" + d);
                return c;
            }, z.object = function(a, b) {
                if (null == a) return {};
                for (var c = {}, d = 0, e = a.length; d < e; d++) b ? c[a[d]] = b[d] : c[a[d][0]] = a[d][1];
                return c;
            }, z.indexOf = function(a, b, c) {
                if (null == a) return -1;
                var d = 0, e = a.length;
                if (c) {
                    if ("number" != typeof c) return d = z.sortedIndex(a, b), a[d] === b ? d : -1;
                    d = c < 0 ? Math.max(0, e + c) : c;
                }
                if (u && a.indexOf === u) return a.indexOf(b, c);
                for (;d < e; d++) if (a[d] === b) return d;
                return -1;
            }, z.lastIndexOf = function(a, b, c) {
                if (null == a) return -1;
                var d = null != c;
                if (v && a.lastIndexOf === v) return d ? a.lastIndexOf(b, c) : a.lastIndexOf(b);
                for (var e = d ? c : a.length; e--; ) if (a[e] === b) return e;
                return -1;
            }, z.range = function(a, b, c) {
                arguments.length <= 1 && (b = a || 0, a = 0), c = arguments[2] || 1;
                for (var d = Math.max(Math.ceil((b - a) / c), 0), e = 0, f = new Array(d); e < d; ) f[e++] = a, 
                a += c;
                return f;
            }, z.bind = function(a, b) {
                if (a.bind === y && y) return y.apply(a, j.call(arguments, 1));
                var c = j.call(arguments, 2);
                return function() {
                    return a.apply(b, c.concat(j.call(arguments)));
                };
            }, z.partial = function(a) {
                var b = j.call(arguments, 1);
                return function() {
                    return a.apply(this, b.concat(j.call(arguments)));
                };
            }, z.bindAll = function(a) {
                var b = j.call(arguments, 1);
                return 0 === b.length && (b = z.functions(a)), A(b, function(b) {
                    a[b] = z.bind(a[b], a);
                }), a;
            }, z.memoize = function(a, b) {
                var c = {};
                return b || (b = z.identity), function() {
                    var d = b.apply(this, arguments);
                    return z.has(c, d) ? c[d] : c[d] = a.apply(this, arguments);
                };
            }, z.delay = function(a, b) {
                var c = j.call(arguments, 2);
                return setTimeout(function() {
                    return a.apply(null, c);
                }, b);
            }, z.defer = function(a) {
                return z.delay.apply(z, [ a, 1 ].concat(j.call(arguments, 1)));
            }, z.throttle = function(a, b) {
                var c, d, e, f, g = 0, h = function() {
                    g = new Date(), e = null, f = a.apply(c, d);
                };
                return function() {
                    var i = new Date(), j = b - (i - g);
                    return c = this, d = arguments, j <= 0 ? (clearTimeout(e), e = null, g = i, f = a.apply(c, d)) : e || (e = setTimeout(h, j)), 
                    f;
                };
            }, z.debounce = function(a, b, c) {
                var d, e;
                return function() {
                    var f = this, g = arguments, h = function() {
                        d = null, c || (e = a.apply(f, g));
                    }, i = c && !d;
                    return clearTimeout(d), d = setTimeout(h, b), i && (e = a.apply(f, g)), e;
                };
            }, z.once = function(a) {
                var b, c = !1;
                return function() {
                    return c ? b : (c = !0, b = a.apply(this, arguments), a = null, b);
                };
            }, z.wrap = function(a, b) {
                return function() {
                    var c = [ a ];
                    return i.apply(c, arguments), b.apply(this, c);
                };
            }, z.compose = function() {
                var a = arguments;
                return function() {
                    for (var b = arguments, c = a.length - 1; c >= 0; c--) b = [ a[c].apply(this, b) ];
                    return b[0];
                };
            }, z.after = function(a, b) {
                return a <= 0 ? b() : function() {
                    if (--a < 1) return b.apply(this, arguments);
                };
            }, z.keys = x || function(a) {
                if (a !== Object(a)) throw new TypeError("Invalid object");
                var b = [];
                for (var c in a) z.has(a, c) && (b[b.length] = c);
                return b;
            }, z.values = function(a) {
                var b = [];
                for (var c in a) z.has(a, c) && b.push(a[c]);
                return b;
            }, z.pairs = function(a) {
                var b = [];
                for (var c in a) z.has(a, c) && b.push([ c, a[c] ]);
                return b;
            }, z.invert = function(a) {
                var b = {};
                for (var c in a) z.has(a, c) && (b[a[c]] = c);
                return b;
            }, z.functions = z.methods = function(a) {
                var b = [];
                for (var c in a) z.isFunction(a[c]) && b.push(c);
                return b.sort();
            }, z.extend = function(a) {
                return A(j.call(arguments, 1), function(b) {
                    if (b) for (var c in b) a[c] = b[c];
                }), a;
            }, z.pick = function(a) {
                var b = {}, c = k.apply(f, j.call(arguments, 1));
                return A(c, function(c) {
                    c in a && (b[c] = a[c]);
                }), b;
            }, z.omit = function(a) {
                var b = {}, c = k.apply(f, j.call(arguments, 1));
                for (var d in a) z.contains(c, d) || (b[d] = a[d]);
                return b;
            }, z.defaults = function(a) {
                return A(j.call(arguments, 1), function(b) {
                    if (b) for (var c in b) null == a[c] && (a[c] = b[c]);
                }), a;
            }, z.clone = function(a) {
                return z.isObject(a) ? z.isArray(a) ? a.slice() : z.extend({}, a) : a;
            }, z.tap = function(a, b) {
                return b(a), a;
            };
            var G = function(a, b, c, d) {
                if (a === b) return 0 !== a || 1 / a == 1 / b;
                if (null == a || null == b) return a === b;
                a instanceof z && (a = a._wrapped), b instanceof z && (b = b._wrapped);
                var e = l.call(a);
                if (e != l.call(b)) return !1;
                switch (e) {
                  case "[object String]":
                    return a == String(b);

                  case "[object Number]":
                    return a != +a ? b != +b : 0 == a ? 1 / a == 1 / b : a == +b;

                  case "[object Date]":
                  case "[object Boolean]":
                    return +a == +b;

                  case "[object RegExp]":
                    return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
                }
                if ("object" != typeof a || "object" != typeof b) return !1;
                for (var f = c.length; f--; ) if (c[f] == a) return d[f] == b;
                c.push(a), d.push(b);
                var g = 0, h = !0;
                if ("[object Array]" == e) {
                    if (g = a.length, h = g == b.length) for (;g-- && (h = G(a[g], b[g], c, d)); ) ;
                } else {
                    var i = a.constructor, j = b.constructor;
                    if (i !== j && !(z.isFunction(i) && i instanceof i && z.isFunction(j) && j instanceof j)) return !1;
                    for (var k in a) if (z.has(a, k) && (g++, !(h = z.has(b, k) && G(a[k], b[k], c, d)))) break;
                    if (h) {
                        for (k in b) if (z.has(b, k) && !g--) break;
                        h = !g;
                    }
                }
                return c.pop(), d.pop(), h;
            };
            z.isEqual = function(a, b) {
                return G(a, b, [], []);
            }, z.isEmpty = function(a) {
                if (null == a) return !0;
                if (z.isArray(a) || z.isString(a)) return 0 === a.length;
                for (var b in a) if (z.has(a, b)) return !1;
                return !0;
            }, z.isElement = function(a) {
                return !(!a || 1 !== a.nodeType);
            }, z.isArray = w || function(a) {
                return "[object Array]" == l.call(a);
            }, z.isObject = function(a) {
                return a === Object(a);
            }, A([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(a) {
                z["is" + a] = function(b) {
                    return l.call(b) == "[object " + a + "]";
                };
            }), z.isArguments(arguments) || (z.isArguments = function(a) {
                return !(!a || !z.has(a, "callee"));
            }), "function" != typeof /./ && (z.isFunction = function(a) {
                return "function" == typeof a;
            }), z.isFinite = function(a) {
                return isFinite(a) && !isNaN(parseFloat(a));
            }, z.isNaN = function(a) {
                return z.isNumber(a) && a != +a;
            }, z.isBoolean = function(a) {
                return a === !0 || a === !1 || "[object Boolean]" == l.call(a);
            }, z.isNull = function(a) {
                return null === a;
            }, z.isUndefined = function(a) {
                return void 0 === a;
            }, z.has = function(a, b) {
                return m.call(a, b);
            }, z.noConflict = function() {
                return a._ = d, this;
            }, z.identity = function(a) {
                return a;
            }, z.times = function(a, b, c) {
                for (var d = Array(a), e = 0; e < a; e++) d[e] = b.call(c, e);
                return d;
            }, z.random = function(a, b) {
                return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
            };
            var H = {
                escape: {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#x27;",
                    "/": "&#x2F;"
                }
            };
            H.unescape = z.invert(H.escape);
            var I = {
                escape: new RegExp("[" + z.keys(H.escape).join("") + "]", "g"),
                unescape: new RegExp("(" + z.keys(H.unescape).join("|") + ")", "g")
            };
            z.each([ "escape", "unescape" ], function(a) {
                z[a] = function(b) {
                    return null == b ? "" : ("" + b).replace(I[a], function(b) {
                        return H[a][b];
                    });
                };
            }), z.result = function(a, b) {
                if (null == a) return null;
                var c = a[b];
                return z.isFunction(c) ? c.call(a) : c;
            }, z.mixin = function(a) {
                A(z.functions(a), function(b) {
                    var c = z[b] = a[b];
                    z.prototype[b] = function() {
                        var a = [ this._wrapped ];
                        return i.apply(a, arguments), N.call(this, c.apply(z, a));
                    };
                });
            };
            var J = 0;
            z.uniqueId = function(a) {
                var b = ++J + "";
                return a ? a + b : b;
            }, z.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };
            var K = /(.)^/, L = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                "\t": "t",
                "\u2028": "u2028",
                "\u2029": "u2029"
            }, M = /\\|'|\r|\n|\t|\u2028|\u2029/g;
            z.template = function(a, b, c) {
                var d;
                c = z.defaults({}, c, z.templateSettings);
                var e = new RegExp([ (c.escape || K).source, (c.interpolate || K).source, (c.evaluate || K).source ].join("|") + "|$", "g"), f = 0, g = "__p+='";
                a.replace(e, function(b, c, d, e, h) {
                    return g += a.slice(f, h).replace(M, function(a) {
                        return "\\" + L[a];
                    }), c && (g += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'"), d && (g += "'+\n((__t=(" + d + "))==null?'':__t)+\n'"), 
                    e && (g += "';\n" + e + "\n__p+='"), f = h + b.length, b;
                }), g += "';\n", c.variable || (g = "with(obj||{}){\n" + g + "}\n"), g = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + g + "return __p;\n";
                try {
                    d = new Function(c.variable || "obj", "_", g);
                } catch (a) {
                    throw a.source = g, a;
                }
                if (b) return d(b, z);
                var h = function(a) {
                    return d.call(this, a, z);
                };
                return h.source = "function(" + (c.variable || "obj") + "){\n" + g + "}", h;
            }, z.chain = function(a) {
                return z(a).chain();
            };
            var N = function(a) {
                return this._chain ? z(a).chain() : a;
            };
            z.mixin(z), A([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(a) {
                var b = f[a];
                z.prototype[a] = function() {
                    var c = this._wrapped;
                    return b.apply(c, arguments), "shift" != a && "splice" != a || 0 !== c.length || delete c[0], 
                    N.call(this, c);
                };
            }), A([ "concat", "join", "slice" ], function(a) {
                var b = f[a];
                z.prototype[a] = function() {
                    return N.call(this, b.apply(this._wrapped, arguments));
                };
            }), z.extend(z.prototype, {
                chain: function() {
                    return this._chain = !0, this;
                },
                value: function() {
                    return this._wrapped;
                }
            });
        }.call(this);
    }, {} ],
    23: [ function(a, b, c) {
        "undefined" != typeof window && "function" != typeof window.requestAnimationFrame && (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
            setTimeout(a, 1e3 / 60);
        }), Leap = a("../lib/index");
    }, {
        "../lib/index": 9
    } ]
}, {}, [ 23 ]), function() {
    var a;
    a = function() {
        var a;
        return a = [], a.remove = function() {
            for (var a, b, c = arguments, d = c.length; d && this.length; ) for (a = c[--d]; (b = this.indexOf(a)) !== -1; ) this.splice(b, 1);
            return this;
        }, this.on("deviceDisconnected", function() {
            var b, c, d, e;
            for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.emit("handLost", this.lastConnectionFrame.hand(b)));
            return e;
        }), {
            frame: function(b) {
                var c, d, e, f, g;
                d = b.hands.map(function(a) {
                    return a.id;
                });
                for (var h = 0, i = a.length; h < i; h++) c = a[h], d.indexOf(c) == -1 && (a.remove(c), 
                this.emit("handLost", this.frame(1).hand(c)), h--, i--);
                for (g = [], e = 0, f = d.length; e < f; e++) c = d[e], a.indexOf(c) === -1 ? (a.push(c), 
                g.push(this.emit("handFound", b.hand(c)))) : g.push(void 0);
                return g;
            }
        };
    }, "undefined" != typeof Leap && Leap.Controller ? Leap.Controller.plugin("handEntry", a) : module.exports.handEntry = a;
}.call(this), function() {
    var a;
    a = function() {
        var a;
        return a = {}, {
            hand: {
                data: function(b, c) {
                    var d, e, f;
                    if (a[e = this.id] || (a[e] = []), c) return a[this.id][b] = c;
                    if ("[object String]" === toString.call(b)) return a[this.id][b];
                    f = [];
                    for (d in b) c = b[d], void 0 === c ? f.push(delete a[this.id][d]) : f.push(a[this.id][d] = c);
                    return f;
                },
                hold: function(a) {
                    return a ? this.data({
                        holding: a
                    }) : this.hold(this.hovering());
                },
                holding: function() {
                    return this.data("holding");
                },
                release: function() {
                    var a;
                    return a = this.data("holding"), this.data({
                        holding: void 0
                    }), a;
                },
                hoverFn: function(a) {
                    return this.data({
                        getHover: a
                    });
                },
                hovering: function() {
                    var a;
                    if (a = this.data("getHover")) return this._hovering || (this._hovering = a.call(this));
                }
            }
        };
    }, "undefined" != typeof Leap && Leap.Controller ? Leap.Controller.plugin("handHold", a) : module.exports.handHold = a;
}.call(this), function() {
    var a;
    a = function(a) {
        var b, c, d, e;
        return null == a && (a = {}), a.positioning || (a.positioning = "absolute"), a.scale || (a.scale = 1), 
        a.scaleX || (a.scaleX = 1), a.scaleY || (a.scaleY = 1), a.scaleZ || (a.scaleZ = 1), 
        a.verticalOffset || (a.verticalOffset = 0), b = 6, c = -100, e = {
            absolute: function(d) {
                return [ window.innerWidth / 2 + d[0] * b * a.scale * a.scaleX, window.innerHeight + c + a.verticalOffset - d[1] * b * a.scale * a.scaleY, d[2] * b * a.scale * a.scaleZ ];
            }
        }, d = function(b, c) {
            var d;
            return null == c && (c = !1), d = "function" == typeof a.positioning ? a.positioning.call(this, b) : e[a.positioning].call(this, b), 
            c && (this.screenPositionVec3 = d), d;
        }, {
            hand: {
                screenPosition: function(a) {
                    return d.call(this, a || this.stabilizedPalmPosition, !a);
                }
            },
            pointable: {
                screenPosition: function(a) {
                    return d.call(this, a || this.stabilizedTipPosition, !a);
                }
            }
        };
    }, "undefined" != typeof Leap && Leap.Controller ? Leap.Controller.plugin("screenPosition", a) : module.exports.screenPosition = a;
}.call(this), THREE.OBJLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
}, THREE.OBJLoader.prototype = {
    constructor: THREE.OBJLoader,
    load: function(a, b, c, d) {
        var e = this, f = new THREE.XHRLoader(e.manager);
        f.setCrossOrigin(this.crossOrigin), f.load(a, function(a) {
            b(e.parse(a));
        });
    },
    parse: function(a) {
        function b(a, b, c) {
            return new THREE.Vector3(a, b, c);
        }
        function c(a, b) {
            return new THREE.Vector2(a, b);
        }
        function d(a, b, c, d) {
            return new THREE.Face3(a, b, c, d);
        }
        function e(a, b, c, e) {
            void 0 === e ? h.faces.push(d(parseInt(a) - (l + 1), parseInt(b) - (l + 1), parseInt(c) - (l + 1))) : h.faces.push(d(parseInt(a) - (l + 1), parseInt(b) - (l + 1), parseInt(c) - (l + 1), [ n[parseInt(e[0]) - 1].clone(), n[parseInt(e[1]) - 1].clone(), n[parseInt(e[2]) - 1].clone() ]));
        }
        function f(a, b, c) {
            h.faceVertexUvs[0].push([ o[parseInt(a) - 1].clone(), o[parseInt(b) - 1].clone(), o[parseInt(c) - 1].clone() ]);
        }
        function g(a, b, c) {
            void 0 === a[3] ? (e(a[0], a[1], a[2], c), void 0 !== b && b.length > 0 && f(b[0], b[1], b[2])) : (void 0 !== c && c.length > 0 ? (e(a[0], a[1], a[3], [ c[0], c[1], c[3] ]), 
            e(a[1], a[2], a[3], [ c[1], c[2], c[3] ])) : (e(a[0], a[1], a[3]), e(a[1], a[2], a[3])), 
            void 0 !== b && b.length > 0 && (f(b[0], b[1], b[3]), f(b[1], b[2], b[3])));
        }
        var h, i, j, k = new THREE.Object3D(), l = 0;
        /^o /gm.test(a) === !1 && (h = new THREE.Geometry(), i = new THREE.MeshLambertMaterial(), 
        j = new THREE.Mesh(h, i), k.add(j));
        for (var m = 0, n = [], o = [], p = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, q = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, r = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, s = /f( +\d+)( +\d+)( +\d+)( +\d+)?/, t = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/, u = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/, v = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/, w = a.split("\n"), x = 0; x < w.length; x++) {
            var y = w[x];
            y = y.trim();
            var z;
            0 !== y.length && "#" !== y.charAt(0) && (null !== (z = p.exec(y)) ? h.vertices.push(b(parseFloat(z[1]), parseFloat(z[2]), parseFloat(z[3]))) : null !== (z = q.exec(y)) ? n.push(b(parseFloat(z[1]), parseFloat(z[2]), parseFloat(z[3]))) : null !== (z = r.exec(y)) ? o.push(c(parseFloat(z[1]), parseFloat(z[2]))) : null !== (z = s.exec(y)) ? g([ z[1], z[2], z[3], z[4] ]) : null !== (z = t.exec(y)) ? g([ z[2], z[5], z[8], z[11] ], [ z[3], z[6], z[9], z[12] ]) : null !== (z = u.exec(y)) ? g([ z[2], z[6], z[10], z[14] ], [ z[3], z[7], z[11], z[15] ], [ z[4], z[8], z[12], z[16] ]) : null !== (z = v.exec(y)) ? g([ z[2], z[5], z[8], z[11] ], [], [ z[3], z[6], z[9], z[12] ]) : /^o /.test(y) ? (void 0 !== h && (l += h.vertices.length), 
            h = new THREE.Geometry(), i = new THREE.MeshLambertMaterial(), j = new THREE.Mesh(h, i), 
            j.name = y.substring(2).trim(), k.add(j), m = 0) : /^g /.test(y) || (/^usemtl /.test(y) ? i.name = y.substring(7).trim() : /^mtllib /.test(y) || /^s /.test(y)));
        }
        for (var x = 0, A = k.children.length; x < A; x++) {
            var h = k.children[x].geometry;
            h.computeCentroids(), h.computeFaceNormals(), h.computeBoundingSphere();
        }
        return k;
    }
}, particleVertexShader = [ "attribute vec3  customColor;", "attribute float customOpacity;", "attribute float customSize;", "attribute float customAngle;", "attribute float customVisible;", "varying vec4  vColor;", "varying float vAngle;", "void main()", "{", "if ( customVisible > 0.5 )", "vColor = vec4( customColor, customOpacity );", "else", "vColor = vec4(0.0, 0.0, 0.0, 0.0);", "vAngle = customAngle;", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "gl_PointSize = customSize * ( 300.0 / length( mvPosition.xyz ) );", "gl_Position = projectionMatrix * mvPosition;", "}" ].join("\n"), 
particleFragmentShader = [ "uniform sampler2D texture;", "varying vec4 vColor;", "varying float vAngle;", "void main()", "{", "gl_FragColor = vColor;", "float c = cos(vAngle);", "float s = sin(vAngle);", "vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,", "c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);", "vec4 rotatedTexture = texture2D( texture,  rotatedUV );", "gl_FragColor = gl_FragColor * rotatedTexture;", "}" ].join("\n"), 
ParticleTween.prototype.lerp = function(a) {
    for (var b = 0, c = this.times.length; b < c && a > this.times[b]; ) b++;
    if (0 == b) return this.values[0];
    if (b == c) return this.values[c - 1];
    var d = (a - this.times[b - 1]) / (this.times[b] - this.times[b - 1]);
    return this.values[0] instanceof THREE.Vector3 ? this.values[b - 1].clone().lerp(this.values[b], d) : this.values[b - 1] + d * (this.values[b] - this.values[b - 1]);
}, Particle.prototype.update = function(a) {
    if (this.position.add(this.velocity.clone().multiplyScalar(a)), this.velocity.add(this.acceleration.clone().multiplyScalar(a)), 
    this.angle += .01745329251 * this.angleVelocity * a, this.angleVelocity += .01745329251 * this.angleAcceleration * a, 
    this.age += a, this.sizeTween.times.length > 0 && (this.size = this.sizeTween.lerp(this.age)), 
    this.colorTween.times.length > 0) {
        var b = this.colorTween.lerp(this.age);
        this.color = new THREE.Color().setHSL(b.x, b.y, b.z);
    }
    this.opacityTween.times.length > 0 && (this.opacity = this.opacityTween.lerp(this.age));
};

var Type = Object.freeze({
    CUBE: 1,
    SPHERE: 2
});

ParticleEngine.prototype.setValues = function(a) {
    if (void 0 !== a) {
        this.sizeTween = new ParticleTween(), this.colorTween = new ParticleTween(), this.opacityTween = new ParticleTween();
        for (var b in a) this[b] = a[b];
        Particle.prototype.sizeTween = this.sizeTween, Particle.prototype.colorTween = this.colorTween, 
        Particle.prototype.opacityTween = this.opacityTween, this.particleArray = [], this.emitterAge = 0, 
        this.emitterAlive = !0, this.particleCount = this.particlesPerSecond * Math.min(this.particleDeathAge, this.emitterDeathAge), 
        this.particleGeometry = new THREE.Geometry(), this.particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                texture: {
                    type: "t",
                    value: this.particleTexture
                }
            },
            attributes: {
                customVisible: {
                    type: "f",
                    value: []
                },
                customAngle: {
                    type: "f",
                    value: []
                },
                customSize: {
                    type: "f",
                    value: []
                },
                customColor: {
                    type: "c",
                    value: []
                },
                customOpacity: {
                    type: "f",
                    value: []
                }
            },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: !0,
            alphaTest: .5,
            blending: THREE.NormalBlending,
            depthTest: !0
        }), this.particleMesh = new THREE.PointCloud();
    }
}, ParticleEngine.prototype.randomValue = function(a, b) {
    return a + b * (Math.random() - .5);
}, ParticleEngine.prototype.randomVector3 = function(a, b) {
    var c = new THREE.Vector3(Math.random() - .5, Math.random() - .5, Math.random() - .5);
    return new THREE.Vector3().addVectors(a, new THREE.Vector3().multiplyVectors(b, c));
}, ParticleEngine.prototype.createParticle = function() {
    var a = new Particle();
    if (this.positionStyle == Type.CUBE && (a.position = this.randomVector3(this.positionBase, this.positionSpread)), 
    this.positionStyle == Type.SPHERE) {
        var b = 2 * Math.random() - 1, c = 6.2832 * Math.random(), d = Math.sqrt(1 - b * b), e = new THREE.Vector3(d * Math.cos(c), d * Math.sin(c), b);
        a.position = new THREE.Vector3().addVectors(this.positionBase, e.multiplyScalar(this.positionRadius));
    }
    if (this.velocityStyle == Type.CUBE && (a.velocity = this.randomVector3(this.velocityBase, this.velocitySpread)), 
    this.velocityStyle == Type.SPHERE) {
        var f = new THREE.Vector3().subVectors(a.position, this.positionBase), g = this.randomValue(this.speedBase, this.speedSpread);
        a.velocity = f.normalize().multiplyScalar(g);
    }
    a.acceleration = this.randomVector3(this.accelerationBase, this.accelerationSpread), 
    a.angle = this.randomValue(this.angleBase, this.angleSpread), a.angleVelocity = this.randomValue(this.angleVelocityBase, this.angleVelocitySpread), 
    a.angleAcceleration = this.randomValue(this.angleAccelerationBase, this.angleAccelerationSpread), 
    a.size = this.randomValue(this.sizeBase, this.sizeSpread);
    var h = this.randomVector3(this.colorBase, this.colorSpread);
    return a.color = new THREE.Color().setHSL(h.x, h.y, h.z), a.opacity = this.randomValue(this.opacityBase, this.opacitySpread), 
    a.age = 0, a.alive = 0, a;
}, ParticleEngine.prototype.initialize = function() {
    for (var a = 0; a < this.particleCount; a++) this.particleArray[a] = this.createParticle(), 
    this.particleGeometry.vertices[a] = this.particleArray[a].position, this.particleMaterial.attributes.customVisible.value[a] = this.particleArray[a].alive, 
    this.particleMaterial.attributes.customColor.value[a] = this.particleArray[a].color, 
    this.particleMaterial.attributes.customOpacity.value[a] = this.particleArray[a].opacity, 
    this.particleMaterial.attributes.customSize.value[a] = this.particleArray[a].size, 
    this.particleMaterial.attributes.customAngle.value[a] = this.particleArray[a].angle;
    this.particleMaterial.blending = this.blendStyle, this.blendStyle != THREE.NormalBlending && (this.particleMaterial.depthTest = !1), 
    this.particleMesh = new THREE.PointCloud(this.particleGeometry, this.particleMaterial), 
    this.particleMesh.dynamic = !0, this.particleMesh.sortParticles = !0, app.add(this.particleMesh, this);
}, ParticleEngine.prototype.update = function(a) {
    for (var b = [], c = 0; c < this.particleCount; c++) this.particleArray[c].alive && (this.particleArray[c].update(a), 
    this.particleArray[c].age > this.particleDeathAge && (this.particleArray[c].alive = 0, 
    b.push(c)), this.particleMaterial.attributes.customVisible.value[c] = this.particleArray[c].alive, 
    this.particleMaterial.attributes.customColor.value[c] = this.particleArray[c].color, 
    this.particleMaterial.attributes.customOpacity.value[c] = this.particleArray[c].opacity, 
    this.particleMaterial.attributes.customSize.value[c] = this.particleArray[c].size, 
    this.particleMaterial.attributes.customAngle.value[c] = this.particleArray[c].angle);
    if (this.emitterAlive) {
        if (this.emitterAge < this.particleDeathAge) {
            var d = Math.round(this.particlesPerSecond * (this.emitterAge + 0)), e = Math.round(this.particlesPerSecond * (this.emitterAge + a));
            e > this.particleCount && (e = this.particleCount);
            for (var c = d; c < e; c++) this.particleArray[c].alive = 1;
        }
        for (var f = 0; f < b.length; f++) {
            var c = b[f];
            this.particleArray[c] = this.createParticle(), this.particleArray[c].alive = 1, 
            this.particleGeometry.vertices[c] = this.particleArray[c].position;
        }
        this.emitterAge += a, this.repeat || this.emitterAge > this.emitterDeathAge && (this.emitterAlive = !1);
    }
}, ParticleEngine.prototype.destroy = function() {
    app.remove(this.particleMesh);
};

var Type = Object.freeze({
    CUBE: 1,
    SPHERE: 2
});

ParticleEngineModels = {
    fountain: {
        positionStyle: Type.CUBE,
        positionBase: new THREE.Vector3(0, 5, 0),
        positionSpread: new THREE.Vector3(10, 0, 10),
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(0, 160, 0),
        velocitySpread: new THREE.Vector3(100, 20, 100),
        accelerationBase: new THREE.Vector3(0, -100, 0),
        angleBase: 0,
        angleSpread: 180,
        angleVelocityBase: 0,
        angleVelocitySpread: 1440,
        sizeTween: new ParticleTween([ 0, 1 ], [ 1, 20 ]),
        opacityTween: new ParticleTween([ 2, 3 ], [ 1, 0 ]),
        colorTween: new ParticleTween([ .5, 2 ], [ new THREE.Vector3(0, 1, .5), new THREE.Vector3(.8, 1, .5) ]),
        particlesPerSecond: 200,
        particleDeathAge: 3,
        emitterDeathAge: 60
    },
    fireball: {
        positionStyle: Type.SPHERE,
        positionBase: new THREE.Vector3(0, 50, 0),
        positionRadius: 2,
        velocityStyle: Type.SPHERE,
        speedBase: 40,
        speedSpread: 8,
        particleTexture: THREE.ImageUtils.loadTexture("img/smokeparticle.png"),
        sizeTween: new ParticleTween([ 0, .1 ], [ 1, 150 ]),
        opacityTween: new ParticleTween([ .7, 1 ], [ 1, 0 ]),
        colorBase: new THREE.Vector3(.02, 1, .4),
        blendStyle: THREE.AdditiveBlending,
        particlesPerSecond: 60,
        particleDeathAge: 1.5,
        emitterDeathAge: 60
    },
    smoke: {
        positionStyle: Type.CUBE,
        positionBase: new THREE.Vector3(0, 0, 0),
        positionSpread: new THREE.Vector3(10, 0, 10),
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(0, 150, 0),
        velocitySpread: new THREE.Vector3(80, 50, 80),
        accelerationBase: new THREE.Vector3(0, -10, 0),
        particleTexture: THREE.ImageUtils.loadTexture("img/smokeparticle.png"),
        angleBase: 0,
        angleSpread: 720,
        angleVelocityBase: 0,
        angleVelocitySpread: 720,
        sizeTween: new ParticleTween([ 0, 1 ], [ 32, 128 ]),
        opacityTween: new ParticleTween([ .8, 2 ], [ .5, 0 ]),
        colorTween: new ParticleTween([ .4, 1 ], [ new THREE.Vector3(0, 0, .2), new THREE.Vector3(0, 0, .5) ]),
        particlesPerSecond: 200,
        particleDeathAge: 2,
        emitterDeathAge: 60
    },
    clouds: {
        positionStyle: Type.CUBE,
        positionBase: new THREE.Vector3(-100, 100, 0),
        positionSpread: new THREE.Vector3(0, 50, 60),
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(40, 0, 0),
        velocitySpread: new THREE.Vector3(20, 0, 0),
        particleTexture: THREE.ImageUtils.loadTexture("img/smokeparticle.png"),
        sizeBase: 80,
        sizeSpread: 100,
        colorBase: new THREE.Vector3(0, 0, 1),
        opacityTween: new ParticleTween([ 0, 1, 4, 5 ], [ 0, 1, 1, 0 ]),
        particlesPerSecond: 50,
        particleDeathAge: 10,
        emitterDeathAge: 60
    },
    snow: {
        positionStyle: Type.CUBE,
        positionBase: new THREE.Vector3(0, 200, 0),
        positionSpread: new THREE.Vector3(500, 0, 500),
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(0, -60, 0),
        velocitySpread: new THREE.Vector3(50, 20, 50),
        accelerationBase: new THREE.Vector3(0, -10, 0),
        angleBase: 0,
        angleSpread: 720,
        angleVelocityBase: 0,
        angleVelocitySpread: 60,
        sizeTween: new ParticleTween([ 0, .25 ], [ 1, 10 ]),
        colorBase: new THREE.Vector3(.66, 1, .9),
        opacityTween: new ParticleTween([ 2, 3 ], [ .8, 0 ]),
        particlesPerSecond: 200,
        particleDeathAge: 4,
        emitterDeathAge: 60
    },
    rain: {
        positionStyle: Type.CUBE,
        positionBase: new THREE.Vector3(0, 200, 0),
        positionSpread: new THREE.Vector3(600, 0, 600),
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(0, -400, 0),
        velocitySpread: new THREE.Vector3(10, 50, 10),
        accelerationBase: new THREE.Vector3(0, -10, 0),
        sizeBase: 8,
        sizeSpread: 4,
        colorBase: new THREE.Vector3(.66, 1, .7),
        colorSpread: new THREE.Vector3(0, 0, .2),
        opacityBase: .6,
        particlesPerSecond: 1e3,
        particleDeathAge: 1,
        emitterDeathAge: 60
    },
    starfield: {
        positionStyle: Type.CUBE,
        positionBase: new THREE.Vector3(0, 200, 0),
        positionSpread: new THREE.Vector3(600, 400, 600),
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(0, 0, 0),
        velocitySpread: new THREE.Vector3(.5, .5, .5),
        angleBase: 0,
        angleSpread: 720,
        angleVelocityBase: 0,
        angleVelocitySpread: 4,
        sizeBase: 10,
        sizeSpread: 2,
        colorBase: new THREE.Vector3(.15, 1, .9),
        colorSpread: new THREE.Vector3(0, 0, .2),
        opacityBase: 1,
        particlesPerSecond: 2e4,
        particleDeathAge: 60,
        emitterDeathAge: .1
    },
    fireflies: {
        positionStyle: Type.CUBE,
        positionBase: new THREE.Vector3(0, 100, 0),
        positionSpread: new THREE.Vector3(400, 200, 400),
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(0, 0, 0),
        velocitySpread: new THREE.Vector3(60, 20, 60),
        sizeBase: 30,
        sizeSpread: 2,
        opacityTween: new ParticleTween([ 0, 1, 1.1, 2, 2.1, 3, 3.1, 4, 4.1, 5, 5.1, 6, 6.1 ], [ .2, .2, 1, 1, .2, .2, 1, 1, .2, .2, 1, 1, .2 ]),
        colorBase: new THREE.Vector3(.3, 1, .6),
        colorSpread: new THREE.Vector3(.3, 0, 0),
        particlesPerSecond: 20,
        particleDeathAge: 6.1,
        emitterDeathAge: 600
    },
    startunnel: {
        positionStyle: Type.CUBE,
        positionBase: new THREE.Vector3(0, 0, 0),
        positionSpread: new THREE.Vector3(10, 10, 10),
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(0, 100, 200),
        velocitySpread: new THREE.Vector3(40, 40, 80),
        angleBase: 0,
        angleSpread: 720,
        angleVelocityBase: 10,
        angleVelocitySpread: 0,
        sizeBase: 4,
        sizeSpread: 2,
        colorBase: new THREE.Vector3(.15, 1, .8),
        opacityBase: 1,
        blendStyle: THREE.AdditiveBlending,
        particlesPerSecond: 500,
        particleDeathAge: 4,
        emitterDeathAge: 60
    },
    firework: {
        positionStyle: Type.SPHERE,
        positionBase: new THREE.Vector3(0, 100, 0),
        positionRadius: 10,
        velocityStyle: Type.SPHERE,
        speedBase: 90,
        speedSpread: 10,
        accelerationBase: new THREE.Vector3(0, -80, 0),
        sizeTween: new ParticleTween([ .5, .7, 1.3 ], [ 5, 40, 1 ]),
        opacityTween: new ParticleTween([ .2, .7, 2.5 ], [ .75, 1, 0 ]),
        colorTween: new ParticleTween([ .4, .8, 1 ], [ new THREE.Vector3(0, 1, 1), new THREE.Vector3(0, 1, .6), new THREE.Vector3(.8, 1, .6) ]),
        blendStyle: THREE.AdditiveBlending,
        particlesPerSecond: 3e3,
        particleDeathAge: 2.5,
        emitterDeathAge: .2
    },
    candle: {
        positionStyle: Type.SPHERE,
        positionBase: new THREE.Vector3(0, 0, 0),
        positionRadius: 1,
        velocityStyle: Type.CUBE,
        velocityBase: new THREE.Vector3(0, 100, 0),
        velocitySpread: new THREE.Vector3(20, 0, 20),
        particleTexture: THREE.ImageUtils.loadTexture("img/smokeparticle.png"),
        sizeTween: new ParticleTween([ 0, .3, 1.2 ], [ 20, 150, 1 ]),
        opacityTween: new ParticleTween([ .9, 1.5 ], [ 1, 0 ]),
        colorTween: new ParticleTween([ .5, 1 ], [ new THREE.Vector3(.02, 1, .5), new THREE.Vector3(.05, 1, 0) ]),
        blendStyle: THREE.AdditiveBlending,
        particlesPerSecond: 20,
        particleDeathAge: 1.5,
        emitterDeathAge: 60,
        repeat: !0
    }
}, window.Physijs = function() {
    "use strict";
    var a, b, c, d, e, f, g, h, i, j = !1, k = l, l = {}, m = new THREE.Vector3(), n = new THREE.Vector3(), o = new THREE.Matrix4(), p = new THREE.Quaternion(), q = {
        WORLDREPORT: 0,
        COLLISIONREPORT: 1,
        VEHICLEREPORT: 2,
        CONSTRAINTREPORT: 3
    }, r = 14, s = 5, t = 9, u = 6;
    return l.scripts = {}, b = function() {
        this._eventListeners = {};
    }, b.prototype.addEventListener = function(a, b) {
        this._eventListeners.hasOwnProperty(a) || (this._eventListeners[a] = []), this._eventListeners[a].push(b);
    }, b.prototype.removeEventListener = function(a, b) {
        var c;
        return !!this._eventListeners.hasOwnProperty(a) && ((c = this._eventListeners[a].indexOf(b)) >= 0 && (this._eventListeners[a].splice(c, 1), 
        !0));
    }, b.prototype.dispatchEvent = function(a) {
        var b, c = Array.prototype.splice.call(arguments, 1);
        if (this._eventListeners.hasOwnProperty(a)) for (b = 0; b < this._eventListeners[a].length; b++) this._eventListeners[a][b].apply(this, c);
    }, b.make = function(a) {
        a.prototype.addEventListener = b.prototype.addEventListener, a.prototype.removeEventListener = b.prototype.removeEventListener, 
        a.prototype.dispatchEvent = b.prototype.dispatchEvent;
    }, c = function() {
        var a = 1;
        return function() {
            return a++;
        };
    }(), d = function(a, b, c, d) {
        return new THREE.Vector3(Math.atan2(2 * (a * d - b * c), d * d - a * a - b * b + c * c), Math.asin(2 * (a * c + b * d)), Math.atan2(2 * (c * d - a * b), d * d + a * a - b * b - c * c));
    }, e = function(a, b, c) {
        var d, e, f, g, h, i, j, k;
        return d = Math.cos(b), e = Math.sin(b), f = Math.cos(-c), g = Math.sin(-c), h = Math.cos(a), 
        i = Math.sin(a), j = d * f, k = e * g, {
            w: j * h - k * i,
            x: j * i + k * h,
            y: e * f * h + d * g * i,
            z: d * g * h - e * f * i
        };
    }, f = function(a, b) {
        return o.identity(), o.identity().makeRotationFromQuaternion(b.quaternion), o.getInverse(o), 
        m.copy(a), n.copy(b.position), m.sub(n).applyMatrix4(o);
    }, l.noConflict = function() {
        return window.Physijs = k, l;
    }, l.createMaterial = function(a, b, c) {
        var d = function() {};
        return d.prototype = a, d = new d(), d._physijs = {
            id: a.id,
            friction: void 0 === b ? .8 : b,
            restitution: void 0 === c ? .2 : c
        }, d;
    }, l.PointConstraint = function(a, b, d) {
        void 0 === d && (d = b, b = void 0), this.type = "point", this.appliedImpulse = 0, 
        this.id = c(), this.objecta = a._physijs.id, this.positiona = f(d, a).clone(), b && (this.objectb = b._physijs.id, 
        this.positionb = f(d, b).clone());
    }, l.PointConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb
        };
    }, l.HingeConstraint = function(a, b, d, e) {
        void 0 === e && (e = d, d = b, b = void 0), this.type = "hinge", this.appliedImpulse = 0, 
        this.id = c(), this.scene = a.parent, this.objecta = a._physijs.id, this.positiona = f(d, a).clone(), 
        this.position = d.clone(), this.axis = e, b && (this.objectb = b._physijs.id, this.positionb = f(d, b).clone());
    }, l.HingeConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb,
            axis: this.axis
        };
    }, l.HingeConstraint.prototype.setLimits = function(a, b, c, d) {
        this.scene.execute("hinge_setLimits", {
            constraint: this.id,
            low: a,
            high: b,
            bias_factor: c,
            relaxation_factor: d
        });
    }, l.HingeConstraint.prototype.enableAngularMotor = function(a, b) {
        this.scene.execute("hinge_enableAngularMotor", {
            constraint: this.id,
            velocity: a,
            acceleration: b
        });
    }, l.HingeConstraint.prototype.disableMotor = function(a, b) {
        this.scene.execute("hinge_disableMotor", {
            constraint: this.id
        });
    }, l.SliderConstraint = function(a, b, d, e) {
        void 0 === e && (e = d, d = b, b = void 0), this.type = "slider", this.appliedImpulse = 0, 
        this.id = c(), this.scene = a.parent, this.objecta = a._physijs.id, this.positiona = f(d, a).clone(), 
        this.axis = e, b && (this.objectb = b._physijs.id, this.positionb = f(d, b).clone());
    }, l.SliderConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb,
            axis: this.axis
        };
    }, l.SliderConstraint.prototype.setLimits = function(a, b, c, d) {
        this.scene.execute("slider_setLimits", {
            constraint: this.id,
            lin_lower: a,
            lin_upper: b,
            ang_lower: c,
            ang_upper: d
        });
    }, l.SliderConstraint.prototype.setRestitution = function(a, b) {
        this.scene.execute("slider_setRestitution", {
            constraint: this.id,
            linear: a,
            angular: b
        });
    }, l.SliderConstraint.prototype.enableLinearMotor = function(a, b) {
        this.scene.execute("slider_enableLinearMotor", {
            constraint: this.id,
            velocity: a,
            acceleration: b
        });
    }, l.SliderConstraint.prototype.disableLinearMotor = function() {
        this.scene.execute("slider_disableLinearMotor", {
            constraint: this.id
        });
    }, l.SliderConstraint.prototype.enableAngularMotor = function(a, b) {
        this.scene.execute("slider_enableAngularMotor", {
            constraint: this.id,
            velocity: a,
            acceleration: b
        });
    }, l.SliderConstraint.prototype.disableAngularMotor = function() {
        this.scene.execute("slider_disableAngularMotor", {
            constraint: this.id
        });
    }, l.ConeTwistConstraint = function(a, b, d) {
        if (void 0 === d) throw "Both objects must be defined in a ConeTwistConstraint.";
        this.type = "conetwist", this.appliedImpulse = 0, this.id = c(), this.scene = a.parent, 
        this.objecta = a._physijs.id, this.positiona = f(d, a).clone(), this.objectb = b._physijs.id, 
        this.positionb = f(d, b).clone(), this.axisa = {
            x: a.rotation.x,
            y: a.rotation.y,
            z: a.rotation.z
        }, this.axisb = {
            x: b.rotation.x,
            y: b.rotation.y,
            z: b.rotation.z
        };
    }, l.ConeTwistConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb,
            axisa: this.axisa,
            axisb: this.axisb
        };
    }, l.ConeTwistConstraint.prototype.setLimit = function(a, b, c) {
        this.scene.execute("conetwist_setLimit", {
            constraint: this.id,
            x: a,
            y: b,
            z: c
        });
    }, l.ConeTwistConstraint.prototype.enableMotor = function() {
        this.scene.execute("conetwist_enableMotor", {
            constraint: this.id
        });
    }, l.ConeTwistConstraint.prototype.setMaxMotorImpulse = function(a) {
        this.scene.execute("conetwist_setMaxMotorImpulse", {
            constraint: this.id,
            max_impulse: a
        });
    }, l.ConeTwistConstraint.prototype.setMotorTarget = function(a) {
        a instanceof THREE.Vector3 ? a = new THREE.Quaternion().setFromEuler(new THREE.Euler(a.x, a.y, a.z)) : a instanceof THREE.Euler ? a = new THREE.Quaternion().setFromEuler(a) : a instanceof THREE.Matrix4 && (a = new THREE.Quaternion().setFromRotationMatrix(a)), 
        this.scene.execute("conetwist_setMotorTarget", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z,
            w: a.w
        });
    }, l.ConeTwistConstraint.prototype.disableMotor = function() {
        this.scene.execute("conetwist_disableMotor", {
            constraint: this.id
        });
    }, l.DOFConstraint = function(a, b, d) {
        void 0 === d && (d = b, b = void 0), this.type = "dof", this.appliedImpulse = 0, 
        this.id = c(), this.scene = a.parent, this.objecta = a._physijs.id, this.positiona = f(d, a).clone(), 
        this.axisa = {
            x: a.rotation.x,
            y: a.rotation.y,
            z: a.rotation.z
        }, b && (this.objectb = b._physijs.id, this.positionb = f(d, b).clone(), this.axisb = {
            x: b.rotation.x,
            y: b.rotation.y,
            z: b.rotation.z
        });
    }, l.DOFConstraint.prototype.getDefinition = function() {
        return {
            type: this.type,
            id: this.id,
            objecta: this.objecta,
            objectb: this.objectb,
            positiona: this.positiona,
            positionb: this.positionb,
            axisa: this.axisa,
            axisb: this.axisb
        };
    }, l.DOFConstraint.prototype.setLinearLowerLimit = function(a) {
        this.scene.execute("dof_setLinearLowerLimit", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.DOFConstraint.prototype.setLinearUpperLimit = function(a) {
        this.scene.execute("dof_setLinearUpperLimit", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.DOFConstraint.prototype.setAngularLowerLimit = function(a) {
        this.scene.execute("dof_setAngularLowerLimit", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.DOFConstraint.prototype.setAngularUpperLimit = function(a) {
        this.scene.execute("dof_setAngularUpperLimit", {
            constraint: this.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.DOFConstraint.prototype.enableAngularMotor = function(a) {
        this.scene.execute("dof_enableAngularMotor", {
            constraint: this.id,
            which: a
        });
    }, l.DOFConstraint.prototype.configureAngularMotor = function(a, b, c, d, e) {
        this.scene.execute("dof_configureAngularMotor", {
            constraint: this.id,
            which: a,
            low_angle: b,
            high_angle: c,
            velocity: d,
            max_force: e
        });
    }, l.DOFConstraint.prototype.disableAngularMotor = function(a) {
        this.scene.execute("dof_disableAngularMotor", {
            constraint: this.id,
            which: a
        });
    }, l.Scene = function(c) {
        var d = this;
        b.call(this), THREE.Scene.call(this), this._worker = new Worker(l.scripts.worker || "physijs_worker.js"), 
        this._worker.transferableMessage = this._worker.webkitPostMessage || this._worker.postMessage, 
        this._materials_ref_counts = {}, this._objects = {}, this._vehicles = {}, this._constraints = {};
        var e = new ArrayBuffer(1);
        this._worker.transferableMessage(e, [ e ]), a = 0 === e.byteLength, this._worker.onmessage = function(a) {
            var b, c = a.data;
            if (c instanceof ArrayBuffer && 1 !== c.byteLength && (c = new Float32Array(c)), 
            c instanceof Float32Array) switch (c[0]) {
              case q.WORLDREPORT:
                d._updateScene(c);
                break;

              case q.COLLISIONREPORT:
                d._updateCollisions(c);
                break;

              case q.VEHICLEREPORT:
                d._updateVehicles(c);
                break;

              case q.CONSTRAINTREPORT:
                d._updateConstraints(c);
            } else if (c.cmd) switch (c.cmd) {
              case "objectReady":
                b = c.params, d._objects[b] && d._objects[b].dispatchEvent("ready");
                break;

              case "worldReady":
                d.dispatchEvent("ready");
                break;

              case "vehicle":
                window.test = c;
                break;

              default:
                console.debug("Received: " + c.cmd), console.dir(c.params);
            } else switch (c[0]) {
              case q.WORLDREPORT:
                d._updateScene(c);
                break;

              case q.COLLISIONREPORT:
                d._updateCollisions(c);
                break;

              case q.VEHICLEREPORT:
                d._updateVehicles(c);
                break;

              case q.CONSTRAINTREPORT:
                d._updateConstraints(c);
            }
        }, c = c || {}, c.ammo = l.scripts.ammo || "ammo.js", c.fixedTimeStep = c.fixedTimeStep || 1 / 60, 
        c.rateLimit = c.rateLimit || !0, this.execute("init", c);
    }, l.Scene.prototype = new THREE.Scene(), l.Scene.prototype.constructor = l.Scene, 
    b.make(l.Scene), l.Scene.prototype._updateScene = function(b) {
        var c, d, e, f = b[1];
        for (d = 0; d < f; d++) e = 2 + d * r, c = this._objects[b[e]], void 0 !== c && (c.__dirtyPosition === !1 && c.position.set(b[e + 1], b[e + 2], b[e + 3]), 
        c.__dirtyRotation === !1 && c.quaternion.set(b[e + 4], b[e + 5], b[e + 6], b[e + 7]), 
        c._physijs.linearVelocity.set(b[e + 8], b[e + 9], b[e + 10]), c._physijs.angularVelocity.set(b[e + 11], b[e + 12], b[e + 13]));
        a && this._worker.transferableMessage(b.buffer, [ b.buffer ]), j = !1, this.dispatchEvent("update");
    }, l.Scene.prototype._updateVehicles = function(b) {
        var c, d, e, f;
        for (e = 0; e < (b.length - 1) / t; e++) f = 1 + e * t, c = this._vehicles[b[f]], 
        void 0 !== c && (d = c.wheels[b[f + 1]], d.position.set(b[f + 2], b[f + 3], b[f + 4]), 
        d.quaternion.set(b[f + 5], b[f + 6], b[f + 7], b[f + 8]));
        a && this._worker.transferableMessage(b.buffer, [ b.buffer ]);
    }, l.Scene.prototype._updateConstraints = function(b) {
        var c, d, e, f;
        for (e = 0; e < (b.length - 1) / u; e++) f = 1 + e * u, c = this._constraints[b[f]], 
        d = this._objects[b[f + 1]], void 0 !== c && void 0 !== d && (m.set(b[f + 2], b[f + 3], b[f + 4]), 
        o.extractRotation(d.matrix), m.applyMatrix4(o), c.positiona.addVectors(d.position, m), 
        c.appliedImpulse = b[f + 5]);
        a && this._worker.transferableMessage(b.buffer, [ b.buffer ]);
    }, l.Scene.prototype._updateCollisions = function(b) {
        var c, d, e, f, g, j, k, l = {}, n = {};
        for (c = 0; c < b[1]; c++) e = 2 + c * s, f = b[e], g = b[e + 1], n[f + "-" + g] = e + 2, 
        n[g + "-" + f] = -1 * (e + 2), l[f] || (l[f] = []), l[f].push(g), l[g] || (l[g] = []), 
        l[g].push(f);
        for (j in this._objects) if (this._objects.hasOwnProperty(j)) if (f = this._objects[j], 
        l[j]) {
            for (d = 0; d < f._physijs.touches.length; d++) l[j].indexOf(f._physijs.touches[d]) === -1 && f._physijs.touches.splice(d--, 1);
            for (d = 0; d < l[j].length; d++) if (k = l[j][d], g = this._objects[k], g && f._physijs.touches.indexOf(k) === -1) {
                f._physijs.touches.push(k), m.subVectors(f.getLinearVelocity(), g.getLinearVelocity()), 
                h = m.clone(), m.subVectors(f.getAngularVelocity(), g.getAngularVelocity()), i = m.clone();
                var o = n[f._physijs.id + "-" + g._physijs.id];
                o > 0 ? m.set(-b[o], -b[o + 1], -b[o + 2]) : (o *= -1, m.set(b[o], b[o + 1], b[o + 2])), 
                f.dispatchEvent("collision", g, h, i, m);
            }
        } else f._physijs.touches.length = 0;
        this.collisions = l, a && this._worker.transferableMessage(b.buffer, [ b.buffer ]);
    }, l.Scene.prototype.addConstraint = function(a, b) {
        if (this._constraints[a.id] = a, this.execute("addConstraint", a.getDefinition()), 
        b) {
            var c;
            switch (a.type) {
              case "point":
                c = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshNormalMaterial()), 
                c.position.copy(a.positiona), this._objects[a.objecta].add(c);
                break;

              case "hinge":
                c = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshNormalMaterial()), 
                c.position.copy(a.positiona), this._objects[a.objecta].add(c);
                break;

              case "slider":
                c = new THREE.Mesh(new THREE.CubeGeometry(10, 1, 1), new THREE.MeshNormalMaterial()), 
                c.position.copy(a.positiona), c.rotation.set(a.axis.y, a.axis.x, a.axis.z), this._objects[a.objecta].add(c);
                break;

              case "conetwist":
                c = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshNormalMaterial()), 
                c.position.copy(a.positiona), this._objects[a.objecta].add(c);
                break;

              case "dof":
                c = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshNormalMaterial()), 
                c.position.copy(a.positiona), this._objects[a.objecta].add(c);
            }
        }
        return a;
    }, l.Scene.prototype.removeConstraint = function(a) {
        void 0 !== this._constraints[a.id] && (this.execute("removeConstraint", {
            id: a.id
        }), delete this._constraints[a.id]);
    }, l.Scene.prototype.execute = function(a, b) {
        this._worker.postMessage({
            cmd: a,
            params: b
        });
    }, g = function(a, b) {
        var c;
        for (c = 0; c < b.children.length; c++) b.children[c]._physijs && (b.children[c].updateMatrix(), 
        b.children[c].updateMatrixWorld(), m.getPositionFromMatrix(b.children[c].matrixWorld), 
        p.setFromRotationMatrix(b.children[c].matrixWorld), b.children[c]._physijs.position_offset = {
            x: m.x,
            y: m.y,
            z: m.z
        }, b.children[c]._physijs.rotation = {
            x: p.x,
            y: p.y,
            z: p.z,
            w: p.w
        }, a._physijs.children.push(b.children[c]._physijs)), g(a, b.children[c]);
    }, l.Scene.prototype.add = function(a) {
        if (THREE.Mesh.prototype.add.call(this, a), a._physijs) if (a.world = this, a instanceof l.Vehicle) this.add(a.mesh), 
        this._vehicles[a._physijs.id] = a, this.execute("addVehicle", a._physijs); else {
            a.__dirtyPosition = !1, a.__dirtyRotation = !1, this._objects[a._physijs.id] = a, 
            a.children.length && (a._physijs.children = [], g(a, a)), a.material._physijs && (this._materials_ref_counts.hasOwnProperty(a.material._physijs.id) ? this._materials_ref_counts[a.material._physijs.id]++ : (this.execute("registerMaterial", a.material._physijs), 
            a._physijs.materialId = a.material._physijs.id, this._materials_ref_counts[a.material._physijs.id] = 1)), 
            a._physijs.position = {
                x: a.position.x,
                y: a.position.y,
                z: a.position.z
            }, a._physijs.rotation = {
                x: a.quaternion.x,
                y: a.quaternion.y,
                z: a.quaternion.z,
                w: a.quaternion.w
            };
            new THREE.Vector3(1, 1, 1);
            a._physijs.width && (a._physijs.width *= a.scale.x), a._physijs.height && (a._physijs.height *= a.scale.y), 
            a._physijs.depth && (a._physijs.depth *= a.scale.z), this.execute("addObject", a._physijs);
        }
    }, l.Scene.prototype.remove = function(a) {
        if (a instanceof l.Vehicle) {
            for (this.execute("removeVehicle", {
                id: a._physijs.id
            }); a.wheels.length; ) this.remove(a.wheels.pop());
            this.remove(a.mesh), delete this._vehicles[a._physijs.id];
        } else THREE.Mesh.prototype.remove.call(this, a), a._physijs && (delete this._objects[a._physijs.id], 
        this.execute("removeObject", {
            id: a._physijs.id
        }));
        a.material && a.material._physijs && this._materials_ref_counts.hasOwnProperty(a.material._physijs.id) && (this._materials_ref_counts[a.material._physijs.id]--, 
        0 == this._materials_ref_counts[a.material._physijs.id] && (this.execute("unRegisterMaterial", a.material._physijs), 
        delete this._materials_ref_counts[a.material._physijs.id]));
    }, l.Scene.prototype.setFixedTimeStep = function(a) {
        a && this.execute("setFixedTimeStep", a);
    }, l.Scene.prototype.setGravity = function(a) {
        a && this.execute("setGravity", a);
    }, l.Scene.prototype.simulate = function(a, b) {
        var c, d, e;
        if (j) return !1;
        j = !0;
        for (c in this._objects) this._objects.hasOwnProperty(c) && (d = this._objects[c], 
        (d.__dirtyPosition || d.__dirtyRotation) && (e = {
            id: d._physijs.id
        }, d.__dirtyPosition && (e.pos = {
            x: d.position.x,
            y: d.position.y,
            z: d.position.z
        }, d.__dirtyPosition = !1), d.__dirtyRotation && (e.quat = {
            x: d.quaternion.x,
            y: d.quaternion.y,
            z: d.quaternion.z,
            w: d.quaternion.w
        }, d.__dirtyRotation = !1), this.execute("updateTransform", e)));
        return this.execute("simulate", {
            timeStep: a,
            maxSubSteps: b
        }), !0;
    }, l.Mesh = function(a, d, e) {
        a && (b.call(this), THREE.Mesh.call(this, a, d), a.boundingBox || a.computeBoundingBox(), 
        this._physijs = {
            type: null,
            id: c(),
            mass: e || 0,
            touches: [],
            linearVelocity: new THREE.Vector3(),
            angularVelocity: new THREE.Vector3()
        });
    }, l.Mesh.prototype = new THREE.Mesh(), l.Mesh.prototype.constructor = l.Mesh, b.make(l.Mesh), 
    l.Mesh.prototype.__defineGetter__("mass", function() {
        return this._physijs.mass;
    }), l.Mesh.prototype.__defineSetter__("mass", function(a) {
        this._physijs.mass = a, this.world && this.world.execute("updateMass", {
            id: this._physijs.id,
            mass: a
        });
    }), l.Mesh.prototype.applyCentralImpulse = function(a) {
        this.world && this.world.execute("applyCentralImpulse", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.Mesh.prototype.applyImpulse = function(a, b) {
        this.world && this.world.execute("applyImpulse", {
            id: this._physijs.id,
            impulse_x: a.x,
            impulse_y: a.y,
            impulse_z: a.z,
            x: b.x,
            y: b.y,
            z: b.z
        });
    }, l.Mesh.prototype.applyCentralForce = function(a) {
        this.world && this.world.execute("applyCentralForce", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.Mesh.prototype.applyForce = function(a, b) {
        this.world && this.world.execute("applyForce", {
            id: this._physijs.id,
            force_x: a.x,
            force_y: a.y,
            force_z: a.z,
            x: b.x,
            y: b.y,
            z: b.z
        });
    }, l.Mesh.prototype.getAngularVelocity = function() {
        return this._physijs.angularVelocity;
    }, l.Mesh.prototype.setAngularVelocity = function(a) {
        this.world && this.world.execute("setAngularVelocity", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.Mesh.prototype.getLinearVelocity = function() {
        return this._physijs.linearVelocity;
    }, l.Mesh.prototype.setLinearVelocity = function(a) {
        this.world && this.world.execute("setLinearVelocity", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.Mesh.prototype.setAngularFactor = function(a) {
        this.world && this.world.execute("setAngularFactor", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.Mesh.prototype.setLinearFactor = function(a) {
        this.world && this.world.execute("setLinearFactor", {
            id: this._physijs.id,
            x: a.x,
            y: a.y,
            z: a.z
        });
    }, l.Mesh.prototype.setDamping = function(a, b) {
        this.world && this.world.execute("setDamping", {
            id: this._physijs.id,
            linear: a,
            angular: b
        });
    }, l.Mesh.prototype.setCcdMotionThreshold = function(a) {
        this.world && this.world.execute("setCcdMotionThreshold", {
            id: this._physijs.id,
            threshold: a
        });
    }, l.Mesh.prototype.setCcdSweptSphereRadius = function(a) {
        this.world && this.world.execute("setCcdSweptSphereRadius", {
            id: this._physijs.id,
            radius: a
        });
    }, l.PlaneMesh = function(a, b, c) {
        var d, e;
        l.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, this._physijs.type = "plane", this._physijs.normal = a.faces[0].normal.clone(), 
        this._physijs.mass = "undefined" == typeof c ? d * e : c;
    }, l.PlaneMesh.prototype = new l.Mesh(), l.PlaneMesh.prototype.constructor = l.PlaneMesh, 
    l.HeightfieldMesh = function(a, b, c, d, e) {
        l.Mesh.call(this, a, b, c), this._physijs.type = "heightfield", this._physijs.xsize = a.boundingBox.max.x - a.boundingBox.min.x, 
        this._physijs.ysize = a.boundingBox.max.y - a.boundingBox.min.y, this._physijs.xpts = "undefined" == typeof d ? Math.sqrt(a.vertices.length) : d + 1, 
        this._physijs.ypts = "undefined" == typeof e ? Math.sqrt(a.vertices.length) : e + 1, 
        this._physijs.absMaxHeight = Math.max(a.boundingBox.max.z, Math.abs(a.boundingBox.min.z));
        for (var f, g, h = [], i = 0; i < a.vertices.length; i++) f = i % this._physijs.xpts, 
        g = Math.round(i / this._physijs.xpts - i % this._physijs.xpts / this._physijs.xpts), 
        h[i] = a.vertices[f + (this._physijs.ypts - g - 1) * this._physijs.ypts].z;
        this._physijs.points = h;
    }, l.HeightfieldMesh.prototype = new l.Mesh(), l.HeightfieldMesh.prototype.constructor = l.HeightfieldMesh, 
    l.BoxMesh = function(a, b, c) {
        var d, e, f;
        l.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, f = a.boundingBox.max.z - a.boundingBox.min.z, 
        this._physijs.type = "box", this._physijs.width = d, this._physijs.height = e, this._physijs.depth = f, 
        this._physijs.mass = "undefined" == typeof c ? d * e * f : c;
    }, l.BoxMesh.prototype = new l.Mesh(), l.BoxMesh.prototype.constructor = l.BoxMesh, 
    l.SphereMesh = function(a, b, c) {
        l.Mesh.call(this, a, b, c), a.boundingSphere || a.computeBoundingSphere(), this._physijs.type = "sphere", 
        this._physijs.radius = a.boundingSphere.radius, this._physijs.mass = "undefined" == typeof c ? 4 / 3 * Math.PI * Math.pow(this._physijs.radius, 3) : c;
    }, l.SphereMesh.prototype = new l.Mesh(), l.SphereMesh.prototype.constructor = l.SphereMesh, 
    l.CylinderMesh = function(a, b, c) {
        var d, e, f;
        l.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, f = a.boundingBox.max.z - a.boundingBox.min.z, 
        this._physijs.type = "cylinder", this._physijs.width = d, this._physijs.height = e, 
        this._physijs.depth = f, this._physijs.mass = "undefined" == typeof c ? d * e * f : c;
    }, l.CylinderMesh.prototype = new l.Mesh(), l.CylinderMesh.prototype.constructor = l.CylinderMesh, 
    l.CapsuleMesh = function(a, b, c) {
        var d, e, f;
        l.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, f = a.boundingBox.max.z - a.boundingBox.min.z, 
        this._physijs.type = "capsule", this._physijs.radius = Math.max(d / 2, f / 2), this._physijs.height = e, 
        this._physijs.mass = "undefined" == typeof c ? d * e * f : c;
    }, l.CapsuleMesh.prototype = new l.Mesh(), l.CapsuleMesh.prototype.constructor = l.CapsuleMesh, 
    l.ConeMesh = function(a, b, c) {
        var d, e;
        l.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = a.boundingBox.max.x - a.boundingBox.min.x, 
        e = a.boundingBox.max.y - a.boundingBox.min.y, this._physijs.type = "cone", this._physijs.radius = d / 2, 
        this._physijs.height = e, this._physijs.mass = "undefined" == typeof c ? d * e : c;
    }, l.ConeMesh.prototype = new l.Mesh(), l.ConeMesh.prototype.constructor = l.ConeMesh, 
    l.ConcaveMesh = function(a, b, c) {
        var d, e, f, g, h, i, j = [];
        for (l.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), h = a.vertices, 
        d = 0; d < a.faces.length; d++) i = a.faces[d], i instanceof THREE.Face3 ? j.push([ {
            x: h[i.a].x,
            y: h[i.a].y,
            z: h[i.a].z
        }, {
            x: h[i.b].x,
            y: h[i.b].y,
            z: h[i.b].z
        }, {
            x: h[i.c].x,
            y: h[i.c].y,
            z: h[i.c].z
        } ]) : i instanceof THREE.Face4 && (j.push([ {
            x: h[i.a].x,
            y: h[i.a].y,
            z: h[i.a].z
        }, {
            x: h[i.b].x,
            y: h[i.b].y,
            z: h[i.b].z
        }, {
            x: h[i.d].x,
            y: h[i.d].y,
            z: h[i.d].z
        } ]), j.push([ {
            x: h[i.b].x,
            y: h[i.b].y,
            z: h[i.b].z
        }, {
            x: h[i.c].x,
            y: h[i.c].y,
            z: h[i.c].z
        }, {
            x: h[i.d].x,
            y: h[i.d].y,
            z: h[i.d].z
        } ]));
        e = a.boundingBox.max.x - a.boundingBox.min.x, f = a.boundingBox.max.y - a.boundingBox.min.y, 
        g = a.boundingBox.max.z - a.boundingBox.min.z, this._physijs.type = "concave", this._physijs.triangles = j, 
        this._physijs.mass = "undefined" == typeof c ? e * f * g : c;
    }, l.ConcaveMesh.prototype = new l.Mesh(), l.ConcaveMesh.prototype.constructor = l.ConcaveMesh, 
    l.ConvexMesh = function(a, b, c) {
        var d, e, f, g, h = [];
        for (l.Mesh.call(this, a, b, c), a.boundingBox || a.computeBoundingBox(), d = 0; d < a.vertices.length; d++) h.push({
            x: a.vertices[d].x,
            y: a.vertices[d].y,
            z: a.vertices[d].z
        });
        e = a.boundingBox.max.x - a.boundingBox.min.x, f = a.boundingBox.max.y - a.boundingBox.min.y, 
        g = a.boundingBox.max.z - a.boundingBox.min.z, this._physijs.type = "convex", this._physijs.points = h, 
        this._physijs.mass = "undefined" == typeof c ? e * f * g : c;
    }, l.ConvexMesh.prototype = new l.Mesh(), l.ConvexMesh.prototype.constructor = l.ConvexMesh, 
    l.Vehicle = function(a, b) {
        b = b || new l.VehicleTuning(), this.mesh = a, this.wheels = [], this._physijs = {
            id: c(),
            rigidBody: a._physijs.id,
            suspension_stiffness: b.suspension_stiffness,
            suspension_compression: b.suspension_compression,
            suspension_damping: b.suspension_damping,
            max_suspension_travel: b.max_suspension_travel,
            friction_slip: b.friction_slip,
            max_suspension_force: b.max_suspension_force
        };
    }, l.Vehicle.prototype.addWheel = function(a, b, c, d, e, f, g, h, i) {
        var j = new THREE.Mesh(a, b);
        j.castShadow = j.receiveShadow = !0, j.position.copy(d).multiplyScalar(f / 100).add(c), 
        this.world.add(j), this.wheels.push(j), this.world.execute("addWheel", {
            id: this._physijs.id,
            connection_point: {
                x: c.x,
                y: c.y,
                z: c.z
            },
            wheel_direction: {
                x: d.x,
                y: d.y,
                z: d.z
            },
            wheel_axle: {
                x: e.x,
                y: e.y,
                z: e.z
            },
            suspension_rest_length: f,
            wheel_radius: g,
            is_front_wheel: h,
            tuning: i
        });
    }, l.Vehicle.prototype.setSteering = function(a, b) {
        if (void 0 !== b && void 0 !== this.wheels[b]) this.world.execute("setSteering", {
            id: this._physijs.id,
            wheel: b,
            steering: a
        }); else if (this.wheels.length > 0) for (var c = 0; c < this.wheels.length; c++) this.world.execute("setSteering", {
            id: this._physijs.id,
            wheel: c,
            steering: a
        });
    }, l.Vehicle.prototype.setBrake = function(a, b) {
        if (void 0 !== b && void 0 !== this.wheels[b]) this.world.execute("setBrake", {
            id: this._physijs.id,
            wheel: b,
            brake: a
        }); else if (this.wheels.length > 0) for (var c = 0; c < this.wheels.length; c++) this.world.execute("setBrake", {
            id: this._physijs.id,
            wheel: c,
            brake: a
        });
    }, l.Vehicle.prototype.applyEngineForce = function(a, b) {
        if (void 0 !== b && void 0 !== this.wheels[b]) this.world.execute("applyEngineForce", {
            id: this._physijs.id,
            wheel: b,
            force: a
        }); else if (this.wheels.length > 0) for (var c = 0; c < this.wheels.length; c++) this.world.execute("applyEngineForce", {
            id: this._physijs.id,
            wheel: c,
            force: a
        });
    }, l.VehicleTuning = function(a, b, c, d, e, f) {
        this.suspension_stiffness = void 0 !== a ? a : 5.88, this.suspension_compression = void 0 !== b ? b : .83, 
        this.suspension_damping = void 0 !== c ? c : .88, this.max_suspension_travel = void 0 !== d ? d : 500, 
        this.friction_slip = void 0 !== e ? e : 10.5, this.max_suspension_force = void 0 !== f ? f : 6e3;
    }, l;
}();

var TWEEN = TWEEN || function() {
    var a, b, c, d, e = [];
    return {
        start: function(a) {
            c = setInterval(this.update, 1e3 / (a || 60));
        },
        stop: function() {
            clearInterval(c);
        },
        add: function(a) {
            e.push(a);
        },
        getAll: function() {
            return e;
        },
        removeAll: function() {
            e = [];
        },
        remove: function(b) {
            a = e.indexOf(b), a !== -1 && e.splice(a, 1);
        },
        update: function() {
            for (a = 0, b = e.length, d = new Date().getTime(); a < b; ) e[a].update(d) ? a++ : (e.splice(a, 1), 
            b--);
        }
    };
}();

TWEEN.Tween = function(a) {
    var b = {}, c = {}, d = {}, e = 1e3, f = 0, g = null, h = TWEEN.Easing.Linear.EaseNone, i = null, j = null, k = null;
    this.to = function(b, c) {
        null !== c && (e = c);
        for (var f in b) null !== a[f] && (d[f] = b[f]);
        return this;
    }, this.start = function() {
        TWEEN.add(this), g = new Date().getTime() + f;
        for (var e in d) null !== a[e] && (b[e] = a[e], c[e] = d[e] - a[e]);
        return this;
    }, this.stop = function() {
        return TWEEN.remove(this), this;
    }, this.delay = function(a) {
        return f = a, this;
    }, this.easing = function(a) {
        return h = a, this;
    }, this.chain = function(a) {
        i = a;
    }, this.onUpdate = function(a) {
        return j = a, this;
    }, this.onComplete = function(a) {
        return k = a, this;
    }, this.update = function(d) {
        var f, l;
        if (d < g) return !0;
        d = (d - g) / e, d = d > 1 ? 1 : d, l = h(d);
        for (f in c) a[f] = b[f] + c[f] * l;
        return null !== j && j.call(a, l), 1 != d || (null !== k && k.call(a), null !== i && i.start(), 
        !1);
    };
}, TWEEN.Easing = {
    Linear: {},
    Quadratic: {},
    Cubic: {},
    Quartic: {},
    Quintic: {},
    Sinusoidal: {},
    Exponential: {},
    Circular: {},
    Elastic: {},
    Back: {},
    Bounce: {}
}, TWEEN.Easing.Linear.EaseNone = function(a) {
    return a;
}, TWEEN.Easing.Quadratic.EaseIn = function(a) {
    return a * a;
}, TWEEN.Easing.Quadratic.EaseOut = function(a) {
    return -a * (a - 2);
}, TWEEN.Easing.Quadratic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1);
}, TWEEN.Easing.Cubic.EaseIn = function(a) {
    return a * a * a;
}, TWEEN.Easing.Cubic.EaseOut = function(a) {
    return --a * a * a + 1;
}, TWEEN.Easing.Cubic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2);
}, TWEEN.Easing.Quartic.EaseIn = function(a) {
    return a * a * a * a;
}, TWEEN.Easing.Quartic.EaseOut = function(a) {
    return -(--a * a * a * a - 1);
}, TWEEN.Easing.Quartic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2);
}, TWEEN.Easing.Quintic.EaseIn = function(a) {
    return a * a * a * a * a;
}, TWEEN.Easing.Quintic.EaseOut = function(a) {
    return (a -= 1) * a * a * a * a + 1;
}, TWEEN.Easing.Quintic.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2);
}, TWEEN.Easing.Sinusoidal.EaseIn = function(a) {
    return -Math.cos(a * Math.PI / 2) + 1;
}, TWEEN.Easing.Sinusoidal.EaseOut = function(a) {
    return Math.sin(a * Math.PI / 2);
}, TWEEN.Easing.Sinusoidal.EaseInOut = function(a) {
    return -.5 * (Math.cos(Math.PI * a) - 1);
}, TWEEN.Easing.Exponential.EaseIn = function(a) {
    return 0 == a ? 0 : Math.pow(2, 10 * (a - 1));
}, TWEEN.Easing.Exponential.EaseOut = function(a) {
    return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1;
}, TWEEN.Easing.Exponential.EaseInOut = function(a) {
    return 0 == a ? 0 : 1 == a ? 1 : (a *= 2) < 1 ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2);
}, TWEEN.Easing.Circular.EaseIn = function(a) {
    return -(Math.sqrt(1 - a * a) - 1);
}, TWEEN.Easing.Circular.EaseOut = function(a) {
    return Math.sqrt(1 - --a * a);
}, TWEEN.Easing.Circular.EaseInOut = function(a) {
    return (a /= .5) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
}, TWEEN.Easing.Elastic.EaseIn = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3), !c || c < 1 ? (c = 1, b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c), 
    -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d)));
}, TWEEN.Easing.Elastic.EaseOut = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3), !c || c < 1 ? (c = 1, b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c), 
    c * Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / d) + 1);
}, TWEEN.Easing.Elastic.EaseInOut = function(a) {
    var b, c = .1, d = .4;
    return 0 == a ? 0 : 1 == a ? 1 : (d || (d = .3), !c || c < 1 ? (c = 1, b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / c), 
    (a *= 2) < 1 ? -.5 * c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d) : c * Math.pow(2, -10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / d) * .5 + 1);
}, TWEEN.Easing.Back.EaseIn = function(a) {
    return a * a * (2.70158 * a - 1.70158);
}, TWEEN.Easing.Back.EaseOut = function(a) {
    return (a -= 1) * a * (2.70158 * a + 1.70158) + 1;
}, TWEEN.Easing.Back.EaseInOut = function(a) {
    return (a *= 2) < 1 ? .5 * a * a * (3.5949095 * a - 2.5949095) : .5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2);
}, TWEEN.Easing.Bounce.EaseIn = function(a) {
    return 1 - TWEEN.Easing.Bounce.EaseOut(1 - a);
}, TWEEN.Easing.Bounce.EaseOut = function(a) {
    return (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375;
}, TWEEN.Easing.Bounce.EaseInOut = function(a) {
    return a < .5 ? .5 * TWEEN.Easing.Bounce.EaseIn(2 * a) : .5 * TWEEN.Easing.Bounce.EaseOut(2 * a - 1) + .5;
}, function() {
    var a = this, b = a._, c = Array.prototype, d = Object.prototype, e = Function.prototype, f = c.push, g = c.slice, h = c.concat, i = d.toString, j = d.hasOwnProperty, k = Array.isArray, l = Object.keys, m = e.bind, n = function(a) {
        return a instanceof n ? a : this instanceof n ? void (this._wrapped = a) : new n(a);
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = n), 
    exports._ = n) : a._ = n, n.VERSION = "1.7.0";
    var o = function(a, b, c) {
        if (void 0 === b) return a;
        switch (null == c ? 3 : c) {
          case 1:
            return function(c) {
                return a.call(b, c);
            };

          case 2:
            return function(c, d) {
                return a.call(b, c, d);
            };

          case 3:
            return function(c, d, e) {
                return a.call(b, c, d, e);
            };

          case 4:
            return function(c, d, e, f) {
                return a.call(b, c, d, e, f);
            };
        }
        return function() {
            return a.apply(b, arguments);
        };
    };
    n.iteratee = function(a, b, c) {
        return null == a ? n.identity : n.isFunction(a) ? o(a, b, c) : n.isObject(a) ? n.matches(a) : n.property(a);
    }, n.each = n.forEach = function(a, b, c) {
        if (null == a) return a;
        b = o(b, c);
        var d, e = a.length;
        if (e === +e) for (d = 0; e > d; d++) b(a[d], d, a); else {
            var f = n.keys(a);
            for (d = 0, e = f.length; e > d; d++) b(a[f[d]], f[d], a);
        }
        return a;
    }, n.map = n.collect = function(a, b, c) {
        if (null == a) return [];
        b = n.iteratee(b, c);
        for (var d, e = a.length !== +a.length && n.keys(a), f = (e || a).length, g = Array(f), h = 0; f > h; h++) d = e ? e[h] : h, 
        g[h] = b(a[d], d, a);
        return g;
    };
    var p = "Reduce of empty array with no initial value";
    n.reduce = n.foldl = n.inject = function(a, b, c, d) {
        null == a && (a = []), b = o(b, d, 4);
        var e, f = a.length !== +a.length && n.keys(a), g = (f || a).length, h = 0;
        if (arguments.length < 3) {
            if (!g) throw new TypeError(p);
            c = a[f ? f[h++] : h++];
        }
        for (;g > h; h++) e = f ? f[h] : h, c = b(c, a[e], e, a);
        return c;
    }, n.reduceRight = n.foldr = function(a, b, c, d) {
        null == a && (a = []), b = o(b, d, 4);
        var e, f = a.length !== +a.length && n.keys(a), g = (f || a).length;
        if (arguments.length < 3) {
            if (!g) throw new TypeError(p);
            c = a[f ? f[--g] : --g];
        }
        for (;g--; ) e = f ? f[g] : g, c = b(c, a[e], e, a);
        return c;
    }, n.find = n.detect = function(a, b, c) {
        var d;
        return b = n.iteratee(b, c), n.some(a, function(a, c, e) {
            return b(a, c, e) ? (d = a, !0) : void 0;
        }), d;
    }, n.filter = n.select = function(a, b, c) {
        var d = [];
        return null == a ? d : (b = n.iteratee(b, c), n.each(a, function(a, c, e) {
            b(a, c, e) && d.push(a);
        }), d);
    }, n.reject = function(a, b, c) {
        return n.filter(a, n.negate(n.iteratee(b)), c);
    }, n.every = n.all = function(a, b, c) {
        if (null == a) return !0;
        b = n.iteratee(b, c);
        var d, e, f = a.length !== +a.length && n.keys(a), g = (f || a).length;
        for (d = 0; g > d; d++) if (e = f ? f[d] : d, !b(a[e], e, a)) return !1;
        return !0;
    }, n.some = n.any = function(a, b, c) {
        if (null == a) return !1;
        b = n.iteratee(b, c);
        var d, e, f = a.length !== +a.length && n.keys(a), g = (f || a).length;
        for (d = 0; g > d; d++) if (e = f ? f[d] : d, b(a[e], e, a)) return !0;
        return !1;
    }, n.contains = n.include = function(a, b) {
        return null != a && (a.length !== +a.length && (a = n.values(a)), n.indexOf(a, b) >= 0);
    }, n.invoke = function(a, b) {
        var c = g.call(arguments, 2), d = n.isFunction(b);
        return n.map(a, function(a) {
            return (d ? b : a[b]).apply(a, c);
        });
    }, n.pluck = function(a, b) {
        return n.map(a, n.property(b));
    }, n.where = function(a, b) {
        return n.filter(a, n.matches(b));
    }, n.findWhere = function(a, b) {
        return n.find(a, n.matches(b));
    }, n.max = function(a, b, c) {
        var d, e, f = -1 / 0, g = -1 / 0;
        if (null == b && null != a) {
            a = a.length === +a.length ? a : n.values(a);
            for (var h = 0, i = a.length; i > h; h++) d = a[h], d > f && (f = d);
        } else b = n.iteratee(b, c), n.each(a, function(a, c, d) {
            e = b(a, c, d), (e > g || e === -1 / 0 && f === -1 / 0) && (f = a, g = e);
        });
        return f;
    }, n.min = function(a, b, c) {
        var d, e, f = 1 / 0, g = 1 / 0;
        if (null == b && null != a) {
            a = a.length === +a.length ? a : n.values(a);
            for (var h = 0, i = a.length; i > h; h++) d = a[h], f > d && (f = d);
        } else b = n.iteratee(b, c), n.each(a, function(a, c, d) {
            e = b(a, c, d), (g > e || 1 / 0 === e && 1 / 0 === f) && (f = a, g = e);
        });
        return f;
    }, n.shuffle = function(a) {
        for (var b, c = a && a.length === +a.length ? a : n.values(a), d = c.length, e = Array(d), f = 0; d > f; f++) b = n.random(0, f), 
        b !== f && (e[f] = e[b]), e[b] = c[f];
        return e;
    }, n.sample = function(a, b, c) {
        return null == b || c ? (a.length !== +a.length && (a = n.values(a)), a[n.random(a.length - 1)]) : n.shuffle(a).slice(0, Math.max(0, b));
    }, n.sortBy = function(a, b, c) {
        return b = n.iteratee(b, c), n.pluck(n.map(a, function(a, c, d) {
            return {
                value: a,
                index: c,
                criteria: b(a, c, d)
            };
        }).sort(function(a, b) {
            var c = a.criteria, d = b.criteria;
            if (c !== d) {
                if (c > d || void 0 === c) return 1;
                if (d > c || void 0 === d) return -1;
            }
            return a.index - b.index;
        }), "value");
    };
    var q = function(a) {
        return function(b, c, d) {
            var e = {};
            return c = n.iteratee(c, d), n.each(b, function(d, f) {
                var g = c(d, f, b);
                a(e, d, g);
            }), e;
        };
    };
    n.groupBy = q(function(a, b, c) {
        n.has(a, c) ? a[c].push(b) : a[c] = [ b ];
    }), n.indexBy = q(function(a, b, c) {
        a[c] = b;
    }), n.countBy = q(function(a, b, c) {
        n.has(a, c) ? a[c]++ : a[c] = 1;
    }), n.sortedIndex = function(a, b, c, d) {
        c = n.iteratee(c, d, 1);
        for (var e = c(b), f = 0, g = a.length; g > f; ) {
            var h = f + g >>> 1;
            c(a[h]) < e ? f = h + 1 : g = h;
        }
        return f;
    }, n.toArray = function(a) {
        return a ? n.isArray(a) ? g.call(a) : a.length === +a.length ? n.map(a, n.identity) : n.values(a) : [];
    }, n.size = function(a) {
        return null == a ? 0 : a.length === +a.length ? a.length : n.keys(a).length;
    }, n.partition = function(a, b, c) {
        b = n.iteratee(b, c);
        var d = [], e = [];
        return n.each(a, function(a, c, f) {
            (b(a, c, f) ? d : e).push(a);
        }), [ d, e ];
    }, n.first = n.head = n.take = function(a, b, c) {
        return null == a ? void 0 : null == b || c ? a[0] : 0 > b ? [] : g.call(a, 0, b);
    }, n.initial = function(a, b, c) {
        return g.call(a, 0, Math.max(0, a.length - (null == b || c ? 1 : b)));
    }, n.last = function(a, b, c) {
        return null == a ? void 0 : null == b || c ? a[a.length - 1] : g.call(a, Math.max(a.length - b, 0));
    }, n.rest = n.tail = n.drop = function(a, b, c) {
        return g.call(a, null == b || c ? 1 : b);
    }, n.compact = function(a) {
        return n.filter(a, n.identity);
    };
    var r = function(a, b, c, d) {
        if (b && n.every(a, n.isArray)) return h.apply(d, a);
        for (var e = 0, g = a.length; g > e; e++) {
            var i = a[e];
            n.isArray(i) || n.isArguments(i) ? b ? f.apply(d, i) : r(i, b, c, d) : c || d.push(i);
        }
        return d;
    };
    n.flatten = function(a, b) {
        return r(a, b, !1, []);
    }, n.without = function(a) {
        return n.difference(a, g.call(arguments, 1));
    }, n.uniq = n.unique = function(a, b, c, d) {
        if (null == a) return [];
        n.isBoolean(b) || (d = c, c = b, b = !1), null != c && (c = n.iteratee(c, d));
        for (var e = [], f = [], g = 0, h = a.length; h > g; g++) {
            var i = a[g];
            if (b) g && f === i || e.push(i), f = i; else if (c) {
                var j = c(i, g, a);
                n.indexOf(f, j) < 0 && (f.push(j), e.push(i));
            } else n.indexOf(e, i) < 0 && e.push(i);
        }
        return e;
    }, n.union = function() {
        return n.uniq(r(arguments, !0, !0, []));
    }, n.intersection = function(a) {
        if (null == a) return [];
        for (var b = [], c = arguments.length, d = 0, e = a.length; e > d; d++) {
            var f = a[d];
            if (!n.contains(b, f)) {
                for (var g = 1; c > g && n.contains(arguments[g], f); g++) ;
                g === c && b.push(f);
            }
        }
        return b;
    }, n.difference = function(a) {
        var b = r(g.call(arguments, 1), !0, !0, []);
        return n.filter(a, function(a) {
            return !n.contains(b, a);
        });
    }, n.zip = function(a) {
        if (null == a) return [];
        for (var b = n.max(arguments, "length").length, c = Array(b), d = 0; b > d; d++) c[d] = n.pluck(arguments, d);
        return c;
    }, n.object = function(a, b) {
        if (null == a) return {};
        for (var c = {}, d = 0, e = a.length; e > d; d++) b ? c[a[d]] = b[d] : c[a[d][0]] = a[d][1];
        return c;
    }, n.indexOf = function(a, b, c) {
        if (null == a) return -1;
        var d = 0, e = a.length;
        if (c) {
            if ("number" != typeof c) return d = n.sortedIndex(a, b), a[d] === b ? d : -1;
            d = 0 > c ? Math.max(0, e + c) : c;
        }
        for (;e > d; d++) if (a[d] === b) return d;
        return -1;
    }, n.lastIndexOf = function(a, b, c) {
        if (null == a) return -1;
        var d = a.length;
        for ("number" == typeof c && (d = 0 > c ? d + c + 1 : Math.min(d, c + 1)); --d >= 0; ) if (a[d] === b) return d;
        return -1;
    }, n.range = function(a, b, c) {
        arguments.length <= 1 && (b = a || 0, a = 0), c = c || 1;
        for (var d = Math.max(Math.ceil((b - a) / c), 0), e = Array(d), f = 0; d > f; f++, 
        a += c) e[f] = a;
        return e;
    };
    var s = function() {};
    n.bind = function(a, b) {
        var c, d;
        if (m && a.bind === m) return m.apply(a, g.call(arguments, 1));
        if (!n.isFunction(a)) throw new TypeError("Bind must be called on a function");
        return c = g.call(arguments, 2), d = function() {
            if (!(this instanceof d)) return a.apply(b, c.concat(g.call(arguments)));
            s.prototype = a.prototype;
            var e = new s();
            s.prototype = null;
            var f = a.apply(e, c.concat(g.call(arguments)));
            return n.isObject(f) ? f : e;
        };
    }, n.partial = function(a) {
        var b = g.call(arguments, 1);
        return function() {
            for (var c = 0, d = b.slice(), e = 0, f = d.length; f > e; e++) d[e] === n && (d[e] = arguments[c++]);
            for (;c < arguments.length; ) d.push(arguments[c++]);
            return a.apply(this, d);
        };
    }, n.bindAll = function(a) {
        var b, c, d = arguments.length;
        if (1 >= d) throw new Error("bindAll must be passed function names");
        for (b = 1; d > b; b++) c = arguments[b], a[c] = n.bind(a[c], a);
        return a;
    }, n.memoize = function(a, b) {
        var c = function(d) {
            var e = c.cache, f = b ? b.apply(this, arguments) : d;
            return n.has(e, f) || (e[f] = a.apply(this, arguments)), e[f];
        };
        return c.cache = {}, c;
    }, n.delay = function(a, b) {
        var c = g.call(arguments, 2);
        return setTimeout(function() {
            return a.apply(null, c);
        }, b);
    }, n.defer = function(a) {
        return n.delay.apply(n, [ a, 1 ].concat(g.call(arguments, 1)));
    }, n.throttle = function(a, b, c) {
        var d, e, f, g = null, h = 0;
        c || (c = {});
        var i = function() {
            h = c.leading === !1 ? 0 : n.now(), g = null, f = a.apply(d, e), g || (d = e = null);
        };
        return function() {
            var j = n.now();
            h || c.leading !== !1 || (h = j);
            var k = b - (j - h);
            return d = this, e = arguments, 0 >= k || k > b ? (clearTimeout(g), g = null, h = j, 
            f = a.apply(d, e), g || (d = e = null)) : g || c.trailing === !1 || (g = setTimeout(i, k)), 
            f;
        };
    }, n.debounce = function(a, b, c) {
        var d, e, f, g, h, i = function() {
            var j = n.now() - g;
            b > j && j > 0 ? d = setTimeout(i, b - j) : (d = null, c || (h = a.apply(f, e), 
            d || (f = e = null)));
        };
        return function() {
            f = this, e = arguments, g = n.now();
            var j = c && !d;
            return d || (d = setTimeout(i, b)), j && (h = a.apply(f, e), f = e = null), h;
        };
    }, n.wrap = function(a, b) {
        return n.partial(b, a);
    }, n.negate = function(a) {
        return function() {
            return !a.apply(this, arguments);
        };
    }, n.compose = function() {
        var a = arguments, b = a.length - 1;
        return function() {
            for (var c = b, d = a[b].apply(this, arguments); c--; ) d = a[c].call(this, d);
            return d;
        };
    }, n.after = function(a, b) {
        return function() {
            return --a < 1 ? b.apply(this, arguments) : void 0;
        };
    }, n.before = function(a, b) {
        var c;
        return function() {
            return --a > 0 ? c = b.apply(this, arguments) : b = null, c;
        };
    }, n.once = n.partial(n.before, 2), n.keys = function(a) {
        if (!n.isObject(a)) return [];
        if (l) return l(a);
        var b = [];
        for (var c in a) n.has(a, c) && b.push(c);
        return b;
    }, n.values = function(a) {
        for (var b = n.keys(a), c = b.length, d = Array(c), e = 0; c > e; e++) d[e] = a[b[e]];
        return d;
    }, n.pairs = function(a) {
        for (var b = n.keys(a), c = b.length, d = Array(c), e = 0; c > e; e++) d[e] = [ b[e], a[b[e]] ];
        return d;
    }, n.invert = function(a) {
        for (var b = {}, c = n.keys(a), d = 0, e = c.length; e > d; d++) b[a[c[d]]] = c[d];
        return b;
    }, n.functions = n.methods = function(a) {
        var b = [];
        for (var c in a) n.isFunction(a[c]) && b.push(c);
        return b.sort();
    }, n.extend = function(a) {
        if (!n.isObject(a)) return a;
        for (var b, c, d = 1, e = arguments.length; e > d; d++) {
            b = arguments[d];
            for (c in b) j.call(b, c) && (a[c] = b[c]);
        }
        return a;
    }, n.pick = function(a, b, c) {
        var d, e = {};
        if (null == a) return e;
        if (n.isFunction(b)) {
            b = o(b, c);
            for (d in a) {
                var f = a[d];
                b(f, d, a) && (e[d] = f);
            }
        } else {
            var i = h.apply([], g.call(arguments, 1));
            a = new Object(a);
            for (var j = 0, k = i.length; k > j; j++) d = i[j], d in a && (e[d] = a[d]);
        }
        return e;
    }, n.omit = function(a, b, c) {
        if (n.isFunction(b)) b = n.negate(b); else {
            var d = n.map(h.apply([], g.call(arguments, 1)), String);
            b = function(a, b) {
                return !n.contains(d, b);
            };
        }
        return n.pick(a, b, c);
    }, n.defaults = function(a) {
        if (!n.isObject(a)) return a;
        for (var b = 1, c = arguments.length; c > b; b++) {
            var d = arguments[b];
            for (var e in d) void 0 === a[e] && (a[e] = d[e]);
        }
        return a;
    }, n.clone = function(a) {
        return n.isObject(a) ? n.isArray(a) ? a.slice() : n.extend({}, a) : a;
    }, n.tap = function(a, b) {
        return b(a), a;
    };
    var t = function(a, b, c, d) {
        if (a === b) return 0 !== a || 1 / a === 1 / b;
        if (null == a || null == b) return a === b;
        a instanceof n && (a = a._wrapped), b instanceof n && (b = b._wrapped);
        var e = i.call(a);
        if (e !== i.call(b)) return !1;
        switch (e) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a == "" + b;

          case "[object Number]":
            return +a !== +a ? +b !== +b : 0 === +a ? 1 / +a === 1 / b : +a === +b;

          case "[object Date]":
          case "[object Boolean]":
            return +a === +b;
        }
        if ("object" != typeof a || "object" != typeof b) return !1;
        for (var f = c.length; f--; ) if (c[f] === a) return d[f] === b;
        var g = a.constructor, h = b.constructor;
        if (g !== h && "constructor" in a && "constructor" in b && !(n.isFunction(g) && g instanceof g && n.isFunction(h) && h instanceof h)) return !1;
        c.push(a), d.push(b);
        var j, k;
        if ("[object Array]" === e) {
            if (j = a.length, k = j === b.length) for (;j-- && (k = t(a[j], b[j], c, d)); ) ;
        } else {
            var l, m = n.keys(a);
            if (j = m.length, k = n.keys(b).length === j) for (;j-- && (l = m[j], k = n.has(b, l) && t(a[l], b[l], c, d)); ) ;
        }
        return c.pop(), d.pop(), k;
    };
    n.isEqual = function(a, b) {
        return t(a, b, [], []);
    }, n.isEmpty = function(a) {
        if (null == a) return !0;
        if (n.isArray(a) || n.isString(a) || n.isArguments(a)) return 0 === a.length;
        for (var b in a) if (n.has(a, b)) return !1;
        return !0;
    }, n.isElement = function(a) {
        return !(!a || 1 !== a.nodeType);
    }, n.isArray = k || function(a) {
        return "[object Array]" === i.call(a);
    }, n.isObject = function(a) {
        var b = typeof a;
        return "function" === b || "object" === b && !!a;
    }, n.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(a) {
        n["is" + a] = function(b) {
            return i.call(b) === "[object " + a + "]";
        };
    }), n.isArguments(arguments) || (n.isArguments = function(a) {
        return n.has(a, "callee");
    }), "function" != typeof /./ && (n.isFunction = function(a) {
        return "function" == typeof a || !1;
    }), n.isFinite = function(a) {
        return isFinite(a) && !isNaN(parseFloat(a));
    }, n.isNaN = function(a) {
        return n.isNumber(a) && a !== +a;
    }, n.isBoolean = function(a) {
        return a === !0 || a === !1 || "[object Boolean]" === i.call(a);
    }, n.isNull = function(a) {
        return null === a;
    }, n.isUndefined = function(a) {
        return void 0 === a;
    }, n.has = function(a, b) {
        return null != a && j.call(a, b);
    }, n.noConflict = function() {
        return a._ = b, this;
    }, n.identity = function(a) {
        return a;
    }, n.constant = function(a) {
        return function() {
            return a;
        };
    }, n.noop = function() {}, n.property = function(a) {
        return function(b) {
            return b[a];
        };
    }, n.matches = function(a) {
        var b = n.pairs(a), c = b.length;
        return function(a) {
            if (null == a) return !c;
            a = new Object(a);
            for (var d = 0; c > d; d++) {
                var e = b[d], f = e[0];
                if (e[1] !== a[f] || !(f in a)) return !1;
            }
            return !0;
        };
    }, n.times = function(a, b, c) {
        var d = Array(Math.max(0, a));
        b = o(b, c, 1);
        for (var e = 0; a > e; e++) d[e] = b(e);
        return d;
    }, n.random = function(a, b) {
        return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
    }, n.now = Date.now || function() {
        return new Date().getTime();
    };
    var u = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, v = n.invert(u), w = function(a) {
        var b = function(b) {
            return a[b];
        }, c = "(?:" + n.keys(a).join("|") + ")", d = RegExp(c), e = RegExp(c, "g");
        return function(a) {
            return a = null == a ? "" : "" + a, d.test(a) ? a.replace(e, b) : a;
        };
    };
    n.escape = w(u), n.unescape = w(v), n.result = function(a, b) {
        if (null != a) {
            var c = a[b];
            return n.isFunction(c) ? a[b]() : c;
        }
    };
    var x = 0;
    n.uniqueId = function(a) {
        var b = ++x + "";
        return a ? a + b : b;
    }, n.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var y = /(.)^/, z = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, A = /\\|'|\r|\n|\u2028|\u2029/g, B = function(a) {
        return "\\" + z[a];
    };
    n.template = function(a, b, c) {
        !b && c && (b = c), b = n.defaults({}, b, n.templateSettings);
        var d = RegExp([ (b.escape || y).source, (b.interpolate || y).source, (b.evaluate || y).source ].join("|") + "|$", "g"), e = 0, f = "__p+='";
        a.replace(d, function(b, c, d, g, h) {
            return f += a.slice(e, h).replace(A, B), e = h + b.length, c ? f += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'" : d ? f += "'+\n((__t=(" + d + "))==null?'':__t)+\n'" : g && (f += "';\n" + g + "\n__p+='"), 
            b;
        }), f += "';\n", b.variable || (f = "with(obj||{}){\n" + f + "}\n"), f = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + f + "return __p;\n";
        try {
            var g = new Function(b.variable || "obj", "_", f);
        } catch (a) {
            throw a.source = f, a;
        }
        var h = function(a) {
            return g.call(this, a, n);
        }, i = b.variable || "obj";
        return h.source = "function(" + i + "){\n" + f + "}", h;
    }, n.chain = function(a) {
        var b = n(a);
        return b._chain = !0, b;
    };
    var C = function(a) {
        return this._chain ? n(a).chain() : a;
    };
    n.mixin = function(a) {
        n.each(n.functions(a), function(b) {
            var c = n[b] = a[b];
            n.prototype[b] = function() {
                var a = [ this._wrapped ];
                return f.apply(a, arguments), C.call(this, c.apply(n, a));
            };
        });
    }, n.mixin(n), n.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(a) {
        var b = c[a];
        n.prototype[a] = function() {
            var c = this._wrapped;
            return b.apply(c, arguments), "shift" !== a && "splice" !== a || 0 !== c.length || delete c[0], 
            C.call(this, c);
        };
    }), n.each([ "concat", "join", "slice" ], function(a) {
        var b = c[a];
        n.prototype[a] = function() {
            return C.call(this, b.apply(this._wrapped, arguments));
        };
    }), n.prototype.value = function() {
        return this._wrapped;
    }, "function" == typeof define && define.amd && define("underscore", [], function() {
        return n;
    });
}.call(this), BEE.version = "0.1", BEE.authors = [ {
    name: "Marco Stagni",
    website: "http://marcostagni.com"
} ], BEE.MAX_CHILDREN_COUNT = 2, BEE.MAX_PARENTS_COUNT = 1, BEE.MAX_ID_SIZE = 12, 
BEE.MAX_ROOT_NUMBER = 1, BEE.VALID_BEE = "Please use a valid BEE object.", BEE.UNTOUCHABLE = "Untouchable value. Get away.", 
BEE.VALID_BRANCH = "Please specify a valid branch.", BEE.NO_MORE_CHILDREN = "No more children allowed for this node.", 
BEE.NO_MORE_PARENTS = "This node already have a parent.", BEE.ERROR_NO_LEAVES = "Sorry, something wrong in your BEE. There are no leaves :(", 
BEE.ERROR_NO_PARENTS = "Sorry, something wrong in your BEE. There are no leaves :(", 
BEE.ERROR_STRANGE_ROOTS = "Sorry, something wrong in your BEE. Strange number of root nodes", 
BEE.ERROR_ALREADY_LEFT = "Sorry, this node already have a left branch.", BEE.ERROR_ALREADY_RIGHT = "Sorry, this node already have a right branch.", 
BEE.BAD_ARGUMENTS = "BAD ARGUMENTS, please check them.", BEE.prototype.createNode = function(a) {
    var b = new Node({
        tree: this,
        data: a
    });
    return b;
}, BEE.prototype.getAllLeaves = function() {
    var a = [];
    for (var b in this.nodes) this.nodes[b]._isLeaf && a.push(this.nodes[b]);
    if (0 == a.length) throw BEE.ERROR_NO_LEAVES;
    return a;
}, BEE.prototype.getRootNode = function() {
    var a = [];
    for (var b in this.nodes) this.nodes[b]._isRoot && a.push(this.nodes[b]);
    if (1 != a.length) throw BEE.ERROR_STRANGE_ROOTS;
    return a[0];
}, BEE.prototype.getAllParents = function() {
    var a = [];
    for (var b in this.nodes) this.nodes[b]._isParent && a.push(this.nodes[b]);
    if (0 == a.length) throw BEE.ERROR_NO_PARENTS;
    return a;
}, BEE.prototype.getPath = function(a) {
    var b, c, d = [];
    for (d.push({
        n: a,
        w: void 0
    }), b = a.parent, c = a; b; ) {
        var e = b.leftBranch._id == c._id ? b.leftWeight : b.rightWeight;
        d.push({
            n: b,
            w: e
        }), c = b, b = b.parent;
    }
    return d.reverse();
}, BEE.prototype.each = function(a, b) {
    var c = 0;
    if ("function" != typeof a) throw BEE.BAD_ARGUMENTS;
    "post" == b ? (console.log("inside post"), console.log(this.getRootNode()), _postEach(a, c, this.getRootNode())) : "pre" == b ? _preEach(a, c, this.getRootNode()) : _defEach(a, c, this.getRootNode());
}, BEE.prototype.has = function(a, b, c) {
    if ("function" != typeof b) throw BEE.BAD_ARGUMENTS;
    var d;
    if (c) if (_s = c.toLowerCase(), "ltr" == _s) d = _hasLTR(a, this.getRootNode(), b); else {
        if ("rtl" != _s) throw BEE.BAD_ARGUMENTS;
        d = _hasRTL(a, this.getRootNode(), b);
    } else d = _hasLTR(a, this.getRootNode(), b);
    return d;
}, BEE.prototype.orderedHas = function(a, b) {
    return _orderedIns(a, this.getRootNode(), b);
}, BEE.prototype.height = function() {
    var a = _height(this.getRootNode());
    return a;
}, BEE.prototype.orderedIns = function(a, b) {
    try {
        _orderedIns(a, this.getRootNode(), b);
    } catch (a) {
        return console.log("Something bad happened in ordIns"), !1;
    }
}, BEE.prototype.buildNode = function(a, b, c) {
    var d = this.createNode(a);
    return d.addLeaf(b, {
        branch: "left"
    }), d.addLeaf(c, {
        branch: "right"
    }), d;
}, Node.prototype.setRoot = function(a) {
    this._isRoot = a;
}, Node.prototype.setParent = function(a) {
    this._isParent = a;
}, Node.prototype.setLeaf = function(a) {
    this._isLeaf = a;
}, Node.prototype.update = function() {
    0 == this.children ? 0 == this.parents ? (this.setLeaf(!1), this.setRoot(!0), this.setParent(!1)) : (this.setLeaf(!0), 
    this.setRoot(!1), this.setParent(!1)) : 0 == this.parents ? (this.setLeaf(!1), this.setRoot(!0), 
    this.setParent(!0)) : (this.setLeaf(!1), this.setRoot(!1), this.setParent(!0));
}, Node.prototype.addLeaf = function(a, b) {
    if (this.children + 1 > BEE.MAX_CHILDREN_COUNT) throw BEE.NO_MORE_CHILDREN;
    if (!b.branch) throw BEE.BAD_ARGUMENTS;
    if ("left" == b.branch) {
        if (this.leftBranch) throw BEE.ERROR_ALREADY_LEFT;
        this.leftBranch = a, this.leftWeight = b.weights && b.weights.l ? b.weights.l : 0;
    } else {
        if ("right" != b.branch) throw BEE.VALID_BRANCH;
        if (this.rightBranch) throw BEE.ERROR_ALREADY_RIGHT;
        this.rightBranch = a, this.rightWeight = b.weights && b.weights.r ? b.weights.r : 1;
    }
    this.children += 1, a.parent = this, a.parents = 1, this.update(), a.update();
}, Node.prototype.addParent = function(a, b) {
    if (this.parents + 1 > BEE.MAX_PARENTS_COUNT) throw BEE.NO_MORE_PARENTS;
    if (a.children + 1 > BEE.MAX_CHILDREN_COUNT) throw BEE.NO_MORE_CHILDREN;
    a.addLeaf(this, b);
};

var __pool__ = {};

__class__ = function(a, b) {
    this.name = a, this.methods = b;
}, __class__.prototype.has = {}.hasOwnProperty, __class__.prototype._extends = function(a) {
    var b = (window[this.name], "string" == typeof a ? window[a] : a);
    if (!b) throw "NO UPPER CLASS";
    window[this.name].prototype = Object.create(b.prototype), window[this.name].prototype.constructor = window[this.name], 
    this._setMethods(), window[this.name].prototype.__getSuper = function() {
        return b;
    }, window.subClasses = window.subClasses || {}, window.subClasses[a] || (window.subClasses[a] = this.name), 
    window[this.name].prototype._super = "string" == typeof a ? window[a].call : a.call;
}, __class__.prototype._setMethods = function() {
    for (var a in this.methods) a != this.name && (window[__upperCaseFirstLetter__(this.name)].prototype[a] = this.methods[a]);
}, HashMap.prototype.clear = function() {
    for (key in this.map) this.map["" + key] = void 0;
    this.total = 0, this.keys = new Array();
}, HashMap.prototype.clone = function() {
    var a = new HashMap();
    for (key in this.map) a.map["" + key] = this.map["" + key];
    return a;
}, HashMap.prototype.containsKey = function(a) {
    var b = !1;
    for (innerkey in this.map) if (innerkey == a) {
        b = !0;
        break;
    }
    return b;
}, HashMap.prototype.containsValue = function(a) {
    var b = !1;
    for (key in this.map) if (this.map["" + key] == a) {
        b = !0;
        break;
    }
    return b;
}, HashMap.prototype.get = function(a) {
    for (innerkey in this.map) if (innerkey == a) return this.map["" + innerkey];
    return null;
}, HashMap.prototype.isEmpty = function() {
    return 0 == this.total;
}, HashMap.prototype.put = function(a, b) {
    return this.maxDimension ? this.total < this.maxDimension && (this.map["" + a] = b, 
    this.keys.push(a), this.total += 1, !0) : (this.map["" + a] = b, this.keys.push(a), 
    this.total += 1, !0);
}, HashMap.prototype.remove = function(a) {
    try {
        for (innerkey in this.map) if (innerkey == a) {
            for (var b = this.keys.indexOf(innerkey), c = new Array(), d = 0; d < this.keys.length; d++) d != b && c.push(this.keys[d]);
            return this.keys = new Array(), this.keys = c, delete this.map["" + innerkey], this.total = 0, 
            !0;
        }
        return !1;
    } catch (a) {
        return console.log("HASHMAP ERROR "), console.error(a), console.trace(), !1;
    }
}, HashMap.prototype.size = function() {
    return this.total;
}, THREE.FlyControls = function(a, b) {
    function c(a, b) {
        return function() {
            b.apply(a, arguments);
        };
    }
    this.object = a, this.domElement = void 0 !== b ? b : document, b && this.domElement.setAttribute("tabindex", -1), 
    this.movementSpeed = 1, this.rollSpeed = .005, this.dragToLook = !1, this.autoForward = !1, 
    this.tmpQuaternion = new THREE.Quaternion(), this.mouseStatus = 0, this.moveState = {
        up: 0,
        down: 0,
        left: 0,
        right: 0,
        forward: 0,
        back: 0,
        pitchUp: 0,
        pitchDown: 0,
        yawLeft: 0,
        yawRight: 0,
        rollLeft: 0,
        rollRight: 0
    }, this.moveVector = new THREE.Vector3(0, 0, 0), this.rotationVector = new THREE.Vector3(0, 0, 0), 
    this.handleEvent = function(a) {
        "function" == typeof this[a.type] && this[a.type](a);
    }, this.keydown = function(a) {
        if (!a.altKey) {
            switch (a.keyCode) {
              case 16:
                this.movementSpeedMultiplier = .1;
                break;

              case 87:
                this.moveState.forward = 1;
                break;

              case 83:
                this.moveState.back = 1;
                break;

              case 65:
                this.moveState.left = 1;
                break;

              case 68:
                this.moveState.right = 1;
                break;

              case 82:
                this.moveState.up = 1;
                break;

              case 70:
                this.moveState.down = 1;
                break;

              case 38:
                this.moveState.pitchUp = 1;
                break;

              case 40:
                this.moveState.pitchDown = 1;
                break;

              case 37:
                this.moveState.yawLeft = 1;
                break;

              case 39:
                this.moveState.yawRight = 1;
                break;

              case 81:
                this.moveState.rollLeft = 1;
                break;

              case 69:
                this.moveState.rollRight = 1;
            }
            this.updateMovementVector(), this.updateRotationVector();
        }
    }, this.keyup = function(a) {
        switch (a.keyCode) {
          case 16:
            this.movementSpeedMultiplier = 1;
            break;

          case 87:
            this.moveState.forward = 0;
            break;

          case 83:
            this.moveState.back = 0;
            break;

          case 65:
            this.moveState.left = 0;
            break;

          case 68:
            this.moveState.right = 0;
            break;

          case 82:
            this.moveState.up = 0;
            break;

          case 70:
            this.moveState.down = 0;
            break;

          case 38:
            this.moveState.pitchUp = 0;
            break;

          case 40:
            this.moveState.pitchDown = 0;
            break;

          case 37:
            this.moveState.yawLeft = 0;
            break;

          case 39:
            this.moveState.yawRight = 0;
            break;

          case 81:
            this.moveState.rollLeft = 0;
            break;

          case 69:
            this.moveState.rollRight = 0;
        }
        this.updateMovementVector(), this.updateRotationVector();
    }, this.mousedown = function(a) {
        if (this.domElement !== document && this.domElement.focus(), a.preventDefault(), 
        a.stopPropagation(), this.dragToLook) this.mouseStatus++; else {
            switch (a.button) {
              case 0:
                this.moveState.forward = 1;
                break;

              case 2:
                this.moveState.back = 1;
            }
            this.updateMovementVector();
        }
    }, this.mousemove = function(a) {
        if (!this.dragToLook || this.mouseStatus > 0) {
            var b = this.getContainerDimensions(), c = b.size[0] / 2, d = b.size[1] / 2;
            this.moveState.yawLeft = -(a.pageX - b.offset[0] - c) / c, this.moveState.pitchDown = (a.pageY - b.offset[1] - d) / d, 
            this.updateRotationVector();
        }
    }, this.mouseup = function(a) {
        if (a.preventDefault(), a.stopPropagation(), this.dragToLook) this.mouseStatus--, 
        this.moveState.yawLeft = this.moveState.pitchDown = 0; else {
            switch (a.button) {
              case 0:
                this.moveState.forward = 0;
                break;

              case 2:
                this.moveState.back = 0;
            }
            this.updateMovementVector();
        }
        this.updateRotationVector();
    }, this.update = function(a) {
        var b = a * this.movementSpeed, c = a * this.rollSpeed;
        this.object.translateX(this.moveVector.x * b), this.object.translateY(this.moveVector.y * b), 
        this.object.translateZ(this.moveVector.z * b), this.tmpQuaternion.set(this.rotationVector.x * c, this.rotationVector.y * c, this.rotationVector.z * c, 1).normalize(), 
        this.object.quaternion.multiply(this.tmpQuaternion), this.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order);
    }, this.updateMovementVector = function() {
        var a = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0;
        this.moveVector.x = -this.moveState.left + this.moveState.right, this.moveVector.y = -this.moveState.down + this.moveState.up, 
        this.moveVector.z = -a + this.moveState.back;
    }, this.updateRotationVector = function() {
        this.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp, this.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft, 
        this.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft;
    }, this.getContainerDimensions = function() {
        return this.domElement != document ? {
            size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
            offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]
        } : {
            size: [ window.innerWidth, window.innerHeight ],
            offset: [ 0, 0 ]
        };
    }, this.domElement.addEventListener("contextmenu", function(a) {
        a.preventDefault();
    }, !1), this.domElement.addEventListener("mousemove", c(this, this.mousemove), !1), 
    this.domElement.addEventListener("mousedown", c(this, this.mousedown), !1), this.domElement.addEventListener("mouseup", c(this, this.mouseup), !1), 
    this.domElement.addEventListener("keydown", c(this, this.keydown), !1), this.domElement.addEventListener("keyup", c(this, this.keyup), !1), 
    this.updateMovementVector(), this.updateRotationVector();
}, THREE.PointerLockControls = function(a) {
    var b = this;
    a.rotation.set(0, 0, 0);
    var c = new THREE.Object3D();
    c.add(a);
    var d = new THREE.Object3D();
    d.position.y = 10, d.add(c);
    var e = !1, f = !1, g = !1, h = !1, i = !1, j = !1, k = new THREE.Vector3(), m = Math.PI / 2, n = function(a) {
        if (b.enabled !== !1) {
            var e = a.movementX || a.mozMovementX || a.webkitMovementX || 0, f = a.movementY || a.mozMovementY || a.webkitMovementY || 0;
            d.rotation.y -= .002 * e, c.rotation.x -= .002 * f, c.rotation.x = Math.max(-m, Math.min(m, c.rotation.x));
        }
    }, o = function(a) {
        switch (l("inside pointer lock controls onKeyDown " + a.keyCode), a.keyCode) {
          case 38:
          case 87:
            e = !0;
            break;

          case 37:
          case 65:
            g = !0;
            break;

          case 40:
          case 83:
            f = !0;
            break;

          case 39:
          case 68:
            h = !0;
            break;

          case 32:
            j === !0 && (k.y += 10), j = !1;
        }
    }, p = function(a) {
        switch (a.keyCode) {
          case 38:
          case 87:
            e = !1;
            break;

          case 37:
          case 65:
            g = !1;
            break;

          case 40:
          case 83:
            f = !1;
            break;

          case 39:
          case 68:
            h = !1;
        }
    };
    document.addEventListener("mousemove", n, !1), document.addEventListener("keydown", o, !1), 
    document.addEventListener("keyup", p, !1), this.enabled = !1, this.getObject = function() {
        return d;
    }, this.isOnObject = function(a) {
        i = a, j = a;
    }, this.getDirection = function() {
        var a = new THREE.Vector3(0, 0, -1), b = new THREE.Euler(0, 0, 0, "YXZ");
        return function(e) {
            return b.set(c.rotation.x, d.rotation.y, 0), e.copy(a).applyEuler(b), e;
        };
    }(), this.update = function(a) {
        if (b.enabled === !1) return void l("pointerlock not enabled. please enable it.");
        a *= .1, k.y -= .25 * a;
        var c = .1;
        e && (k.z = -c), f && (k.z = c), f || e || (k.z = 0), g && (k.x = -c), h && (k.x = c), 
        h || g || (k.x = 0), i === !0 && (k.y = Math.max(0, k.y)), d.translateX(k.x), d.translateY(k.y), 
        d.translateZ(k.z), d.position.y < 10 && (k.y = 0, d.position.y = 10, j = !0);
    };
}, Class("Entity", {
    Entity: function() {},
    start: function() {},
    update: function() {},
    addScript: function(a, b) {
        var c = Game.SCRIPTS_DIR + (b || "");
        "/" != c[c.length - 1] && (c += "/"), Game.attachScriptToObject(this, a, c);
    },
    __loadScript: function(a) {
        for (var b in a) this[b] = a[b];
        try {
            this.start();
        } catch (b) {
            console.log("I told you, man. Check your start method inside your " + a.name + ".js script");
        }
    },
    addSound: function(a, b) {
        var c = b.autoplay || !1;
        this.isPlayingSound = c, this.sound = new Sound(a, {
            mesh: this.mesh,
            autoplay: c,
            effect: b.effect
        });
    },
    addDirectionalSound: function(a, b) {
        var c = b.autoplay || !1;
        this.isPlayingSound = c, this.sound = new DirectionalSound(a, {
            mesh: this.mesh,
            autoplay: c,
            effect: b.effect
        });
    },
    addAmbientSound: function(a, b) {
        var c = b.autoplay || !1, d = b.loop || !1;
        this.isPlayingSound = c, this.sound = new AmbientSound(a, {
            mesh: this.mesh,
            autoplay: c,
            loop: d,
            effect: b.effect
        });
    },
    addMesh: function(a) {
        this.mesh.add(a);
    },
    addLight: function(a, b, c) {
        var d = {
            x: this.mesh.position.x,
            y: this.mesh.position.y,
            z: this.mesh.position.z
        };
        this.light = new PointLight(a, b, c, d), this.addMesh(this.light.mesh.mesh);
    },
    playSound: function() {
        this.sound && (this.isPlayingSound || (this.sound.start(), this.isPlayingSound = !0));
    },
    stopSound: function() {
        this.sound && this.isPlayingSound && (this.sound.stop(), this.isPlayingSound = !1);
    },
    scale: function(a, b, c) {
        this.mesh && this.mesh.scale.set(a, b, c);
    }
}), Class("Camera", {
    Camera: function(a) {
        Entity.call(this), this.options = a, this.object = new THREE.PerspectiveCamera(a.fov, a.ratio, a.near, a.far);
    }
})._extends("Entity"), Class("Mesh", {
    Mesh: function(a, b, c) {
        if (Entity.call(this), this.geometry = a, this.material = b, this.script = {}, this.hasScript = !1, 
        this.mesh = new THREE.Mesh(a, b), app.util.cast_shadow && (this.mesh.castShadow = !0, 
        this.mesh.receiveShadow = !0), app.add(this.mesh, this), c) for (var d in c) this[d] = c[d], 
        "script" == d && (this.hasScript = !0, this.addScript(c[d], c.dir));
    }
})._extends("Entity"), Class("ShaderMesh", {
    ShaderMesh: function(a, b, c, d, e) {
        Entity.call(this), this.geometry = a, this.attributes = c, this.uniforms = d, this.shaderName = b;
        var f = new Shader(this.shaderName, this.attributes, this.uniforms);
        if (c || (this.attributes = f.attributes), d || (this.uniforms = f.uniforms), this.script = {}, 
        this.hasScript = !1, this.mesh = new THREE.Mesh(a, f.material), app.add(this.mesh, this), 
        e) for (var g in e) this[g] = e[g], "script" == g && (this.hasScript = !0, this.addScript(e[g], e.dir));
    }
})._extends("Entity"), Class("AnimatedMesh", {
    AnimatedMesh: function(a, b, c) {
        Entity.call(this), this.animations = {}, this.weightSchedule = [], this.warpSchedule = [];
        var d = b[0];
        d.skinning = !0, this.meshVisible = !0, this.mesh = new THREE.SkinnedMesh(a, d), 
        this.mesh.visible = this.meshVisible, app.add(this.mesh, this);
        for (var e = 0; e < a.animations.length; ++e) {
            var f = a.animations[e].name;
            this.animations[f] = new THREE.Animation(this.mesh, a.animations[e]);
        }
        if (this.skeleton = new THREE.SkeletonHelper(this.mesh), this.skeleton.material.linediwth = 3, 
        this.mesh.add(this.skeleton), this.skeletonVisible = !1, this.skeleton.visible = this.skeletonVisible, 
        c) for (var g in c) this[g] = c[g], "script" == g && (this.hasScript = !0, this.addScript(c[g], c.dir));
    },
    toggleSkeleton: function() {
        this.skeletonVisible = !this.skeletonVisible, this.skeleton.visible = this.skeletonVisible;
    },
    toggleModel: function() {
        this.meshVisible = !this.meshVisible, this.mesh.visible = this.meshVisible;
    },
    setWeights: function(a) {
        for (name in a) this.animations[name] && (this.animations[name].weight = a[name]);
    },
    update: function(a) {
        this.animate(a);
    },
    animate: function(a) {
        for (var b = this.weightSchedule.length - 1; b >= 0; --b) {
            var c = this.weightSchedule[b];
            c.timeElapsed += a, c.timeElapsed > c.duration ? (c.anim.weight = c.endWeight, this.weightSchedule.splice(b, 1), 
            0 == c.anim.weight && c.anim.stop(0)) : c.anim.weight = c.startWeight + (c.endWeight - c.startWeight) * c.timeElapsed / c.duration;
        }
        this.updateWarps(a), this.skeleton.update(), THREE.AnimationHandler.update(a);
    },
    updateWarps: function(a) {
        for (var b = this.warpSchedule.length - 1; b >= 0; --b) {
            var c = this.warpSchedule[b];
            if (c.timeElapsed += a, c.timeElapsed > c.duration) c.to.weight = 1, c.to.timeScale = 1, 
            c.from.weight = 0, c.from.timeScale = 1, c.from.stop(0), this.warpSchedule.splice(b, 1); else {
                var d = c.timeElapsed / c.duration, e = c.from.data.length, f = c.to.data.length, g = e / f, h = f / e;
                c.from.timeScale = 1 - d + g * d, c.to.timeScale = d + h * (1 - d), c.from.weight = 1 - d, 
                c.to.weight = d;
            }
        }
    },
    play: function(a) {
        var b = void 0 === this.animations[a].weight ? this.animations[a] : 1;
        this.animations[a].play(0, b);
    },
    crossfade: function(a, b, c) {
        var d = this.animations[a], e = this.animations[b];
        d.play(0, 1), e.play(0, 0), this.weightSchedule.push({
            anim: d,
            startWeight: 1,
            endWeight: 0,
            timeElapsed: 0,
            duration: c
        }), this.weightSchedule.push({
            anim: e,
            startWeight: 0,
            endWeight: 1,
            timeElapsed: 0,
            duration: c
        });
    },
    warp: function(a, b, c) {
        var d = this.animations[a], e = this.animations[b];
        d.play(0, 1), e.play(0, 0), this.warpSchedule.push({
            from: d,
            to: e,
            timeElapsed: 0,
            duration: c
        });
    },
    applyWeight: function(a, b) {
        this.animations[a].weight = b;
    },
    pauseAll: function() {
        for (var a in this.animations) this.animations[a].isPlaying && this.animations[a].stop();
    },
    unPauseAll: function() {
        for (var a in this.animations) this.animations[a].isPlaying && this.animations[a].isPaused && this.animations[a].pause();
    },
    stopAll: function() {
        for (a in this.animations) this.animations[a].isPlaying && this.animations[a].stop(0), 
        this.animations[a].weight = 0;
        this.weightSchedule.length = 0, this.warpSchedule.length = 0;
    },
    getForward: function() {
        var a = new THREE.Vector3();
        return function() {
            return a.set(-this.matrix.elements[8], -this.matrix.elements[9], -this.matrix.elements[10]), 
            a;
        };
    }
})._extends("Entity"), function() {
    window.LightEngine = {
        delayFactor: .1,
        delayStep: 30,
        holderRadius: .01,
        holderSegments: 1,
        init: function() {
            LightEngine.map = new HashMap(), LightEngine.lights = [];
        },
        numLights: 0,
        add: function(a) {
            LightEngine.lights.push(a);
        },
        update: function() {
            var a = new Date();
            for (var b in LightEngine.lights) {
                var c = LightEngine.lights[b];
                if (c.update(app.clock.getDelta()), +new Date() - a > 50) return;
            }
        }
    }, LightEngine.init();
}(), Class("Light", {
    Light: function(a, b, c) {
        Entity.call(this), this.color = a, this.intensity = b, this.position = c || {
            x: 0,
            y: 0,
            z: 0
        }, this.isLightOn = !1, this.mesh = void 0, LightEngine.add(this);
    },
    on: function() {
        if (this.light) {
            var a = this, b = function() {
                a.light.intensity += LightEngine.delayFactor, a.light.intensity < a.intensity ? setTimeout(b, LightEngine.delayStep) : a.isLightOn = !0;
            };
            b();
        } else console.log("You should create your light, first");
    },
    off: function() {
        if (this.light) {
            var a = this, b = function() {
                a.light.intensity -= LightEngine.delayFactor, a.light.intensity > 0 ? setTimeout(b, LightEngine.delayStep) : a.isLightOn = !1;
            };
            b();
        } else console.log("You should create your light, first");
    }
})._extends("Entity"), Class("AmbientLight", {
    AmbientLight: function(a, b, c) {
        var d = b ? b : 1, e = c ? c : new THREE.Vector3(0, 0, 0);
        Light.call(this, a, d, e), this.light = new THREE.AmbientLight(a), app.add(this.light, this);
    }
})._extends("Light"), Class("PointLight", {
    PointLight: function(a, b, c, d) {
        Light.call(this, a, b, d), this.geometry = new THREE.SphereGeometry(LightEngine.holderRadius, LightEngine.holderSegment, LightEngine.holderSegment), 
        this.material = new THREE.MeshPhongMaterial({
            color: this.color
        }), this.mesh = new Mesh(this.geometry, this.material), this.light = new THREE.PointLight(a, b, c), 
        this.mesh.mesh.position.set(this.position.x, this.position.y, this.position.z), 
        this.light.position = this.mesh.mesh.position, this.mesh.mesh.add(this.light);
    }
})._extends("Light"), Class("DirectionalLight", {
    DirectionalLight: function(a, b, c, d, e) {
        Light.call(this, a, b, d), this.light = new THREE.DirectionalLight(a, b), e && this.light.target.position.copy(e.position), 
        this.light.position.set(d.x, d.y, d.z), this.light.castShadow = !0, this.light.shadow.mapSize.width = 512, 
        this.light.shadow.mapSize.height = 512;
        var f = 300;
        this.light.shadow.camera.left = -f, this.light.shadow.camera.right = f, this.light.shadow.camera.top = f, 
        this.light.shadow.camera.bottom = -f, this.light.shadow.camera.far = 1e3, app.add(this.light, this);
    }
})._extends("Light"), window.Control = {}, Control = {
    type: void 0,
    allowedTypes: [ "fly", "fps", "custom" ],
    oldType: void 0,
    handler: void 0,
    clock: void 0,
    options: {
        fps: {
            height: 5,
            mouseFactor: .002,
            jumpHeight: 5,
            fallFactor: .25,
            delta: .1,
            velocity: .5,
            crouch: .25
        },
        fly: {}
    },
    set: function(a) {
        var b = "" + a, c = Control.allowedTypes.indexOf(b);
        if (c != -1) switch (c) {
          case 0:
            1 == Control.oldType && (document.removeEventListener("pointerlockchange", Control.internal_pointerlockchange, !1), 
            document.removeEventListener("mozpointerlockchange", Control.internal_pointerlockchange, !1), 
            document.removeEventListener("webkitpointerlockchange", Control.internal_pointerlockchange, !1), 
            document.removeEventListener("pointerlockerror", Control.internal_pointerlockerror, !1), 
            document.removeEventListener("mozpointerlockerror", Control.internal_pointerlockerror, !1), 
            document.removeEventListener("webkitpointerlockerror", Control.internal_pointerlockerror, !1), 
            document.removeEventListener("fullscreenchange", Control.internal_fullscreenchange, !1), 
            document.removeEventListener("mozfullscreenchange", Control.internal_fullscreenchange, !1), 
            document.removeEventListener("mousemove", Control.handler.onMouseMove, !1), document.removeEventListener("keydown", Control.handler.onKeyDown, !1), 
            document.removeEventListener("keyup", Control.handler.onKeyUp, !1), document.removeEventListener("click", Control.internal_pointerlockonclick, !1), 
            Control.handler.enabled = !1, Control.handler = {}), Control.fly(app.camera.object), 
            Control.type = "fly", Control.oldType = 0;
            break;

          case 1:
            0 == Control.oldType && (document.removeEventListener("contextmenu", function(a) {
                a.preventDefault();
            }, !1), document.removeEventListener("mousemove", Control.handler.mousemove, !1), 
            document.removeEventListener("mousedown", Control.handler.mousedown, !1), document.removeEventListener("mouseup", Control.handler.mouseup, !1), 
            document.removeEventListener("keydown", Control.handler.keydown, !1), document.removeEventListener("keyup", Control.handler.keyup, !1)), 
            Control.fps(app.camera.object), app.add(Control.handler.getObject(), Control.handler), 
            Control.fps_uuid = Control.handler.getObject().uuid, Control.type = "fps", Control.oldType = 1;
        }
    },
    internal_fly: function(a, b) {
        function c(a, b) {
            return function() {
                b.apply(a, arguments);
            };
        }
        this.object = a, this.domElement = void 0 !== b ? b : document, b && this.domElement.setAttribute("tabindex", -1), 
        this.movementSpeed = 1, this.rollSpeed = .5, this.dragToLook = !1, this.autoForward = !1, 
        this.tmpQuaternion = new THREE.Quaternion(), this.mouseStatus = 0, this.moveState = {
            up: 0,
            down: 0,
            left: 0,
            right: 0,
            forward: 0,
            back: 0,
            pitchUp: 0,
            pitchDown: 0,
            yawLeft: 0,
            yawRight: 0,
            rollLeft: 0,
            rollRight: 0
        }, this.moveVector = new THREE.Vector3(0, 0, 0), this.rotationVector = new THREE.Vector3(0, 0, 0), 
        this.handleEvent = function(a) {
            "function" == typeof this[a.type] && this[a.type](a);
        }, this.keydown = function(a) {
            if (!a.altKey) {
                switch (a.keyCode) {
                  case 16:
                    this.movementSpeedMultiplier = .1;
                    break;

                  case 87:
                    this.moveState.forward = 1;
                    break;

                  case 83:
                    this.moveState.back = 1;
                    break;

                  case 65:
                    this.moveState.left = 1;
                    break;

                  case 68:
                    this.moveState.right = 1;
                    break;

                  case 82:
                    this.moveState.up = 1;
                    break;

                  case 70:
                    this.moveState.down = 1;
                    break;

                  case 38:
                    this.moveState.pitchUp = 1;
                    break;

                  case 40:
                    this.moveState.pitchDown = 1;
                    break;

                  case 37:
                    this.moveState.yawLeft = 1;
                    break;

                  case 39:
                    this.moveState.yawRight = 1;
                    break;

                  case 81:
                    this.moveState.rollLeft = 2.5;
                    break;

                  case 69:
                    this.moveState.rollRight = 2.5;
                }
                this.updateMovementVector(), this.updateRotationVector();
            }
        }, this.keyup = function(a) {
            switch (a.keyCode) {
              case 16:
                this.movementSpeedMultiplier = 1;
                break;

              case 87:
                this.moveState.forward = 0;
                break;

              case 83:
                this.moveState.back = 0;
                break;

              case 65:
                this.moveState.left = 0;
                break;

              case 68:
                this.moveState.right = 0;
                break;

              case 82:
                this.moveState.up = 0;
                break;

              case 70:
                this.moveState.down = 0;
                break;

              case 38:
                this.moveState.pitchUp = 0;
                break;

              case 40:
                this.moveState.pitchDown = 0;
                break;

              case 37:
                this.moveState.yawLeft = 0;
                break;

              case 39:
                this.moveState.yawRight = 0;
                break;

              case 81:
                this.moveState.rollLeft = 0;
                break;

              case 69:
                this.moveState.rollRight = 0;
            }
            this.updateMovementVector(), this.updateRotationVector();
        }, this.mousedown = function(a) {
            if (this.domElement !== document && this.domElement.focus(), a.preventDefault(), 
            a.stopPropagation(), this.dragToLook) this.mouseStatus++; else {
                switch (a.button) {
                  case 0:
                    this.moveState.forward = 1;
                    break;

                  case 2:
                    this.moveState.back = 1;
                }
                this.updateMovementVector();
            }
        }, this.mousemove = function(a) {
            if (!this.dragToLook || this.mouseStatus > 0) {
                var b = this.getContainerDimensions(), c = b.size[0] / 2, d = b.size[1] / 2;
                this.moveState.yawLeft = 3 * -((a.pageX - b.offset[0] - c) / c), this.moveState.pitchDown = (a.pageY - b.offset[1] - d) / d * 3, 
                this.updateRotationVector();
            }
        }, this.mouseup = function(a) {
            if (a.preventDefault(), a.stopPropagation(), this.dragToLook) this.mouseStatus--, 
            this.moveState.yawLeft = this.moveState.pitchDown = 0; else {
                switch (a.button) {
                  case 0:
                    this.moveState.forward = 0;
                    break;

                  case 2:
                    this.moveState.back = 0;
                }
                this.updateMovementVector();
            }
            this.updateRotationVector();
        }, this.update = function(a) {
            var b = a * this.movementSpeed, c = a * this.rollSpeed;
            this.object.translateX(this.moveVector.x * b), this.object.translateY(this.moveVector.y * b), 
            this.object.translateZ(this.moveVector.z * b), this.tmpQuaternion.set(this.rotationVector.x * c, this.rotationVector.y * c, this.rotationVector.z * c, 1).normalize(), 
            this.object.quaternion.multiply(this.tmpQuaternion), this.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order);
        }, this.updateMovementVector = function() {
            var a = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0;
            this.moveVector.x = -this.moveState.left + this.moveState.right, this.moveVector.y = -this.moveState.down + this.moveState.up, 
            this.moveVector.z = -a + this.moveState.back;
        }, this.updateRotationVector = function() {
            this.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp, this.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft, 
            this.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft;
        }, this.getContainerDimensions = function() {
            return this.domElement != document ? {
                size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
                offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]
            } : {
                size: [ window.innerWidth, window.innerHeight ],
                offset: [ 0, 0 ]
            };
        }, this.domElement.addEventListener("contextmenu", function(a) {
            a.preventDefault();
        }, !1), this.domElement.addEventListener("mousemove", c(this, this.mousemove), !1), 
        this.domElement.addEventListener("mousedown", c(this, this.mousedown), !1), this.domElement.addEventListener("mouseup", c(this, this.mouseup), !1), 
        this.domElement.addEventListener("keydown", c(this, this.keydown), !1), this.domElement.addEventListener("keyup", c(this, this.keyup), !1), 
        this.updateMovementVector(), this.updateRotationVector();
    },
    fly: function() {
        $("body").css({
            cursor: "url(img/pointer_cross.png), auto"
        }), Control.handler = new Control.internal_fly(app.camera.object), Control.handler.movementSpeed = 3, 
        Control.handler.domElement = document, Control.handler.rollSpeed = .05, Control.handler.autoForward = !1, 
        Control.handler.dragToLook = !1;
    },
    internal_pointerlockchange: function(a) {
        Control.handler.enabled = !0;
    },
    internal_pointerlockonclick: function(a) {
        var b = document.body;
        b.requestPointerLock = b.requestPointerLock || b.mozRequestPointerLock || b.webkitRequestPointerLock, 
        /Firefox/i.test(navigator.userAgent) ? (document.addEventListener("fullscreenchange", Control.internal_fullscreenchange, !1), 
        document.addEventListener("mozfullscreenchange", Control.internal_fullscreenchange, !1), 
        b.requestFullscreen = b.requestFullscreen || b.mozRequestFullscreen || b.mozRequestFullScreen || b.webkitRequestFullscreen, 
        b.requestFullscreen()) : b.requestPointerLock();
    },
    internal_pointerlockerror: function(a) {
        app.log("POINTER LOCK ERROR");
    },
    internal_fullscreenchange: function(a) {
        document.fullscreenElement !== document && document.mozFullscreenElement !== document && document.mozFullScreenElement !== document || (document.removeEventListener("fullscreenchange", Control.internal_fullscreenchange), 
        document.removeEventListener("mozfullscreenchange", Control.internal_fullscreenchange), 
        document.requestPointerLock());
    },
    fps_uuid: void 0,
    fps: function(a) {
        Control.handler = new Control.internal_fps(app.camera.object);
        var b = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
        b ? (app.log("we have pointer lock ability"), Control.handler.enabled = !0, document.addEventListener("pointerlockchange", Control.internal_pointerlockchange, !1), 
        document.addEventListener("mozpointerlockchange", Control.internal_pointerlockchange, !1), 
        document.addEventListener("webkitpointerlockchange", Control.internal_pointerlockchange, !1), 
        document.addEventListener("pointerlockerror", Control.internal_pointerlockerror, !1), 
        document.addEventListener("mozpointerlockerror", Control.internal_pointerlockerror, !1), 
        document.addEventListener("webkitpointerlockerror", Control.internal_pointerlockerror, !1), 
        document.addEventListener("click", Control.internal_pointerlockonclick, !1)) : app.log("BROWSER DOESN'T SUPPORT POINTER LOCK API.");
    },
    internal_fps: function(a) {
        var b = this;
        a.rotation.set(0, 0, 0);
        var c = new THREE.Object3D();
        c.add(a);
        var d = new THREE.Object3D();
        d.position.y = Control.options.fps.height, d.add(c);
        var e = !1, f = !1, g = !1, h = !1, i = !1, j = !1, k = new THREE.Vector3(), l = Math.PI / 2, m = !1;
        this._onKeyDown = function(a) {}, this.setKeyDownListener = function(a) {
            this._onKeyDown = a;
        }, this._onKeyUp = function(a) {}, this.setKeyUpListener = function(a) {
            this._onKeyUp = a;
        }, this._onMouseMove = function(a) {}, this.setMouseMoveListener = function(a) {
            this._onMouseMove = a;
        }, this.onMouseMove = function(a) {
            if (b.enabled !== !1) {
                var e = a.movementX || a.mozMovementX || a.webkitMovementX || 0, f = a.movementY || a.mozMovementY || a.webkitMovementY || 0;
                d.rotation.y -= e * Control.options.fps.mouseFactor, c.rotation.x -= f * Control.options.fps.mouseFactor, 
                c.rotation.x = Math.max(-l, Math.min(l, c.rotation.x)), Control.handler._onMouseMove(a);
            }
        }, this.onKeyDown = function(a) {
            switch (a.keyCode) {
              case 38:
              case 87:
                e = !0;
                break;

              case 37:
              case 65:
                g = !0;
                break;

              case 40:
              case 83:
                f = !0;
                break;

              case 39:
              case 68:
                h = !0;
                break;

              case 32:
                j === !0 && (k.y += Control.options.fps.jumpHeight), j = !1;
                break;

              case 16:
                Control.options.fps._oldV = Control.options.fps.velocity, Control.options.fps.velocity = Control.options.fps.crouch, 
                d.position.y = Control.options.fps.height / 2, j = !1, m = !0;
            }
            Control.handler._onKeyDown(a);
        }, this.onKeyUp = function(a) {
            switch (a.keyCode) {
              case 38:
              case 87:
                e = !1;
                break;

              case 37:
              case 65:
                g = !1;
                break;

              case 40:
              case 83:
                f = !1;
                break;

              case 39:
              case 68:
                h = !1;
                break;

              case 16:
                Control.options.fps.velocity = Control.options.fps._oldV, d.position.y = Control.options.fps.height, 
                j = !0, m = !1;
            }
            Control.handler._onKeyUp(a);
        }, document.addEventListener("mousemove", this.onMouseMove, !1), document.addEventListener("keydown", this.onKeyDown, !1), 
        document.addEventListener("keyup", this.onKeyUp, !1), this.enabled = !1, this.getObject = function() {
            return d;
        }, this.isOnObject = function(a) {
            i = a, j = a;
        }, this.getDirection = function() {
            var a = new THREE.Vector3(0, 0, -1), b = new THREE.Euler(0, 0, 0, "YXZ");
            return function(e) {
                return b.set(c.rotation.x, d.rotation.y, 0), e.copy(a).applyEuler(b), e;
            };
        }(), this.update = function(a) {
            if (b.enabled === !1) return void app.log("pointerlock not enabled. please enable it.");
            a *= Control.options.fps.delta, k.y -= Control.options.fps.fallFactor * a;
            var c = Control.options.fps.velocity;
            e && (k.z = -c), f && (k.z = c), f || e || (k.z = 0), g && (k.x = -c), h && (k.x = c), 
            h || g || (k.x = 0), i === !0 && (k.y = Math.max(0, k.y)), d.translateX(k.x), d.translateY(k.y), 
            d.translateZ(k.z), d.position.y < Control.options.fps.height && (k.y = 0, d.position.y = m ? Control.options.fps.height / 2 : Control.options.fps.height, 
            j = !0);
        };
    },
    update: function() {
        if (Control.handler) {
            Control.clock.getDelta();
            try {
                Control.handler.update(app.clock.getDelta());
            } catch (a) {
                console.error(a), console.trace();
            }
        }
    },
    init: function() {
        Control.clock = new THREE.Clock();
        try {
            app.keydown && app.keyup ? (Control.type = "custom", Control.oldType = 2, window.addEventListener("keydown", app.keydown), 
            window.addEventListener("keyup", app.keyup)) : (Control.type = "fly", Control.fly(app.camera.object), 
            Control.oldType = 0);
        } catch (a) {
            Control.type = "fly", Control.fly(app.camera.object), Control.oldType = 0;
        }
    }
}, window.Game = {}, Game.SCRIPTS_DIR = "app/scripts/", Game.update = function() {}, 
Game.script = function(a, b) {
    var c = {};
    c.name = a;
    for (var d in b) c[d] = b[d];
    c.start || (c.start = new Function("console.log('please, add a start method');")), 
    c.update || (c.update = new Function("console.log('please, add a update method');")), 
    a in Game.scripts || (Game.scripts[a] = c);
}, Game.attachScriptToObject = function(a, b, c) {
    var d = c + b;
    include(d, function() {
        a.__loadScript(Game.scripts[b]);
    });
}, Game.scripts = {};

var Gui = {};

Gui = {
    miniMap: void 0,
    menu: void 0,
    init: void 0
}, window.Universe = {}, Universe = {
    universe: void 0,
    loaded: !1,
    worker: void 0,
    init: function() {
        console.log("inside universe init"), Universe.loaded = !0, Universe.universe = new HashMap();
    },
    cube: void 0,
    addRandomCube: function() {
        var a = new THREE.CubeGeometry(1, 1, 1), b = new THREE.MeshBasicMaterial({
            color: 65280,
            wireframe: !0
        }), c = new THREE.Mesh(a, b);
        c.position.x = 5 * Math.random(), c.position.y = 5 * Math.random(), c.position.z = 5 * Math.random(), 
        c.auto_render = function() {
            this.rotation.x += .01;
        }, app.scene.add(c), Universe.universe.put(c.uuid, c);
    },
    testingShaders: function() {
        var a = new THREE.ShaderMaterial({
            uniforms: {
                tExplosion: {
                    type: "t",
                    value: THREE.ImageUtils.loadTexture("img/explosion.png", {}, function(a) {
                        console.log(a);
                    })
                },
                time: {
                    type: "f",
                    value: 0
                }
            },
            vertexShader: document.getElementById("vertexShader").textContent,
            fragmentShader: document.getElementById("fragmentShader").textContent
        }), b = new THREE.Mesh(new THREE.IcosahedronGeometry(20, 4), a);
        b.start_time = Date.now(), b.auto_render = function() {
            this.material.uniforms.time.value = 25e-5 * (Date.now() - this.start_time);
        }, app.scene.add(b), Universe.universe.put(b.uuid, b);
    },
    addPlanetAndSatellite: function() {
        var a = new THREE.MeshBasicMaterial({
            color: 16777215,
            wireframe: !0
        }), b = new THREE.SphereGeometry(15, 40, 40);
        b.dynamic = !0;
        var c = new THREE.Mesh(b, a);
        c.position.x = 0, c.position.y = 0, c.position.z = 0, c.auto_render = function() {
            this.rotation.y += 1e-4;
        }, app.scene.add(c), Universe.universe.put(c.uuid, c), l("PLANET GEOMETRY"), l(c.geometry.dynamic + " - " + c.geometry.verticesNeedUpdate + " - " + c.geometry.normalsNeedUpdate);
        var a = new THREE.MeshBasicMaterial({
            color: 16777215,
            wireframe: !0
        }), d = new THREE.Mesh(new THREE.SphereGeometry(30, 40, 40), a);
        d.position.x = 0, d.position.y = 400, d.position.z = 0, d.auto_render = function() {
            this.position.x += this.position.z += this.rotation.y += 1e-4;
        };
    },
    update: function() {
        var a = Universe.universe.keys.concat();
        if (0 != a.length) {
            var b = +new Date();
            do {
                var c = Universe.universe.get(a.shift());
                c.update && c.update(app.clock.getDelta());
            } while (a.length > 0 && +new Date() - b < 50);
        }
    }
}, Universe.init(), window.User = {}, User = {
    real_name: void 0,
    real_surname: void 0,
    username: void 0,
    clock: void 0,
    flyControl: void 0,
    fpsControl: void 0,
    init: function() {
        User.clock = new THREE.Clock(), User.fpsControl = new THREE.PointerLockControls(app.camera), 
        app.scene.add(User.fpsControl.getObject());
    },
    position: {
        x: void 0,
        y: void 0,
        z: void 0
    },
    handleUserInput: function() {}
}, window.AssetsManager = {}, AssetsManager.completed = {
    sound: !1,
    video: !0,
    images: !1,
    general: !0,
    shaders: !1
}, AssetsManager.load = function(a) {
    AssetsManager.callback = a, AudioEngine.load(), VideoEngine.load(), ImagesEngine.load(), 
    GeneralAssetsEngine.load(), fx.ShadersEngine.load(), AssetsManager.checkInterval = setInterval(AssetsManager.check, 100);
}, AssetsManager.loadingMessage = function(a) {}, AssetsManager.check = function() {
    AssetsManager.completed.sound && AssetsManager.completed.video && AssetsManager.completed.images && AssetsManager.completed.general ? (AssetsManager.loadingMessage(!0), 
    clearInterval(AssetsManager.checkInterval), AssetsManager.callback()) : AssetsManager.loadingMessage(!1);
}, window.fx = {}, function() {
    window.AudioEngine = {
        DELAY_FACTOR: .02,
        DELAY_STEP: 1,
        DELAY_MIN_VALUE: .2,
        DELAY_NORMAL_VALUE: 40,
        VOLUME: 80,
        _volume: 80,
        soundPath: "js/core/sound/",
        soundModules: [ "js/core/audio/beat", "js/core/audio/sound", "js/core/audio/ambientSound" ],
        numSound: 0,
        soundLoaded: 0,
        load: function() {
            AudioEngine.map = new HashMap(), AudioEngine.sounds = [], AudioEngine.AudioContext = window.AudioContext || window.webkitAudioContext || null, 
            AudioEngine.AudioContext ? (AudioEngine.context = new AudioEngine.AudioContext(), 
            AudioEngine.volume = AudioEngine.context.createGain(), AudioEngine.volume.gain.value = AudioEngine.VOLUME, 
            AudioEngine.volume.connect(AudioEngine.context.destination)) : console.error("No Audio Context available, sorry.");
            for (var a in Assets.Audio) AudioEngine.numSound++, AudioEngine.loadSingleFile(a, Assets.Audio[a]);
            0 == AudioEngine.numSound && (AssetsManager.completed.sound = !0);
        },
        get: function(a) {
            return AudioEngine.map.get(a) || !1;
        },
        loadSingleFile: function(a, b) {
            var c = new XMLHttpRequest();
            c.open("GET", b, !0), c.responseType = "arraybuffer", c.onload = function(b) {
                AudioEngine.context.decodeAudioData(this.response, function(b) {
                    AudioEngine.map.put(a, b), AudioEngine.soundLoaded++, AudioEngine.checkLoad();
                }, function() {
                    AudioEngine.map.put(a, null), AudioEngine.soundLoaded++, console.error("Decoding the audio buffer failed");
                });
            }, c.send();
        },
        checkLoad: function() {
            AudioEngine.soundLoaded == AudioEngine.numSound && (AssetsManager.completed.sound = !0);
        },
        add: function(a) {
            AudioEngine.sounds.push(a);
        },
        update: function() {
            var a = new Date();
            for (var b in AudioEngine.sounds) {
                var c = AudioEngine.sounds[b];
                c.update(app.clock.getDelta()), app.camera.object.updateMatrixWorld();
                var d = new THREE.Vector3();
                d.setFromMatrixPosition(app.camera.object.matrixWorld), AudioEngine.context.listener.setPosition(d.x, d.y, d.z);
                var e = app.camera.object.matrix;
                mx = e.elements[12], my = e.elements[13], mz = e.elements[14], e.elements[12] = e.elements[13] = e.elements[14] = 0;
                var f = new THREE.Vector3(0, 0, 1);
                f.applyProjection(e), f.normalize();
                var g = new THREE.Vector3(0, -1, 0);
                if (g.applyProjection(e), g.normalize(), AudioEngine.context.listener.setOrientation(f.x, f.y, f.z, g.x, g.y, g.z), 
                e.elements[12] = mx, e.elements[13] = my, e.elements[14] = mz, +new Date() - a > 50) return;
            }
        }
    }, Object.defineProperty(AudioEngine, "VOLUME", {
        set: function(a) {
            AudioEngine._volume = a, AudioEngine.volume.gain.value = AudioEngine._volume;
        },
        get: function() {
            if (AudioEngine._volume) return AudioEngine._volume;
        }
    });
}(), Class("Beat", {
    Beat: function(a) {
        this.name = a, this.sound = {}, this.sound.source = AudioEngine.context.createBufferSource(), 
        this.sound.volume = AudioEngine.context.createGain(), this.sound.volume.gain.value = AudioEngine.VOLUME, 
        this.setListeners(), this.sound.source.connect(this.sound.volume), this.sound.volume.connect(AudioEngine.volume);
    },
    setListeners: function() {
        this.sound.source._caller = this;
    },
    reset: function() {
        this.sound.source.disconnect(), this.sound.source = AudioEngine.context.createBufferSource(), 
        this.sound.source.connect(this.sound.volume), this.setListeners();
    },
    start: function() {
        var a = AudioEngine.get(this.name);
        if (!a) return void console.error("Unable to load sound, sorry.");
        this.sound.source.buffer = a, this.sound.volume.gain.value = 0, this.sound.source.start(AudioEngine.context.currentTime);
        var b = this, c = function() {
            b.sound.volume.gain.value = b.sound.volume.gain.value + AudioEngine.DELAY_FACTOR, 
            b.sound.volume.gain.value < AudioEngine.DELAY_NORMAL_VALUE && setTimeout(c, AudioEngine.DELAY_STEP);
        };
        c();
    },
    stop: function() {
        var a = this, b = function() {
            a.sound.volume.gain.value = a.sound.volume.gain.value - AudioEngine.DELAY_FACTOR, 
            a.sound.volume.gain.value > AudioEngine.DELAY_MIN_VALUE ? setTimeout(b, AudioEngine.DELAY_STEP) : a.sound.source.stop();
        };
        b();
    },
    onEnd: function() {
        this._caller.onEndCallback && this._caller.onEndCallback(), this._caller.reset();
    },
    onLoopEnd: function() {
        this._caller.onLoopEndCallback && this._caller.onLoopEndCallback();
    },
    onLoopStart: function() {
        this._caller.onLoopStartCallback && this._caller.onLoopStartCallback();
    }
}), Class("Sound", {
    Sound: function(a, b) {
        Beat.call(this, a);
        var c = b || {};
        this.sound.panner = AudioEngine.context.createPanner(), this.sound.volume.disconnect(), 
        this.sound.volume.connect(this.sound.panner), this.sound.panner.connect(AudioEngine.volume), 
        c.mesh ? this.mesh = c.mesh : this.update = function() {}, c.effect && (this.convolver = AudioEngine.context.createConvolver(), 
        this.mixer = AudioEngine.createGain(), this.sound.panner.disconnect(), this.sound.panner.connect(this.mixer), 
        this.plainGain = AudioEngine.context.createGain(), this.convolverGain = AudioEngine.context.createGain(), 
        this.mixer.connect(plainGain), this.mixer.connect(convolverGain), this.plainGain.connect(AudioEngine.volume), 
        this.convolverGain.connect(AudioEngine.volume), this.convolver.buffer = AudioEngine.get(c.effect), 
        this.convolverGain.gain.value = .7, this.plainGain.gain.value = .3);
        var d = c.autoplay || !1;
        d && this.start(), AudioEngine.add(this);
    },
    update: function(a) {
        if (this.mesh) {
            var b = new THREE.Vector3();
            b.setFromMatrixPosition(this.mesh.matrixWorld);
            var c = b.x, d = b.y, e = b.z;
            this.mesh.updateMatrixWorld();
            var f = new THREE.Vector3();
            f.setFromMatrixPosition(this.mesh.matrixWorld);
            var g = f.x - c, h = f.y - d, i = f.z - e;
            try {
                this.sound.panner.setPosition(f.x, f.y, f.z), this.sound.panner.setVelocity(g / a, h / a, i / a);
            } catch (a) {}
        }
    }
})._extends("Beat"), Class("AmbientSound", {
    AmbientSound: function(a, b) {
        Beat.call(this, a), this.sound.source.loop = b.loop || !1, this.sound.panner = AudioEngine.context.createPanner(), 
        this.sound.volume.disconnect(), this.sound.volume.connect(this.sound.panner), this.sound.panner.connect(AudioEngine.volume), 
        this.mesh = b.mesh, b.effect && (this.convolver = AudioEngine.context.createConvolver(), 
        this.mixer = AudioEngine.createGain(), this.sound.panner.disconnect(), this.sound.panner.connect(this.mixer), 
        this.plainGain = AudioEngine.context.createGain(), this.convolverGain = AudioEngine.context.createGain(), 
        this.mixer.connect(plainGain), this.mixer.connect(convolverGain), this.plainGain.connect(AudioEngine.volume), 
        this.convolverGain.connect(AudioEngine.volume), this.convolver.buffer = AudioEngine.get(b.effect), 
        this.convolverGain.gain.value = .7, this.plainGain.gain.value = .3);
        var c = b.autoplay || !1;
        c && this.start(), AudioEngine.add(this);
    },
    update: function(a) {
        this.mesh.updateMatrixWorld();
        var b = new THREE.Vector3();
        b.setFromMatrixPosition(this.mesh.matrixWorld), this.sound.panner.setPosition(b.x, b.y, b.z);
    }
})._extends("Beat"), Class("DirectionalSound", {
    DirectionalSound: function(a, b, c) {
        Beat.call(this, a), this.sound.panner = AudioEngine.context.createPanner(), this.sound.volume.disconnect(), 
        this.sound.volume.connect(this.sound.panner), this.sound.panner.connect(AudioEngine.volume), 
        this.mesh = c.mesh, this.sound.panner.coneInnerAngle = b.innerAngleInDegrees, this.sound.panner.coneOuterAngle = b.outerAngleInDegrees, 
        this.sound.panner.coneOuterGain = b.outerGainFactor, c.effect && (this.convolver = AudioEngine.context.createConvolver(), 
        this.mixer = AudioEngine.createGain(), this.sound.panner.disconnect(), this.sound.panner.connect(this.mixer), 
        this.plainGain = AudioEngine.context.createGain(), this.convolverGain = AudioEngine.context.createGain(), 
        this.mixer.connect(plainGain), this.mixer.connect(convolverGain), this.plainGain.connect(AudioEngine.volume), 
        this.convolverGain.connect(AudioEngine.volume), this.convolver.buffer = AudioEngine.get(c.effect), 
        this.convolverGain.gain.value = .7, this.plainGain.gain.value = .3);
        var d = c.autoplay || !1;
        d && this.start(), AudioEngine.add(this);
    },
    update: function(a) {
        var b = new THREE.Vector3();
        b.setFromMatrixPosition(this.mesh.matrixWorld);
        var c = b.x, d = b.y, e = b.z;
        this.mesh.updateMatrixWorld();
        var f = new THREE.Vector3();
        f.setFromMatrixPosition(this.mesh.matrixWorld);
        var g = f.x - c, h = f.y - d, i = f.z - e;
        this.sound.panner.setPosition(f.x, f.y, f.z), this.sound.panner.setVelocity(g / a, h / a, i / a);
        var j = new THREE.Vector3(0, 0, 1), k = this.mesh.matrixWorld, l = k.elements[12], m = k.elements[13], n = k.elements[14];
        k.elements[12] = k.elements[13] = k.elements[14] = 0, j.applyProjection(k), j.normalize(), 
        this.sound.panner.setOrientation(j.x, j.y, j.z), k.elements[12] = l, k.elements[13] = m, 
        k.elements[14] = n;
    }
})._extends("Beat"), Class("BackgroundSound", {
    BackgroundSound: function(a, b) {
        Beat.call(this, a), this.sound.source.loop = b.loop || !0, this.mesh = b.mesh, b.effect && (this.convolver = AudioEngine.context.createConvolver(), 
        this.mixer = AudioEngine.context.createGain(), this.sound.panner.disconnect(), this.sound.panner.connect(this.mixer), 
        this.plainGain = AudioEngine.context.createGain(), this.convolverGain = AudioEngine.context.createGain(), 
        this.mixer.connect(plainGain), this.mixer.connect(convolverGain), this.plainGain.connect(AudioEngine.volume), 
        this.convolverGain.connect(AudioEngine.volume), this.convolver.buffer = AudioEngine.get(b.effect), 
        this.convolverGain.gain.value = .7, this.plainGain.gain.value = .3);
        var c = b.autoplay || !0;
        c && this.start(), AudioEngine.add(this);
    },
    update: function(a) {}
})._extends("Beat"), function() {
    window.VideoEngine = {}, VideoEngine.load = function() {};
}(), function() {
    window.ImagesEngine = {
        numImages: 0,
        imagesLoaded: 0,
        load: function() {
            ImagesEngine.map = new HashMap(), ImagesEngine.images = [], ImagesEngine.numImages = 0, 
            ImagesEngine.loader = new THREE.TextureLoader();
            for (var a in Assets.Images) ImagesEngine.numImages++, ImagesEngine.loadSingleFile(a, Assets.Images[a]);
            0 == ImagesEngine.numImages && (AssetsManager.completed.images = !0);
        },
        get: function(a) {
            return ImagesEngine.map.get(a) || !1;
        },
        loadSingleFile: function(a, b) {
            try {
                ImagesEngine.imagesLoaded++, ImagesEngine.loader.load(b, function(b) {
                    ImagesEngine.map.put(a, b), ImagesEngine.checkLoad();
                }, function() {}, function() {
                    console.log("An error occurred while fetching texture."), ImagesEngine.checkLoad();
                });
            } catch (a) {}
        },
        checkLoad: function() {
            ImagesEngine.imagesLoaded == ImagesEngine.numImages && (AssetsManager.completed.images = !0);
        },
        add: function(a, b) {
            a && b && ImagesEngine.map.put(a, b);
        }
    };
}(), function() {
    window.GeneralAssetsEngine = {}, GeneralAssetsEngine.load = function() {};
}(), window.fx.ShadersEngine = {
    SHADERS_DIR: "app/shaders/",
    shaders: {},
    numShaders: 0,
    shadersLoaded: 0,
    update: function() {},
    load: function() {
        if (fx.ShadersEngine.map = new HashMap(), fx.ShadersEngine.shaders = [], Assets.Shaders) for (var a in Assets.Shaders) fx.ShadersEngine.numShaders++, 
        fx.ShadersEngine.loadSingleFile(a, Assets.Shaders[a]);
        0 == fx.ShadersEngine.numShaders && (AssetsManager.completed.shaders = !0);
    },
    get: function(a) {
        return fx.ShadersEngine.map.get(a) || !1;
    },
    loadSingleFile: function(a, b) {
        var c = b.split(".")[1];
        if ("js" == c) include(b.split(".js")[0], this.checkLoad); else {
            var d = new XMLHttpRequest();
            d.open("GET", b, !0), d.responseType = "text", d.onload = function(b) {
                var c = fx.ShadersEngine._parseShader(this.responseText);
                fx.ShadersEngine.map.put(a, c), fx.ShadersEngine.shadersLoaded++, fx.ShadersEngine.checkLoad();
            }, d.send();
        }
    },
    _parseShader: function(a) {
        var b = {};
        return b.name = a.substring(a.indexOf("<name>") + 6, a.indexOf("</name>")), b.vertex = a.substring(a.indexOf("<vertex>") + 8, a.indexOf("</vertex>")), 
        b.fragment = a.substring(a.indexOf("<fragment>") + 10, a.indexOf("</fragment>")), 
        b.options = {}, b.attributes = {}, b.uniforms = {}, b;
    },
    create: function(a, b) {
        var c = {};
        c.name = a, c.vertex = b.vertex || "", c.fragment = b.fragment || "", c.options = b.options || {}, 
        c.attributes = b.attributes || {}, c.uniforms = b.uniforms || {}, fx.ShadersEngine.map.put(a, c);
    },
    checkLoad: function() {
        fx.ShadersEngine.shadersLoaded == fx.ShadersEngine.numShaders && (AssetsManager.completed.shaders = !0);
    },
    add: function(a) {
        fx.ShadersEngine.shaders.push(a);
    }
}, Class("Shader", {
    Shader: function(a, b, c, d) {
        this.shader = fx.ShadersEngine.get(a), this.name = this.shader.name, this.vertex = this.shader.vertex, 
        this.fragment = this.shader.fragment, this.attributes = b ? b : this.shader.attributes, 
        this.uniforms = c ? c : this.shader.uniforms;
        var e = {
            attributes: this.attributes,
            uniforms: this.uniforms,
            vertexShader: this.shader.vertex,
            fragmentShader: this.shader.fragment
        }, f = d ? d : this.shader.options;
        for (o in f) e[o] = f[o];
        this.material = new THREE.ShaderMaterial(e);
    }
}), window.Util = window.Util || {}, Util.tests = [ "webgl", "webaudioapi", "webworker", "ajax" ], 
Util.start = function() {
    window.requestAnimFrame = function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a, b) {
            window.setTimeout(a, 1e3 / 60);
        };
    }();
}, Util.check = {
    start: function(a, b) {
        var c = app.util.tests || Util.tests;
        c.indexOf("webgl") == -1 && c.push("webgl");
        for (var d in c) {
            if (Util.tests.indexOf(c[d]) == -1) return b("No Such Test", c[d]), !1;
            if (!Util.check[c[d]]()) return b("Test failed", c[d]), !1;
        }
        return a("All systems are go!"), !0;
    },
    webgl: function() {
        var a = document.createElement("canvas"), b = a.getContext("webgl") || a.getContext("experimental-webgl");
        return !!b;
    },
    webaudioapi: function() {
        return !(!window.webkitAudioContext && !window.AudioContext);
    },
    webworker: function() {
        return !!window.Worker;
    },
    ajax: function() {
        var a = null;
        try {
            a = new XMLHttpRequest();
        } catch (a) {}
        try {
            a = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (a) {}
        try {
            a = new ActiveXObject("Msxml2.XMLHTTP");
        } catch (a) {}
        return null != a;
    }
}, Util.degToRad = function(a) {
    return a * (Math.PI / 180);
}, Util.getProportion = function(a, b, c) {
    return a * b / c;
}, Class("App", {
    App: function() {
        this.log_types = {
            e: "error",
            w: "warn",
            i: "info"
        }, this.util = _.extend({
            h: window.innerHeight,
            w: window.innerWidth,
            ratio: window.innerWidth / window.innerHeight,
            frameRate: 60,
            camera: {
                fov: 75,
                near: .1,
                far: 100
            }
        }, config), this.threeLib = void 0, this.camera = void 0, this.user = void 0, this.scene = void 0, 
        this.renderer = void 0, this.clearColor = 0, Object.defineProperty(this, "clearColor", {
            set: function(a) {
                try {
                    this.renderer && (this.renderer.setClearColor(a), this.clearColor = a);
                } catch (a) {}
            }
        }), this.debug = !0, this.clock = new THREE.Clock(), this.mouseX = 0, this.mouseY = 0, 
        this.zoom = 0, this.windowHalfX = window.innerWidth / 2, this.windowHalfY = window.innerHeight / 2, 
        this.CAMERA_MAX_Z = 1e3, this.CAMERA_MIN_Z = 250, window.addEventListener("onmessage", this.onMessage, !1), 
        window.addEventListener("message", this.onMessage, !1);
    },
    onCreate: function() {},
    preload: function(a) {
        a();
    },
    prepareScene: function() {},
    progressAnimation: function(a) {
        $("#loader").animate({
            opacity: "0",
            "margin-top": "250px"
        }, 1e3, function() {
            $("#loader").remove(), $("body").animate({
                backgroundColor: "#fff"
            }, 200, a);
        });
    },
    _render: function() {},
    setUpLeap: function() {},
    onLeapSocketConnected: function() {},
    onLeapDeviceConnected: function() {},
    onLeapDeviceDisconnected: function() {},
    render: function() {
        User.handleUserInput(), Game.update(), AudioEngine.update(), LightEngine.update(), 
        Universe.update(), Control.update(), app.camera.update && app.camera.update(app.clock.getDelta()), 
        app.renderer.autoClear = !1, app.renderer.clear(app.clearColor), app._render(), 
        app.renderer.render(app.scene, app.camera.object), setTimeout(function() {
            app.util.physics_enabled && Physijs._isLoaded && app.scene.simulate(), app.util.tween_enabled && TWEEN.update(), 
            requestAnimFrame(app.render);
        }, 1e3 / app.util.frameRate);
    },
    add: function(a, b) {
        this.scene.add(a), Universe.universe.put(a.uuid, b);
    },
    remove: function(a) {
        this.scene.remove(a), Universe.universe.remove(a.uuid);
    },
    init: function() {
        app.three = THREE;
        var a = app.util.camera, b = app.util;
        if (window.keypress && (app._keylistener = new window.keypress.Listener()), config) if (app.log("config loaded"), 
        app.util.physics_enabled) {
            app.log("physics enabled.");
            try {
                Physijs.scripts.worker = "workers/physijs_worker.js", Physijs.scripts.ammo = "ammo.js", 
                app.scene = new Physijs.Scene(), Physijs._isLoaded = !0;
            } catch (a) {
                app.log("something bad trying to create physijs scene", "e"), app.log(a), Physijs._isLoaded = !1, 
                app.scene = new app.three.Scene();
            }
        } else app.log("physics not enabled."), Physijs._isLoaded = !1, app.scene = new app.three.Scene(); else app.log("config not loaded, switching to three.js"), 
        Physijs._isLoaded = !1, app.scene = new app.three.Scene();
        var c = {
            fov: a.fov,
            ratio: b.ratio,
            near: a.near,
            far: a.far
        };
        config && app.util.camera && (c.fov = app.util.camera.fov ? app.util.camera.fov : c.fov, 
        c.ratio = app.util.camera.ratio ? app.util.camera.ratio : c.ratio, c.near = app.util.camera.near ? app.util.camera.near : c.near, 
        c.far = app.util.camera.far ? app.util.camera.far : c.far), app.camera = new Camera(c);
        var d = !1;
        app.util.alpha && (d = !0), app.renderer = new app.three.WebGLRenderer({
            alpha: d,
            antialias: !0
        }), app.util.cast_shadow && (app.renderer.shadowMap.enabled = !0, app.renderer.shadowMap.type = THREE.PCFSoftShadowMap, 
        app.renderer.sortObjects = !1), app.renderer.setPixelRatio(window.devicePixelRatio), 
        app.renderer.setSize(b.w, b.h), document.getElementById("gameContainer").appendChild(app.renderer.domElement), 
        User.handleUserInput(), Game.update(), Universe.update(), Control.init(), app.render(), 
        app.onCreate instanceof Function ? app.onCreate() : console.log("Something wrong in your onCreate method");
    },
    load: function() {
        console.log("inside load"), "function" != typeof this.progressAnimation && (this.progressAnimation = function(a) {
            console.log("def progressAnimation"), a();
        }), this.progressAnimation(app.init);
    },
    sendMessage: function(a) {
        parent.postMessage(a, location.origin);
    },
    onMessage: function() {
        var a = event.origin || event.originalEvent.origin;
        a !== location.origin;
    },
    onkey: function(a, b) {
        app._keylistener && app._keylistener.simple_combo(a, b);
    },
    log: function() {
        this.debug && (arguments.length > 1 && arguments[1] in this.log_types ? console[this.log_types[arguments[1]]](arguments[0]) : console.log(arguments[0]));
    },
    onDocumentMouseWheel: function(a) {
        a.preventDefault(), app.zoom = .05 * a.wheelDelta, app.camera.object.position.z += app.zoom;
    },
    onDocumentMouseMove: function(a) {
        app.mouseX = a.clientX - app.windowHalfX, app.mouseY = a.clientY - app.windowHalfY;
    },
    onDocumentTouchStart: function(a) {
        1 === a.touches.length && (a.preventDefault(), app.mouseX = a.touches[0].pageX - app.windowHalfX, 
        app.mouseY = a.touches[0].pageY - app.windowHalfY);
    },
    onDocumentTouchMove: function(a) {
        1 === a.touches.length && (a.preventDefault(), app.mouseX = a.touches[0].pageX - app.windowHalfX, 
        app.mouseY = a.touches[0].pageY - app.windowHalfY);
    },
    keyup: function(a) {},
    keydown: function(a) {},
    onFailedTest: function(a, b) {},
    onSuccededTest: function(a) {}
});

var app;

window.onload = function() {
    if (console.log("inside window onload"), window.subClasses.App) {
        var a = window.subClasses.App;
        app = new window[a]();
    } else app = new App();
    Util.start(), Util.check.start(app.onSuccededTest, app.onFailedTest) && app.preload(function() {
        AssetsManager.load(function() {
            app.prepareScene(), app.load();
        });
    });
}, window.onresize = function() {
    app.util.h = window.innerHeight, app.util.w = window.innerWidth, app.util.ratio = app.util.w / app.util.h, 
    app.camera && app.renderer && (app.camera.object.aspect = app.util.ratio, app.camera.object.updateProjectionMatrix(), 
    app.renderer.setSize(app.util.w, app.util.h));
};